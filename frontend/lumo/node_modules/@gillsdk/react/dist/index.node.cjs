'use strict';

var React = require('react');
var reactQuery = require('@tanstack/react-query');
var gill = require('gill');
var token = require('gill/programs/token');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var React__default = /*#__PURE__*/_interopDefault(React);

// src/const.ts
var GILL_NAME = "gill";
var GILL_HOOK_CLIENT_KEY = "gill-client";
function SolanaProvider({
  client,
  children,
  queryClient = new reactQuery.QueryClient()
}) {
  queryClient.setQueryData([GILL_HOOK_CLIENT_KEY], client);
  return /* @__PURE__ */ React__default.default.createElement(reactQuery.QueryClientProvider, { client: queryClient }, children);
}
function useSolanaClient() {
  const { data: config } = reactQuery.useQuery({
    queryKey: [GILL_HOOK_CLIENT_KEY],
    staleTime: Infinity,
    // fallback data should not be reached if used within `SolanaProvider`
    // since we set the initial value. but just in case => devnet
    initialData: gill.createSolanaClient({
      urlOrMoniker: "devnet"
    })
  });
  return config;
}
function useUpdateSolanaClient() {
  const queryClient = reactQuery.useQueryClient();
  return reactQuery.useMutation({
    mutationFn: async (newClient) => {
      queryClient.setQueryData([GILL_HOOK_CLIENT_KEY], newClient);
      return newClient;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [GILL_HOOK_CLIENT_KEY] });
      queryClient.prefetchQuery({ queryKey: [GILL_HOOK_CLIENT_KEY] });
      queryClient.refetchQueries({
        queryKey: [GILL_HOOK_CLIENT_KEY]
      });
    }
  });
}

// src/hooks/account.ts
function useAccount({ options, config, abortSignal, address: address2, decoder }) {
  const { rpc } = useSolanaClient();
  if (abortSignal) {
    config = {
      ...config || {},
      abortSignal
    };
  }
  const { data, ...rest } = reactQuery.useQuery({
    networkMode: "offlineFirst",
    ...options,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getAccountInfo", address2],
    queryFn: async () => {
      const account = await gill.fetchEncodedAccount(rpc, address2, config);
      gill.assertAccountExists(account);
      if (decoder) return gill.decodeAccount(account, decoder);
      return account;
    },
    enabled: !!address2
  });
  return {
    ...rest,
    account: data
  };
}
function useBalance({
  options,
  config,
  abortSignal,
  address: address2
}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = reactQuery.useQuery({
    networkMode: "offlineFirst",
    ...options,
    enabled: !!address2,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getBalance", address2],
    queryFn: async () => {
      const { value } = await rpc.getBalance(address2, config).send({ abortSignal });
      return value;
    }
  });
  return {
    ...rest,
    balance: data
  };
}
function useLatestBlockhash({
  options,
  config,
  abortSignal
} = {}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = reactQuery.useQuery({
    ...options,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getLatestBlockhash"],
    queryFn: async () => {
      const { value } = await rpc.getLatestBlockhash(config).send({ abortSignal });
      return value;
    }
  });
  return {
    ...rest,
    latestBlockhash: data
  };
}
function useProgramAccounts({
  options,
  config,
  abortSignal,
  program
}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = reactQuery.useQuery({
    ...options,
    enabled: !!program,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getProgramAccounts", program],
    queryFn: async () => {
      const accounts = await rpc.getProgramAccounts(program, config).send({ abortSignal });
      return accounts;
    }
  });
  return {
    ...rest,
    accounts: data
  };
}
function useRecentPrioritizationFees({
  options,
  abortSignal,
  addresses
} = {}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = reactQuery.useQuery({
    ...options,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getRecentPrioritizationFees", addresses],
    queryFn: async () => {
      const fees = await rpc.getRecentPrioritizationFees(addresses).send({ abortSignal });
      return fees;
    }
  });
  return {
    ...rest,
    fees: data
  };
}
function useSignatureStatuses({
  options,
  config,
  abortSignal,
  signatures
}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = reactQuery.useQuery({
    ...options,
    enabled: signatures && signatures.length > 0,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getSignatureStatuses", signatures],
    queryFn: async () => {
      const { value } = await rpc.getSignatureStatuses(signatures, config).send({ abortSignal });
      return value;
    }
  });
  return {
    ...rest,
    statuses: data
  };
}
function useSignaturesForAddress({
  options,
  config,
  abortSignal,
  address: address2
}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = reactQuery.useQuery({
    networkMode: "offlineFirst",
    ...options,
    enabled: !!address2,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getSignaturesForAddress", address2],
    queryFn: async () => {
      const signatures = await rpc.getSignaturesForAddress(address2, config).send({ abortSignal });
      return signatures;
    }
  });
  return {
    ...rest,
    signatures: data
  };
}
function useSlot({
  options,
  config,
  abortSignal
} = {}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = reactQuery.useQuery({
    ...options,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getSlot"],
    queryFn: async () => {
      const slot = await rpc.getSlot(config).send({ abortSignal });
      return slot;
    }
  });
  return {
    ...rest,
    slot: data
  };
}
function hasDeclaredAta(input) {
  return input.ata !== void 0;
}
function useTokenAccount({
  options,
  config,
  abortSignal,
  // tokenProgram,
  ...tokenAccountOptions
}) {
  const { rpc } = useSolanaClient();
  if (abortSignal) {
    config = {
      ...config || {},
      abortSignal
    };
  }
  const { data, ...rest } = reactQuery.useQuery({
    networkMode: "offlineFirst",
    ...options,
    enabled: hasDeclaredAta(tokenAccountOptions) ? !!tokenAccountOptions.ata : Boolean(tokenAccountOptions.mint && tokenAccountOptions.owner),
    queryFn: async () => {
      let ata;
      if (hasDeclaredAta(tokenAccountOptions)) {
        ata = tokenAccountOptions.ata;
      } else {
        if (!tokenAccountOptions.tokenProgram) {
          const mint = await token.fetchMint(rpc, gill.address(tokenAccountOptions.mint));
          tokenAccountOptions.tokenProgram = mint.programAddress;
        }
        token.checkedTokenProgramAddress(tokenAccountOptions.tokenProgram);
        ata = await token.getAssociatedTokenAccountAddress(
          tokenAccountOptions.mint,
          tokenAccountOptions.owner,
          tokenAccountOptions.tokenProgram
        );
      }
      gill.assertIsAddress(ata);
      const account = await gill.fetchEncodedAccount(rpc, ata, config);
      gill.assertAccountExists(account);
      return token.decodeToken(account);
    },
    queryKey: [
      GILL_HOOK_CLIENT_KEY,
      "getTokenAccount",
      hasDeclaredAta(tokenAccountOptions) ? [{ ata: tokenAccountOptions.ata }] : [
        {
          mint: tokenAccountOptions.mint,
          owner: tokenAccountOptions.owner
        }
      ]
    ]
  });
  return {
    ...rest,
    account: data
  };
}
function useTokenMint({
  options,
  config,
  abortSignal,
  mint
}) {
  const { rpc } = useSolanaClient();
  if (abortSignal) {
    config = {
      ...config || {},
      abortSignal
    };
  }
  const { data, ...rest } = reactQuery.useQuery({
    networkMode: "offlineFirst",
    ...options,
    enabled: !!mint,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getMintAccount", mint],
    queryFn: async () => {
      const account = await gill.fetchEncodedAccount(rpc, mint, config);
      gill.assertAccountExists(account);
      return token.decodeMint(account);
    }
  });
  return {
    ...rest,
    account: data
  };
}
function useTransaction({
  options,
  config,
  abortSignal,
  signature
}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = reactQuery.useQuery({
    networkMode: "offlineFirst",
    ...options,
    enabled: !!signature,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getTransaction", signature],
    queryFn: async () => {
      const response = await rpc.getTransaction(signature, {
        // set default values for better DX
        maxSupportedTransactionVersion: 0,
        encoding: "json",
        ...config || {}
      }).send({ abortSignal });
      return response;
    }
  });
  return {
    ...rest,
    transaction: data
  };
}

// src/index.ts
if (BigInt.prototype.toJSON === void 0) {
  BigInt.prototype.toJSON = function() {
    return String(this);
  };
}

exports.GILL_HOOK_CLIENT_KEY = GILL_HOOK_CLIENT_KEY;
exports.GILL_NAME = GILL_NAME;
exports.SolanaProvider = SolanaProvider;
exports.useAccount = useAccount;
exports.useBalance = useBalance;
exports.useLatestBlockhash = useLatestBlockhash;
exports.useProgramAccounts = useProgramAccounts;
exports.useRecentPrioritizationFees = useRecentPrioritizationFees;
exports.useSignatureStatuses = useSignatureStatuses;
exports.useSignaturesForAddress = useSignaturesForAddress;
exports.useSlot = useSlot;
exports.useSolanaClient = useSolanaClient;
exports.useTokenAccount = useTokenAccount;
exports.useTokenMint = useTokenMint;
exports.useTransaction = useTransaction;
exports.useUpdateSolanaClient = useUpdateSolanaClient;
//# sourceMappingURL=index.node.cjs.map
//# sourceMappingURL=index.node.cjs.map