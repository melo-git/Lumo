import React from 'react';
import { QueryClientProvider, QueryClient, useQuery, useQueryClient, useMutation } from '@tanstack/react-query';
import { createSolanaClient, fetchEncodedAccount, assertAccountExists, decodeAccount, address, assertIsAddress } from 'gill';
import { fetchMint, checkedTokenProgramAddress, getAssociatedTokenAccountAddress, decodeToken, decodeMint } from 'gill/programs/token';

// src/const.ts
var GILL_NAME = "gill";
var GILL_HOOK_CLIENT_KEY = "gill-client";
function SolanaProvider({
  client,
  children,
  queryClient = new QueryClient()
}) {
  queryClient.setQueryData([GILL_HOOK_CLIENT_KEY], client);
  return /* @__PURE__ */ React.createElement(QueryClientProvider, { client: queryClient }, children);
}
function useSolanaClient() {
  const { data: config } = useQuery({
    queryKey: [GILL_HOOK_CLIENT_KEY],
    staleTime: Infinity,
    // fallback data should not be reached if used within `SolanaProvider`
    // since we set the initial value. but just in case => devnet
    initialData: createSolanaClient({
      urlOrMoniker: "devnet"
    })
  });
  return config;
}
function useUpdateSolanaClient() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async (newClient) => {
      queryClient.setQueryData([GILL_HOOK_CLIENT_KEY], newClient);
      return newClient;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [GILL_HOOK_CLIENT_KEY] });
      queryClient.prefetchQuery({ queryKey: [GILL_HOOK_CLIENT_KEY] });
      queryClient.refetchQueries({
        queryKey: [GILL_HOOK_CLIENT_KEY]
      });
    }
  });
}

// src/hooks/account.ts
function useAccount({ options, config, abortSignal, address: address2, decoder }) {
  const { rpc } = useSolanaClient();
  if (abortSignal) {
    config = {
      ...config || {},
      abortSignal
    };
  }
  const { data, ...rest } = useQuery({
    networkMode: "offlineFirst",
    ...options,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getAccountInfo", address2],
    queryFn: async () => {
      const account = await fetchEncodedAccount(rpc, address2, config);
      assertAccountExists(account);
      if (decoder) return decodeAccount(account, decoder);
      return account;
    },
    enabled: !!address2
  });
  return {
    ...rest,
    account: data
  };
}
function useBalance({
  options,
  config,
  abortSignal,
  address: address2
}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = useQuery({
    networkMode: "offlineFirst",
    ...options,
    enabled: !!address2,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getBalance", address2],
    queryFn: async () => {
      const { value } = await rpc.getBalance(address2, config).send({ abortSignal });
      return value;
    }
  });
  return {
    ...rest,
    balance: data
  };
}
function useLatestBlockhash({
  options,
  config,
  abortSignal
} = {}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = useQuery({
    ...options,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getLatestBlockhash"],
    queryFn: async () => {
      const { value } = await rpc.getLatestBlockhash(config).send({ abortSignal });
      return value;
    }
  });
  return {
    ...rest,
    latestBlockhash: data
  };
}
function useProgramAccounts({
  options,
  config,
  abortSignal,
  program
}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = useQuery({
    ...options,
    enabled: !!program,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getProgramAccounts", program],
    queryFn: async () => {
      const accounts = await rpc.getProgramAccounts(program, config).send({ abortSignal });
      return accounts;
    }
  });
  return {
    ...rest,
    accounts: data
  };
}
function useRecentPrioritizationFees({
  options,
  abortSignal,
  addresses
} = {}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = useQuery({
    ...options,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getRecentPrioritizationFees", addresses],
    queryFn: async () => {
      const fees = await rpc.getRecentPrioritizationFees(addresses).send({ abortSignal });
      return fees;
    }
  });
  return {
    ...rest,
    fees: data
  };
}
function useSignatureStatuses({
  options,
  config,
  abortSignal,
  signatures
}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = useQuery({
    ...options,
    enabled: signatures && signatures.length > 0,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getSignatureStatuses", signatures],
    queryFn: async () => {
      const { value } = await rpc.getSignatureStatuses(signatures, config).send({ abortSignal });
      return value;
    }
  });
  return {
    ...rest,
    statuses: data
  };
}
function useSignaturesForAddress({
  options,
  config,
  abortSignal,
  address: address2
}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = useQuery({
    networkMode: "offlineFirst",
    ...options,
    enabled: !!address2,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getSignaturesForAddress", address2],
    queryFn: async () => {
      const signatures = await rpc.getSignaturesForAddress(address2, config).send({ abortSignal });
      return signatures;
    }
  });
  return {
    ...rest,
    signatures: data
  };
}
function useSlot({
  options,
  config,
  abortSignal
} = {}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = useQuery({
    ...options,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getSlot"],
    queryFn: async () => {
      const slot = await rpc.getSlot(config).send({ abortSignal });
      return slot;
    }
  });
  return {
    ...rest,
    slot: data
  };
}
function hasDeclaredAta(input) {
  return input.ata !== void 0;
}
function useTokenAccount({
  options,
  config,
  abortSignal,
  // tokenProgram,
  ...tokenAccountOptions
}) {
  const { rpc } = useSolanaClient();
  if (abortSignal) {
    config = {
      ...config || {},
      abortSignal
    };
  }
  const { data, ...rest } = useQuery({
    networkMode: "offlineFirst",
    ...options,
    enabled: hasDeclaredAta(tokenAccountOptions) ? !!tokenAccountOptions.ata : Boolean(tokenAccountOptions.mint && tokenAccountOptions.owner),
    queryFn: async () => {
      let ata;
      if (hasDeclaredAta(tokenAccountOptions)) {
        ata = tokenAccountOptions.ata;
      } else {
        if (!tokenAccountOptions.tokenProgram) {
          const mint = await fetchMint(rpc, address(tokenAccountOptions.mint));
          tokenAccountOptions.tokenProgram = mint.programAddress;
        }
        checkedTokenProgramAddress(tokenAccountOptions.tokenProgram);
        ata = await getAssociatedTokenAccountAddress(
          tokenAccountOptions.mint,
          tokenAccountOptions.owner,
          tokenAccountOptions.tokenProgram
        );
      }
      assertIsAddress(ata);
      const account = await fetchEncodedAccount(rpc, ata, config);
      assertAccountExists(account);
      return decodeToken(account);
    },
    queryKey: [
      GILL_HOOK_CLIENT_KEY,
      "getTokenAccount",
      hasDeclaredAta(tokenAccountOptions) ? [{ ata: tokenAccountOptions.ata }] : [
        {
          mint: tokenAccountOptions.mint,
          owner: tokenAccountOptions.owner
        }
      ]
    ]
  });
  return {
    ...rest,
    account: data
  };
}
function useTokenMint({
  options,
  config,
  abortSignal,
  mint
}) {
  const { rpc } = useSolanaClient();
  if (abortSignal) {
    config = {
      ...config || {},
      abortSignal
    };
  }
  const { data, ...rest } = useQuery({
    networkMode: "offlineFirst",
    ...options,
    enabled: !!mint,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getMintAccount", mint],
    queryFn: async () => {
      const account = await fetchEncodedAccount(rpc, mint, config);
      assertAccountExists(account);
      return decodeMint(account);
    }
  });
  return {
    ...rest,
    account: data
  };
}
function useTransaction({
  options,
  config,
  abortSignal,
  signature
}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = useQuery({
    networkMode: "offlineFirst",
    ...options,
    enabled: !!signature,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getTransaction", signature],
    queryFn: async () => {
      const response = await rpc.getTransaction(signature, {
        // set default values for better DX
        maxSupportedTransactionVersion: 0,
        encoding: "json",
        ...config || {}
      }).send({ abortSignal });
      return response;
    }
  });
  return {
    ...rest,
    transaction: data
  };
}

// src/index.ts
if (BigInt.prototype.toJSON === void 0) {
  BigInt.prototype.toJSON = function() {
    return String(this);
  };
}

export { GILL_HOOK_CLIENT_KEY, GILL_NAME, SolanaProvider, useAccount, useBalance, useLatestBlockhash, useProgramAccounts, useRecentPrioritizationFees, useSignatureStatuses, useSignaturesForAddress, useSlot, useSolanaClient, useTokenAccount, useTokenMint, useTransaction, useUpdateSolanaClient };
//# sourceMappingURL=index.browser.mjs.map
//# sourceMappingURL=index.browser.mjs.map