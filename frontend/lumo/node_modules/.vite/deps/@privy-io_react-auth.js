import {
  B as B2,
  _ as _4,
  h as h4,
  toAccount,
  y as y3
} from "./chunk-45NQXWYW.js";
import {
  bytesToHex,
  sha256
} from "./chunk-4WVDYSSH.js";
import {
  $,
  $d,
  $n,
  $o,
  $r,
  A,
  Aa,
  Aa2,
  Ad,
  Ai,
  An,
  ArrowRightEndOnRectangleIcon_default,
  B,
  Ban,
  Bl,
  Bn,
  Bp,
  Br,
  C,
  Ca,
  CalendarIcon_default,
  Ch,
  CheckCircleIcon_default,
  ChevronRightIcon_default,
  Ci,
  CircleAlert,
  CircleCheckBig,
  CircleX,
  ClockIcon_default,
  CloudUpload,
  Cn,
  D,
  Da,
  Da2,
  DevicePhoneMobileIcon_default,
  Di,
  Dn,
  Dr,
  E,
  Ea,
  Ea2,
  El,
  En,
  EnvelopeIcon_default,
  Ep,
  ExclamationTriangleIcon_default,
  ExternalLink,
  F,
  F2,
  Fh,
  FingerPrintIcon_default,
  Fingerprint,
  Fn,
  G,
  Ga,
  Gd,
  Gg,
  GlobeAltIcon_default,
  Gn,
  Gr,
  H,
  Ha,
  Hf,
  Hn,
  Hr,
  I,
  Ia,
  Ia2,
  In,
  Ip,
  J,
  Ja,
  Jn,
  K,
  K2,
  Ka,
  Ke,
  Kg,
  Kn,
  Ko,
  L,
  L2,
  La,
  La2,
  Lf,
  Ll,
  Ln,
  Lp,
  M,
  M2,
  Ma,
  Mh,
  MinusCircleIcon_default,
  Ml,
  Mn,
  Mu,
  N,
  Na,
  Na2,
  Ni,
  Nl,
  Nn,
  Np,
  O,
  Oa,
  Oa2,
  Od,
  Oe,
  Ol,
  Or,
  Ou,
  P,
  P2,
  Pf,
  Ph,
  PhoneIcon_default,
  Pl,
  Pn,
  Pp,
  Pr,
  Q,
  Qa,
  Qn,
  QuestionMarkCircleIcon_default,
  R,
  Ra,
  Ra2,
  Rl,
  S,
  Sd,
  ShieldCheckIcon_default,
  Sl,
  Sn,
  T,
  Ta,
  Tn,
  Trash2,
  U,
  Ua,
  Uc,
  Ul,
  Un,
  V,
  Va,
  Vn,
  Vr,
  W,
  Wh,
  Wl,
  Wn,
  Wp,
  Wr,
  X,
  Xa,
  Xh,
  Xn,
  Xo,
  Xu,
  Y,
  Ya,
  Yg,
  Yh,
  Yn,
  Za,
  Zf,
  Zg,
  Zn,
  Zp,
  Zr,
  _,
  _2,
  _3,
  _a,
  _a2,
  _l,
  _n,
  a,
  a2,
  aa,
  ai,
  api,
  ar,
  b,
  b2,
  base64url_exports,
  bc,
  bm,
  c,
  ca,
  create,
  d,
  da,
  decodeJwt,
  dm,
  dp,
  dt,
  du,
  e,
  e2,
  e3,
  ea,
  ea2,
  ed,
  eh,
  er,
  f,
  f2,
  fc,
  fn,
  fr,
  ft,
  g,
  ga,
  gn,
  gr,
  h,
  h2,
  h3,
  ha,
  ho,
  hp,
  hr,
  ht,
  i,
  i2,
  i4 as i3,
  ia,
  ia2,
  id,
  ir,
  j,
  j2,
  jd,
  jn,
  k,
  k2,
  ka,
  kd,
  kl,
  kn,
  kp,
  l,
  l2,
  la,
  la2,
  ln,
  lt,
  m,
  m2,
  mi,
  mn,
  mp,
  n,
  n3 as n2,
  n4 as n3,
  na,
  nc,
  nh,
  ni,
  nr,
  ny,
  o,
  o2,
  oa,
  ofetch,
  on,
  or,
  p,
  p2,
  p3,
  pa,
  pi,
  pp,
  q,
  q2,
  qa,
  qf,
  qn,
  qo,
  qr,
  qu,
  r,
  r2,
  r3,
  r4,
  r5,
  r7 as r6,
  ra,
  ra2,
  rc,
  rd,
  require_browser,
  require_es5,
  require_lib,
  s,
  sa,
  sa2,
  sp,
  sr,
  t,
  t2,
  t3,
  t4,
  t5,
  ta,
  ta2,
  th,
  ti,
  tr,
  ua,
  ua2,
  ui,
  ur,
  v,
  v2,
  v4_default,
  va,
  va2,
  vm,
  vn,
  vu,
  w,
  w2,
  wa,
  wc,
  wn,
  x,
  x2,
  xa,
  xc,
  xd,
  xn,
  y,
  y2,
  yi,
  yn,
  zc,
  ze,
  zh,
  zl,
  zn
} from "./chunk-UDZM6VGO.js";
import "./chunk-RHY4GUXE.js";
import "./chunk-VRS73S24.js";
import "./chunk-DRSJMV4G.js";
import {
  createWalletClient,
  hashAuthorization,
  http,
  parseSignature,
  zeroAddress
} from "./chunk-BVEVOLUJ.js";
import "./chunk-MLKXWGQV.js";
import {
  getAddress,
  isAddress,
  isHex,
  toHex
} from "./chunk-PKYTL2RT.js";
import "./chunk-UU5WQT5Y.js";
import "./chunk-YIZCVY2B.js";
import "./chunk-OFYYQGW5.js";
import "./chunk-A5EXECA2.js";
import "./chunk-4A34GHET.js";
import "./chunk-3HCG2SZW.js";
import "./chunk-OISTZNKL.js";
import "./chunk-IZNJ6FWV.js";
import {
  eventemitter3_default,
  import_index
} from "./chunk-NSRIWIO5.js";
import "./chunk-O6QMZTUY.js";
import "./chunk-UXERXID2.js";
import {
  require_jsx_runtime
} from "./chunk-RCILDZKZ.js";
import {
  require_react
} from "./chunk-PEG7TMOV.js";
import {
  __commonJS,
  __toESM,
  import_buffer,
  init_shim
} from "./chunk-HEPQZC56.js";

// node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;
    function number(n6) {
      if (!Number.isSafeInteger(n6) || n6 < 0)
        throw new Error(`positive integer expected, not ${n6}`);
    }
    exports.number = number;
    function bool(b4) {
      if (typeof b4 !== "boolean")
        throw new Error(`boolean expected, not ${b4}`);
    }
    exports.bool = bool;
    function isBytes(a3) {
      return a3 instanceof Uint8Array || a3 != null && typeof a3 === "object" && a3.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes;
    function bytes(b4, ...lengths) {
      if (!isBytes(b4))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b4.length))
        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b4.length}`);
    }
    exports.bytes = bytes;
    function hash(h7) {
      if (typeof h7 !== "function" || typeof h7.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(h7.outputLen);
      number(h7.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = { number, bool, bytes, hash, exists, output };
    exports.default = assert;
  }
});

// node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n6, le = false) {
      if (le)
        return { h: Number(n6 & U32_MASK64), l: Number(n6 >> _32n & U32_MASK64) };
      return { h: Number(n6 >> _32n & U32_MASK64) | 0, l: Number(n6 & U32_MASK64) | 0 };
    }
    exports.fromBig = fromBig;
    function split(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al2 = new Uint32Array(lst.length);
      for (let i5 = 0; i5 < lst.length; i5++) {
        const { h: h7, l: l5 } = fromBig(lst[i5], le);
        [Ah[i5], Al2[i5]] = [h7, l5];
      }
      return [Ah, Al2];
    }
    exports.split = split;
    var toBig = (h7, l5) => BigInt(h7 >>> 0) << _32n | BigInt(l5 >>> 0);
    exports.toBig = toBig;
    var shrSH = (h7, _l3, s3) => h7 >>> s3;
    exports.shrSH = shrSH;
    var shrSL = (h7, l5, s3) => h7 << 32 - s3 | l5 >>> s3;
    exports.shrSL = shrSL;
    var rotrSH = (h7, l5, s3) => h7 >>> s3 | l5 << 32 - s3;
    exports.rotrSH = rotrSH;
    var rotrSL = (h7, l5, s3) => h7 << 32 - s3 | l5 >>> s3;
    exports.rotrSL = rotrSL;
    var rotrBH = (h7, l5, s3) => h7 << 64 - s3 | l5 >>> s3 - 32;
    exports.rotrBH = rotrBH;
    var rotrBL = (h7, l5, s3) => h7 >>> s3 - 32 | l5 << 64 - s3;
    exports.rotrBL = rotrBL;
    var rotr32H = (_h, l5) => l5;
    exports.rotr32H = rotr32H;
    var rotr32L = (h7, _l3) => h7;
    exports.rotr32L = rotr32L;
    var rotlSH = (h7, l5, s3) => h7 << s3 | l5 >>> 32 - s3;
    exports.rotlSH = rotlSH;
    var rotlSL = (h7, l5, s3) => l5 << s3 | h7 >>> 32 - s3;
    exports.rotlSL = rotlSL;
    var rotlBH = (h7, l5, s3) => l5 << s3 - 32 | h7 >>> 64 - s3;
    exports.rotlBH = rotlBH;
    var rotlBL = (h7, l5, s3) => h7 << s3 - 32 | l5 >>> 64 - s3;
    exports.rotlBL = rotlBL;
    function add(Ah, Al2, Bh, Bl3) {
      const l5 = (Al2 >>> 0) + (Bl3 >>> 0);
      return { h: Ah + Bh + (l5 / 2 ** 32 | 0) | 0, l: l5 | 0 };
    }
    exports.add = add;
    var add3L = (Al2, Bl3, Cl2) => (Al2 >>> 0) + (Bl3 >>> 0) + (Cl2 >>> 0);
    exports.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch2) => Ah + Bh + Ch2 + (low / 2 ** 32 | 0) | 0;
    exports.add3H = add3H;
    var add4L = (Al2, Bl3, Cl2, Dl2) => (Al2 >>> 0) + (Bl3 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0);
    exports.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch2, Dh) => Ah + Bh + Ch2 + Dh + (low / 2 ** 32 | 0) | 0;
    exports.add4H = add4H;
    var add5L = (Al2, Bl3, Cl2, Dl2, El3) => (Al2 >>> 0) + (Bl3 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0) + (El3 >>> 0);
    exports.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch2, Dh, Eh) => Ah + Bh + Ch2 + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = exports.isBytes = void 0;
    var crypto_1 = require_crypto();
    var _assert_js_1 = require_assert();
    function isBytes(a3) {
      return a3 instanceof Uint8Array || a3 != null && typeof a3 === "object" && a3.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes;
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
    exports.rotl = rotl;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    exports.byteSwap = byteSwap;
    exports.byteSwapIfBE = exports.isLE ? (n6) => n6 : (n6) => (0, exports.byteSwap)(n6);
    function byteSwap32(arr) {
      for (let i5 = 0; i5 < arr.length; i5++) {
        arr[i5] = (0, exports.byteSwap)(arr[i5]);
      }
    }
    exports.byteSwap32 = byteSwap32;
    var hexes = Array.from({ length: 256 }, (_5, i5) => i5.toString(16).padStart(2, "0"));
    function bytesToHex2(bytes) {
      (0, _assert_js_1.bytes)(bytes);
      let hex = "";
      for (let i5 = 0; i5 < bytes.length; i5++) {
        hex += hexes[bytes[i5]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex2;
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl2 = hex.length;
      const al2 = hl2 / 2;
      if (hl2 % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl2);
      const array = new Uint8Array(al2);
      for (let ai2 = 0, hi = 0; ai2 < al2; ai2++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n22 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n22 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai2] = n1 * 16 + n22;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts2 = Date.now();
      for (let i5 = 0; i5 < iters; i5++) {
        cb(i5);
        const diff = Date.now() - ts2;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts2 += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      (0, _assert_js_1.bytes)(data);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i5 = 0; i5 < arrays.length; i5++) {
        const a3 = arrays[i5];
        (0, _assert_js_1.bytes)(a3);
        sum += a3.length;
      }
      const res = new Uint8Array(sum);
      for (let i5 = 0, pad = 0; i5 < arrays.length; i5++) {
        const a3 = arrays[i5];
        res.set(a3, pad);
        pad += a3.length;
      }
      return res;
    }
    exports.concatBytes = concatBytes;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS({
  "node_modules/@noble/hashes/sha3.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
    var _assert_js_1 = require_assert();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils();
    var SHA3_PI = [];
    var SHA3_ROTL = [];
    var _SHA3_IOTA = [];
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    for (let round = 0, R2 = _1n, x4 = 1, y6 = 0; round < 24; round++) {
      [x4, y6] = [y6, (2 * x4 + 3 * y6) % 5];
      SHA3_PI.push(2 * (5 * y6 + x4));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t8 = _0n;
      for (let j3 = 0; j3 < 7; j3++) {
        R2 = (R2 << _1n ^ (R2 >> _7n) * _0x71n) % _256n;
        if (R2 & _2n)
          t8 ^= _1n << (_1n << BigInt(j3)) - _1n;
      }
      _SHA3_IOTA.push(t8);
    }
    var [SHA3_IOTA_H, SHA3_IOTA_L] = (0, _u64_js_1.split)(_SHA3_IOTA, true);
    var rotlH = (h7, l5, s3) => s3 > 32 ? (0, _u64_js_1.rotlBH)(h7, l5, s3) : (0, _u64_js_1.rotlSH)(h7, l5, s3);
    var rotlL = (h7, l5, s3) => s3 > 32 ? (0, _u64_js_1.rotlBL)(h7, l5, s3) : (0, _u64_js_1.rotlSL)(h7, l5, s3);
    function keccakP(s3, rounds = 24) {
      const B3 = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x4 = 0; x4 < 10; x4++)
          B3[x4] = s3[x4] ^ s3[x4 + 10] ^ s3[x4 + 20] ^ s3[x4 + 30] ^ s3[x4 + 40];
        for (let x4 = 0; x4 < 10; x4 += 2) {
          const idx1 = (x4 + 8) % 10;
          const idx0 = (x4 + 2) % 10;
          const B0 = B3[idx0];
          const B1 = B3[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B3[idx1];
          const Tl2 = rotlL(B0, B1, 1) ^ B3[idx1 + 1];
          for (let y6 = 0; y6 < 50; y6 += 10) {
            s3[x4 + y6] ^= Th;
            s3[x4 + y6 + 1] ^= Tl2;
          }
        }
        let curH = s3[2];
        let curL = s3[3];
        for (let t8 = 0; t8 < 24; t8++) {
          const shift = SHA3_ROTL[t8];
          const Th = rotlH(curH, curL, shift);
          const Tl2 = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t8];
          curH = s3[PI];
          curL = s3[PI + 1];
          s3[PI] = Th;
          s3[PI + 1] = Tl2;
        }
        for (let y6 = 0; y6 < 50; y6 += 10) {
          for (let x4 = 0; x4 < 10; x4++)
            B3[x4] = s3[y6 + x4];
          for (let x4 = 0; x4 < 10; x4++)
            s3[y6 + x4] ^= ~B3[(x4 + 2) % 10] & B3[(x4 + 4) % 10];
        }
        s3[0] ^= SHA3_IOTA_H[round];
        s3[1] ^= SHA3_IOTA_L[round];
      }
      B3.fill(0);
    }
    exports.keccakP = keccakP;
    var Keccak = class _Keccak extends utils_js_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.number)(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        if (!utils_js_1.isLE)
          (0, utils_js_1.byteSwap32)(this.state32);
        keccakP(this.state32, this.rounds);
        if (!utils_js_1.isLE)
          (0, utils_js_1.byteSwap32)(this.state32);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i5 = 0; i5 < take; i5++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to2) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to2 || (to2 = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to2.state32.set(this.state32);
        to2.pos = this.pos;
        to2.posOut = this.posOut;
        to2.finished = this.finished;
        to2.rounds = rounds;
        to2.suffix = suffix;
        to2.outputLen = outputLen;
        to2.enableXOF = enableXOF;
        to2.destroyed = this.destroyed;
        return to2;
      }
    };
    exports.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports.sha3_224 = gen(6, 144, 224 / 8);
    exports.sha3_256 = gen(6, 136, 256 / 8);
    exports.sha3_384 = gen(6, 104, 384 / 8);
    exports.sha3_512 = gen(6, 72, 512 / 8);
    exports.keccak_224 = gen(1, 144, 224 / 8);
    exports.keccak_256 = gen(1, 136, 256 / 8);
    exports.keccak_384 = gen(1, 104, 384 / 8);
    exports.keccak_512 = gen(1, 72, 512 / 8);
    var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports.shake128 = genShake(31, 168, 128 / 8);
    exports.shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/util.cjs
var require_util = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/util.cjs"(exports, module) {
    init_shim();
    var { keccak_256 } = require_sha3();
    function zeros(bytes) {
      return import_buffer.Buffer.allocUnsafe(bytes).fill(0);
    }
    function bitLengthFromBigInt(num) {
      return num.toString(2).length;
    }
    function bufferBEFromBigInt(num, length) {
      let hex = num.toString(16);
      if (hex.length % 2 !== 0) hex = "0" + hex;
      const byteArray = hex.match(/.{1,2}/g).map((byte) => parseInt(byte, 16));
      while (byteArray.length < length) {
        byteArray.unshift(0);
      }
      return import_buffer.Buffer.from(byteArray);
    }
    function twosFromBigInt(value, width) {
      const isNegative = value < 0n;
      let result;
      if (isNegative) {
        const mask = (1n << BigInt(width)) - 1n;
        result = (~value & mask) + 1n;
      } else {
        result = value;
      }
      result &= (1n << BigInt(width)) - 1n;
      return result;
    }
    function setLength(msg, length, right) {
      const buf = zeros(length);
      msg = toBuffer(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    }
    function setLengthRight(msg, length) {
      return setLength(msg, length, true);
    }
    function toBuffer(v5) {
      if (!import_buffer.Buffer.isBuffer(v5)) {
        if (Array.isArray(v5)) {
          v5 = import_buffer.Buffer.from(v5);
        } else if (typeof v5 === "string") {
          if (isHexString2(v5)) {
            v5 = import_buffer.Buffer.from(padToEven(stripHexPrefix(v5)), "hex");
          } else {
            v5 = import_buffer.Buffer.from(v5);
          }
        } else if (typeof v5 === "number") {
          v5 = intToBuffer(v5);
        } else if (v5 === null || v5 === void 0) {
          v5 = import_buffer.Buffer.allocUnsafe(0);
        } else if (typeof v5 === "bigint") {
          v5 = bufferBEFromBigInt(v5);
        } else if (v5.toArray) {
          v5 = import_buffer.Buffer.from(v5.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v5;
    }
    function bufferToHex(buf) {
      buf = toBuffer(buf);
      return "0x" + buf.toString("hex");
    }
    function keccak(a3, bits) {
      a3 = toBuffer(a3);
      if (!bits) bits = 256;
      if (bits !== 256) {
        throw new Error("unsupported");
      }
      return import_buffer.Buffer.from(keccak_256(new Uint8Array(a3)));
    }
    function padToEven(str) {
      return str.length % 2 ? "0" + str : str;
    }
    function isHexString2(str) {
      return typeof str === "string" && str.match(/^0x[0-9A-Fa-f]*$/);
    }
    function stripHexPrefix(str) {
      if (typeof str === "string" && str.startsWith("0x")) {
        return str.slice(2);
      }
      return str;
    }
    module.exports = {
      zeros,
      setLength,
      setLengthRight,
      isHexString: isHexString2,
      stripHexPrefix,
      toBuffer,
      bufferToHex,
      keccak,
      bitLengthFromBigInt,
      bufferBEFromBigInt,
      twosFromBigInt
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/abi.cjs
var require_abi = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/abi.cjs"(exports, module) {
    init_shim();
    var util = require_util();
    function elementaryName(name) {
      if (name.startsWith("int[")) {
        return "int256" + name.slice(3);
      } else if (name === "int") {
        return "int256";
      } else if (name.startsWith("uint[")) {
        return "uint256" + name.slice(4);
      } else if (name === "uint") {
        return "uint256";
      } else if (name.startsWith("fixed[")) {
        return "fixed128x128" + name.slice(5);
      } else if (name === "fixed") {
        return "fixed128x128";
      } else if (name.startsWith("ufixed[")) {
        return "ufixed128x128" + name.slice(6);
      } else if (name === "ufixed") {
        return "ufixed128x128";
      }
      return name;
    }
    function parseTypeN(type) {
      return Number.parseInt(/^\D+(\d+)$/.exec(type)[1], 10);
    }
    function parseTypeNxM(type) {
      var tmp = /^\D+(\d+)x(\d+)$/.exec(type);
      return [Number.parseInt(tmp[1], 10), Number.parseInt(tmp[2], 10)];
    }
    function parseTypeArray(type) {
      var tmp = type.match(/(.*)\[(.*?)\]$/);
      if (tmp) {
        return tmp[2] === "" ? "dynamic" : Number.parseInt(tmp[2], 10);
      }
      return null;
    }
    function parseNumber(arg) {
      var type = typeof arg;
      if (type === "string" || type === "number") {
        return BigInt(arg);
      } else if (type === "bigint") {
        return arg;
      } else {
        throw new Error("Argument is not a number");
      }
    }
    function encodeSingle(type, arg) {
      var size, num, ret, i5;
      if (type === "address") {
        return encodeSingle("uint160", parseNumber(arg));
      } else if (type === "bool") {
        return encodeSingle("uint8", arg ? 1 : 0);
      } else if (type === "string") {
        return encodeSingle("bytes", new import_buffer.Buffer(arg, "utf8"));
      } else if (isArray(type)) {
        if (typeof arg.length === "undefined") {
          throw new Error("Not an array?");
        }
        size = parseTypeArray(type);
        if (size !== "dynamic" && size !== 0 && arg.length > size) {
          throw new Error("Elements exceed array size: " + size);
        }
        ret = [];
        type = type.slice(0, type.lastIndexOf("["));
        if (typeof arg === "string") {
          arg = JSON.parse(arg);
        }
        for (i5 in arg) {
          ret.push(encodeSingle(type, arg[i5]));
        }
        if (size === "dynamic") {
          var length = encodeSingle("uint256", arg.length);
          ret.unshift(length);
        }
        return import_buffer.Buffer.concat(ret);
      } else if (type === "bytes") {
        arg = new import_buffer.Buffer(arg);
        ret = import_buffer.Buffer.concat([encodeSingle("uint256", arg.length), arg]);
        if (arg.length % 32 !== 0) {
          ret = import_buffer.Buffer.concat([ret, util.zeros(32 - arg.length % 32)]);
        }
        return ret;
      } else if (type.startsWith("bytes")) {
        size = parseTypeN(type);
        if (size < 1 || size > 32) {
          throw new Error("Invalid bytes<N> width: " + size);
        }
        return util.setLengthRight(arg, 32);
      } else if (type.startsWith("uint")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid uint<N> width: " + size);
        }
        num = parseNumber(arg);
        const bitLength = util.bitLengthFromBigInt(num);
        if (bitLength > size) {
          throw new Error("Supplied uint exceeds width: " + size + " vs " + bitLength);
        }
        if (num < 0) {
          throw new Error("Supplied uint is negative");
        }
        return util.bufferBEFromBigInt(num, 32);
      } else if (type.startsWith("int")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid int<N> width: " + size);
        }
        num = parseNumber(arg);
        const bitLength = util.bitLengthFromBigInt(num);
        if (bitLength > size) {
          throw new Error("Supplied int exceeds width: " + size + " vs " + bitLength);
        }
        const twos = util.twosFromBigInt(num, 256);
        return util.bufferBEFromBigInt(twos, 32);
      } else if (type.startsWith("ufixed")) {
        size = parseTypeNxM(type);
        num = parseNumber(arg);
        if (num < 0) {
          throw new Error("Supplied ufixed is negative");
        }
        return encodeSingle("uint256", num * BigInt(2) ** BigInt(size[1]));
      } else if (type.startsWith("fixed")) {
        size = parseTypeNxM(type);
        return encodeSingle("int256", parseNumber(arg) * BigInt(2) ** BigInt(size[1]));
      }
      throw new Error("Unsupported or invalid type: " + type);
    }
    function isDynamic(type) {
      return type === "string" || type === "bytes" || parseTypeArray(type) === "dynamic";
    }
    function isArray(type) {
      return type.lastIndexOf("]") === type.length - 1;
    }
    function rawEncode(types, values) {
      var output = [];
      var data = [];
      var headLength = 32 * types.length;
      for (var i5 in types) {
        var type = elementaryName(types[i5]);
        var value = values[i5];
        var cur = encodeSingle(type, value);
        if (isDynamic(type)) {
          output.push(encodeSingle("uint256", headLength));
          data.push(cur);
          headLength += cur.length;
        } else {
          output.push(cur);
        }
      }
      return import_buffer.Buffer.concat(output.concat(data));
    }
    function solidityPack(types, values) {
      if (types.length !== values.length) {
        throw new Error("Number of types are not matching the values");
      }
      var size, num;
      var ret = [];
      for (var i5 = 0; i5 < types.length; i5++) {
        var type = elementaryName(types[i5]);
        var value = values[i5];
        if (type === "bytes") {
          ret.push(value);
        } else if (type === "string") {
          ret.push(new import_buffer.Buffer(value, "utf8"));
        } else if (type === "bool") {
          ret.push(new import_buffer.Buffer(value ? "01" : "00", "hex"));
        } else if (type === "address") {
          ret.push(util.setLength(value, 20));
        } else if (type.startsWith("bytes")) {
          size = parseTypeN(type);
          if (size < 1 || size > 32) {
            throw new Error("Invalid bytes<N> width: " + size);
          }
          ret.push(util.setLengthRight(value, size));
        } else if (type.startsWith("uint")) {
          size = parseTypeN(type);
          if (size % 8 || size < 8 || size > 256) {
            throw new Error("Invalid uint<N> width: " + size);
          }
          num = parseNumber(value);
          const bitLength = util.bitLengthFromBigInt(num);
          if (bitLength > size) {
            throw new Error("Supplied uint exceeds width: " + size + " vs " + bitLength);
          }
          ret.push(util.bufferBEFromBigInt(num, size / 8));
        } else if (type.startsWith("int")) {
          size = parseTypeN(type);
          if (size % 8 || size < 8 || size > 256) {
            throw new Error("Invalid int<N> width: " + size);
          }
          num = parseNumber(value);
          const bitLength = util.bitLengthFromBigInt(num);
          if (bitLength > size) {
            throw new Error("Supplied int exceeds width: " + size + " vs " + bitLength);
          }
          const twos = util.twosFromBigInt(num, size);
          ret.push(util.bufferBEFromBigInt(twos, size / 8));
        } else {
          throw new Error("Unsupported or invalid type: " + type);
        }
      }
      return import_buffer.Buffer.concat(ret);
    }
    function soliditySHA3(types, values) {
      return util.keccak(solidityPack(types, values));
    }
    module.exports = {
      rawEncode,
      solidityPack,
      soliditySHA3
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/index.cjs
var require_eth_eip712_util = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/index.cjs"(exports, module) {
    init_shim();
    var util = require_util();
    var abi = require_abi();
    var TYPED_MESSAGE_SCHEMA = {
      type: "object",
      properties: {
        types: {
          type: "object",
          additionalProperties: {
            type: "array",
            items: {
              type: "object",
              properties: {
                name: { type: "string" },
                type: { type: "string" }
              },
              required: ["name", "type"]
            }
          }
        },
        primaryType: { type: "string" },
        domain: { type: "object" },
        message: { type: "object" }
      },
      required: ["types", "primaryType", "domain", "message"]
    };
    var TypedDataUtils = {
      /**
       * Encodes an object by encoding and concatenating each of its members
       *
       * @param {string} primaryType - Root type
       * @param {Object} data - Object to encode
       * @param {Object} types - Type definitions
       * @returns {string} - Encoded representation of an object
       */
      encodeData(primaryType, data, types, useV4 = true) {
        const encodedTypes = ["bytes32"];
        const encodedValues = [this.hashType(primaryType, types)];
        if (useV4) {
          const encodeField = (name, type, value) => {
            if (types[type] !== void 0) {
              return ["bytes32", value == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : util.keccak(this.encodeData(type, value, types, useV4))];
            }
            if (value === void 0)
              throw new Error(`missing value for field ${name} of type ${type}`);
            if (type === "bytes") {
              return ["bytes32", util.keccak(value)];
            }
            if (type === "string") {
              if (typeof value === "string") {
                value = import_buffer.Buffer.from(value, "utf8");
              }
              return ["bytes32", util.keccak(value)];
            }
            if (type.lastIndexOf("]") === type.length - 1) {
              const parsedType = type.slice(0, type.lastIndexOf("["));
              const typeValuePairs = value.map((item) => encodeField(name, parsedType, item));
              return ["bytes32", util.keccak(abi.rawEncode(
                typeValuePairs.map(([type2]) => type2),
                typeValuePairs.map(([, value2]) => value2)
              ))];
            }
            return [type, value];
          };
          for (const field of types[primaryType]) {
            const [type, value] = encodeField(field.name, field.type, data[field.name]);
            encodedTypes.push(type);
            encodedValues.push(value);
          }
        } else {
          for (const field of types[primaryType]) {
            let value = data[field.name];
            if (value !== void 0) {
              if (field.type === "bytes") {
                encodedTypes.push("bytes32");
                value = util.keccak(value);
                encodedValues.push(value);
              } else if (field.type === "string") {
                encodedTypes.push("bytes32");
                if (typeof value === "string") {
                  value = import_buffer.Buffer.from(value, "utf8");
                }
                value = util.keccak(value);
                encodedValues.push(value);
              } else if (types[field.type] !== void 0) {
                encodedTypes.push("bytes32");
                value = util.keccak(this.encodeData(field.type, value, types, useV4));
                encodedValues.push(value);
              } else if (field.type.lastIndexOf("]") === field.type.length - 1) {
                throw new Error("Arrays currently unimplemented in encodeData");
              } else {
                encodedTypes.push(field.type);
                encodedValues.push(value);
              }
            }
          }
        }
        return abi.rawEncode(encodedTypes, encodedValues);
      },
      /**
       * Encodes the type of an object by encoding a comma delimited list of its members
       *
       * @param {string} primaryType - Root type to encode
       * @param {Object} types - Type definitions
       * @returns {string} - Encoded representation of the type of an object
       */
      encodeType(primaryType, types) {
        let result = "";
        let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType);
        deps = [primaryType].concat(deps.sort());
        for (const type of deps) {
          const children = types[type];
          if (!children) {
            throw new Error("No type definition specified: " + type);
          }
          result += type + "(" + types[type].map(({ name, type: type2 }) => type2 + " " + name).join(",") + ")";
        }
        return result;
      },
      /**
       * Finds all types within a type definition object
       *
       * @param {string} primaryType - Root type
       * @param {Object} types - Type definitions
       * @param {Array} results - current set of accumulated types
       * @returns {Array} - Set of all types found in the type definition
       */
      findTypeDependencies(primaryType, types, results = []) {
        primaryType = primaryType.match(/^\w*/)[0];
        if (results.includes(primaryType) || types[primaryType] === void 0) {
          return results;
        }
        results.push(primaryType);
        for (const field of types[primaryType]) {
          for (const dep of this.findTypeDependencies(field.type, types, results)) {
            !results.includes(dep) && results.push(dep);
          }
        }
        return results;
      },
      /**
       * Hashes an object
       *
       * @param {string} primaryType - Root type
       * @param {Object} data - Object to hash
       * @param {Object} types - Type definitions
       * @returns {Buffer} - Hash of an object
       */
      hashStruct(primaryType, data, types, useV4 = true) {
        return util.keccak(this.encodeData(primaryType, data, types, useV4));
      },
      /**
       * Hashes the type of an object
       *
       * @param {string} primaryType - Root type to hash
       * @param {Object} types - Type definitions
       * @returns {string} - Hash of an object
       */
      hashType(primaryType, types) {
        return util.keccak(this.encodeType(primaryType, types));
      },
      /**
       * Removes properties from a message object that are not defined per EIP-712
       *
       * @param {Object} data - typed message object
       * @returns {Object} - typed message object with only allowed fields
       */
      sanitizeData(data) {
        const sanitizedData = {};
        for (const key in TYPED_MESSAGE_SCHEMA.properties) {
          data[key] && (sanitizedData[key] = data[key]);
        }
        if (sanitizedData.types) {
          sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
        }
        return sanitizedData;
      },
      /**
       * Returns the hash of a typed message as per EIP-712 for signing
       *
       * @param {Object} typedData - Types message data to sign
       * @returns {string} - sha3 hash for signing
       */
      hash(typedData, useV4 = true) {
        const sanitizedData = this.sanitizeData(typedData);
        const parts = [import_buffer.Buffer.from("1901", "hex")];
        parts.push(this.hashStruct("EIP712Domain", sanitizedData.domain, sanitizedData.types, useV4));
        if (sanitizedData.primaryType !== "EIP712Domain") {
          parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));
        }
        return util.keccak(import_buffer.Buffer.concat(parts));
      }
    };
    module.exports = {
      TYPED_MESSAGE_SCHEMA,
      TypedDataUtils,
      hashForSignTypedDataLegacy: function(msgParams) {
        return typedSignatureHashLegacy(msgParams.data);
      },
      hashForSignTypedData_v3: function(msgParams) {
        return TypedDataUtils.hash(msgParams.data, false);
      },
      hashForSignTypedData_v4: function(msgParams) {
        return TypedDataUtils.hash(msgParams.data);
      }
    };
    function typedSignatureHashLegacy(typedData) {
      const error = new Error("Expect argument to be non-empty array");
      if (typeof typedData !== "object" || !typedData.length) throw error;
      const data = typedData.map(function(e7) {
        return e7.type === "bytes" ? util.toBuffer(e7.value) : e7.value;
      });
      const types = typedData.map(function(e7) {
        return e7.type;
      });
      const schema = typedData.map(function(e7) {
        if (!e7.name) throw error;
        return e7.type + " " + e7.name;
      });
      return abi.soliditySHA3(
        ["bytes32", "bytes32"],
        [
          abi.soliditySHA3(new Array(typedData.length).fill("string"), schema),
          abi.soliditySHA3(types, data)
        ]
      );
    }
  }
});

// node_modules/@privy-io/react-auth/dist/esm/index.mjs
init_shim();
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);

// node_modules/mipd/dist/esm/index.js
init_shim();

// node_modules/mipd/dist/esm/store.js
init_shim();

// node_modules/mipd/dist/esm/utils.js
init_shim();
function requestProviders(listener) {
  if (typeof window === "undefined")
    return;
  const handler = (event) => listener(event.detail);
  window.addEventListener("eip6963:announceProvider", handler);
  window.dispatchEvent(new CustomEvent("eip6963:requestProvider"));
  return () => window.removeEventListener("eip6963:announceProvider", handler);
}

// node_modules/mipd/dist/esm/store.js
function createStore() {
  const listeners = /* @__PURE__ */ new Set();
  let providerDetails = [];
  const request = () => requestProviders((providerDetail) => {
    if (providerDetails.some(({ info }) => info.uuid === providerDetail.info.uuid))
      return;
    providerDetails = [...providerDetails, providerDetail];
    listeners.forEach((listener) => listener(providerDetails, { added: [providerDetail] }));
  });
  let unwatch = request();
  return {
    _listeners() {
      return listeners;
    },
    clear() {
      listeners.forEach((listener) => listener([], { removed: [...providerDetails] }));
      providerDetails = [];
    },
    destroy() {
      this.clear();
      listeners.clear();
      unwatch?.();
    },
    findProvider({ rdns }) {
      return providerDetails.find((providerDetail) => providerDetail.info.rdns === rdns);
    },
    getProviders() {
      return providerDetails;
    },
    reset() {
      this.clear();
      unwatch?.();
      unwatch = request();
    },
    subscribe(listener, { emitImmediately } = {}) {
      listeners.add(listener);
      if (emitImmediately)
        listener(providerDetails, { added: providerDetails });
      return () => listeners.delete(listener);
    }
  };
}

// node_modules/@privy-io/react-auth/dist/esm/index.mjs
var import_react3 = __toESM(require_react(), 1);
var import_react_device_detect = __toESM(require_lib(), 1);

// node_modules/@coinbase/wallet-sdk/dist/index.js
init_shim();

// node_modules/@coinbase/wallet-sdk/dist/CoinbaseWalletSDK.js
init_shim();

// node_modules/@coinbase/wallet-sdk/dist/assets/wallet-logo.js
init_shim();

// node_modules/@coinbase/wallet-sdk/dist/CoinbaseWalletProvider.js
init_shim();

// node_modules/@coinbase/wallet-sdk/dist/sign/util.js
init_shim();

// node_modules/@coinbase/wallet-sdk/dist/sign/scw/SCWSigner.js
init_shim();

// node_modules/@coinbase/wallet-sdk/dist/sign/scw/SCWKeyManager.js
init_shim();

// node_modules/@coinbase/wallet-sdk/dist/core/storage/ScopedLocalStorage.js
init_shim();
var ScopedLocalStorage = class _ScopedLocalStorage {
  constructor(scope, module) {
    this.scope = scope;
    this.module = module;
  }
  storeObject(key, item) {
    this.setItem(key, JSON.stringify(item));
  }
  loadObject(key) {
    const item = this.getItem(key);
    return item ? JSON.parse(item) : void 0;
  }
  setItem(key, value) {
    localStorage.setItem(this.scopedKey(key), value);
  }
  getItem(key) {
    return localStorage.getItem(this.scopedKey(key));
  }
  removeItem(key) {
    localStorage.removeItem(this.scopedKey(key));
  }
  clear() {
    const prefix = this.scopedKey("");
    const keysToRemove = [];
    for (let i5 = 0; i5 < localStorage.length; i5++) {
      const key = localStorage.key(i5);
      if (typeof key === "string" && key.startsWith(prefix)) {
        keysToRemove.push(key);
      }
    }
    keysToRemove.forEach((key) => localStorage.removeItem(key));
  }
  scopedKey(key) {
    return `-${this.scope}${this.module ? `:${this.module}` : ""}:${key}`;
  }
  static clearAll() {
    new _ScopedLocalStorage("CBWSDK").clear();
    new _ScopedLocalStorage("walletlink").clear();
  }
};

// node_modules/@coinbase/wallet-sdk/dist/util/cipher.js
init_shim();

// node_modules/@coinbase/wallet-sdk/dist/core/type/util.js
init_shim();

// node_modules/@coinbase/wallet-sdk/dist/core/error/errors.js
init_shim();

// node_modules/@coinbase/wallet-sdk/dist/core/error/constants.js
init_shim();
var standardErrorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901,
    unsupportedChain: 4902
  }
};
var errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  "4001": {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  "4100": {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  "4200": {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  "4900": {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  "4901": {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  },
  "4902": {
    standard: "EIP-3085",
    message: "Unrecognized chain ID."
  }
};

// node_modules/@coinbase/wallet-sdk/dist/core/error/utils.js
init_shim();
var FALLBACK_MESSAGE = "Unspecified error message.";
var JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
  if (code && Number.isInteger(code)) {
    const codeString = code.toString();
    if (hasKey(errorValues, codeString)) {
      return errorValues[codeString].message;
    }
    if (isJsonRpcServerError(code)) {
      return JSON_RPC_SERVER_ERROR_MESSAGE;
    }
  }
  return fallbackMessage;
}
function isValidCode(code) {
  if (!Number.isInteger(code)) {
    return false;
  }
  const codeString = code.toString();
  if (errorValues[codeString]) {
    return true;
  }
  if (isJsonRpcServerError(code)) {
    return true;
  }
  return false;
}
function serialize(error, { shouldIncludeStack = false } = {}) {
  const serialized = {};
  if (error && typeof error === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
    const _error = error;
    serialized.code = _error.code;
    if (_error.message && typeof _error.message === "string") {
      serialized.message = _error.message;
      if (hasKey(_error, "data")) {
        serialized.data = _error.data;
      }
    } else {
      serialized.message = getMessageFromCode(serialized.code);
      serialized.data = { originalError: assignOriginalError(error) };
    }
  } else {
    serialized.code = standardErrorCodes.rpc.internal;
    serialized.message = hasStringProperty(error, "message") ? error.message : FALLBACK_MESSAGE;
    serialized.data = { originalError: assignOriginalError(error) };
  }
  if (shouldIncludeStack) {
    serialized.stack = hasStringProperty(error, "stack") ? error.stack : void 0;
  }
  return serialized;
}
function isJsonRpcServerError(code) {
  return code >= -32099 && code <= -32e3;
}
function assignOriginalError(error) {
  if (error && typeof error === "object" && !Array.isArray(error)) {
    return Object.assign({}, error);
  }
  return error;
}
function hasKey(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function hasStringProperty(obj, prop) {
  return typeof obj === "object" && obj !== null && prop in obj && typeof obj[prop] === "string";
}

// node_modules/@coinbase/wallet-sdk/dist/core/error/errors.js
var standardErrors = {
  rpc: {
    parse: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.parse, arg),
    invalidRequest: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.invalidRequest, arg),
    invalidParams: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.invalidParams, arg),
    methodNotFound: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.methodNotFound, arg),
    internal: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.internal, arg),
    server: (opts) => {
      if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      }
      const { code } = opts;
      if (!Number.isInteger(code) || code > -32005 || code < -32099) {
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      }
      return getEthJsonRpcError(code, opts);
    },
    invalidInput: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.invalidInput, arg),
    resourceNotFound: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.resourceNotFound, arg),
    resourceUnavailable: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.resourceUnavailable, arg),
    transactionRejected: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.transactionRejected, arg),
    methodNotSupported: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.methodNotSupported, arg),
    limitExceeded: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.limitExceeded, arg)
  },
  provider: {
    userRejectedRequest: (arg) => {
      return getEthProviderError(standardErrorCodes.provider.userRejectedRequest, arg);
    },
    unauthorized: (arg) => {
      return getEthProviderError(standardErrorCodes.provider.unauthorized, arg);
    },
    unsupportedMethod: (arg) => {
      return getEthProviderError(standardErrorCodes.provider.unsupportedMethod, arg);
    },
    disconnected: (arg) => {
      return getEthProviderError(standardErrorCodes.provider.disconnected, arg);
    },
    chainDisconnected: (arg) => {
      return getEthProviderError(standardErrorCodes.provider.chainDisconnected, arg);
    },
    unsupportedChain: (arg) => {
      return getEthProviderError(standardErrorCodes.provider.unsupportedChain, arg);
    },
    custom: (opts) => {
      if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      }
      const { code, message, data } = opts;
      if (!message || typeof message !== "string") {
        throw new Error('"message" must be a nonempty string');
      }
      return new EthereumProviderError(code, message, data);
    }
  }
};
function getEthJsonRpcError(code, arg) {
  const [message, data] = parseOpts(arg);
  return new EthereumRpcError(code, message || getMessageFromCode(code), data);
}
function getEthProviderError(code, arg) {
  const [message, data] = parseOpts(arg);
  return new EthereumProviderError(code, message || getMessageFromCode(code), data);
}
function parseOpts(arg) {
  if (arg) {
    if (typeof arg === "string") {
      return [arg];
    } else if (typeof arg === "object" && !Array.isArray(arg)) {
      const { message, data } = arg;
      if (message && typeof message !== "string") {
        throw new Error("Must specify string message.");
      }
      return [message || void 0, data];
    }
  }
  return [];
}
var EthereumRpcError = class extends Error {
  constructor(code, message, data) {
    if (!Number.isInteger(code)) {
      throw new Error('"code" must be an integer.');
    }
    if (!message || typeof message !== "string") {
      throw new Error('"message" must be a nonempty string.');
    }
    super(message);
    this.code = code;
    if (data !== void 0) {
      this.data = data;
    }
  }
};
var EthereumProviderError = class extends EthereumRpcError {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(code, message, data) {
    if (!isValidEthProviderCode(code)) {
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    }
    super(code, message, data);
  }
};
function isValidEthProviderCode(code) {
  return Number.isInteger(code) && code >= 1e3 && code <= 4999;
}

// node_modules/@coinbase/wallet-sdk/dist/core/type/index.js
init_shim();
function OpaqueType() {
  return (value) => value;
}
var HexString = OpaqueType();
var AddressString = OpaqueType();
var BigIntString = OpaqueType();
function IntNumber(num) {
  return Math.floor(num);
}
var RegExpString = OpaqueType();

// node_modules/@coinbase/wallet-sdk/dist/core/type/util.js
var INT_STRING_REGEX = /^[0-9]*$/;
var HEXADECIMAL_STRING_REGEX = /^[a-f0-9]*$/;
function randomBytesHex(length) {
  return uint8ArrayToHex(crypto.getRandomValues(new Uint8Array(length)));
}
function uint8ArrayToHex(value) {
  return [...value].map((b4) => b4.toString(16).padStart(2, "0")).join("");
}
function hexStringToUint8Array(hexString) {
  return new Uint8Array(hexString.match(/.{1,2}/g).map((byte) => Number.parseInt(byte, 16)));
}
function hexStringFromBuffer(buf, includePrefix = false) {
  const hex = buf.toString("hex");
  return HexString(includePrefix ? `0x${hex}` : hex);
}
function encodeToHexString(str) {
  return hexStringFromBuffer(ensureBuffer(str), true);
}
function bigIntStringFromBigInt(bi) {
  return BigIntString(bi.toString(10));
}
function hexStringFromNumber(num) {
  return HexString(`0x${BigInt(num).toString(16)}`);
}
function has0xPrefix(str) {
  return str.startsWith("0x") || str.startsWith("0X");
}
function strip0x(hex) {
  if (has0xPrefix(hex)) {
    return hex.slice(2);
  }
  return hex;
}
function prepend0x(hex) {
  if (has0xPrefix(hex)) {
    return `0x${hex.slice(2)}`;
  }
  return `0x${hex}`;
}
function isHexString(hex) {
  if (typeof hex !== "string") {
    return false;
  }
  const s3 = strip0x(hex).toLowerCase();
  return HEXADECIMAL_STRING_REGEX.test(s3);
}
function ensureHexString(hex, includePrefix = false) {
  if (typeof hex === "string") {
    const s3 = strip0x(hex).toLowerCase();
    if (HEXADECIMAL_STRING_REGEX.test(s3)) {
      return HexString(includePrefix ? `0x${s3}` : s3);
    }
  }
  throw standardErrors.rpc.invalidParams(`"${String(hex)}" is not a hexadecimal string`);
}
function ensureEvenLengthHexString(hex, includePrefix = false) {
  let h7 = ensureHexString(hex, false);
  if (h7.length % 2 === 1) {
    h7 = HexString(`0${h7}`);
  }
  return includePrefix ? HexString(`0x${h7}`) : h7;
}
function ensureAddressString(str) {
  if (typeof str === "string") {
    const s3 = strip0x(str).toLowerCase();
    if (isHexString(s3) && s3.length === 40) {
      return AddressString(prepend0x(s3));
    }
  }
  throw standardErrors.rpc.invalidParams(`Invalid Ethereum address: ${String(str)}`);
}
function ensureBuffer(str) {
  if (import_buffer.Buffer.isBuffer(str)) {
    return str;
  }
  if (typeof str === "string") {
    if (isHexString(str)) {
      const s3 = ensureEvenLengthHexString(str, false);
      return import_buffer.Buffer.from(s3, "hex");
    }
    return import_buffer.Buffer.from(str, "utf8");
  }
  throw standardErrors.rpc.invalidParams(`Not binary data: ${String(str)}`);
}
function ensureIntNumber(num) {
  if (typeof num === "number" && Number.isInteger(num)) {
    return IntNumber(num);
  }
  if (typeof num === "string") {
    if (INT_STRING_REGEX.test(num)) {
      return IntNumber(Number(num));
    }
    if (isHexString(num)) {
      return IntNumber(Number(BigInt(ensureEvenLengthHexString(num, true))));
    }
  }
  throw standardErrors.rpc.invalidParams(`Not an integer: ${String(num)}`);
}
function ensureBigInt(val) {
  if (val !== null && (typeof val === "bigint" || isBigNumber(val))) {
    return BigInt(val.toString(10));
  }
  if (typeof val === "number") {
    return BigInt(ensureIntNumber(val));
  }
  if (typeof val === "string") {
    if (INT_STRING_REGEX.test(val)) {
      return BigInt(val);
    }
    if (isHexString(val)) {
      return BigInt(ensureEvenLengthHexString(val, true));
    }
  }
  throw standardErrors.rpc.invalidParams(`Not an integer: ${String(val)}`);
}
function ensureParsedJSONObject(val) {
  if (typeof val === "string") {
    return JSON.parse(val);
  }
  if (typeof val === "object") {
    return val;
  }
  throw standardErrors.rpc.invalidParams(`Not a JSON string or an object: ${String(val)}`);
}
function isBigNumber(val) {
  if (val == null || typeof val.constructor !== "function") {
    return false;
  }
  const { constructor } = val;
  return typeof constructor.config === "function" && typeof constructor.EUCLID === "number";
}

// node_modules/@coinbase/wallet-sdk/dist/util/cipher.js
async function generateKeyPair() {
  return crypto.subtle.generateKey({
    name: "ECDH",
    namedCurve: "P-256"
  }, true, ["deriveKey"]);
}
async function deriveSharedSecret(ownPrivateKey, peerPublicKey) {
  return crypto.subtle.deriveKey({
    name: "ECDH",
    public: peerPublicKey
  }, ownPrivateKey, {
    name: "AES-GCM",
    length: 256
  }, false, ["encrypt", "decrypt"]);
}
async function encrypt(sharedSecret, plainText) {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const cipherText = await crypto.subtle.encrypt({
    name: "AES-GCM",
    iv
  }, sharedSecret, new TextEncoder().encode(plainText));
  return { iv, cipherText };
}
async function decrypt(sharedSecret, { iv, cipherText }) {
  const plainText = await crypto.subtle.decrypt({
    name: "AES-GCM",
    iv
  }, sharedSecret, cipherText);
  return new TextDecoder().decode(plainText);
}
function getFormat(keyType) {
  switch (keyType) {
    case "public":
      return "spki";
    case "private":
      return "pkcs8";
  }
}
async function exportKeyToHexString(type, key) {
  const format = getFormat(type);
  const exported = await crypto.subtle.exportKey(format, key);
  return uint8ArrayToHex(new Uint8Array(exported));
}
async function importKeyFromHexString(type, hexString) {
  const format = getFormat(type);
  const arrayBuffer = hexStringToUint8Array(hexString).buffer;
  return await crypto.subtle.importKey(format, new Uint8Array(arrayBuffer), {
    name: "ECDH",
    namedCurve: "P-256"
  }, true, type === "private" ? ["deriveKey"] : []);
}
async function encryptContent(content, sharedSecret) {
  const serialized = JSON.stringify(content, (_5, value) => {
    if (!(value instanceof Error))
      return value;
    const error = value;
    return Object.assign(Object.assign({}, error.code ? { code: error.code } : {}), { message: error.message });
  });
  return encrypt(sharedSecret, serialized);
}
async function decryptContent(encryptedData, sharedSecret) {
  return JSON.parse(await decrypt(sharedSecret, encryptedData));
}

// node_modules/@coinbase/wallet-sdk/dist/sign/scw/SCWKeyManager.js
var OWN_PRIVATE_KEY = {
  storageKey: "ownPrivateKey",
  keyType: "private"
};
var OWN_PUBLIC_KEY = {
  storageKey: "ownPublicKey",
  keyType: "public"
};
var PEER_PUBLIC_KEY = {
  storageKey: "peerPublicKey",
  keyType: "public"
};
var SCWKeyManager = class {
  constructor() {
    this.storage = new ScopedLocalStorage("CBWSDK", "SCWKeyManager");
    this.ownPrivateKey = null;
    this.ownPublicKey = null;
    this.peerPublicKey = null;
    this.sharedSecret = null;
  }
  async getOwnPublicKey() {
    await this.loadKeysIfNeeded();
    return this.ownPublicKey;
  }
  // returns null if the shared secret is not yet derived
  async getSharedSecret() {
    await this.loadKeysIfNeeded();
    return this.sharedSecret;
  }
  async setPeerPublicKey(key) {
    this.sharedSecret = null;
    this.peerPublicKey = key;
    await this.storeKey(PEER_PUBLIC_KEY, key);
    await this.loadKeysIfNeeded();
  }
  async clear() {
    this.ownPrivateKey = null;
    this.ownPublicKey = null;
    this.peerPublicKey = null;
    this.sharedSecret = null;
    this.storage.removeItem(OWN_PUBLIC_KEY.storageKey);
    this.storage.removeItem(OWN_PRIVATE_KEY.storageKey);
    this.storage.removeItem(PEER_PUBLIC_KEY.storageKey);
  }
  async generateKeyPair() {
    const newKeyPair = await generateKeyPair();
    this.ownPrivateKey = newKeyPair.privateKey;
    this.ownPublicKey = newKeyPair.publicKey;
    await this.storeKey(OWN_PRIVATE_KEY, newKeyPair.privateKey);
    await this.storeKey(OWN_PUBLIC_KEY, newKeyPair.publicKey);
  }
  async loadKeysIfNeeded() {
    if (this.ownPrivateKey === null) {
      this.ownPrivateKey = await this.loadKey(OWN_PRIVATE_KEY);
    }
    if (this.ownPublicKey === null) {
      this.ownPublicKey = await this.loadKey(OWN_PUBLIC_KEY);
    }
    if (this.ownPrivateKey === null || this.ownPublicKey === null) {
      await this.generateKeyPair();
    }
    if (this.peerPublicKey === null) {
      this.peerPublicKey = await this.loadKey(PEER_PUBLIC_KEY);
    }
    if (this.sharedSecret === null) {
      if (this.ownPrivateKey === null || this.peerPublicKey === null)
        return;
      this.sharedSecret = await deriveSharedSecret(this.ownPrivateKey, this.peerPublicKey);
    }
  }
  // storage methods
  async loadKey(item) {
    const key = this.storage.getItem(item.storageKey);
    if (!key)
      return null;
    return importKeyFromHexString(item.keyType, key);
  }
  async storeKey(item, key) {
    const hexString = await exportKeyToHexString(item.keyType, key);
    this.storage.setItem(item.storageKey, hexString);
  }
};

// node_modules/@coinbase/wallet-sdk/dist/util/provider.js
init_shim();

// node_modules/@coinbase/wallet-sdk/dist/sdk-info.js
init_shim();
var VERSION = "4.3.2";
var NAME = "@coinbase/wallet-sdk";

// node_modules/@coinbase/wallet-sdk/dist/util/provider.js
async function fetchRPCRequest(request, rpcUrl) {
  const requestBody = Object.assign(Object.assign({}, request), { jsonrpc: "2.0", id: crypto.randomUUID() });
  const res = await window.fetch(rpcUrl, {
    method: "POST",
    body: JSON.stringify(requestBody),
    mode: "cors",
    headers: {
      "Content-Type": "application/json",
      "X-Cbw-Sdk-Version": VERSION,
      "X-Cbw-Sdk-Platform": NAME
    }
  });
  const { result, error } = await res.json();
  if (error)
    throw error;
  return result;
}
function getCoinbaseInjectedLegacyProvider() {
  const window2 = globalThis;
  return window2.coinbaseWalletExtension;
}
function getInjectedEthereum() {
  var _a3, _b;
  try {
    const window2 = globalThis;
    return (_a3 = window2.ethereum) !== null && _a3 !== void 0 ? _a3 : (_b = window2.top) === null || _b === void 0 ? void 0 : _b.ethereum;
  } catch (_c2) {
    return void 0;
  }
}
function getCoinbaseInjectedProvider({ metadata, preference }) {
  var _a3, _b;
  const { appName, appLogoUrl, appChainIds } = metadata;
  if (preference.options !== "smartWalletOnly") {
    const extension = getCoinbaseInjectedLegacyProvider();
    if (extension) {
      (_a3 = extension.setAppInfo) === null || _a3 === void 0 ? void 0 : _a3.call(extension, appName, appLogoUrl, appChainIds, preference);
      return extension;
    }
  }
  const ethereum = getInjectedEthereum();
  if (ethereum === null || ethereum === void 0 ? void 0 : ethereum.isCoinbaseBrowser) {
    (_b = ethereum.setAppInfo) === null || _b === void 0 ? void 0 : _b.call(ethereum, appName, appLogoUrl, appChainIds, preference);
    return ethereum;
  }
  return void 0;
}
function checkErrorForInvalidRequestArgs(args) {
  if (!args || typeof args !== "object" || Array.isArray(args)) {
    throw standardErrors.rpc.invalidParams({
      message: "Expected a single, non-array, object argument.",
      data: args
    });
  }
  const { method, params } = args;
  if (typeof method !== "string" || method.length === 0) {
    throw standardErrors.rpc.invalidParams({
      message: "'args.method' must be a non-empty string.",
      data: args
    });
  }
  if (params !== void 0 && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
    throw standardErrors.rpc.invalidParams({
      message: "'args.params' must be an object or array if provided.",
      data: args
    });
  }
  switch (method) {
    case "eth_sign":
    case "eth_signTypedData_v2":
    case "eth_subscribe":
    case "eth_unsubscribe":
      throw standardErrors.provider.unsupportedMethod();
  }
}

// node_modules/@coinbase/wallet-sdk/dist/sign/scw/SCWSigner.js
var ACCOUNTS_KEY = "accounts";
var ACTIVE_CHAIN_STORAGE_KEY = "activeChain";
var AVAILABLE_CHAINS_STORAGE_KEY = "availableChains";
var WALLET_CAPABILITIES_STORAGE_KEY = "walletCapabilities";
var SCWSigner = class {
  constructor(params) {
    var _a3, _b, _c2;
    this.metadata = params.metadata;
    this.communicator = params.communicator;
    this.callback = params.callback;
    this.keyManager = new SCWKeyManager();
    this.storage = new ScopedLocalStorage("CBWSDK", "SCWStateManager");
    this.accounts = (_a3 = this.storage.loadObject(ACCOUNTS_KEY)) !== null && _a3 !== void 0 ? _a3 : [];
    this.chain = this.storage.loadObject(ACTIVE_CHAIN_STORAGE_KEY) || {
      id: (_c2 = (_b = params.metadata.appChainIds) === null || _b === void 0 ? void 0 : _b[0]) !== null && _c2 !== void 0 ? _c2 : 1
    };
    this.handshake = this.handshake.bind(this);
    this.request = this.request.bind(this);
    this.createRequestMessage = this.createRequestMessage.bind(this);
    this.decryptResponseMessage = this.decryptResponseMessage.bind(this);
  }
  async handshake(args) {
    var _a3, _b, _c2, _d2;
    await ((_b = (_a3 = this.communicator).waitForPopupLoaded) === null || _b === void 0 ? void 0 : _b.call(_a3));
    const handshakeMessage = await this.createRequestMessage({
      handshake: {
        method: args.method,
        params: Object.assign({}, this.metadata, (_c2 = args.params) !== null && _c2 !== void 0 ? _c2 : {})
      }
    });
    const response = await this.communicator.postRequestAndWaitForResponse(handshakeMessage);
    if ("failure" in response.content)
      throw response.content.failure;
    const peerPublicKey = await importKeyFromHexString("public", response.sender);
    await this.keyManager.setPeerPublicKey(peerPublicKey);
    const decrypted = await this.decryptResponseMessage(response);
    const result = decrypted.result;
    if ("error" in result)
      throw result.error;
    switch (args.method) {
      case "eth_requestAccounts": {
        const accounts = result.value;
        this.accounts = accounts;
        this.storage.storeObject(ACCOUNTS_KEY, accounts);
        (_d2 = this.callback) === null || _d2 === void 0 ? void 0 : _d2.call(this, "accountsChanged", accounts);
        break;
      }
    }
  }
  async request(request) {
    var _a3;
    if (this.accounts.length === 0) {
      switch (request.method) {
        case "wallet_sendCalls":
          return this.sendRequestToPopup(request);
        default:
          throw standardErrors.provider.unauthorized();
      }
    }
    switch (request.method) {
      case "eth_requestAccounts":
        (_a3 = this.callback) === null || _a3 === void 0 ? void 0 : _a3.call(this, "connect", { chainId: hexStringFromNumber(this.chain.id) });
        return this.accounts;
      case "eth_accounts":
        return this.accounts;
      case "eth_coinbase":
        return this.accounts[0];
      case "net_version":
        return this.chain.id;
      case "eth_chainId":
        return hexStringFromNumber(this.chain.id);
      case "wallet_getCapabilities":
        return this.storage.loadObject(WALLET_CAPABILITIES_STORAGE_KEY);
      case "wallet_switchEthereumChain":
        return this.handleSwitchChainRequest(request);
      case "eth_ecRecover":
      case "personal_sign":
      case "wallet_sign":
      case "personal_ecRecover":
      case "eth_signTransaction":
      case "eth_sendTransaction":
      case "eth_signTypedData_v1":
      case "eth_signTypedData_v3":
      case "eth_signTypedData_v4":
      case "eth_signTypedData":
      case "wallet_addEthereumChain":
      case "wallet_watchAsset":
      case "wallet_sendCalls":
      case "wallet_showCallsStatus":
      case "wallet_grantPermissions":
        return this.sendRequestToPopup(request);
      default:
        if (!this.chain.rpcUrl)
          throw standardErrors.rpc.internal("No RPC URL set for chain");
        return fetchRPCRequest(request, this.chain.rpcUrl);
    }
  }
  async sendRequestToPopup(request) {
    var _a3, _b;
    await ((_b = (_a3 = this.communicator).waitForPopupLoaded) === null || _b === void 0 ? void 0 : _b.call(_a3));
    const response = await this.sendEncryptedRequest(request);
    const decrypted = await this.decryptResponseMessage(response);
    const result = decrypted.result;
    if ("error" in result)
      throw result.error;
    return result.value;
  }
  async cleanup() {
    var _a3, _b;
    this.storage.clear();
    await this.keyManager.clear();
    this.accounts = [];
    this.chain = {
      id: (_b = (_a3 = this.metadata.appChainIds) === null || _a3 === void 0 ? void 0 : _a3[0]) !== null && _b !== void 0 ? _b : 1
    };
  }
  /**
   * @returns `null` if the request was successful.
   * https://eips.ethereum.org/EIPS/eip-3326#wallet_switchethereumchain
   */
  async handleSwitchChainRequest(request) {
    var _a3;
    const params = request.params;
    if (!params || !((_a3 = params[0]) === null || _a3 === void 0 ? void 0 : _a3.chainId)) {
      throw standardErrors.rpc.invalidParams();
    }
    const chainId = ensureIntNumber(params[0].chainId);
    const localResult = this.updateChain(chainId);
    if (localResult)
      return null;
    const popupResult = await this.sendRequestToPopup(request);
    if (popupResult === null) {
      this.updateChain(chainId);
    }
    return popupResult;
  }
  async sendEncryptedRequest(request) {
    const sharedSecret = await this.keyManager.getSharedSecret();
    if (!sharedSecret) {
      throw standardErrors.provider.unauthorized("No valid session found, try requestAccounts before other methods");
    }
    const encrypted = await encryptContent({
      action: request,
      chainId: this.chain.id
    }, sharedSecret);
    const message = await this.createRequestMessage({ encrypted });
    return this.communicator.postRequestAndWaitForResponse(message);
  }
  async createRequestMessage(content) {
    const publicKey = await exportKeyToHexString("public", await this.keyManager.getOwnPublicKey());
    return {
      id: crypto.randomUUID(),
      sender: publicKey,
      content,
      timestamp: /* @__PURE__ */ new Date()
    };
  }
  async decryptResponseMessage(message) {
    var _a3, _b;
    const content = message.content;
    if ("failure" in content) {
      throw content.failure;
    }
    const sharedSecret = await this.keyManager.getSharedSecret();
    if (!sharedSecret) {
      throw standardErrors.provider.unauthorized("Invalid session");
    }
    const response = await decryptContent(content.encrypted, sharedSecret);
    const availableChains = (_a3 = response.data) === null || _a3 === void 0 ? void 0 : _a3.chains;
    if (availableChains) {
      const chains = Object.entries(availableChains).map(([id3, rpcUrl]) => ({
        id: Number(id3),
        rpcUrl
      }));
      this.storage.storeObject(AVAILABLE_CHAINS_STORAGE_KEY, chains);
      this.updateChain(this.chain.id, chains);
    }
    const walletCapabilities = (_b = response.data) === null || _b === void 0 ? void 0 : _b.capabilities;
    if (walletCapabilities) {
      this.storage.storeObject(WALLET_CAPABILITIES_STORAGE_KEY, walletCapabilities);
    }
    return response;
  }
  updateChain(chainId, newAvailableChains) {
    var _a3;
    const chains = newAvailableChains !== null && newAvailableChains !== void 0 ? newAvailableChains : this.storage.loadObject(AVAILABLE_CHAINS_STORAGE_KEY);
    const chain = chains === null || chains === void 0 ? void 0 : chains.find((chain2) => chain2.id === chainId);
    if (!chain)
      return false;
    if (chain !== this.chain) {
      this.chain = chain;
      this.storage.storeObject(ACTIVE_CHAIN_STORAGE_KEY, chain);
      (_a3 = this.callback) === null || _a3 === void 0 ? void 0 : _a3.call(this, "chainChanged", hexStringFromNumber(chain.id));
    }
    return true;
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/WalletLinkSigner.js
init_shim();
var import_eth_eip712_util = __toESM(require_eth_eip712_util(), 1);

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/constants.js
init_shim();
var WALLET_USER_NAME_KEY = "walletUsername";
var LOCAL_STORAGE_ADDRESSES_KEY = "Addresses";
var APP_VERSION_KEY = "AppVersion";

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/type/Web3Response.js
init_shim();
function isErrorResponse(response) {
  return response.errorMessage !== void 0;
}

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/WalletLinkRelay.js
init_shim();

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/connection/WalletLinkConnection.js
init_shim();

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/connection/WalletLinkCipher.js
init_shim();
var WalletLinkCipher = class {
  // @param secret hex representation of 32-byte secret
  constructor(secret) {
    this.secret = secret;
  }
  /**
   *
   * @param plainText string to be encrypted
   * returns hex string representation of bytes in the order: initialization vector (iv),
   * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the
   * encrypted plainText.
   */
  async encrypt(plainText) {
    const secret = this.secret;
    if (secret.length !== 64)
      throw Error(`secret must be 256 bits`);
    const ivBytes = crypto.getRandomValues(new Uint8Array(12));
    const secretKey = await crypto.subtle.importKey("raw", hexStringToUint8Array(secret), { name: "aes-gcm" }, false, ["encrypt", "decrypt"]);
    const enc = new TextEncoder();
    const encryptedResult = await window.crypto.subtle.encrypt({
      name: "AES-GCM",
      iv: ivBytes
    }, secretKey, enc.encode(plainText));
    const tagLength = 16;
    const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);
    const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);
    const authTagBytes = new Uint8Array(authTag);
    const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);
    const concatted = new Uint8Array([...ivBytes, ...authTagBytes, ...encryptedPlaintextBytes]);
    return uint8ArrayToHex(concatted);
  }
  /**
   *
   * @param cipherText hex string representation of bytes in the order: initialization vector (iv),
   * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.
   */
  async decrypt(cipherText) {
    const secret = this.secret;
    if (secret.length !== 64)
      throw Error(`secret must be 256 bits`);
    return new Promise((resolve, reject) => {
      void (async function() {
        const secretKey = await crypto.subtle.importKey("raw", hexStringToUint8Array(secret), { name: "aes-gcm" }, false, ["encrypt", "decrypt"]);
        const encrypted = hexStringToUint8Array(cipherText);
        const ivBytes = encrypted.slice(0, 12);
        const authTagBytes = encrypted.slice(12, 28);
        const encryptedPlaintextBytes = encrypted.slice(28);
        const concattedBytes = new Uint8Array([...encryptedPlaintextBytes, ...authTagBytes]);
        const algo = {
          name: "AES-GCM",
          iv: new Uint8Array(ivBytes)
        };
        try {
          const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);
          const decoder = new TextDecoder();
          resolve(decoder.decode(decrypted));
        } catch (err) {
          reject(err);
        }
      })();
    });
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/connection/WalletLinkHTTP.js
init_shim();
var WalletLinkHTTP = class {
  constructor(linkAPIUrl, sessionId, sessionKey) {
    this.linkAPIUrl = linkAPIUrl;
    this.sessionId = sessionId;
    const credentials = `${sessionId}:${sessionKey}`;
    this.auth = `Basic ${btoa(credentials)}`;
  }
  // mark unseen events as seen
  async markUnseenEventsAsSeen(events) {
    return Promise.all(events.map((e7) => fetch(`${this.linkAPIUrl}/events/${e7.eventId}/seen`, {
      method: "POST",
      headers: {
        Authorization: this.auth
      }
    }))).catch((error) => console.error("Unabled to mark event as failed:", error));
  }
  async fetchUnseenEvents() {
    var _a3;
    const response = await fetch(`${this.linkAPIUrl}/events?unseen=true`, {
      headers: {
        Authorization: this.auth
      }
    });
    if (response.ok) {
      const { events, error } = await response.json();
      if (error) {
        throw new Error(`Check unseen events failed: ${error}`);
      }
      const responseEvents = (_a3 = events === null || events === void 0 ? void 0 : events.filter((e7) => e7.event === "Web3Response").map((e7) => ({
        type: "Event",
        sessionId: this.sessionId,
        eventId: e7.id,
        event: e7.event,
        data: e7.data
      }))) !== null && _a3 !== void 0 ? _a3 : [];
      this.markUnseenEventsAsSeen(responseEvents);
      return responseEvents;
    }
    throw new Error(`Check unseen events failed: ${response.status}`);
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/connection/WalletLinkWebSocket.js
init_shim();
var ConnectionState;
(function(ConnectionState2) {
  ConnectionState2[ConnectionState2["DISCONNECTED"] = 0] = "DISCONNECTED";
  ConnectionState2[ConnectionState2["CONNECTING"] = 1] = "CONNECTING";
  ConnectionState2[ConnectionState2["CONNECTED"] = 2] = "CONNECTED";
})(ConnectionState || (ConnectionState = {}));
var WalletLinkWebSocket = class {
  setConnectionStateListener(listener) {
    this.connectionStateListener = listener;
  }
  setIncomingDataListener(listener) {
    this.incomingDataListener = listener;
  }
  /**
   * Constructor
   * @param url WebSocket server URL
   * @param [WebSocketClass] Custom WebSocket implementation
   */
  constructor(url, WebSocketClass = WebSocket) {
    this.WebSocketClass = WebSocketClass;
    this.webSocket = null;
    this.pendingData = [];
    this.url = url.replace(/^http/, "ws");
  }
  /**
   * Make a websocket connection
   * @returns a Promise that resolves when connected
   */
  async connect() {
    if (this.webSocket) {
      throw new Error("webSocket object is not null");
    }
    return new Promise((resolve, reject) => {
      var _a3;
      let webSocket;
      try {
        this.webSocket = webSocket = new this.WebSocketClass(this.url);
      } catch (err) {
        reject(err);
        return;
      }
      (_a3 = this.connectionStateListener) === null || _a3 === void 0 ? void 0 : _a3.call(this, ConnectionState.CONNECTING);
      webSocket.onclose = (evt) => {
        var _a4;
        this.clearWebSocket();
        reject(new Error(`websocket error ${evt.code}: ${evt.reason}`));
        (_a4 = this.connectionStateListener) === null || _a4 === void 0 ? void 0 : _a4.call(this, ConnectionState.DISCONNECTED);
      };
      webSocket.onopen = (_5) => {
        var _a4;
        resolve();
        (_a4 = this.connectionStateListener) === null || _a4 === void 0 ? void 0 : _a4.call(this, ConnectionState.CONNECTED);
        if (this.pendingData.length > 0) {
          const pending = [...this.pendingData];
          pending.forEach((data) => this.sendData(data));
          this.pendingData = [];
        }
      };
      webSocket.onmessage = (evt) => {
        var _a4, _b;
        if (evt.data === "h") {
          (_a4 = this.incomingDataListener) === null || _a4 === void 0 ? void 0 : _a4.call(this, {
            type: "Heartbeat"
          });
        } else {
          try {
            const message = JSON.parse(evt.data);
            (_b = this.incomingDataListener) === null || _b === void 0 ? void 0 : _b.call(this, message);
          } catch (_c2) {
          }
        }
      };
    });
  }
  /**
   * Disconnect from server
   */
  disconnect() {
    var _a3;
    const { webSocket } = this;
    if (!webSocket) {
      return;
    }
    this.clearWebSocket();
    (_a3 = this.connectionStateListener) === null || _a3 === void 0 ? void 0 : _a3.call(this, ConnectionState.DISCONNECTED);
    this.connectionStateListener = void 0;
    this.incomingDataListener = void 0;
    try {
      webSocket.close();
    } catch (_b) {
    }
  }
  /**
   * Send data to server
   * @param data text to send
   */
  sendData(data) {
    const { webSocket } = this;
    if (!webSocket) {
      this.pendingData.push(data);
      this.connect();
      return;
    }
    webSocket.send(data);
  }
  clearWebSocket() {
    const { webSocket } = this;
    if (!webSocket) {
      return;
    }
    this.webSocket = null;
    webSocket.onclose = null;
    webSocket.onerror = null;
    webSocket.onmessage = null;
    webSocket.onopen = null;
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/connection/WalletLinkConnection.js
var HEARTBEAT_INTERVAL = 1e4;
var REQUEST_TIMEOUT = 6e4;
var WalletLinkConnection = class {
  /**
   * Constructor
   * @param session Session
   * @param linkAPIUrl Coinbase Wallet link server URL
   * @param listener WalletLinkConnectionUpdateListener
   * @param [WebSocketClass] Custom WebSocket implementation
   */
  constructor({ session, linkAPIUrl, listener }) {
    this.destroyed = false;
    this.lastHeartbeatResponse = 0;
    this.nextReqId = IntNumber(1);
    this._connected = false;
    this._linked = false;
    this.shouldFetchUnseenEventsOnConnect = false;
    this.requestResolutions = /* @__PURE__ */ new Map();
    this.handleSessionMetadataUpdated = (metadata) => {
      if (!metadata)
        return;
      const handlers = /* @__PURE__ */ new Map([
        ["__destroyed", this.handleDestroyed],
        ["EthereumAddress", this.handleAccountUpdated],
        ["WalletUsername", this.handleWalletUsernameUpdated],
        ["AppVersion", this.handleAppVersionUpdated],
        [
          "ChainId",
          // ChainId and JsonRpcUrl are always updated together
          (v5) => metadata.JsonRpcUrl && this.handleChainUpdated(v5, metadata.JsonRpcUrl)
        ]
      ]);
      handlers.forEach((handler, key) => {
        const value = metadata[key];
        if (value === void 0)
          return;
        handler(value);
      });
    };
    this.handleDestroyed = (__destroyed) => {
      var _a3;
      if (__destroyed !== "1")
        return;
      (_a3 = this.listener) === null || _a3 === void 0 ? void 0 : _a3.resetAndReload();
    };
    this.handleAccountUpdated = async (encryptedEthereumAddress) => {
      var _a3;
      const address = await this.cipher.decrypt(encryptedEthereumAddress);
      (_a3 = this.listener) === null || _a3 === void 0 ? void 0 : _a3.accountUpdated(address);
    };
    this.handleMetadataUpdated = async (key, encryptedMetadataValue) => {
      var _a3;
      const decryptedValue = await this.cipher.decrypt(encryptedMetadataValue);
      (_a3 = this.listener) === null || _a3 === void 0 ? void 0 : _a3.metadataUpdated(key, decryptedValue);
    };
    this.handleWalletUsernameUpdated = async (walletUsername) => {
      this.handleMetadataUpdated(WALLET_USER_NAME_KEY, walletUsername);
    };
    this.handleAppVersionUpdated = async (appVersion) => {
      this.handleMetadataUpdated(APP_VERSION_KEY, appVersion);
    };
    this.handleChainUpdated = async (encryptedChainId, encryptedJsonRpcUrl) => {
      var _a3;
      const chainId = await this.cipher.decrypt(encryptedChainId);
      const jsonRpcUrl = await this.cipher.decrypt(encryptedJsonRpcUrl);
      (_a3 = this.listener) === null || _a3 === void 0 ? void 0 : _a3.chainUpdated(chainId, jsonRpcUrl);
    };
    this.session = session;
    this.cipher = new WalletLinkCipher(session.secret);
    this.listener = listener;
    const ws2 = new WalletLinkWebSocket(`${linkAPIUrl}/rpc`, WebSocket);
    ws2.setConnectionStateListener(async (state) => {
      let connected = false;
      switch (state) {
        case ConnectionState.DISCONNECTED:
          if (!this.destroyed) {
            const connect = async () => {
              await new Promise((resolve) => setTimeout(resolve, 5e3));
              if (!this.destroyed) {
                ws2.connect().catch(() => {
                  connect();
                });
              }
            };
            connect();
          }
          break;
        case ConnectionState.CONNECTED:
          connected = await this.handleConnected();
          this.updateLastHeartbeat();
          setInterval(() => {
            this.heartbeat();
          }, HEARTBEAT_INTERVAL);
          if (this.shouldFetchUnseenEventsOnConnect) {
            this.fetchUnseenEventsAPI();
          }
          break;
        case ConnectionState.CONNECTING:
          break;
      }
      if (this.connected !== connected) {
        this.connected = connected;
      }
    });
    ws2.setIncomingDataListener((m4) => {
      var _a3;
      switch (m4.type) {
        // handle server's heartbeat responses
        case "Heartbeat":
          this.updateLastHeartbeat();
          return;
        // handle link status updates
        case "IsLinkedOK":
        case "Linked": {
          const linked = m4.type === "IsLinkedOK" ? m4.linked : void 0;
          this.linked = linked || m4.onlineGuests > 0;
          break;
        }
        // handle session config updates
        case "GetSessionConfigOK":
        case "SessionConfigUpdated": {
          this.handleSessionMetadataUpdated(m4.metadata);
          break;
        }
        case "Event": {
          this.handleIncomingEvent(m4);
          break;
        }
      }
      if (m4.id !== void 0) {
        (_a3 = this.requestResolutions.get(m4.id)) === null || _a3 === void 0 ? void 0 : _a3(m4);
      }
    });
    this.ws = ws2;
    this.http = new WalletLinkHTTP(linkAPIUrl, session.id, session.key);
  }
  /**
   * Make a connection to the server
   */
  connect() {
    if (this.destroyed) {
      throw new Error("instance is destroyed");
    }
    this.ws.connect();
  }
  /**
   * Terminate connection, and mark as destroyed. To reconnect, create a new
   * instance of WalletSDKConnection
   */
  async destroy() {
    if (this.destroyed)
      return;
    await this.makeRequest({
      type: "SetSessionConfig",
      id: IntNumber(this.nextReqId++),
      sessionId: this.session.id,
      metadata: { __destroyed: "1" }
    }, { timeout: 1e3 });
    this.destroyed = true;
    this.ws.disconnect();
    this.listener = void 0;
  }
  get connected() {
    return this._connected;
  }
  set connected(connected) {
    this._connected = connected;
  }
  get linked() {
    return this._linked;
  }
  set linked(linked) {
    var _a3, _b;
    this._linked = linked;
    if (linked)
      (_a3 = this.onceLinked) === null || _a3 === void 0 ? void 0 : _a3.call(this);
    (_b = this.listener) === null || _b === void 0 ? void 0 : _b.linkedUpdated(linked);
  }
  setOnceLinked(callback) {
    return new Promise((resolve) => {
      if (this.linked) {
        callback().then(resolve);
      } else {
        this.onceLinked = () => {
          callback().then(resolve);
          this.onceLinked = void 0;
        };
      }
    });
  }
  async handleIncomingEvent(m4) {
    var _a3;
    if (m4.type !== "Event" || m4.event !== "Web3Response") {
      return;
    }
    const decryptedData = await this.cipher.decrypt(m4.data);
    const message = JSON.parse(decryptedData);
    if (message.type !== "WEB3_RESPONSE")
      return;
    const { id: id3, response } = message;
    (_a3 = this.listener) === null || _a3 === void 0 ? void 0 : _a3.handleWeb3ResponseMessage(id3, response);
  }
  async checkUnseenEvents() {
    if (!this.connected) {
      this.shouldFetchUnseenEventsOnConnect = true;
      return;
    }
    await new Promise((resolve) => setTimeout(resolve, 250));
    try {
      await this.fetchUnseenEventsAPI();
    } catch (e7) {
      console.error("Unable to check for unseen events", e7);
    }
  }
  async fetchUnseenEventsAPI() {
    this.shouldFetchUnseenEventsOnConnect = false;
    const responseEvents = await this.http.fetchUnseenEvents();
    responseEvents.forEach((e7) => this.handleIncomingEvent(e7));
  }
  /**
   * Publish an event and emit event ID when successful
   * @param event event name
   * @param unencryptedData unencrypted event data
   * @param callWebhook whether the webhook should be invoked
   * @returns a Promise that emits event ID when successful
   */
  async publishEvent(event, unencryptedData, callWebhook = false) {
    const data = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, unencryptedData), { origin: location.origin, location: location.href, relaySource: "coinbaseWalletExtension" in window && window.coinbaseWalletExtension ? "injected_sdk" : "sdk" })));
    const message = {
      type: "PublishEvent",
      id: IntNumber(this.nextReqId++),
      sessionId: this.session.id,
      event,
      data,
      callWebhook
    };
    return this.setOnceLinked(async () => {
      const res = await this.makeRequest(message);
      if (res.type === "Fail") {
        throw new Error(res.error || "failed to publish event");
      }
      return res.eventId;
    });
  }
  sendData(message) {
    this.ws.sendData(JSON.stringify(message));
  }
  updateLastHeartbeat() {
    this.lastHeartbeatResponse = Date.now();
  }
  heartbeat() {
    if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {
      this.ws.disconnect();
      return;
    }
    try {
      this.ws.sendData("h");
    } catch (_a3) {
    }
  }
  async makeRequest(message, options = { timeout: REQUEST_TIMEOUT }) {
    const reqId = message.id;
    this.sendData(message);
    let timeoutId;
    return Promise.race([
      new Promise((_5, reject) => {
        timeoutId = window.setTimeout(() => {
          reject(new Error(`request ${reqId} timed out`));
        }, options.timeout);
      }),
      new Promise((resolve) => {
        this.requestResolutions.set(reqId, (m4) => {
          clearTimeout(timeoutId);
          resolve(m4);
          this.requestResolutions.delete(reqId);
        });
      })
    ]);
  }
  async handleConnected() {
    const res = await this.makeRequest({
      type: "HostSession",
      id: IntNumber(this.nextReqId++),
      sessionId: this.session.id,
      sessionKey: this.session.key
    });
    if (res.type === "Fail")
      return false;
    this.sendData({
      type: "IsLinked",
      id: IntNumber(this.nextReqId++),
      sessionId: this.session.id
    });
    this.sendData({
      type: "GetSessionConfig",
      id: IntNumber(this.nextReqId++),
      sessionId: this.session.id
    });
    return true;
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/RelayEventManager.js
init_shim();
var RelayEventManager = class {
  constructor() {
    this._nextRequestId = 0;
    this.callbacks = /* @__PURE__ */ new Map();
  }
  makeRequestId() {
    this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
    const id3 = this._nextRequestId;
    const idStr = prepend0x(id3.toString(16));
    const callback = this.callbacks.get(idStr);
    if (callback) {
      this.callbacks.delete(idStr);
    }
    return id3;
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/type/WalletLinkSession.js
init_shim();
var STORAGE_KEY_SESSION_ID = "session:id";
var STORAGE_KEY_SESSION_SECRET = "session:secret";
var STORAGE_KEY_SESSION_LINKED = "session:linked";
var WalletLinkSession = class _WalletLinkSession {
  constructor(storage2, id3, secret, linked = false) {
    this.storage = storage2;
    this.id = id3;
    this.secret = secret;
    this.key = bytesToHex(sha256(`${id3}, ${secret} WalletLink`));
    this._linked = !!linked;
  }
  static create(storage2) {
    const id3 = randomBytesHex(16);
    const secret = randomBytesHex(32);
    return new _WalletLinkSession(storage2, id3, secret).save();
  }
  static load(storage2) {
    const id3 = storage2.getItem(STORAGE_KEY_SESSION_ID);
    const linked = storage2.getItem(STORAGE_KEY_SESSION_LINKED);
    const secret = storage2.getItem(STORAGE_KEY_SESSION_SECRET);
    if (id3 && secret) {
      return new _WalletLinkSession(storage2, id3, secret, linked === "1");
    }
    return null;
  }
  get linked() {
    return this._linked;
  }
  set linked(val) {
    this._linked = val;
    this.persistLinked();
  }
  save() {
    this.storage.setItem(STORAGE_KEY_SESSION_ID, this.id);
    this.storage.setItem(STORAGE_KEY_SESSION_SECRET, this.secret);
    this.persistLinked();
    return this;
  }
  persistLinked() {
    this.storage.setItem(STORAGE_KEY_SESSION_LINKED, this._linked ? "1" : "0");
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/util.js
init_shim();
function isInIFrame() {
  try {
    return window.frameElement !== null;
  } catch (e7) {
    return false;
  }
}
function getLocation() {
  try {
    if (isInIFrame() && window.top) {
      return window.top.location;
    }
    return window.location;
  } catch (e7) {
    return window.location;
  }
}
function isMobileWeb() {
  var _a3;
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test((_a3 = window === null || window === void 0 ? void 0 : window.navigator) === null || _a3 === void 0 ? void 0 : _a3.userAgent);
}
function isDarkMode() {
  var _a3, _b;
  return (_b = (_a3 = window === null || window === void 0 ? void 0 : window.matchMedia) === null || _a3 === void 0 ? void 0 : _a3.call(window, "(prefers-color-scheme: dark)").matches) !== null && _b !== void 0 ? _b : false;
}

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/WalletLinkRelayUI.js
init_shim();

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/cssReset/cssReset.js
init_shim();

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/cssReset/cssReset-css.js
init_shim();
var cssReset_css_default = /* @__PURE__ */ (() => `@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}`)();

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/cssReset/cssReset.js
function injectCssReset() {
  const styleEl = document.createElement("style");
  styleEl.type = "text/css";
  styleEl.appendChild(document.createTextNode(cssReset_css_default));
  document.documentElement.appendChild(styleEl);
}

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/Snackbar/Snackbar.js
init_shim();

// node_modules/@coinbase/wallet-sdk/node_modules/clsx/dist/clsx.m.js
init_shim();
function r7(e7) {
  var t8, f4, n6 = "";
  if ("string" == typeof e7 || "number" == typeof e7) n6 += e7;
  else if ("object" == typeof e7) if (Array.isArray(e7)) for (t8 = 0; t8 < e7.length; t8++) e7[t8] && (f4 = r7(e7[t8])) && (n6 && (n6 += " "), n6 += f4);
  else for (t8 in e7) e7[t8] && (n6 && (n6 += " "), n6 += t8);
  return n6;
}
function clsx() {
  for (var e7, t8, f4 = 0, n6 = ""; f4 < arguments.length; ) (e7 = arguments[f4++]) && (t8 = r7(e7)) && (n6 && (n6 += " "), n6 += t8);
  return n6;
}

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/Snackbar/Snackbar-css.js
init_shim();
var Snackbar_css_default = /* @__PURE__ */ (() => `.-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}`)();

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/Snackbar/Snackbar.js
var cblogo = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+`;
var gearIcon = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=`;
var Snackbar = class {
  constructor() {
    this.items = /* @__PURE__ */ new Map();
    this.nextItemKey = 0;
    this.root = null;
    this.darkMode = isDarkMode();
  }
  attach(el2) {
    this.root = document.createElement("div");
    this.root.className = "-cbwsdk-snackbar-root";
    el2.appendChild(this.root);
    this.render();
  }
  presentItem(itemProps) {
    const key = this.nextItemKey++;
    this.items.set(key, itemProps);
    this.render();
    return () => {
      this.items.delete(key);
      this.render();
    };
  }
  clear() {
    this.items.clear();
    this.render();
  }
  render() {
    if (!this.root) {
      return;
    }
    B2(_4(
      "div",
      null,
      _4(SnackbarContainer, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([key, itemProps]) => _4(SnackbarInstance, Object.assign({}, itemProps, { key }))))
    ), this.root);
  }
};
var SnackbarContainer = (props) => _4(
  "div",
  { class: clsx("-cbwsdk-snackbar-container") },
  _4("style", null, Snackbar_css_default),
  _4("div", { class: "-cbwsdk-snackbar" }, props.children)
);
var SnackbarInstance = ({ autoExpand, message, menuItems }) => {
  const [hidden, setHidden] = h4(true);
  const [expanded, setExpanded] = h4(autoExpand !== null && autoExpand !== void 0 ? autoExpand : false);
  y3(() => {
    const timers = [
      window.setTimeout(() => {
        setHidden(false);
      }, 1),
      window.setTimeout(() => {
        setExpanded(true);
      }, 1e4)
    ];
    return () => {
      timers.forEach(window.clearTimeout);
    };
  });
  const toggleExpanded = () => {
    setExpanded(!expanded);
  };
  return _4(
    "div",
    { class: clsx("-cbwsdk-snackbar-instance", hidden && "-cbwsdk-snackbar-instance-hidden", expanded && "-cbwsdk-snackbar-instance-expanded") },
    _4(
      "div",
      { class: "-cbwsdk-snackbar-instance-header", onClick: toggleExpanded },
      _4("img", { src: cblogo, class: "-cbwsdk-snackbar-instance-header-cblogo" }),
      " ",
      _4("div", { class: "-cbwsdk-snackbar-instance-header-message" }, message),
      _4(
        "div",
        { class: "-gear-container" },
        !expanded && _4(
          "svg",
          { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
          _4("circle", { cx: "12", cy: "12", r: "12", fill: "#F5F7F8" })
        ),
        _4("img", { src: gearIcon, class: "-gear-icon", title: "Expand" })
      )
    ),
    menuItems && menuItems.length > 0 && _4("div", { class: "-cbwsdk-snackbar-instance-menu" }, menuItems.map((action, i5) => _4(
      "div",
      { class: clsx("-cbwsdk-snackbar-instance-menu-item", action.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"), onClick: action.onClick, key: i5 },
      _4(
        "svg",
        { width: action.svgWidth, height: action.svgHeight, viewBox: "0 0 10 11", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
        _4("path", { "fill-rule": action.defaultFillRule, "clip-rule": action.defaultClipRule, d: action.path, fill: "#AAAAAA" })
      ),
      _4("span", { class: clsx("-cbwsdk-snackbar-instance-menu-item-info", action.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red") }, action.info)
    )))
  );
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/WalletLinkRelayUI.js
var RETRY_SVG_PATH = "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z";
var WalletLinkRelayUI = class {
  constructor() {
    this.attached = false;
    this.snackbar = new Snackbar();
  }
  attach() {
    if (this.attached) {
      throw new Error("Coinbase Wallet SDK UI is already attached");
    }
    const el2 = document.documentElement;
    const container = document.createElement("div");
    container.className = "-cbwsdk-css-reset";
    el2.appendChild(container);
    this.snackbar.attach(container);
    this.attached = true;
    injectCssReset();
  }
  showConnecting(options) {
    let snackbarProps;
    if (options.isUnlinkedErrorState) {
      snackbarProps = {
        autoExpand: true,
        message: "Connection lost",
        menuItems: [
          {
            isRed: false,
            info: "Reset connection",
            svgWidth: "10",
            svgHeight: "11",
            path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
            defaultFillRule: "evenodd",
            defaultClipRule: "evenodd",
            onClick: options.onResetConnection
          }
        ]
      };
    } else {
      snackbarProps = {
        message: "Confirm on phone",
        menuItems: [
          {
            isRed: true,
            info: "Cancel transaction",
            svgWidth: "11",
            svgHeight: "11",
            path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
            defaultFillRule: "inherit",
            defaultClipRule: "inherit",
            onClick: options.onCancel
          },
          {
            isRed: false,
            info: "Reset connection",
            svgWidth: "10",
            svgHeight: "11",
            path: RETRY_SVG_PATH,
            defaultFillRule: "evenodd",
            defaultClipRule: "evenodd",
            onClick: options.onResetConnection
          }
        ]
      };
    }
    return this.snackbar.presentItem(snackbarProps);
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/WLMobileRelayUI.js
init_shim();

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/RedirectDialog/RedirectDialog.js
init_shim();

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/RedirectDialog/RedirectDialog-css.js
init_shim();
var RedirectDialog_css_default = /* @__PURE__ */ (() => `.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop{position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s;background-color:rgba(10,11,13,.5)}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box{display:block;position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);padding:20px;border-radius:8px;background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box p{display:block;font-weight:400;font-size:14px;line-height:20px;padding-bottom:12px;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box button{appearance:none;border:none;background:none;color:#0052ff;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark{background-color:#0a0b0d;color:#fff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark button{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light{background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light button{color:#0052ff}`)();

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/RedirectDialog/RedirectDialog.js
var RedirectDialog = class {
  constructor() {
    this.root = null;
    this.darkMode = isDarkMode();
  }
  attach() {
    const el2 = document.documentElement;
    this.root = document.createElement("div");
    this.root.className = "-cbwsdk-css-reset";
    el2.appendChild(this.root);
    injectCssReset();
  }
  present(props) {
    this.render(props);
  }
  clear() {
    this.render(null);
  }
  render(props) {
    if (!this.root)
      return;
    B2(null, this.root);
    if (!props)
      return;
    B2(_4(RedirectDialogContent, Object.assign({}, props, { onDismiss: () => {
      this.clear();
    }, darkMode: this.darkMode })), this.root);
  }
};
var RedirectDialogContent = ({ title, buttonText, darkMode, onButtonClick, onDismiss }) => {
  const theme = darkMode ? "dark" : "light";
  return _4(
    SnackbarContainer,
    { darkMode },
    _4(
      "div",
      { class: "-cbwsdk-redirect-dialog" },
      _4("style", null, RedirectDialog_css_default),
      _4("div", { class: "-cbwsdk-redirect-dialog-backdrop", onClick: onDismiss }),
      _4(
        "div",
        { class: clsx("-cbwsdk-redirect-dialog-box", theme) },
        _4("p", null, title),
        _4("button", { onClick: onButtonClick }, buttonText)
      )
    )
  );
};

// node_modules/@coinbase/wallet-sdk/dist/core/constants.js
init_shim();
var CB_KEYS_URL = "https://keys.coinbase.com/connect";
var CB_WALLET_RPC_URL = "https://rpc.wallet.coinbase.com";
var WALLETLINK_URL = "https://www.walletlink.org";
var CBW_MOBILE_DEEPLINK_URL = "https://go.cb-w.com/walletlink";

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/WLMobileRelayUI.js
var WLMobileRelayUI = class {
  constructor() {
    this.attached = false;
    this.redirectDialog = new RedirectDialog();
  }
  attach() {
    if (this.attached) {
      throw new Error("Coinbase Wallet SDK UI is already attached");
    }
    this.redirectDialog.attach();
    this.attached = true;
  }
  redirectToCoinbaseWallet(walletLinkUrl) {
    const url = new URL(CBW_MOBILE_DEEPLINK_URL);
    url.searchParams.append("redirect_url", getLocation().href);
    if (walletLinkUrl) {
      url.searchParams.append("wl_url", walletLinkUrl);
    }
    const anchorTag = document.createElement("a");
    anchorTag.target = "cbw-opener";
    anchorTag.href = url.href;
    anchorTag.rel = "noreferrer noopener";
    anchorTag.click();
  }
  openCoinbaseWalletDeeplink(walletLinkUrl) {
    this.redirectDialog.present({
      title: "Redirecting to Coinbase Wallet...",
      buttonText: "Open",
      onButtonClick: () => {
        this.redirectToCoinbaseWallet(walletLinkUrl);
      }
    });
    setTimeout(() => {
      this.redirectToCoinbaseWallet(walletLinkUrl);
    }, 99);
  }
  showConnecting(_options) {
    return () => {
      this.redirectDialog.clear();
    };
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/WalletLinkRelay.js
var WalletLinkRelay = class _WalletLinkRelay {
  constructor(options) {
    this.chainCallbackParams = { chainId: "", jsonRpcUrl: "" };
    this.isMobileWeb = isMobileWeb();
    this.linkedUpdated = (linked) => {
      this.isLinked = linked;
      const cachedAddresses = this.storage.getItem(LOCAL_STORAGE_ADDRESSES_KEY);
      if (linked) {
        this._session.linked = linked;
      }
      this.isUnlinkedErrorState = false;
      if (cachedAddresses) {
        const addresses = cachedAddresses.split(" ");
        const wasConnectedViaStandalone = this.storage.getItem("IsStandaloneSigning") === "true";
        if (addresses[0] !== "" && !linked && this._session.linked && !wasConnectedViaStandalone) {
          this.isUnlinkedErrorState = true;
        }
      }
    };
    this.metadataUpdated = (key, value) => {
      this.storage.setItem(key, value);
    };
    this.chainUpdated = (chainId, jsonRpcUrl) => {
      if (this.chainCallbackParams.chainId === chainId && this.chainCallbackParams.jsonRpcUrl === jsonRpcUrl) {
        return;
      }
      this.chainCallbackParams = {
        chainId,
        jsonRpcUrl
      };
      if (this.chainCallback) {
        this.chainCallback(jsonRpcUrl, Number.parseInt(chainId, 10));
      }
    };
    this.accountUpdated = (selectedAddress) => {
      if (this.accountsCallback) {
        this.accountsCallback([selectedAddress]);
      }
      if (_WalletLinkRelay.accountRequestCallbackIds.size > 0) {
        Array.from(_WalletLinkRelay.accountRequestCallbackIds.values()).forEach((id3) => {
          this.invokeCallback(id3, {
            method: "requestEthereumAccounts",
            result: [selectedAddress]
          });
        });
        _WalletLinkRelay.accountRequestCallbackIds.clear();
      }
    };
    this.resetAndReload = this.resetAndReload.bind(this);
    this.linkAPIUrl = options.linkAPIUrl;
    this.storage = options.storage;
    this.metadata = options.metadata;
    this.accountsCallback = options.accountsCallback;
    this.chainCallback = options.chainCallback;
    const { session, ui: ui2, connection } = this.subscribe();
    this._session = session;
    this.connection = connection;
    this.relayEventManager = new RelayEventManager();
    this.ui = ui2;
    this.ui.attach();
  }
  subscribe() {
    const session = WalletLinkSession.load(this.storage) || WalletLinkSession.create(this.storage);
    const { linkAPIUrl } = this;
    const connection = new WalletLinkConnection({
      session,
      linkAPIUrl,
      listener: this
    });
    const ui2 = this.isMobileWeb ? new WLMobileRelayUI() : new WalletLinkRelayUI();
    connection.connect();
    return { session, ui: ui2, connection };
  }
  resetAndReload() {
    this.connection.destroy().then(() => {
      const storedSession = WalletLinkSession.load(this.storage);
      if ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) === this._session.id) {
        ScopedLocalStorage.clearAll();
      }
      document.location.reload();
    }).catch((_5) => {
    });
  }
  signEthereumTransaction(params) {
    return this.sendRequest({
      method: "signEthereumTransaction",
      params: {
        fromAddress: params.fromAddress,
        toAddress: params.toAddress,
        weiValue: bigIntStringFromBigInt(params.weiValue),
        data: hexStringFromBuffer(params.data, true),
        nonce: params.nonce,
        gasPriceInWei: params.gasPriceInWei ? bigIntStringFromBigInt(params.gasPriceInWei) : null,
        maxFeePerGas: params.gasPriceInWei ? bigIntStringFromBigInt(params.gasPriceInWei) : null,
        maxPriorityFeePerGas: params.gasPriceInWei ? bigIntStringFromBigInt(params.gasPriceInWei) : null,
        gasLimit: params.gasLimit ? bigIntStringFromBigInt(params.gasLimit) : null,
        chainId: params.chainId,
        shouldSubmit: false
      }
    });
  }
  signAndSubmitEthereumTransaction(params) {
    return this.sendRequest({
      method: "signEthereumTransaction",
      params: {
        fromAddress: params.fromAddress,
        toAddress: params.toAddress,
        weiValue: bigIntStringFromBigInt(params.weiValue),
        data: hexStringFromBuffer(params.data, true),
        nonce: params.nonce,
        gasPriceInWei: params.gasPriceInWei ? bigIntStringFromBigInt(params.gasPriceInWei) : null,
        maxFeePerGas: params.maxFeePerGas ? bigIntStringFromBigInt(params.maxFeePerGas) : null,
        maxPriorityFeePerGas: params.maxPriorityFeePerGas ? bigIntStringFromBigInt(params.maxPriorityFeePerGas) : null,
        gasLimit: params.gasLimit ? bigIntStringFromBigInt(params.gasLimit) : null,
        chainId: params.chainId,
        shouldSubmit: true
      }
    });
  }
  submitEthereumTransaction(signedTransaction, chainId) {
    return this.sendRequest({
      method: "submitEthereumTransaction",
      params: {
        signedTransaction: hexStringFromBuffer(signedTransaction, true),
        chainId
      }
    });
  }
  getWalletLinkSession() {
    return this._session;
  }
  sendRequest(request) {
    let hideSnackbarItem = null;
    const id3 = randomBytesHex(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id3);
      this.handleErrorResponse(id3, request.method, error);
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    return new Promise((resolve, reject) => {
      {
        hideSnackbarItem = this.ui.showConnecting({
          isUnlinkedErrorState: this.isUnlinkedErrorState,
          onCancel: cancel,
          onResetConnection: this.resetAndReload
          // eslint-disable-line @typescript-eslint/unbound-method
        });
      }
      this.relayEventManager.callbacks.set(id3, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (isErrorResponse(response)) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      this.publishWeb3RequestEvent(id3, request);
    });
  }
  publishWeb3RequestEvent(id3, request) {
    const message = { type: "WEB3_REQUEST", id: id3, request };
    this.publishEvent("Web3Request", message, true).then((_5) => {
    }).catch((err) => {
      this.handleWeb3ResponseMessage(message.id, {
        method: request.method,
        errorMessage: err.message
      });
    });
    if (this.isMobileWeb) {
      this.openCoinbaseWalletDeeplink(request.method);
    }
  }
  // copied from MobileRelay
  openCoinbaseWalletDeeplink(method) {
    if (!(this.ui instanceof WLMobileRelayUI))
      return;
    switch (method) {
      case "requestEthereumAccounts":
      // requestEthereumAccounts is handled via popup
      case "switchEthereumChain":
        return;
      default:
        window.addEventListener("blur", () => {
          window.addEventListener("focus", () => {
            this.connection.checkUnseenEvents();
          }, { once: true });
        }, { once: true });
        this.ui.openCoinbaseWalletDeeplink();
        break;
    }
  }
  publishWeb3RequestCanceledEvent(id3) {
    const message = {
      type: "WEB3_REQUEST_CANCELED",
      id: id3
    };
    this.publishEvent("Web3RequestCanceled", message, false).then();
  }
  publishEvent(event, message, callWebhook) {
    return this.connection.publishEvent(event, message, callWebhook);
  }
  handleWeb3ResponseMessage(id3, response) {
    if (response.method === "requestEthereumAccounts") {
      _WalletLinkRelay.accountRequestCallbackIds.forEach((id4) => this.invokeCallback(id4, response));
      _WalletLinkRelay.accountRequestCallbackIds.clear();
      return;
    }
    this.invokeCallback(id3, response);
  }
  handleErrorResponse(id3, method, error) {
    var _a3;
    const errorMessage = (_a3 = error === null || error === void 0 ? void 0 : error.message) !== null && _a3 !== void 0 ? _a3 : "Unspecified error message.";
    this.handleWeb3ResponseMessage(id3, {
      method,
      errorMessage
    });
  }
  invokeCallback(id3, response) {
    const callback = this.relayEventManager.callbacks.get(id3);
    if (callback) {
      callback(response);
      this.relayEventManager.callbacks.delete(id3);
    }
  }
  requestEthereumAccounts() {
    const { appName, appLogoUrl } = this.metadata;
    const request = {
      method: "requestEthereumAccounts",
      params: {
        appName,
        appLogoUrl
      }
    };
    const hideSnackbarItem = null;
    const id3 = randomBytesHex(8);
    return new Promise((resolve, reject) => {
      this.relayEventManager.callbacks.set(id3, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (isErrorResponse(response)) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      _WalletLinkRelay.accountRequestCallbackIds.add(id3);
      this.publishWeb3RequestEvent(id3, request);
    });
  }
  watchAsset(type, address, symbol, decimals, image, chainId) {
    const request = {
      method: "watchAsset",
      params: {
        type,
        options: {
          address,
          symbol,
          decimals,
          image
        },
        chainId
      }
    };
    let hideSnackbarItem = null;
    const id3 = randomBytesHex(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id3);
      this.handleErrorResponse(id3, request.method, error);
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    {
      hideSnackbarItem = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: cancel,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      });
    }
    return new Promise((resolve, reject) => {
      this.relayEventManager.callbacks.set(id3, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (isErrorResponse(response)) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      this.publishWeb3RequestEvent(id3, request);
    });
  }
  addEthereumChain(chainId, rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency) {
    const request = {
      method: "addEthereumChain",
      params: {
        chainId,
        rpcUrls,
        blockExplorerUrls,
        chainName,
        iconUrls,
        nativeCurrency
      }
    };
    let hideSnackbarItem = null;
    const id3 = randomBytesHex(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id3);
      this.handleErrorResponse(id3, request.method, error);
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    {
      hideSnackbarItem = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: cancel,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      });
    }
    return new Promise((resolve, reject) => {
      this.relayEventManager.callbacks.set(id3, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (isErrorResponse(response)) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      this.publishWeb3RequestEvent(id3, request);
    });
  }
  switchEthereumChain(chainId, address) {
    const request = {
      method: "switchEthereumChain",
      params: Object.assign({ chainId }, { address })
    };
    let hideSnackbarItem = null;
    const id3 = randomBytesHex(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id3);
      this.handleErrorResponse(id3, request.method, error);
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    {
      hideSnackbarItem = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: cancel,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      });
    }
    return new Promise((resolve, reject) => {
      this.relayEventManager.callbacks.set(id3, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (isErrorResponse(response) && response.errorCode) {
          return reject(standardErrors.provider.custom({
            code: response.errorCode,
            message: `Unrecognized chain ID. Try adding the chain using addEthereumChain first.`
          }));
        } else if (isErrorResponse(response)) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      this.publishWeb3RequestEvent(id3, request);
    });
  }
};
WalletLinkRelay.accountRequestCallbackIds = /* @__PURE__ */ new Set();

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/WalletLinkSigner.js
var DEFAULT_CHAIN_ID_KEY = "DefaultChainId";
var DEFAULT_JSON_RPC_URL = "DefaultJsonRpcUrl";
var WalletLinkSigner = class {
  constructor(options) {
    this._relay = null;
    this._addresses = [];
    this.metadata = options.metadata;
    this._storage = new ScopedLocalStorage("walletlink", WALLETLINK_URL);
    this.callback = options.callback || null;
    const cachedAddresses = this._storage.getItem(LOCAL_STORAGE_ADDRESSES_KEY);
    if (cachedAddresses) {
      const addresses = cachedAddresses.split(" ");
      if (addresses[0] !== "") {
        this._addresses = addresses.map((address) => ensureAddressString(address));
      }
    }
    this.initializeRelay();
  }
  getSession() {
    const relay = this.initializeRelay();
    const { id: id3, secret } = relay.getWalletLinkSession();
    return { id: id3, secret };
  }
  async handshake() {
    await this._eth_requestAccounts();
  }
  get selectedAddress() {
    return this._addresses[0] || void 0;
  }
  get jsonRpcUrl() {
    var _a3;
    return (_a3 = this._storage.getItem(DEFAULT_JSON_RPC_URL)) !== null && _a3 !== void 0 ? _a3 : void 0;
  }
  set jsonRpcUrl(value) {
    this._storage.setItem(DEFAULT_JSON_RPC_URL, value);
  }
  updateProviderInfo(jsonRpcUrl, chainId) {
    var _a3;
    this.jsonRpcUrl = jsonRpcUrl;
    const originalChainId = this.getChainId();
    this._storage.setItem(DEFAULT_CHAIN_ID_KEY, chainId.toString(10));
    const chainChanged = ensureIntNumber(chainId) !== originalChainId;
    if (chainChanged) {
      (_a3 = this.callback) === null || _a3 === void 0 ? void 0 : _a3.call(this, "chainChanged", hexStringFromNumber(chainId));
    }
  }
  async watchAsset(params) {
    const request = Array.isArray(params) ? params[0] : params;
    if (!request.type) {
      throw standardErrors.rpc.invalidParams("Type is required");
    }
    if ((request === null || request === void 0 ? void 0 : request.type) !== "ERC20") {
      throw standardErrors.rpc.invalidParams(`Asset of type '${request.type}' is not supported`);
    }
    if (!(request === null || request === void 0 ? void 0 : request.options)) {
      throw standardErrors.rpc.invalidParams("Options are required");
    }
    if (!(request === null || request === void 0 ? void 0 : request.options.address)) {
      throw standardErrors.rpc.invalidParams("Address is required");
    }
    const chainId = this.getChainId();
    const { address, symbol, image, decimals } = request.options;
    const relay = this.initializeRelay();
    const result = await relay.watchAsset(request.type, address, symbol, decimals, image, chainId === null || chainId === void 0 ? void 0 : chainId.toString());
    if (isErrorResponse(result))
      return false;
    return !!result.result;
  }
  async addEthereumChain(params) {
    var _a3, _b;
    const request = params[0];
    if (((_a3 = request.rpcUrls) === null || _a3 === void 0 ? void 0 : _a3.length) === 0) {
      throw standardErrors.rpc.invalidParams("please pass in at least 1 rpcUrl");
    }
    if (!request.chainName || request.chainName.trim() === "") {
      throw standardErrors.rpc.invalidParams("chainName is a required field");
    }
    if (!request.nativeCurrency) {
      throw standardErrors.rpc.invalidParams("nativeCurrency is a required field");
    }
    const chainIdNumber = Number.parseInt(request.chainId, 16);
    if (chainIdNumber === this.getChainId()) {
      return false;
    }
    const relay = this.initializeRelay();
    const { rpcUrls = [], blockExplorerUrls = [], chainName, iconUrls = [], nativeCurrency } = request;
    const res = await relay.addEthereumChain(chainIdNumber.toString(), rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency);
    if (isErrorResponse(res))
      return false;
    if (((_b = res.result) === null || _b === void 0 ? void 0 : _b.isApproved) === true) {
      this.updateProviderInfo(rpcUrls[0], chainIdNumber);
      return null;
    }
    throw standardErrors.rpc.internal("unable to add ethereum chain");
  }
  async switchEthereumChain(params) {
    const request = params[0];
    const chainId = Number.parseInt(request.chainId, 16);
    const relay = this.initializeRelay();
    const res = await relay.switchEthereumChain(chainId.toString(10), this.selectedAddress || void 0);
    if (isErrorResponse(res))
      throw res;
    const switchResponse = res.result;
    if (switchResponse.isApproved && switchResponse.rpcUrl.length > 0) {
      this.updateProviderInfo(switchResponse.rpcUrl, chainId);
    }
    return null;
  }
  async cleanup() {
    this.callback = null;
    if (this._relay) {
      this._relay.resetAndReload();
    }
    this._storage.clear();
  }
  _setAddresses(addresses, _5) {
    var _a3;
    if (!Array.isArray(addresses)) {
      throw new Error("addresses is not an array");
    }
    const newAddresses = addresses.map((address) => ensureAddressString(address));
    if (JSON.stringify(newAddresses) === JSON.stringify(this._addresses)) {
      return;
    }
    this._addresses = newAddresses;
    (_a3 = this.callback) === null || _a3 === void 0 ? void 0 : _a3.call(this, "accountsChanged", newAddresses);
    this._storage.setItem(LOCAL_STORAGE_ADDRESSES_KEY, newAddresses.join(" "));
  }
  async request(request) {
    const params = request.params || [];
    switch (request.method) {
      case "eth_accounts":
        return [...this._addresses];
      case "eth_coinbase":
        return this.selectedAddress || null;
      case "net_version":
        return this.getChainId().toString(10);
      case "eth_chainId":
        return hexStringFromNumber(this.getChainId());
      case "eth_requestAccounts":
        return this._eth_requestAccounts();
      case "eth_ecRecover":
      case "personal_ecRecover":
        return this.ecRecover(request);
      case "personal_sign":
        return this.personalSign(request);
      case "eth_signTransaction":
        return this._eth_signTransaction(params);
      case "eth_sendRawTransaction":
        return this._eth_sendRawTransaction(params);
      case "eth_sendTransaction":
        return this._eth_sendTransaction(params);
      case "eth_signTypedData_v1":
      case "eth_signTypedData_v3":
      case "eth_signTypedData_v4":
      case "eth_signTypedData":
        return this.signTypedData(request);
      case "wallet_addEthereumChain":
        return this.addEthereumChain(params);
      case "wallet_switchEthereumChain":
        return this.switchEthereumChain(params);
      case "wallet_watchAsset":
        return this.watchAsset(params);
      default:
        if (!this.jsonRpcUrl)
          throw standardErrors.rpc.internal("No RPC URL set for chain");
        return fetchRPCRequest(request, this.jsonRpcUrl);
    }
  }
  _ensureKnownAddress(addressString) {
    const addressStr = ensureAddressString(addressString);
    const lowercaseAddresses = this._addresses.map((address) => ensureAddressString(address));
    if (!lowercaseAddresses.includes(addressStr)) {
      throw new Error("Unknown Ethereum address");
    }
  }
  _prepareTransactionParams(tx) {
    const fromAddress = tx.from ? ensureAddressString(tx.from) : this.selectedAddress;
    if (!fromAddress) {
      throw new Error("Ethereum address is unavailable");
    }
    this._ensureKnownAddress(fromAddress);
    const toAddress = tx.to ? ensureAddressString(tx.to) : null;
    const weiValue = tx.value != null ? ensureBigInt(tx.value) : BigInt(0);
    const data = tx.data ? ensureBuffer(tx.data) : import_buffer.Buffer.alloc(0);
    const nonce = tx.nonce != null ? ensureIntNumber(tx.nonce) : null;
    const gasPriceInWei = tx.gasPrice != null ? ensureBigInt(tx.gasPrice) : null;
    const maxFeePerGas = tx.maxFeePerGas != null ? ensureBigInt(tx.maxFeePerGas) : null;
    const maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? ensureBigInt(tx.maxPriorityFeePerGas) : null;
    const gasLimit = tx.gas != null ? ensureBigInt(tx.gas) : null;
    const chainId = tx.chainId ? ensureIntNumber(tx.chainId) : this.getChainId();
    return {
      fromAddress,
      toAddress,
      weiValue,
      data,
      nonce,
      gasPriceInWei,
      maxFeePerGas,
      maxPriorityFeePerGas,
      gasLimit,
      chainId
    };
  }
  async ecRecover(request) {
    const { method, params } = request;
    if (!Array.isArray(params))
      throw standardErrors.rpc.invalidParams();
    const relay = this.initializeRelay();
    const res = await relay.sendRequest({
      method: "ethereumAddressFromSignedMessage",
      params: {
        message: encodeToHexString(params[0]),
        signature: encodeToHexString(params[1]),
        addPrefix: method === "personal_ecRecover"
      }
    });
    if (isErrorResponse(res))
      throw res;
    return res.result;
  }
  getChainId() {
    var _a3;
    return Number.parseInt((_a3 = this._storage.getItem(DEFAULT_CHAIN_ID_KEY)) !== null && _a3 !== void 0 ? _a3 : "1", 10);
  }
  async _eth_requestAccounts() {
    var _a3, _b;
    if (this._addresses.length > 0) {
      (_a3 = this.callback) === null || _a3 === void 0 ? void 0 : _a3.call(this, "connect", { chainId: hexStringFromNumber(this.getChainId()) });
      return this._addresses;
    }
    const relay = this.initializeRelay();
    const res = await relay.requestEthereumAccounts();
    if (isErrorResponse(res))
      throw res;
    if (!res.result) {
      throw new Error("accounts received is empty");
    }
    this._setAddresses(res.result);
    (_b = this.callback) === null || _b === void 0 ? void 0 : _b.call(this, "connect", { chainId: hexStringFromNumber(this.getChainId()) });
    return this._addresses;
  }
  async personalSign({ params }) {
    if (!Array.isArray(params))
      throw standardErrors.rpc.invalidParams();
    const address = params[1];
    const rawData = params[0];
    this._ensureKnownAddress(address);
    const relay = this.initializeRelay();
    const res = await relay.sendRequest({
      method: "signEthereumMessage",
      params: {
        address: ensureAddressString(address),
        message: encodeToHexString(rawData),
        addPrefix: true,
        typedDataJson: null
      }
    });
    if (isErrorResponse(res))
      throw res;
    return res.result;
  }
  async _eth_signTransaction(params) {
    const tx = this._prepareTransactionParams(params[0] || {});
    const relay = this.initializeRelay();
    const res = await relay.signEthereumTransaction(tx);
    if (isErrorResponse(res))
      throw res;
    return res.result;
  }
  async _eth_sendRawTransaction(params) {
    const signedTransaction = ensureBuffer(params[0]);
    const relay = this.initializeRelay();
    const res = await relay.submitEthereumTransaction(signedTransaction, this.getChainId());
    if (isErrorResponse(res))
      throw res;
    return res.result;
  }
  async _eth_sendTransaction(params) {
    const tx = this._prepareTransactionParams(params[0] || {});
    const relay = this.initializeRelay();
    const res = await relay.signAndSubmitEthereumTransaction(tx);
    if (isErrorResponse(res))
      throw res;
    return res.result;
  }
  async signTypedData(request) {
    const { method, params } = request;
    if (!Array.isArray(params))
      throw standardErrors.rpc.invalidParams();
    const encode = (input) => {
      const hashFuncMap = {
        eth_signTypedData_v1: import_eth_eip712_util.default.hashForSignTypedDataLegacy,
        eth_signTypedData_v3: import_eth_eip712_util.default.hashForSignTypedData_v3,
        eth_signTypedData_v4: import_eth_eip712_util.default.hashForSignTypedData_v4,
        eth_signTypedData: import_eth_eip712_util.default.hashForSignTypedData_v4
      };
      return hexStringFromBuffer(hashFuncMap[method]({
        data: ensureParsedJSONObject(input)
      }), true);
    };
    const address = params[method === "eth_signTypedData_v1" ? 1 : 0];
    const rawData = params[method === "eth_signTypedData_v1" ? 0 : 1];
    this._ensureKnownAddress(address);
    const relay = this.initializeRelay();
    const res = await relay.sendRequest({
      method: "signEthereumMessage",
      params: {
        address: ensureAddressString(address),
        message: encode(rawData),
        typedDataJson: JSON.stringify(rawData, null, 2),
        addPrefix: false
      }
    });
    if (isErrorResponse(res))
      throw res;
    return res.result;
  }
  initializeRelay() {
    if (!this._relay) {
      this._relay = new WalletLinkRelay({
        linkAPIUrl: WALLETLINK_URL,
        storage: this._storage,
        metadata: this.metadata,
        accountsCallback: this._setAddresses.bind(this),
        chainCallback: this.updateProviderInfo.bind(this)
      });
    }
    return this._relay;
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/util.js
var SIGNER_TYPE_KEY = "SignerType";
var storage = new ScopedLocalStorage("CBWSDK", "SignerConfigurator");
function loadSignerType() {
  return storage.getItem(SIGNER_TYPE_KEY);
}
function storeSignerType(signerType) {
  storage.setItem(SIGNER_TYPE_KEY, signerType);
}
async function fetchSignerType(params) {
  const { communicator, metadata, handshakeRequest, callback } = params;
  listenForWalletLinkSessionRequest(communicator, metadata, callback).catch(() => {
  });
  const request = {
    id: crypto.randomUUID(),
    event: "selectSignerType",
    data: Object.assign(Object.assign({}, params.preference), { handshakeRequest })
  };
  const { data } = await communicator.postRequestAndWaitForResponse(request);
  return data;
}
function createSigner(params) {
  const { signerType, metadata, communicator, callback } = params;
  switch (signerType) {
    case "scw": {
      return new SCWSigner({
        metadata,
        callback,
        communicator
      });
    }
    case "walletlink": {
      return new WalletLinkSigner({
        metadata,
        callback
      });
    }
  }
}
async function listenForWalletLinkSessionRequest(communicator, metadata, callback) {
  await communicator.onMessage(({ event }) => event === "WalletLinkSessionRequest");
  const walletlink = new WalletLinkSigner({
    metadata,
    callback
  });
  communicator.postMessage({
    event: "WalletLinkUpdate",
    data: { session: walletlink.getSession() }
  });
  await walletlink.handshake();
  communicator.postMessage({
    event: "WalletLinkUpdate",
    data: { connected: true }
  });
}

// node_modules/@coinbase/wallet-sdk/dist/core/communicator/Communicator.js
init_shim();

// node_modules/@coinbase/wallet-sdk/dist/util/web.js
init_shim();

// node_modules/@coinbase/wallet-sdk/dist/util/checkCrossOriginOpenerPolicy.js
init_shim();
var COOP_ERROR_MESSAGE = `Coinbase Wallet SDK requires the Cross-Origin-Opener-Policy header to not be set to 'same-origin'. This is to ensure that the SDK can communicate with the Coinbase Smart Wallet app.

Please see https://www.smartwallet.dev/guides/tips/popup-tips#cross-origin-opener-policy for more information.`;
var createCoopChecker = () => {
  let crossOriginOpenerPolicy;
  return {
    getCrossOriginOpenerPolicy: () => {
      if (crossOriginOpenerPolicy === void 0) {
        return "undefined";
      }
      return crossOriginOpenerPolicy;
    },
    checkCrossOriginOpenerPolicy: async () => {
      if (typeof window === "undefined") {
        crossOriginOpenerPolicy = "non-browser-env";
        return;
      }
      try {
        const url = `${window.location.origin}${window.location.pathname}`;
        const response = await fetch(url, {
          method: "HEAD"
        });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const result = response.headers.get("Cross-Origin-Opener-Policy");
        crossOriginOpenerPolicy = result !== null && result !== void 0 ? result : "null";
        if (crossOriginOpenerPolicy === "same-origin") {
          console.error(COOP_ERROR_MESSAGE);
        }
      } catch (error) {
        console.error("Error checking Cross-Origin-Opener-Policy:", error.message);
        crossOriginOpenerPolicy = "error";
      }
    }
  };
};
var { checkCrossOriginOpenerPolicy, getCrossOriginOpenerPolicy } = createCoopChecker();

// node_modules/@coinbase/wallet-sdk/dist/util/web.js
var POPUP_WIDTH = 420;
var POPUP_HEIGHT = 540;
var RETRY_BUTTON = {
  isRed: false,
  info: "Retry",
  svgWidth: "10",
  svgHeight: "11",
  path: RETRY_SVG_PATH,
  defaultFillRule: "evenodd",
  defaultClipRule: "evenodd"
};
var POPUP_BLOCKED_MESSAGE = "Popup was blocked. Try again.";
var snackbar = null;
function openPopup(url) {
  const left = (window.innerWidth - POPUP_WIDTH) / 2 + window.screenX;
  const top = (window.innerHeight - POPUP_HEIGHT) / 2 + window.screenY;
  appendAppInfoQueryParams(url);
  function tryOpenPopup() {
    const popupId = `wallet_${crypto.randomUUID()}`;
    const popup2 = window.open(url, popupId, `width=${POPUP_WIDTH}, height=${POPUP_HEIGHT}, left=${left}, top=${top}`);
    popup2 === null || popup2 === void 0 ? void 0 : popup2.focus();
    if (!popup2) {
      return null;
    }
    return popup2;
  }
  let popup = tryOpenPopup();
  if (!popup) {
    const sb = initSnackbar();
    return new Promise((resolve, reject) => {
      sb.presentItem({
        autoExpand: true,
        message: POPUP_BLOCKED_MESSAGE,
        menuItems: [
          Object.assign(Object.assign({}, RETRY_BUTTON), { onClick: () => {
            popup = tryOpenPopup();
            if (popup) {
              resolve(popup);
            } else {
              reject(standardErrors.rpc.internal("Popup window was blocked"));
            }
            sb.clear();
          } })
        ]
      });
    });
  }
  return Promise.resolve(popup);
}
function closePopup(popup) {
  if (popup && !popup.closed) {
    popup.close();
  }
}
function appendAppInfoQueryParams(url) {
  const params = {
    sdkName: NAME,
    sdkVersion: VERSION,
    origin: window.location.origin,
    coop: getCrossOriginOpenerPolicy()
  };
  for (const [key, value] of Object.entries(params)) {
    url.searchParams.append(key, value.toString());
  }
}
function initSnackbar() {
  if (!snackbar) {
    const root = document.createElement("div");
    root.className = "-cbwsdk-css-reset";
    document.body.appendChild(root);
    snackbar = new Snackbar();
    snackbar.attach(root);
  }
  return snackbar;
}

// node_modules/@coinbase/wallet-sdk/dist/core/communicator/Communicator.js
var Communicator = class {
  constructor({ url = CB_KEYS_URL, metadata, preference }) {
    this.popup = null;
    this.listeners = /* @__PURE__ */ new Map();
    this.postMessage = async (message) => {
      const popup = await this.waitForPopupLoaded();
      popup.postMessage(message, this.url.origin);
    };
    this.postRequestAndWaitForResponse = async (request) => {
      const responsePromise = this.onMessage(({ requestId }) => requestId === request.id);
      this.postMessage(request);
      return await responsePromise;
    };
    this.onMessage = async (predicate) => {
      return new Promise((resolve, reject) => {
        const listener = (event) => {
          if (event.origin !== this.url.origin)
            return;
          const message = event.data;
          if (predicate(message)) {
            resolve(message);
            window.removeEventListener("message", listener);
            this.listeners.delete(listener);
          }
        };
        window.addEventListener("message", listener);
        this.listeners.set(listener, { reject });
      });
    };
    this.disconnect = () => {
      closePopup(this.popup);
      this.popup = null;
      this.listeners.forEach(({ reject }, listener) => {
        reject(standardErrors.provider.userRejectedRequest("Request rejected"));
        window.removeEventListener("message", listener);
      });
      this.listeners.clear();
    };
    this.waitForPopupLoaded = async () => {
      if (this.popup && !this.popup.closed) {
        this.popup.focus();
        return this.popup;
      }
      this.popup = await openPopup(this.url);
      this.onMessage(({ event }) => event === "PopupUnload").then(this.disconnect).catch(() => {
      });
      return this.onMessage(({ event }) => event === "PopupLoaded").then((message) => {
        this.postMessage({
          requestId: message.id,
          data: {
            version: VERSION,
            metadata: this.metadata,
            preference: this.preference,
            location: window.location.toString()
          }
        });
      }).then(() => {
        if (!this.popup)
          throw standardErrors.rpc.internal();
        return this.popup;
      });
    };
    this.url = new URL(url);
    this.metadata = metadata;
    this.preference = preference;
  }
};

// node_modules/@coinbase/wallet-sdk/dist/core/error/serialize.js
init_shim();
function serializeError(error) {
  const serialized = serialize(getErrorObject(error), {
    shouldIncludeStack: true
  });
  const docUrl = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
  docUrl.searchParams.set("version", VERSION);
  docUrl.searchParams.set("code", serialized.code.toString());
  docUrl.searchParams.set("message", serialized.message);
  return Object.assign(Object.assign({}, serialized), { docUrl: docUrl.href });
}
function getErrorObject(error) {
  var _a3;
  if (typeof error === "string") {
    return {
      message: error,
      code: standardErrorCodes.rpc.internal
    };
  } else if (isErrorResponse(error)) {
    const message = error.errorMessage;
    const code = (_a3 = error.errorCode) !== null && _a3 !== void 0 ? _a3 : message.match(/(denied|rejected)/i) ? standardErrorCodes.provider.userRejectedRequest : void 0;
    return Object.assign(Object.assign({}, error), {
      message,
      code,
      data: { method: error.method }
    });
  }
  return error;
}

// node_modules/@coinbase/wallet-sdk/dist/core/provider/interface.js
init_shim();
var ProviderEventEmitter = class extends import_index.default {
};

// node_modules/@coinbase/wallet-sdk/dist/CoinbaseWalletProvider.js
var __rest = function(s3, e7) {
  var t8 = {};
  for (var p5 in s3) if (Object.prototype.hasOwnProperty.call(s3, p5) && e7.indexOf(p5) < 0)
    t8[p5] = s3[p5];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i5 = 0, p5 = Object.getOwnPropertySymbols(s3); i5 < p5.length; i5++) {
      if (e7.indexOf(p5[i5]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p5[i5]))
        t8[p5[i5]] = s3[p5[i5]];
    }
  return t8;
};
var CoinbaseWalletProvider = class extends ProviderEventEmitter {
  constructor(_a3) {
    var { metadata } = _a3, _b = _a3.preference, { keysUrl } = _b, preference = __rest(_b, ["keysUrl"]);
    super();
    this.signer = null;
    this.isCoinbaseWallet = true;
    this.metadata = metadata;
    this.preference = preference;
    this.communicator = new Communicator({
      url: keysUrl,
      metadata,
      preference
    });
    const signerType = loadSignerType();
    if (signerType) {
      this.signer = this.initSigner(signerType);
    }
  }
  async request(args) {
    try {
      checkErrorForInvalidRequestArgs(args);
      if (!this.signer) {
        switch (args.method) {
          case "eth_requestAccounts": {
            const signerType = await this.requestSignerSelection(args);
            const signer = this.initSigner(signerType);
            await signer.handshake(args);
            this.signer = signer;
            storeSignerType(signerType);
            break;
          }
          case "wallet_sendCalls": {
            const ephemeralSigner = this.initSigner("scw");
            await ephemeralSigner.handshake({ method: "handshake" });
            const result = await ephemeralSigner.request(args);
            await ephemeralSigner.cleanup();
            return result;
          }
          case "wallet_getCallsStatus":
            return fetchRPCRequest(args, CB_WALLET_RPC_URL);
          case "net_version":
            return 1;
          // default value
          case "eth_chainId":
            return hexStringFromNumber(1);
          // default value
          default: {
            throw standardErrors.provider.unauthorized("Must call 'eth_requestAccounts' before other methods");
          }
        }
      }
      return await this.signer.request(args);
    } catch (error) {
      const { code } = error;
      if (code === standardErrorCodes.provider.unauthorized)
        this.disconnect();
      return Promise.reject(serializeError(error));
    }
  }
  /** @deprecated Use `.request({ method: 'eth_requestAccounts' })` instead. */
  async enable() {
    console.warn(`.enable() has been deprecated. Please use .request({ method: "eth_requestAccounts" }) instead.`);
    return await this.request({
      method: "eth_requestAccounts"
    });
  }
  async disconnect() {
    var _a3;
    await ((_a3 = this.signer) === null || _a3 === void 0 ? void 0 : _a3.cleanup());
    this.signer = null;
    ScopedLocalStorage.clearAll();
    this.emit("disconnect", standardErrors.provider.disconnected("User initiated disconnection"));
  }
  requestSignerSelection(handshakeRequest) {
    return fetchSignerType({
      communicator: this.communicator,
      preference: this.preference,
      metadata: this.metadata,
      handshakeRequest,
      callback: this.emit.bind(this)
    });
  }
  initSigner(signerType) {
    return createSigner({
      signerType,
      metadata: this.metadata,
      communicator: this.communicator,
      callback: this.emit.bind(this)
    });
  }
};

// node_modules/@coinbase/wallet-sdk/dist/util/validatePreferences.js
init_shim();
function validatePreferences(preference) {
  if (!preference) {
    return;
  }
  if (!["all", "smartWalletOnly", "eoaOnly"].includes(preference.options)) {
    throw new Error(`Invalid options: ${preference.options}`);
  }
  if (preference.attribution) {
    if (preference.attribution.auto !== void 0 && preference.attribution.dataSuffix !== void 0) {
      throw new Error(`Attribution cannot contain both auto and dataSuffix properties`);
    }
  }
}

// node_modules/@coinbase/wallet-sdk/dist/createCoinbaseWalletSDK.js
init_shim();

// node_modules/@coinbase/wallet-sdk/dist/createCoinbaseWalletProvider.js
init_shim();
function createCoinbaseWalletProvider(options) {
  var _a3;
  const params = {
    metadata: options.metadata,
    preference: options.preference
  };
  return (_a3 = getCoinbaseInjectedProvider(params)) !== null && _a3 !== void 0 ? _a3 : new CoinbaseWalletProvider(params);
}

// node_modules/@coinbase/wallet-sdk/dist/createCoinbaseWalletSDK.js
var DEFAULT_PREFERENCE = {
  options: "all"
};
function createCoinbaseWalletSDK(params) {
  var _a3;
  const versionStorage = new ScopedLocalStorage("CBWSDK");
  versionStorage.setItem("VERSION", VERSION);
  void checkCrossOriginOpenerPolicy();
  const options = {
    metadata: {
      appName: params.appName || "Dapp",
      appLogoUrl: params.appLogoUrl || "",
      appChainIds: params.appChainIds || []
    },
    preference: Object.assign(DEFAULT_PREFERENCE, (_a3 = params.preference) !== null && _a3 !== void 0 ? _a3 : {})
  };
  validatePreferences(options.preference);
  let provider = null;
  return {
    getProvider: () => {
      if (!provider) {
        provider = createCoinbaseWalletProvider(options);
      }
      return provider;
    }
  };
}

// node_modules/@marsidev/react-turnstile/dist/index.mjs
init_shim();
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);
var Component = ({ as: Element = "div", ...props }, ref) => {
  return (0, import_jsx_runtime.jsx)(Element, { ...props, ref });
};
var Container = (0, import_react.forwardRef)(Component);
var SCRIPT_URL = "https://challenges.cloudflare.com/turnstile/v0/api.js";
var DEFAULT_SCRIPT_ID = "cf-turnstile-script";
var DEFAULT_CONTAINER_ID = "cf-turnstile";
var DEFAULT_ONLOAD_NAME = "onloadTurnstileCallback";
var checkElementExistence = (id3) => !!document.getElementById(id3);
var injectTurnstileScript = ({
  render = "explicit",
  onLoadCallbackName = DEFAULT_ONLOAD_NAME,
  scriptOptions: {
    nonce = "",
    defer = true,
    async = true,
    id: id3 = "",
    appendTo,
    onError,
    crossOrigin = ""
  } = {}
}) => {
  const scriptId = id3 || DEFAULT_SCRIPT_ID;
  if (checkElementExistence(scriptId)) {
    return;
  }
  const script = document.createElement("script");
  script.id = scriptId;
  script.src = `${SCRIPT_URL}?onload=${onLoadCallbackName}&render=${render}`;
  if (document.querySelector(`script[src="${script.src}"]`)) {
    return;
  }
  script.defer = !!defer;
  script.async = !!async;
  if (nonce) {
    script.nonce = nonce;
  }
  if (crossOrigin) {
    script.crossOrigin = crossOrigin;
  }
  if (onError) {
    script.onerror = onError;
  }
  const parentEl = appendTo === "body" ? document.body : document.getElementsByTagName("head")[0];
  parentEl.appendChild(script);
};
var CONTAINER_STYLE_SET = {
  normal: {
    width: 300,
    height: 65
  },
  compact: {
    width: 130,
    height: 120
  },
  invisible: {
    width: 0,
    height: 0,
    overflow: "hidden"
  },
  interactionOnly: {
    width: "fit-content",
    height: "auto"
  }
};
function getTurnstileSizeOpts(size) {
  let result;
  if (size !== "invisible") {
    result = size;
  }
  return result;
}
function useObserveScript(scriptId = DEFAULT_SCRIPT_ID) {
  const [scriptLoaded, setScriptLoaded] = (0, import_react.useState)(false);
  (0, import_react.useEffect)(() => {
    const checkScriptExists = () => {
      if (checkElementExistence(scriptId)) {
        setScriptLoaded(true);
      }
    };
    const observer = new MutationObserver(checkScriptExists);
    observer.observe(document, { childList: true, subtree: true });
    checkScriptExists();
    return () => {
      observer.disconnect();
    };
  }, [scriptId]);
  return scriptLoaded;
}
var Turnstile = (0, import_react.forwardRef)((props, ref) => {
  const {
    scriptOptions,
    options = {},
    siteKey,
    onWidgetLoad,
    onSuccess,
    onExpire,
    onError,
    onBeforeInteractive,
    onAfterInteractive,
    onUnsupported,
    onLoadScript,
    id: id3,
    style,
    as: as2 = "div",
    injectScript = true,
    ...divProps
  } = props;
  const widgetSize = options.size ?? "normal";
  const [containerStyle, setContainerStyle] = (0, import_react.useState)(
    options.execution === "execute" ? CONTAINER_STYLE_SET.invisible : options.appearance === "interaction-only" ? CONTAINER_STYLE_SET.interactionOnly : CONTAINER_STYLE_SET[widgetSize]
  );
  const containerRef = (0, import_react.useRef)(null);
  const firstRendered = (0, import_react.useRef)(false);
  const [widgetId, setWidgetId] = (0, import_react.useState)();
  const [turnstileLoaded, setTurnstileLoaded] = (0, import_react.useState)(false);
  const containerId = id3 ?? DEFAULT_CONTAINER_ID;
  const scriptId = injectScript ? scriptOptions?.id || `${DEFAULT_SCRIPT_ID}__${containerId}` : scriptOptions?.id || DEFAULT_SCRIPT_ID;
  const scriptLoaded = useObserveScript(scriptId);
  const onLoadCallbackName = scriptOptions?.onLoadCallbackName ? `${scriptOptions.onLoadCallbackName}__${containerId}` : `${DEFAULT_ONLOAD_NAME}__${containerId}`;
  const renderConfig = (0, import_react.useMemo)(
    () => ({
      sitekey: siteKey,
      action: options.action,
      cData: options.cData,
      callback: onSuccess,
      "error-callback": onError,
      "expired-callback": onExpire,
      "before-interactive-callback": onBeforeInteractive,
      "after-interactive-callback": onAfterInteractive,
      "unsupported-callback": onUnsupported,
      theme: options.theme ?? "auto",
      language: options.language ?? "auto",
      tabindex: options.tabIndex,
      "response-field": options.responseField,
      "response-field-name": options.responseFieldName,
      size: getTurnstileSizeOpts(widgetSize),
      retry: options.retry ?? "auto",
      "retry-interval": options.retryInterval ?? 8e3,
      "refresh-expired": options.refreshExpired ?? "auto",
      execution: options.execution ?? "render",
      appearance: options.appearance ?? "always"
    }),
    [
      siteKey,
      options,
      onSuccess,
      onError,
      onExpire,
      widgetSize,
      onBeforeInteractive,
      onAfterInteractive,
      onUnsupported
    ]
  );
  const renderConfigStringified = (0, import_react.useMemo)(() => JSON.stringify(renderConfig), [renderConfig]);
  (0, import_react.useImperativeHandle)(
    ref,
    () => {
      if (typeof window === "undefined" || !scriptLoaded) {
        return;
      }
      const { turnstile } = window;
      return {
        getResponse() {
          if (!turnstile?.getResponse || !widgetId) {
            console.warn("Turnstile has not been loaded");
            return;
          }
          return turnstile.getResponse(widgetId);
        },
        reset() {
          if (!turnstile?.reset || !widgetId) {
            console.warn("Turnstile has not been loaded");
            return;
          }
          if (options.execution === "execute") {
            setContainerStyle(CONTAINER_STYLE_SET.invisible);
          }
          try {
            turnstile.reset(widgetId);
          } catch (error) {
            console.warn(`Failed to reset Turnstile widget ${widgetId}`, error);
          }
        },
        remove() {
          if (!turnstile?.remove || !widgetId) {
            console.warn("Turnstile has not been loaded");
            return;
          }
          setWidgetId("");
          setContainerStyle(CONTAINER_STYLE_SET.invisible);
          turnstile.remove(widgetId);
        },
        render() {
          if (!turnstile?.render || !containerRef.current || widgetId) {
            console.warn("Turnstile has not been loaded or widget already rendered");
            return;
          }
          const id22 = turnstile.render(containerRef.current, renderConfig);
          setWidgetId(id22);
          if (options.execution !== "execute") {
            setContainerStyle(CONTAINER_STYLE_SET[widgetSize]);
          }
          return id22;
        },
        execute() {
          if (options.execution !== "execute") {
            return;
          }
          if (!turnstile?.execute || !containerRef.current || !widgetId) {
            console.warn("Turnstile has not been loaded or widget has not been rendered");
            return;
          }
          turnstile.execute(containerRef.current, renderConfig);
          setContainerStyle(CONTAINER_STYLE_SET[widgetSize]);
        },
        isExpired() {
          if (!turnstile?.isExpired || !widgetId) {
            console.warn("Turnstile has not been loaded");
            return;
          }
          return turnstile.isExpired(widgetId);
        }
      };
    },
    [scriptLoaded, widgetId, options.execution, widgetSize, renderConfig, containerRef]
  );
  (0, import_react.useEffect)(() => {
    window[onLoadCallbackName] = () => setTurnstileLoaded(true);
    return () => {
      delete window[onLoadCallbackName];
    };
  }, [onLoadCallbackName]);
  (0, import_react.useEffect)(() => {
    if (injectScript && !turnstileLoaded) {
      injectTurnstileScript({
        onLoadCallbackName,
        scriptOptions: {
          ...scriptOptions,
          id: scriptId
        }
      });
    }
  }, [injectScript, turnstileLoaded, onLoadCallbackName, scriptOptions, scriptId]);
  (0, import_react.useEffect)(() => {
    if (scriptLoaded && !turnstileLoaded && window.turnstile) {
      setTurnstileLoaded(true);
    }
  }, [turnstileLoaded, scriptLoaded]);
  (0, import_react.useEffect)(() => {
    if (!siteKey) {
      console.warn("sitekey was not provided");
      return;
    }
    if (!scriptLoaded || !containerRef.current || !turnstileLoaded || firstRendered.current) {
      return;
    }
    const id22 = window.turnstile.render(containerRef.current, renderConfig);
    setWidgetId(id22);
    firstRendered.current = true;
  }, [scriptLoaded, siteKey, renderConfig, firstRendered, turnstileLoaded]);
  (0, import_react.useEffect)(() => {
    if (!window.turnstile)
      return;
    if (containerRef.current && widgetId) {
      if (checkElementExistence(widgetId)) {
        window.turnstile.remove(widgetId);
      }
      const newWidgetId = window.turnstile.render(containerRef.current, renderConfig);
      setWidgetId(newWidgetId);
      firstRendered.current = true;
    }
  }, [renderConfigStringified, siteKey]);
  (0, import_react.useEffect)(() => {
    if (!window.turnstile)
      return;
    if (!widgetId)
      return;
    if (!checkElementExistence(widgetId))
      return;
    onWidgetLoad?.(widgetId);
    return () => {
      window.turnstile.remove(widgetId);
    };
  }, [widgetId, onWidgetLoad]);
  (0, import_react.useEffect)(() => {
    setContainerStyle(
      options.execution === "execute" ? CONTAINER_STYLE_SET.invisible : renderConfig.appearance === "interaction-only" ? CONTAINER_STYLE_SET.interactionOnly : CONTAINER_STYLE_SET[widgetSize]
    );
  }, [options.execution, widgetSize, renderConfig.appearance]);
  (0, import_react.useEffect)(() => {
    if (!scriptLoaded || typeof onLoadScript !== "function")
      return;
    onLoadScript();
  }, [scriptLoaded, onLoadScript]);
  return (0, import_jsx_runtime.jsx)(
    Container,
    {
      ref: containerRef,
      as: as2,
      id: containerId,
      style: { ...containerStyle, ...style },
      ...divProps
    }
  );
});
Turnstile.displayName = "Turnstile";

// node_modules/@privy-io/react-auth/dist/esm/useActiveWallet-58s-VNmj.mjs
init_shim();
var import_react2 = __toESM(require_react(), 1);
var v3 = (n6) => {
  let [r10, l5] = (0, import_react2.useState)("auto");
  return (0, import_react2.useEffect)((() => {
    let e7 = new ResizeObserver(((e8) => {
      l5(e8[0]?.contentRect.height ?? "auto");
    }));
    return n6.current && e7.observe(n6.current), () => {
      n6.current && e7.unobserve(n6.current);
    };
  }), [n6.current]), r10;
};
function y4(e7) {
  let { logout: t8 } = (0, import_react2.useContext)(k2);
  return qr("logout", e7), { logout: t8 };
}
var W2 = dt.div.withConfig({ displayName: "Column", componentId: "sc-cfc52180-0" })(["display:flex;flex-direction:column;"]);
function h5(e7) {
  let { login: t8 } = (0, import_react2.useContext)(k2);
  return qr("login", e7), { login: t8 };
}
function x3(e7) {
  let { connectWallet: t8 } = (0, import_react2.useContext)(k2);
  return qr("connectWallet", e7), { connectWallet: t8 };
}
var b3 = (e7) => {
  qr("fundWallet", e7);
  let { fundWallet: t8 } = s();
  return { fundWallet: ({ address: e8, options: n6 }) => t8(e8, n6) };
};
var C2 = () => {
  let e7 = Pr(), { wallets: n6 } = Nl(), { connectors: a3 } = s(), p5 = (0, import_react2.useMemo)((() => a3.filter(hr).flatMap(((e8) => e8.wallets))), [a3]), w4 = Od(((e8) => e8.wallet));
  (0, import_react2.useEffect)((() => {
    if (!e7.id) return;
    let t8 = ln.get(Gd(e7.id));
    Od.setState({ wallet: t8 });
  }), [e7.id]);
  let v5 = (0, import_react2.useMemo)((() => {
    if (!w4) return;
    let [, e8] = w4.split(":");
    return n6.find(((t8) => t8.address === e8)) || p5.find(((t8) => t8.address === e8));
  }), [w4, n6, p5]), y6 = (0, import_react2.useMemo)((() => v5 ? "ethereum" === v5.type ? v5.chainId : "solana" : void 0), [v5]);
  return { connect: async (t8) => {
    t8?.reset && (ln.del(Gd(e7.id)), Od.setState({ wallet: void 0 }));
    let { wallet: r10 } = await $d();
    if (!r10) return {};
    let [, l5] = r10.split(":"), a4 = n6.find(((e8) => e8.address === l5));
    if (a4) return { wallet: a4, network: a4.chainId };
    let s3 = p5.find(((e8) => e8.address === l5));
    return s3 ? { wallet: s3, network: "solana" } : {};
  }, setActiveWallet: (0, import_react2.useCallback)(((t8) => {
    jd({ address: t8.address, client: t8.walletClientType, appId: e7.id });
  }), [e7.id]), wallet: v5, network: y6 };
};

// node_modules/@heroicons/react/24/solid/esm/CheckBadgeIcon.js
init_shim();
var React = __toESM(require_react());
function CheckBadgeIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return React.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? React.createElement("title", {
    id: titleId
  }, title) : null, React.createElement("path", {
    fillRule: "evenodd",
    d: "M8.603 3.799A4.49 4.49 0 0 1 12 2.25c1.357 0 2.573.6 3.397 1.549a4.49 4.49 0 0 1 3.498 1.307 4.491 4.491 0 0 1 1.307 3.497A4.49 4.49 0 0 1 21.75 12a4.49 4.49 0 0 1-1.549 3.397 4.491 4.491 0 0 1-1.307 3.497 4.491 4.491 0 0 1-3.497 1.307A4.49 4.49 0 0 1 12 21.75a4.49 4.49 0 0 1-3.397-1.549 4.49 4.49 0 0 1-3.498-1.306 4.491 4.491 0 0 1-1.307-3.498A4.49 4.49 0 0 1 2.25 12c0-1.357.6-2.573 1.549-3.397a4.49 4.49 0 0 1 1.307-3.497 4.49 4.49 0 0 1 3.497-1.307Zm7.007 6.387a.75.75 0 1 0-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 0 0-1.06 1.06l2.25 2.25a.75.75 0 0 0 1.14-.094l3.75-5.25Z",
    clipRule: "evenodd"
  }));
}
var ForwardRef = React.forwardRef(CheckBadgeIcon);
var CheckBadgeIcon_default = ForwardRef;

// node_modules/@heroicons/react/24/solid/esm/IdentificationIcon.js
init_shim();
var React2 = __toESM(require_react());
function IdentificationIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return React2.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? React2.createElement("title", {
    id: titleId
  }, title) : null, React2.createElement("path", {
    fillRule: "evenodd",
    d: "M4.5 3.75a3 3 0 0 0-3 3v10.5a3 3 0 0 0 3 3h15a3 3 0 0 0 3-3V6.75a3 3 0 0 0-3-3h-15Zm4.125 3a2.25 2.25 0 1 0 0 4.5 2.25 2.25 0 0 0 0-4.5Zm-3.873 8.703a4.126 4.126 0 0 1 7.746 0 .75.75 0 0 1-.351.92 7.47 7.47 0 0 1-3.522.877 7.47 7.47 0 0 1-3.522-.877.75.75 0 0 1-.351-.92ZM15 8.25a.75.75 0 0 0 0 1.5h3.75a.75.75 0 0 0 0-1.5H15ZM14.25 12a.75.75 0 0 1 .75-.75h3.75a.75.75 0 0 1 0 1.5H15a.75.75 0 0 1-.75-.75Zm.75 2.25a.75.75 0 0 0 0 1.5h3.75a.75.75 0 0 0 0-1.5H15Z",
    clipRule: "evenodd"
  }));
}
var ForwardRef2 = React2.forwardRef(IdentificationIcon);
var IdentificationIcon_default = ForwardRef2;

// node_modules/@heroicons/react/24/solid/esm/ShieldCheckIcon.js
init_shim();
var React3 = __toESM(require_react());
function ShieldCheckIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return React3.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? React3.createElement("title", {
    id: titleId
  }, title) : null, React3.createElement("path", {
    fillRule: "evenodd",
    d: "M12.516 2.17a.75.75 0 0 0-1.032 0 11.209 11.209 0 0 1-7.877 3.08.75.75 0 0 0-.722.515A12.74 12.74 0 0 0 2.25 9.75c0 5.942 4.064 10.933 9.563 12.348a.749.749 0 0 0 .374 0c5.499-1.415 9.563-6.406 9.563-12.348 0-1.39-.223-2.73-.635-3.985a.75.75 0 0 0-.722-.516l-.143.001c-2.996 0-5.717-1.17-7.734-3.08Zm3.094 8.016a.75.75 0 1 0-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 0 0-1.06 1.06l2.25 2.25a.75.75 0 0 0 1.14-.094l3.75-5.25Z",
    clipRule: "evenodd"
  }));
}
var ForwardRef3 = React3.forwardRef(ShieldCheckIcon);
var ShieldCheckIcon_default2 = ForwardRef3;

// node_modules/@privy-io/react-auth/dist/esm/frame-Dh-xhHMG.mjs
init_shim();
var e5 = class {
  async init() {
    if (!this.api) throw new _("Auth flow has no API instance");
    let { nonce: i5, expires_at: a3 } = await this.api.post(g, {});
    return { nonce: i5, expiresAt: a3 };
  }
  async authenticate() {
    if (!this.message || !this.signature || !this.fid) throw new _("Auth flow has no message, signature, or fid");
    if (!this.api) throw new _("Auth flow has no API instance");
    try {
      let s3 = await this.api.post(P, { message: this.message, signature: this.signature, fid: this.fid });
      if (!s3) throw new _("No response from authentication");
      return s3;
    } catch (t8) {
      throw n(t8);
    }
  }
  async link() {
    throw Error("Not implemented");
  }
  setAuthData({ message: t8, signature: s3, fid: i5 }) {
    this.message = t8, this.signature = s3, this.fid = i5;
  }
  constructor() {
    this.meta = {};
  }
};

// node_modules/@privy-io/react-auth/dist/esm/getEmbeddedConnectedWallet-CSSBWE2p.mjs
init_shim();
function e6(e7) {
  return e7.find(((e8) => "privy" === e8.walletClientType && "embedded" === e8.connectorType && !e8.imported)) ?? null;
}

// node_modules/@privy-io/react-auth/dist/esm/index.mjs
var import_fast_password_entropy = __toESM(require_es5(), 1);
var import_qrcode = __toESM(require_browser(), 1);
function Ki(e7) {
  return e7 ? { "privy-ui": "t" } : void 0;
}
var Gi = class {
  async authenticate() {
    if (!this.api) throw new _("Auth flow has no API instance");
    if (!this.meta.email || !this.meta.emailCode) throw new _("Email and email code must be set prior to calling authenticate.");
    try {
      return await this.api.post(M, { email: this.meta.email, code: this.meta.emailCode, mode: this.meta.disableSignup ? "no-signup" : "login-or-sign-up" });
    } catch (e7) {
      throw n(e7);
    }
  }
  async link() {
    if (!this.api) throw new _("Auth flow has no API instance");
    if (!this.meta.email || !this.meta.emailCode) throw new _("Email and email code must be set prior to calling authenticate.");
    try {
      return await this.api.post(b, { email: this.meta.email, code: this.meta.emailCode });
    } catch (e7) {
      throw n(e7);
    }
  }
  async sendCodeEmail({ email: e7, captchaToken: t8, withPrivyUi: r10 }) {
    if (!this.api) throw new _("Auth flow has no API instance");
    if (e7 && (this.meta.email = e7), t8 && (this.meta.captchaToken = t8), !this.meta.email) throw new _("Email must be set when initialzing authentication.");
    let n6 = Ki(r10);
    try {
      return await this.api.post(W, { email: this.meta.email, token: this.meta.captchaToken }, { headers: { ...n6 } });
    } catch (e8) {
      throw n(e8);
    }
  }
  constructor({ email: e7, captchaToken: t8, disableSignup: r10 }) {
    this.meta = { email: e7, captchaToken: t8, disableSignup: r10 ?? false };
  }
};
var Yi = class extends Gi {
  async link() {
    if (!this.api) throw new _("Auth flow has no API instance");
    if (!this.meta.email || !this.meta.emailCode || !this.meta.oldAddress) throw new _("Email, email code, and an old email address must be set prior to calling update.");
    try {
      return await this.api.post(F, { oldAddress: this.meta.oldAddress, newAddress: this.meta.email, code: this.meta.emailCode });
    } catch (e7) {
      throw n(e7);
    }
  }
  constructor(e7, t8, r10) {
    super({ email: t8, captchaToken: r10 }), this.meta = { email: t8, captchaToken: r10, oldAddress: e7, disableSignup: false };
  }
};
var Zi = class {
  get meta() {
    return this._meta;
  }
  async authenticate() {
    if (!this.api) throw new _("Auth flow has no API instance");
    if (!this.meta.channelToken) throw new _("Auth flow must be initialized first");
    try {
      let e7 = await this.api.post(f, { channel_token: this.meta.channelToken, message: this.message, signature: this.signature, fid: this.fid, mode: this.meta.disableSignup ? "no-signup" : "login-or-sign-up" });
      if (!e7) throw new _("No response from authentication");
      return e7;
    } catch (e7) {
      throw n(e7);
    }
  }
  async link() {
    if (!this.api) throw new _("Auth flow has no API instance");
    try {
      return await this.api.post(U, { channel_token: this.meta.channelToken, message: this.message, signature: this.signature, fid: this.fid });
    } catch (e7) {
      throw n(e7);
    }
  }
  async _startChannelOnce() {
    if (!this.api) throw new _("Auth flow has no API instance");
    let e7 = await this.api.post(h, { token: this.captchaToken });
    import_react_device_detect.isMobile && !import_react_device_detect.isIOS && e7.connect_uri && gn(e7.connect_uri, "_blank"), this._meta = { ...this._meta, connectUri: e7.connect_uri, channelToken: e7.channel_token };
  }
  async initializeFarcasterConnect() {
    if (!this.api) throw new _("Auth flow has no API instance");
    await this.startChannelOnce.execute();
  }
  async _pollForReady() {
    if (!this.api) throw new _("Auth flow has no API instance");
    if (!this.meta.channelToken) throw new _("Auth flow must be initialized first");
    let e7 = await this.api.get(C, { headers: { "farcaster-channel-token": this.meta.channelToken } });
    return "completed" === e7.state && (this.message = e7.message, this.signature = e7.signature, this.fid = e7.fid, true);
  }
  constructor(e7, t8 = false) {
    this._meta = { disableSignup: false }, this.captchaToken = e7, this.startChannelOnce = new mn(this._startChannelOnce.bind(this)), this.pollForReady = new mn(this._pollForReady.bind(this)), this._meta.disableSignup = t8;
  }
};
function Ji() {
  return "undefined" != typeof window && "chrome-extension:" === window.location.protocol && "chrome" in window;
}
function Xi() {
  if (!Ji()) return;
  let e7 = window.chrome;
  return e7?.runtime?.id;
}
function Qi() {
  if (!Ji()) return false;
  let e7 = window.chrome;
  return "function" == typeof e7?.identity?.launchWebAuthFlow;
}
async function eo(e7) {
  return new Promise(((t8, r10) => {
    Qi() ? window.chrome.identity.launchWebAuthFlow({ url: e7, interactive: true }, (async (e8) => {
      try {
        let r11 = (function() {
          if (!Ji()) return;
          let e9 = window.chrome;
          return e9?.runtime?.lastError?.message;
        })();
        if (r11 || !e8) {
          let e9 = `WebAuthFlow failed: ${r11 || "Response URI missing"}`;
          throw Error(e9);
        }
        let n6 = new URL(e8), a3 = Xi();
        if (!a3) throw Error("Invalid extension context");
        if ("chrome-extension:" === n6.protocol) {
          if (n6.hostname !== a3) throw Error("Invalid responseUri origin");
        } else {
          if ("https:" !== n6.protocol) throw Error("Invalid responseUri protocol");
          {
            let e9 = n6.hostname.split(".");
            if (3 !== e9.length || "chromiumapp" !== e9[1] || "org" !== e9[2] || e9[0] !== a3) throw Error("Invalid responseUri origin");
          }
        }
        let i5 = n6.searchParams.get("privy_oauth_state"), o4 = n6.searchParams.get("privy_oauth_code");
        if (!i5 || !o4) throw Error("Invalid responseUri - missing required parameters");
        t8({ privyOAuthState: i5, privyOAuthCode: o4 });
      } catch (e9) {
        r10(e9);
      }
    })) : r10(Error("Chrome identity API not available"));
  }));
}
var to = class {
  addCaptchaToken(e7) {
    this.meta.captchaToken = e7;
  }
  isActive() {
    return !!(this.meta.authorizationCode && this.meta.stateCode && this.meta.provider);
  }
  async authenticate() {
    if (!this.api) throw new _("Auth flow has no API instance");
    if (!this.meta.authorizationCode || !this.meta.stateCode) throw new _("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling authenticate.");
    if ("undefined" === this.meta.authorizationCode) throw new _("User denied confirmation during OAuth flow");
    let e7 = qn();
    try {
      let t8 = await this.api.post(q, { authorization_code: this.meta.authorizationCode, state_code: this.meta.stateCode, code_verifier: e7, mode: this.meta.disableSignup ? "no-signup" : "login-or-sign-up" });
      return ln.del(Dn), ln.del(Pn), ln.del(Wn), t8;
    } catch (e8) {
      let t8 = n(e8);
      if (t8.privyErrorCode) throw new _(t8.message || "Invalid code during OAuth flow.", void 0, t8.privyErrorCode);
      if ("User denied confirmation during OAuth flow" === t8.message) throw new _("Invalid code during oauth flow.", void 0, p.OAUTH_USER_DENIED);
      throw new _("Invalid code during OAuth flow.", void 0, p.UNKNOWN_AUTH_ERROR);
    }
  }
  async link() {
    if (!this.api) throw new _("Auth flow has no API instance");
    if (!this.meta.authorizationCode || !this.meta.stateCode) throw new _("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling link.");
    if ("undefined" === this.meta.authorizationCode) throw new _("User denied confirmation during OAuth flow");
    let e7 = ln.get(Dn);
    if (!e7) throw new _("Authentication error.");
    try {
      let t8 = await this.api.post(j, { authorization_code: this.meta.authorizationCode, state_code: this.meta.stateCode, code_verifier: e7 });
      return ln.del(Dn), t8;
    } catch (e8) {
      throw n(e8);
    }
  }
  async getAuthorizationUrl() {
    if (!this.api) throw new _("Auth flow has no API instance");
    if (!this.meta.provider) throw new _("Provider must be set when initializing OAuth authentication.");
    let e7 = $n();
    ln.put(Dn, e7);
    let t8 = Vn();
    ln.put(Ln, t8);
    let r10 = await jn(e7);
    this.meta.withPrivyUi || ln.put(Pn, true), this.meta.disableSignup ? ln.put(Wn, true) : ln.del(Wn);
    let n6 = Ki(this.meta.withPrivyUi), a3 = window.location.href, i5 = (function() {
      let e8 = Xi();
      if (e8) return `https://${e8}.chromiumapp.org`;
    })();
    i5 && (a3 = i5);
    try {
      return await this.api.post($, { provider: this.meta.provider, redirect_to: this.meta.customOAuthRedirectUrl || a3, token: this.meta.captchaToken, code_challenge: r10, state_code: t8 }, { headers: { ...n6 } });
    } catch (e8) {
      throw n(e8);
    }
  }
  constructor(e7) {
    this.meta = e7;
  }
};
var ro = ({ style: e7 }) => (0, import_jsx_runtime2.jsx)(GlobeAltIcon_default, { style: { color: "var(--privy-color-error)", ...e7 } });
var no = { google: { name: "Google", component: Kn }, discord: { name: "Discord", component: Yn }, github: { name: "Github", component: Qn }, linkedin: { name: "LinkedIn", component: ea2 }, twitter: { name: "Twitter", component: aa }, spotify: { name: "Spotify", component: ta2 }, instagram: { name: "Instagram", component: Xn }, tiktok: { name: "Tiktok", component: na }, line: { name: "LINE", component: Jn }, apple: { name: "Apple", component: Zn } };
var ao = (e7) => e7 in no ? no[e7] : { name: "Unknown", component: ro };
function io() {
  let e7 = new URLSearchParams(window.location.search), t8 = e7.get("privy_oauth_code"), r10 = e7.get("privy_oauth_state"), n6 = e7.get("privy_oauth_provider");
  if (!t8 || !r10 || !n6) return { inProgress: false };
  let a3 = false;
  try {
    a3 = !!window.opener.location.origin;
  } catch {
  }
  return { inProgress: true, authorizationCode: t8, stateCode: r10, provider: n6, withPrivyUi: !ln.get(Pn), popupFlow: null !== window.opener && a3, disableSignup: !!ln.get(Wn) };
}
var oo = class {
  async initRegisterFlow(e7) {
    if (!this.api) throw new _("Auth flow has no API instance");
    this.authenticateForRegistration = true, this.meta.initRegisterResponse = await this.initRegisterOnce.execute(e7);
  }
  async initAuthenticationFlow(e7) {
    if (!this.api) throw new _("Auth flow has no API instance");
    this.authenticateForRegistration = false, this.meta.initAuthenticateResponse = await this.initAuthenticateOnce.execute(e7);
  }
  async initLinkFlow() {
    if (!this.api) throw new _("Auth flow has no API instance");
    this.meta.initLinkResponse = await this.initLinkOnce.execute();
  }
  async register() {
    let e7 = await import("./bundle-O6MOEAL6.js");
    if (!this.api) throw new _("Auth flow has no API instance");
    if (!e7.browserSupportsWebAuthn()) throw new _("WebAuthn is not supported in this browser");
    this.meta.initRegisterResponse || (this.meta.initRegisterResponse = await this.initRegisterOnce.execute());
    try {
      let t8 = this.meta.initRegisterResponse.options, r10 = await e7.startRegistration(this._transformInitLinkOptionsToCamelCase(t8));
      return this.meta.setPasskeyAuthState?.({ status: "submitting-response" }), await this.api.post(ra, { relying_party: this.meta.initRegisterResponse.relying_party, authenticator_response: this._transformRegistrationResponseToSnakeCase(r10) });
    } catch (e8) {
      if ("NotAllowedError" === e8.name) throw new _("Passkey request timed out or rejected by user.", void 0, p.PASSKEY_NOT_ALLOWED);
      throw n(e8);
    }
  }
  async authenticate() {
    if (this.authenticateForRegistration) return this.register();
    let e7 = await import("./bundle-O6MOEAL6.js");
    if (!this.api) throw new _("Auth flow has no API instance");
    if (!e7.browserSupportsWebAuthn()) throw new _("WebAuthn is not supported in this browser");
    this.meta.initAuthenticateResponse || (this.meta.initAuthenticateResponse = await this.initAuthenticateOnce.execute());
    let t8 = this.meta.allowedCredentialsIds?.map(((e8) => ({ type: "public-key", id: e8 }))) ?? this.meta.initAuthenticateResponse.options.allow_credentials;
    try {
      let r10 = await e7.startAuthentication(this._transformInitAuthenticateOptionsToCamelCase({ ...this.meta.initAuthenticateResponse.options, allow_credentials: t8 }));
      return this.meta.setPasskeyAuthState?.({ status: "submitting-response" }), await this.api.post(ia, { relying_party: this.meta.initAuthenticateResponse.relying_party, challenge: this.meta.initAuthenticateResponse.options.challenge, authenticator_response: this._transformAuthenticationResponseToSnakeCase(r10) });
    } catch (e8) {
      if ("NotAllowedError" === e8.name) throw new _("Passkey request timed out or rejected by user.", void 0, p.PASSKEY_NOT_ALLOWED);
      throw n(e8);
    }
  }
  async link() {
    let e7 = await import("./bundle-O6MOEAL6.js");
    if (!this.api) throw new _("Auth flow has no API instance");
    if (!e7.browserSupportsWebAuthn()) throw new _("WebAuthn is not supported in this browser");
    this.meta.initLinkResponse || (this.meta.initLinkResponse = await this.initLinkOnce.execute());
    try {
      let t8 = this.meta.initLinkResponse.options, r10 = await e7.startRegistration(this._transformInitLinkOptionsToCamelCase(t8));
      return this.meta.setPasskeyAuthState?.({ status: "submitting-response" }), await this.api.post(_a, { relying_party: this.meta.initLinkResponse.relying_party, authenticator_response: this._transformRegistrationResponseToSnakeCase(r10) });
    } catch (e8) {
      if ("NotAllowedError" === e8.name) throw new _("Passkey request timed out or rejected by user.", void 0, p.PASSKEY_NOT_ALLOWED);
      throw n(e8);
    }
  }
  async _initRegisterOnce(e7) {
    if (!this.api) throw new _("Auth flow has no API instance");
    let t8 = Ki(e7);
    return await this.api.post(ta, { token: this.meta.captchaToken }, { headers: { ...t8 } });
  }
  async _initAuthenticateOnce(e7) {
    if (!this.api) throw new _("Auth flow has no API instance");
    let t8 = Ki(e7);
    return await this.api.post(ea, { token: this.meta.captchaToken }, { headers: { ...t8 } });
  }
  async _initLinkOnce() {
    if (!this.api) throw new _("Auth flow has no API instance");
    return await this.api.post(sa, {});
  }
  _transformInitLinkOptionsToCamelCase(e7) {
    return { rp: e7.rp, user: { id: e7.user.id, name: e7.user.name, displayName: e7.user.display_name }, challenge: e7.challenge, pubKeyCredParams: e7.pub_key_cred_params.map(((e8) => ({ type: e8.type, alg: e8.alg }))), timeout: e7.timeout, excludeCredentials: e7.exclude_credentials?.map(((e8) => ({ id: e8.id, type: e8.type, transports: e8.transports }))), authenticatorSelection: { authenticatorAttachment: e7.authenticator_selection?.authenticator_attachment, requireResidentKey: e7.authenticator_selection?.require_resident_key, residentKey: e7.authenticator_selection?.resident_key, userVerification: e7.authenticator_selection?.user_verification }, attestation: e7.attestation, extensions: { appid: e7.extensions?.app_id, credProps: e7.extensions?.cred_props?.rk, hmacCreateSecret: e7.extensions?.hmac_create_secret } };
  }
  _transformRegistrationResponseToSnakeCase(e7) {
    return { id: e7.id, raw_id: e7.rawId, response: { client_data_json: e7.response.clientDataJSON, attestation_object: e7.response.attestationObject, authenticator_data: e7.response.authenticatorData }, authenticator_attachment: e7.authenticatorAttachment, client_extension_results: { app_id: e7.clientExtensionResults.appid, cred_props: e7.clientExtensionResults.credProps, hmac_create_secret: e7.clientExtensionResults.hmacCreateSecret }, type: e7.type };
  }
  _transformInitAuthenticateOptionsToCamelCase(e7) {
    return { rpId: e7.rp_id, challenge: e7.challenge, allowCredentials: e7.allow_credentials?.map(((e8) => ({ id: e8.id, type: e8.type, transports: e8.transports }))) || [], timeout: e7.timeout, extensions: { appid: e7.extensions?.app_id, credProps: e7.extensions?.cred_props, hmacCreateSecret: e7.extensions?.hmac_create_secret }, userVerification: e7.user_verification };
  }
  _transformAuthenticationResponseToSnakeCase(e7) {
    return { id: e7.id, raw_id: e7.rawId, response: { client_data_json: e7.response.clientDataJSON, authenticator_data: e7.response.authenticatorData, signature: e7.response.signature, user_handle: e7.response.userHandle }, authenticator_attachment: e7.authenticatorAttachment, client_extension_results: { app_id: e7.clientExtensionResults.appid, cred_props: e7.clientExtensionResults.credProps, hmac_create_secret: e7.clientExtensionResults.hmacCreateSecret }, type: e7.type };
  }
  constructor({ captchaToken: e7, setPasskeyAuthState: t8 }) {
    this.authenticateForRegistration = false, this.initRegisterOnce = new mn(this._initRegisterOnce.bind(this)), this.initAuthenticateOnce = new mn(this._initAuthenticateOnce.bind(this)), this.initLinkOnce = new mn(this._initLinkOnce.bind(this)), this.meta = { captchaToken: e7, setPasskeyAuthState: t8 };
  }
};
var so = class {
  async authenticate() {
    if (!this.api) throw new _("Auth flow has no API instance");
    if (!this.meta.phoneNumber || !this.meta.smsCode) throw new _("phone number and sms code must be set prior to calling authenticate.");
    try {
      return await this.api.post(Y, { phoneNumber: this.meta.phoneNumber, code: this.meta.smsCode, mode: this.meta.disableSignup ? "no-signup" : "login-or-sign-up" });
    } catch (e7) {
      throw n(e7);
    }
  }
  async link() {
    if (!this.api) throw new _("Auth flow has no API instance");
    if (!this.meta.phoneNumber || !this.meta.smsCode) throw new _("phone number and sms code must be set prior to calling authenticate.");
    try {
      return await this.api.post(V, { phoneNumber: this.meta.phoneNumber, code: this.meta.smsCode });
    } catch (e7) {
      throw n(e7);
    }
  }
  async sendSmsCode({ phoneNumber: e7, captchaToken: t8, withPrivyUi: r10 }) {
    if (!this.api) throw new _("Auth flow has no API instance");
    if (e7 && (this.meta.phoneNumber = e7), t8 && (this.meta.captchaToken = t8), !this.meta.phoneNumber) throw new _("phone nNumber must be set when initialzing authentication.");
    let n6 = Ki(r10);
    try {
      return await this.api.post(B, { phoneNumber: this.meta.phoneNumber, token: this.meta.captchaToken }, { headers: { ...n6 } });
    } catch (e8) {
      throw n(e8);
    }
  }
  constructor({ phoneNumber: e7, captchaToken: t8, disableSignup: r10 }) {
    this.meta = { phoneNumber: e7, captchaToken: t8, disableSignup: r10 ?? false };
  }
};
var lo = class extends so {
  async link() {
    if (!this.api) throw new _("Auth flow has no API instance");
    if (!this.meta.phoneNumber || !this.meta.smsCode || !this.meta.oldPhoneNumber) throw new _("Phone number, sms code, and an old phone number must be set prior to calling update.");
    try {
      return await this.api.post(G, { old_phone_number: this.meta.oldPhoneNumber, new_phone_number: this.meta.phoneNumber, code: this.meta.smsCode });
    } catch (e7) {
      throw n(e7);
    }
  }
  constructor(e7, t8, r10) {
    super({ phoneNumber: t8, captchaToken: r10 }), this.meta = { phoneNumber: t8, captchaToken: r10, oldPhoneNumber: e7, disableSignup: false };
  }
};
var co = class _co {
  static parse(e7) {
    try {
      return new _co(e7);
    } catch (e8) {
      return null;
    }
  }
  static throwIfNotWellFormedJwt(e7) {
    return decodeJwt(e7), e7;
  }
  get subject() {
    return this._decoded.sub;
  }
  get expiration() {
    return this._decoded.exp;
  }
  get issuer() {
    return this._decoded.iss;
  }
  get audience() {
    return this._decoded.aud;
  }
  isExpired(e7 = 0) {
    return Date.now() >= 1e3 * (this.expiration - e7);
  }
  constructor(e7) {
    this.value = e7, this._decoded = decodeJwt(e7);
  }
};
var uo = class _uo extends co {
  static parse(e7) {
    try {
      return new _uo(e7);
    } catch (e8) {
      return null;
    }
  }
  get appId() {
    return this._decoded.aid ? this._decoded.aid : this.audience;
  }
};
var ho2;
var po;
var mo = class extends Ka {
  async initialize() {
    await this.importPromise, await this.syncAccounts(), this.initialized = true, this.emit("initialized");
  }
  async connect(e7) {
    return e7.showPrompt && await this.promptConnection(), await this.isConnected() ? this.getConnectedWallet() : null;
  }
  disconnect() {
    this.proxyProvider.walletProvider.disconnect(), this.onDisconnect();
  }
  get walletBranding() {
    return { name: this.displayName, icon: Ua, id: "com.coinbase.wallet" };
  }
  async promptConnection() {
    try {
      await this.importPromise;
      let e7 = await this.proxyProvider.request({ method: "eth_requestAccounts" });
      if (!e7 || 0 === e7.length || !e7[0]) throw new r("Unable to retrieve accounts");
      this.connected = true, await this.syncAccounts([e7[0]]);
    } catch (e7) {
      throw Ha(e7);
    }
  }
  constructor(e7, t8, r10, n6, a3) {
    super("base_account", e7, t8, r10), this.connectorType = "base_account", this.walletClientType = "base_account", this.displayName = "Base", this.setBaseAccountSdk = a3, this.proxyProvider = new Xa(void 0, this.rpcTimeoutDuration), this.subscribeListeners(), this.baseAccountConfig = { ...n6, appChainIds: [t8.id].concat(e7.map(((e8) => e8.id))) }, ho2 ? (this.proxyProvider.setWalletProvider(ho2.getProvider()), this.setBaseAccountSdk(ho2), console.log("Base Account SDK Initialized")) : this.importPromise = import("./dist-OANOREQG.js").then((({ createBaseAccountSDK: e8 }) => {
      ho2 = e8(this.baseAccountConfig), this.proxyProvider.setWalletProvider(ho2.getProvider()), this.setBaseAccountSdk(ho2), console.log("Base Account SDK Initialized");
    })).catch(console.error);
  }
};
var wo = [1, 11155111, 137, 10, 8453, 84532, 42161, 7777777, 43114, 56];
var yo = class extends Ka {
  async initialize() {
    await this.syncAccounts(), this.initialized = true, this.emit("initialized");
  }
  async connect(e7) {
    return e7.showPrompt && await this.promptConnection(), await this.isConnected() ? this.getConnectedWallet() : null;
  }
  disconnect() {
    this.proxyProvider.walletProvider.disconnect(), this.onDisconnect();
  }
  get walletBranding() {
    return { name: this.displayName, icon: Oa2, id: "com.coinbase.wallet" };
  }
  async promptConnection() {
    try {
      let e7 = await this.proxyProvider.request({ method: "eth_requestAccounts" });
      if (!e7 || 0 === e7.length || !e7[0]) throw new r("Unable to retrieve accounts");
      this.connected = true, await this.syncAccounts([e7[0]]);
    } catch (e7) {
      throw Ha(e7);
    }
  }
  updateConnectionPreference(e7) {
    this.coinbaseWalletConfig = { ...this.coinbaseWalletConfig, preference: { ...this.coinbaseWalletConfig.preference, options: e7 } }, this.walletClientType = "smartWalletOnly" === e7 ? "coinbase_smart_wallet" : "coinbase_wallet", po = createCoinbaseWalletSDK({ ...this.coinbaseWalletConfig }), this.proxyProvider.setWalletProvider(po.getProvider());
  }
  constructor(e7, t8, r10, n6) {
    if (super("coinbase_wallet", e7, t8, r10), this.connectorType = "coinbase_wallet", this.displayName = "Coinbase Wallet", this.proxyProvider = new Xa(void 0, this.rpcTimeoutDuration), this.subscribeListeners(), this.coinbaseWalletConfig = { ...n6, appChainIds: [t8.id].concat(e7.map(((e8) => e8.id))) }, this.walletClientType = "smartWalletOnly" === this.coinbaseWalletConfig.preference?.options ? "coinbase_smart_wallet" : "coinbase_wallet", "coinbase_smart_wallet" === this.walletClientType && (this.displayName = "Coinbase Smart Wallet"), !po) {
      let e8 = "eoaOnly" !== this.coinbaseWalletConfig.preference?.options ? (this.coinbaseWalletConfig.appChainIds ?? []).filter(((e9) => !wo.includes(e9))) : [];
      e8.length > 0 && !e8.every(((e9) => x2.has(e9))) && console.info(`The configured chains are not supported by Coinbase Smart Wallet: ${e8.join(", ")}`), po = createCoinbaseWalletSDK(this.coinbaseWalletConfig);
    }
    this.proxyProvider.setWalletProvider(po.getProvider());
  }
};
var go = class extends Ka {
  async initialize() {
    await this.syncAccounts(), this.initialized = true, this.emit("initialized");
  }
  async connect(e7) {
    return await this.isConnected() ? (await this.proxyProvider.request({ method: "wallet_switchEthereumChain", params: [Ca(e7?.chainId || "0x1")] }), this.getConnectedWallet()) : null;
  }
  get walletBranding() {
    return { name: "Privy Wallet", icon: Ja, id: "io.privy.wallet" };
  }
  disconnect() {
    this.connected = false;
  }
  async promptConnection() {
  }
  constructor({ provider: e7, chains: t8, defaultChain: r10, rpcConfig: n6, imported: a3, walletIndex: i5 }) {
    super("privy", t8, r10, n6), this.connectorType = "embedded", this.proxyProvider = e7, this.walletIndex = i5, a3 && (this.connectorType = "embedded_imported"), this.subscribeListeners();
  }
};
var fo = ["eth_sign", "eth_populateTransactionRequest", "eth_signTransaction", "personal_sign", "eth_signTypedData_v4", "csw_signUserOperation", "secp256k1_sign"];
var vo = class extends Error {
  constructor(e7, t8, r10) {
    super(e7), this.code = t8, this.data = r10;
  }
};
var Co = class extends eventemitter3_default {
  async handleSendTransaction(e7) {
    if (!e7.params || !Array.isArray(e7.params)) throw new vo(`Invalid params for ${e7.method}`, 4200);
    let t8 = e7.params[0];
    if (!await zc2() || !this.address) throw new vo("Disconnected", 4900);
    let { hash: r10 } = await Vc(t8, { address: this.address });
    return r10;
  }
  async handleSignTransaction(e7) {
    if (!e7.params || !Array.isArray(e7.params)) throw new vo(`Invalid params for ${e7.method}`, 4200);
    let t8 = e7.params[0];
    if (!await zc2() || !this.address) throw new vo("Disconnected", 4900);
    let { signature: r10 } = await Hc(t8, { address: this.address });
    return r10;
  }
  handleSwitchEthereumChain(e7) {
    let t8;
    if (!e7.params || !Array.isArray(e7.params)) throw new vo(`Invalid params for ${e7.method}`, 4200);
    if ("string" == typeof e7.params[0]) t8 = e7.params[0];
    else {
      if (!("chainId" in e7.params[0]) || "string" != typeof e7.params[0].chainId) throw new vo(`Invalid params for ${e7.method}`, 4200);
      t8 = e7.params[0].chainId;
    }
    this.chainId = Number(t8), this.publicClient = ua2(this.chainId, this.chains, this.rpcConfig, { appId: this.appId }), this.emit("chainChanged", t8);
  }
  async handlePersonalSign(e7) {
    if (!e7.params || !Array.isArray(e7.params)) throw Error("Invalid params for personal_sign");
    let t8 = e7.params[0], r10 = e7.params[1], { signature: n6 } = await Bc({ message: t8 }, { address: r10 });
    return n6;
  }
  async handleSignedTypedData(e7) {
    if (!e7.params || !Array.isArray(e7.params)) throw Error("Invalid params for eth_signTypedData_v4");
    let t8 = e7.params[0], r10 = "string" == typeof e7.params[1] ? JSON.parse(e7.params[1]) : e7.params[1], { signature: n6 } = await jc(Aa2(r10), { address: t8 });
    return n6;
  }
  async handleEstimateGas(e7) {
    if (!e7.params || !Array.isArray(e7.params)) throw Error("Invalid params for eth_estimateGas");
    delete e7.params[0].gasPrice, delete e7.params[0].maxFeePerGas, delete e7.params[0].maxPriorityFeePerGas;
    let t8 = { ...e7.params[0], chainId: Ca(this.chainId) };
    return await this.publicClient.estimateGas({ account: t8.from ?? this.address, ...t5(t8) });
  }
  async request(e7) {
    switch (console.debug("Embedded1193Provider.request() called with args", e7), e7.method) {
      case "eth_accounts":
      case "eth_requestAccounts":
        return this.address ? [this.address] : [];
      case "eth_chainId":
        return Ca(this.chainId);
      case "eth_estimateGas":
        return this.handleEstimateGas(e7);
      case "eth_sendTransaction":
        return this.handleSendTransaction(e7);
      case "eth_signTransaction":
        return this.handleSignTransaction(e7);
      case "wallet_switchEthereumChain":
        return this.handleSwitchEthereumChain(e7);
      case "personal_sign":
        return this.handlePersonalSign(e7);
      case "eth_signTypedData_v4":
        return this.handleSignedTypedData(e7);
    }
    if (!((e8) => fo.includes(e8))(e7.method)) return this.publicClient.request({ method: e7.method, params: e7.params });
    {
      let t8 = await zc2();
      if (await $c({ address: this.address }), !t8 || !this.address) throw new vo("Disconnected", 4900);
      try {
        let r10 = { method: e7.method, params: e7.params }, n6 = this.walletAccount;
        return n6 && b2(n6) ? this.handleWalletApiRequest(r10, n6, t8) : (await this.walletProxy.rpc({ accessToken: t8, entropyId: this.entropyId, entropyIdVerifier: this.entropyIdVerifier, chainType: "ethereum", hdWalletIndex: this.walletIndex, request: r10 })).response.data;
      } catch (e8) {
        throw console.error(e8), new vo("Disconnected", 4900);
      }
    }
  }
  async handleWalletApiRequest(e7, t8, r10) {
    let n6 = this.privyClient;
    if (!n6) throw new vo("Disconnected", 4900);
    if ("secp256k1_sign" === e7.method) {
      let a3 = await r4(n6, (async ({ message: e8 }) => this.walletProxy.signWithUserSigner({ accessToken: r10, message: e8 })), { chain_type: "ethereum", method: "secp256k1_sign", wallet_id: t8.id, params: { hash: e7.params[0] } });
      if ("secp256k1_sign" !== a3.method) throw new vo(`Invalid params for ${e7.method}`, 4200);
      return a3.data.signature;
    }
    throw new vo(`Method not supported: ${e7.method}`, 4200);
  }
  constructor({ walletProxy: e7, address: t8, entropyId: r10, entropyIdVerifier: n6, rpcConfig: a3, chains: i5, appId: o4, chainId: s3 = 1, walletIndex: l5, privyClient: c2, walletAccount: d2 }) {
    super(), this.walletProxy = e7, this.address = t8, this.entropyId = r10, this.entropyIdVerifier = n6, this.chainId = s3, this.rpcConfig = a3, this.chains = i5, this.publicClient = ua2(s3, this.chains, a3, { appId: o4 }), this.rpcTimeoutDuration = Ya(a3, "privy"), this.appId = o4, this.walletIndex = l5, this.privyClient = c2, this.walletAccount = d2;
  }
};
function ko(e7, t8) {
  if (!Object.prototype.hasOwnProperty.call(e7, t8)) throw TypeError("attempted to use private field on non-instance");
  return e7;
}
var Ao = 0;
var bo = class extends Ka {
  async initialize() {
    await this.syncAccounts(), this.initialized = true, this.emit("initialized");
  }
  async connect(e7) {
    return e7.showPrompt && await this.promptConnection(), await this.isConnected() ? this.getConnectedWallet() : null;
  }
  get walletBranding() {
    return { name: this.providerDetail.info.name, icon: this.providerDetail.info.icon, id: this.providerDetail.info.rdns };
  }
  disconnect() {
    console.warn(`Programmatic disconnect with ${this.providerDetail.info.name} is not yet supported.`);
  }
  async promptConnection() {
    try {
      let e7 = await this.proxyProvider.request({ method: "eth_requestAccounts" });
      if (!e7 || 0 === e7.length || !e7[0]) throw new r("Unable to retrieve accounts");
      await this.syncAccounts([e7[0]]);
    } catch (e7) {
      throw Ha(e7);
    }
  }
  constructor(e7, t8, r10, n6, a3) {
    super(a3 || "unknown", e7, t8, r10), this.connectorType = "injected", this.proxyProvider = new Xa(void 0, this.rpcTimeoutDuration), this.subscribeListeners(), this.providerDetail = n6;
    let i5 = n6.provider;
    this.proxyProvider.setWalletProvider(i5);
  }
};
var To = "__private_" + Ao++ + "__walletBranding";
var _o = class extends Ka {
  async initialize() {
    await this.syncAccounts(), this.initialized = true, this.emit("initialized");
  }
  async connect(e7) {
    return e7.showPrompt && await this.promptConnection(), await this.isConnected() ? this.getConnectedWallet() : null;
  }
  get walletBranding() {
    return ko(this, To)[To] ?? { name: "Browser Extension", icon: tr, id: "extension" };
  }
  disconnect() {
    console.warn("Programmatic disconnect with browser wallets is not yet supported.");
  }
  async promptConnection() {
    try {
      let e7 = await this.proxyProvider.request({ method: "eth_requestAccounts" });
      if (!e7 || 0 === e7.length || !e7[0]) throw new r("Unable to retrieve accounts");
      await this.syncAccounts([e7[0]]);
    } catch (e7) {
      throw Ha(e7);
    }
  }
  constructor(e7, t8, r10, n6, a3) {
    super(a3 ?? "unknown", e7, t8, r10), Object.defineProperty(this, To, { writable: true, value: void 0 }), this.connectorType = "injected", this.proxyProvider = new Xa(void 0, this.rpcTimeoutDuration), this.subscribeListeners(), this.proxyProvider.setWalletProvider(n6), "metamask" === a3 ? ko(this, To)[To] = { name: "MetaMask", icon: nr, id: "io.metamask" } : "phantom" === a3 && (ko(this, To)[To] = { name: "Phantom", icon: ar, id: "phantom" });
  }
};
var Eo = class extends bo {
  disconnect() {
    console.warn("MetaMask does not support programmatic disconnect.");
  }
  async promptConnection() {
    try {
      import_react_device_detect.isMobile || await this.proxyProvider.request({ method: "wallet_requestPermissions", params: [{ eth_accounts: {} }] });
      let e7 = await this.proxyProvider.request({ method: "eth_requestAccounts" });
      if (!e7 || 0 === e7.length || !e7[0]) throw new r("Unable to retrieve accounts");
      await this.syncAccounts([e7[0]]);
    } catch (e7) {
      throw Ha(e7);
    }
  }
};
var Io = class extends eventemitter3_default {
  get wallets() {
    let e7 = /* @__PURE__ */ new Set();
    return this.walletConnectors.flatMap(((e8) => e8.wallets)).sort(((e8, t8) => e8.connectedAt && t8.connectedAt ? t8.connectedAt - e8.connectedAt : 0)).filter(((t8) => {
      let r10 = `${t8.address}${t8.walletClientType}${t8.connectorType}${t8.meta.id}`;
      return !e7.has(r10) && (e7.add(r10), true);
    }));
  }
  async initialize(e7) {
    if (this.initialized && !e7 || (e7 && this.removeAllConnectors(), this.externalWalletConfig.disableAllExternalWallets)) return;
    let t8 = xa({ store: this.store, walletList: this.walletList, externalWalletConfig: this.externalWalletConfig, walletChainType: this.walletChainType }).then(((e8) => {
      e8.forEach((({ type: e9, eip6963InjectedProvider: t9, legacyInjectedProvider: r10 }) => {
        this.createEthereumWalletConnector({ connectorType: "injected", walletClientType: e9, providers: { eip6963InjectedProvider: t9, legacyInjectedProvider: r10 } });
      }));
    }));
    for (let e8 of (this.walletList.includes("coinbase_wallet") && this.createEthereumWalletConnector({ connectorType: "coinbase_wallet", walletClientType: "coinbase_wallet" }), this.walletList.includes("base_account") && this.createEthereumWalletConnector({ connectorType: "base_account", walletClientType: "base_account" }), Object.values(ir))) !e8.isInstalled && this.walletList.includes(e8.client) && (["ethereum-only", "ethereum-and-solana"].includes(this.walletChainType) && e8.chainTypes.includes("ethereum") && this.createEthereumWalletConnector({ connectorType: "null", walletClientType: e8.client, walletConfig: e8 }), ["ethereum-and-solana", "solana-only"].includes(this.walletChainType) && e8.chainTypes.includes("solana") && this.addSolanaWalletConnector(new ur({ id: e8.client, name: e8.name })));
    this.externalWalletConfig.walletConnect.enabled && this.createEthereumWalletConnector({ connectorType: "wallet_connect_v2", walletClientType: "unknown" }), this.externalWalletConfig.solana.connectors?.get().forEach(this.addSolanaWalletConnector), this.externalWalletConfig.solana.connectors?._setOnConnectorsUpdated?.(((e8) => {
      e8?.forEach(this.addSolanaWalletConnector);
    })), await t8, this.initialized = true;
  }
  findWalletConnector(e7, t8) {
    return "wallet_connect_v2" === e7 ? this.walletConnectors.filter(Qa).find(((t9) => t9.connectorType === e7)) ?? null : this.walletConnectors.filter(Qa).find(((r10) => r10.connectorType === e7 && r10.walletClientType === t8)) ?? null;
  }
  findSolanaWalletConnector(e7) {
    return this.walletConnectors.filter(hr).find(((t8) => "unknown" === t8.walletClientType ? t8.walletBranding.id === e7 : t8.walletClientType === e7)) ?? null;
  }
  findEmbeddedWalletConnectors() {
    return this.walletConnectors.filter(((e7) => "embedded" === e7.connectorType));
  }
  onInitialized(e7) {
    e7.wallets.forEach(((e8) => {
      let t8 = this.storedConnections.find(((t9) => t9.address === e8.address && t9.connectorType === e8.connectorType && ("solana" === e8.type && "unknown" === t9.walletClientType && "unknown" === e8.walletClientType ? e8.meta.id === t9.id : t9.walletClientType === e8.walletClientType)));
      t8 && (e8.connectedAt = t8.connectedAt);
    })), this.emit("walletsUpdated"), this.emit("connectorInitialized");
  }
  onWalletsUpdated(e7) {
    e7.initialized && this.emit("walletsUpdated");
  }
  addEmbeddedWalletConnectors({ walletProxy: e7, user: t8, embeddedWallets: r10, defaultChain: n6, appId: a3, privyClient: i5 }) {
    let { entropyId: o4, entropyIdVerifier: s3 } = Ra2(t8);
    for (let t9 of r10) {
      let r11 = this.findEmbeddedWalletConnectors().find(((e8) => e8.walletIndex === t9.walletIndex));
      if (r11 && Qa(r11)) r11.proxyProvider.walletProxy = e7;
      else {
        let r12 = new go({ provider: new Co({ walletProxy: e7, address: t9.address, entropyId: o4, entropyIdVerifier: s3, rpcConfig: this.rpcConfig, chains: this.chains, appId: a3, chainId: n6.id, walletIndex: t9.walletIndex, privyClient: i5, walletAccount: t9 }), chains: this.chains, defaultChain: n6, rpcConfig: this.rpcConfig, imported: false, walletIndex: t9.walletIndex });
        this.addWalletConnector(r12);
      }
    }
  }
  addImportedWalletConnector(e7, t8, r10, n6) {
    let a3 = this.findWalletConnector("embedded_imported", "privy");
    if (a3 && Qa(a3)) a3.proxyProvider.walletProxy = e7;
    else {
      let a4 = new go({ provider: new Co({ walletProxy: e7, address: t8, entropyId: t8, entropyIdVerifier: "ethereum-address-verifier", walletIndex: 0, rpcConfig: this.rpcConfig, chains: this.chains, appId: n6, chainId: r10.id }), chains: this.chains, walletIndex: 0, defaultChain: r10, rpcConfig: this.rpcConfig, imported: true });
      this.addWalletConnector(a4);
    }
  }
  removeEmbeddedWalletConnectors() {
    this.walletConnectors = this.walletConnectors.filter(((e7) => "embedded" !== e7.connectorType)), this.storedConnections = sr(), this.emit("walletsUpdated");
  }
  removeImportedWalletConnector() {
    let e7 = this.findWalletConnector("embedded_imported", "privy");
    if (e7) {
      let t8 = this.walletConnectors.indexOf(e7);
      this.walletConnectors.splice(t8, 1), this.storedConnections = sr(), this.emit("walletsUpdated");
    }
  }
  async createEthereumWalletConnector({ connectorType: e7, walletClientType: t8, providers: r10, walletConfig: n6 }) {
    let a3 = this.findWalletConnector(e7, t8);
    if (a3 && Qa(a3)) return a3 instanceof Hr && a3.resetConnection(t8), a3;
    let i5 = (() => "injected" !== e7 ? "coinbase_wallet" === e7 ? new yo(this.chains, this.defaultChain, this.rpcConfig, this.externalWalletConfig.coinbaseWallet.config) : "base_account" === e7 ? new mo(this.chains, this.defaultChain, this.rpcConfig, this.externalWalletConfig.baseAccount.config, this.setBaseAccountSdk) : "null" !== e7 ? new Hr({ walletConnectCloudProjectId: this.walletConnectCloudProjectId, rpcConfig: this.rpcConfig, chains: this.chains, defaultChain: this.defaultChain, shouldEnforceDefaultChainOnConnect: this.shouldEnforceDefaultChainOnConnect, privyAppId: this.privyAppId, privyAppName: this.privyAppName, walletClientType: t8 }) : n6 ? new er({ id: n6.client, name: n6.name, defaultChain: this.defaultChain, walletClientType: n6.client }) : null : "metamask" === t8 && r10?.eip6963InjectedProvider ? new Eo(this.chains, this.defaultChain, this.rpcConfig, r10?.eip6963InjectedProvider, "metamask") : "metamask" === t8 && r10?.legacyInjectedProvider ? new _o(this.chains, this.defaultChain, this.rpcConfig, r10?.legacyInjectedProvider, "metamask") : "phantom" === t8 && r10?.legacyInjectedProvider ? new _o(this.chains, this.defaultChain, this.rpcConfig, r10?.legacyInjectedProvider, "phantom") : r10?.legacyInjectedProvider && "unknown_browser_extension" === t8 ? new _o(this.chains, this.defaultChain, this.rpcConfig, r10?.legacyInjectedProvider) : r10?.eip6963InjectedProvider ? new bo(this.chains, this.defaultChain, this.rpcConfig, r10?.eip6963InjectedProvider, t8) : void 0)();
    return i5 && this.addWalletConnector(i5), i5 || null;
  }
  addWalletConnector(e7) {
    this.walletConnectors.push(e7), e7.on("initialized", (() => this.onInitialized(e7))), e7.on("walletsUpdated", (() => this.onWalletsUpdated(e7))), e7.initialize().catch(((e8) => {
      console.debug("Failed to initialize connector", e8);
    }));
  }
  setWalletList(e7) {
    this.walletList = e7, this.initialized && this.initialize(true).catch(console.error);
  }
  removeAllConnectors() {
    for (let e7 of this.walletConnectors) e7.removeAllListeners();
    this.walletConnectors = [];
  }
  constructor(e7, t8, r10, n6, a3, i5, o4, s3, l5, c2, d2, u2) {
    super(), this.addSolanaWalletConnector = async (e8) => {
      let t9 = this.findSolanaWalletConnector(e8.walletClientType);
      if (!t9 || "null" === t9.connectorType) {
        if ("null" === t9?.connectorType) {
          let e9 = this.walletConnectors.indexOf(t9);
          this.walletConnectors.splice(e9, 1);
        }
        this.addWalletConnector(e8);
      }
    }, this.privyAppId = e7, this.walletConnectCloudProjectId = t8, this.rpcConfig = r10, this.chains = n6, this.defaultChain = a3, this.walletConnectors = [], this.initialized = false, this.store = i5, this.walletList = o4, this.shouldEnforceDefaultChainOnConnect = s3, this.externalWalletConfig = l5, this.privyAppName = c2, this.walletChainType = u2 || "ethereum-only", this.setBaseAccountSdk = d2, this.storedConnections = sr();
  }
};
var So = [d, v, da];
var Uo = class {
  async get(e7, t8) {
    try {
      return await this.baseFetch(e7, t8);
    } catch (e8) {
      throw n(e8);
    }
  }
  async post(e7, t8, r10) {
    try {
      return await this.baseFetch(e7, { method: "POST", ...t8 ? { body: t8 } : {}, ...r10 });
    } catch (e8) {
      throw n(e8);
    }
  }
  async delete(e7, t8) {
    try {
      return await this.baseFetch(e7, { method: "DELETE", ...t8 });
    } catch (e8) {
      throw n(e8);
    }
  }
  constructor({ appId: e7, appClientId: t8, client: r10, defaults: n6 }) {
    this.appId = e7, this.appClientId = t8, this.clientAnalyticsId = r10.clientAnalyticsId, this.sdkVersion = Cn, this.client = r10, this.defaults = n6, this.fallbackApiUrl = r10.fallbackApiUrl, this.baseFetch = ofetch.create({ baseURL: this.defaults.baseURL, timeout: this.defaults.timeout, retry: 3, retryDelay: 500, retryStatusCodes: [408, 409, 425, 500, 502, 503, 504], credentials: "include", onRequest: async ({ request: e8, options: t9 }) => {
      let r11 = new Headers(t9.headers);
      r11.set("privy-app-id", this.appId), this.appClientId && r11.set("privy-client-id", this.appClientId), r11.set("privy-ca-id", this.clientAnalyticsId || ""), r11.set("privy-client", `react-auth:${this.sdkVersion}`);
      let n7 = So.includes(e8.toString());
      if (!r11.has("authorization")) {
        let e9 = await this.client.getAccessToken({ disableAutoRefresh: n7 });
        null !== e9 && r11.set("authorization", `Bearer ${e9}`);
      }
      t9.headers = r11, t9.retryDelay && "number" == typeof t9.retryDelay && (t9.retryDelay = 3 * t9.retryDelay);
    }, onRequestError: ({ error: e8 }) => {
      if (e8 instanceof DOMException && "AbortError" === e8.name) throw new i();
    } });
  }
};
var Po = /paymaster\.biconomy\.io\/api/i;
var Wo = { mode: "SPONSORED", calculateGasLimits: true, expiryDuration: 300, sponsorshipInfo: { webhookData: {}, smartAccountInfo: { name: "BICONOMY", version: "2.0.0" } } };
var xo = (e7, t8) => e7 && Po.test(e7) ? Wo : t8 && t8.policy_id ? { policyId: t8.policy_id } : void 0;
var No = (e7) => ({ rpId: e7.rp_id, challenge: e7.challenge, allowCredentials: e7.allow_credentials?.map(((e8) => ({ id: e8.id, type: e8.type, transports: e8.transports }))) || [], timeout: e7.timeout, extensions: { appid: e7.extensions?.app_id, credProps: e7.extensions?.cred_props, hmacCreateSecret: e7.extensions?.hmac_create_secret }, userVerification: e7.user_verification });
var Ro = class {
  async authenticate() {
    if (!this.api) throw new _("Auth flow has no API instance");
    try {
      return await this.api.post(va, { token: this.meta.token });
    } catch (e7) {
      throw n(e7);
    }
  }
  async link() {
    if (!this.api) throw new _("Auth flow has no API instance");
    try {
      return await this.api.post(Aa, { token: this.meta.token });
    } catch (e7) {
      throw n(e7);
    }
  }
  constructor(e7) {
    this.meta = { token: e7 };
  }
};
var Oo = class {
  getOrCreateGuestCredential(e7) {
    let t8 = Mn(e7);
    if (on()) {
      if (ln.get(t8)) return ln.get(t8);
      {
        let e8 = base64url_exports.encode(Hn(32));
        return ln.put(t8, e8), e8;
      }
    }
    return base64url_exports.encode(Hn(32));
  }
  async authenticate() {
    if (!this.api) throw new _("Auth flow has no API instance");
    try {
      return await this.api.post(Ta, { guest_credential: this.meta.guestCredential });
    } catch (e7) {
      throw n(e7);
    }
  }
  async link() {
    throw Error("Linking is not supported for the guest flow");
  }
  constructor(e7) {
    this.meta = { guestCredential: this.getOrCreateGuestCredential(e7) };
  }
};
function Mo() {
  return !(import_react_device_detect.isSafari && window.location.origin.startsWith("http://localhost"));
}
var Fo = create((() => ({ identityToken: null })));
function Lo() {
  let { identityToken: e7 } = Fo();
  return { identityToken: e7 };
}
var Do;
var qo2 = ((Do = {}).PRIVY = "privy_access_token", Do.CUSTOMER = "customer_access_token", Do);
var zo = class {
  get token() {
    return this.privyAccessToken || this.customerAccessToken;
  }
  getToken(e7) {
    return "privy_access_token" === e7 ? this.privyAccessToken : this.customerAccessToken;
  }
  get customerAccessToken() {
    return this._getToken(xn);
  }
  get privyAccessToken() {
    return this._getToken(In);
  }
  _getToken(e7) {
    try {
      let t8 = ln.get(e7);
      return "string" == typeof t8 ? co.throwIfNotWellFormedJwt(t8) : null;
    } catch (e8) {
      return console.error(e8), this.destroyLocalState(), null;
    }
  }
  get refreshToken() {
    try {
      let e7 = ln.get(Tn);
      return "string" == typeof e7 ? e7 : null;
    } catch (e7) {
      return console.error(e7), this.destroyLocalState(), null;
    }
  }
  getProviderAccessToken(e7) {
    try {
      let t8 = ln.get(Fn(e7));
      if ("string" != typeof t8) return null;
      {
        let r10 = new co(t8);
        return r10.isExpired() ? (ln.del(Fn(e7)), null) : r10.value;
      }
    } catch (e8) {
      return console.error(e8), null;
    }
  }
  get mightHaveServerCookies() {
    try {
      let e7 = api.get(Nn);
      return void 0 !== e7 && e7.length > 0;
    } catch (e7) {
      console.error(e7);
    }
    return false;
  }
  hasRefreshCredentials(e7 = "privy_access_token") {
    let t8 = "string" == typeof this.getToken(e7), r10 = "string" == typeof this.refreshToken && this.refreshToken !== zn;
    return this.mightHaveServerCookies || t8 && r10;
  }
  hasActiveAccessToken(e7) {
    let t8 = co.parse(this.getToken(e7));
    return null !== t8 && !t8.isExpired(30);
  }
  authenticate(e7) {
    return this.authenticateOnce.execute(e7);
  }
  link(e7) {
    return this.linkOnce.execute(e7);
  }
  refresh() {
    return this.refreshOnce.execute();
  }
  destroy() {
    return this.destroyOnce.execute();
  }
  storeProviderAccessToken(e7, t8) {
    "string" == typeof t8 ? ln.put(Fn(e7), t8) : ln.del(Fn(e7));
  }
  updateIdentityToken(e7) {
    "string" == typeof e7 ? this.storeIdentityToken(e7) : this.clearIdentityToken();
  }
  async _authenticate(e7) {
    try {
      let t8 = await e7.authenticate(), { user: r10, is_new_user: n6, oauth_tokens: a3 } = t8;
      this.handleTokenResponse(t8);
      let i5 = a3 ? { provider: a3.provider, accessToken: a3.access_token, accessTokenExpiresInSeconds: a3.access_token_expires_in_seconds, refreshToken: a3.refresh_token, refreshTokenExpiresInSeconds: a3.refresh_token_expires_in_seconds, scopes: a3.scopes } : void 0;
      return this._trackAuthenticateEvents(e7, n6), { user: h3(r10), isNewUser: n6, oAuthTokens: i5 };
    } catch (e8) {
      throw console.warn("Error authenticating session"), o(e8);
    }
  }
  _trackAuthenticateEvents(e7, t8) {
    let r10 = (function(e8) {
      return e8 instanceof Gi ? "email" : e8 instanceof so ? "sms" : e8 instanceof oa ? "siwe" : e8 instanceof Oo ? "guest" : e8 instanceof Ro ? "custom_auth" : e8 instanceof to ? e8.meta.provider : null;
    })(e7);
    r10 && this.client && this.client.createAnalyticsEvent({ eventName: "sdk_authenticate", payload: { method: r10, isNewUser: t8 } }), "siwe" === r10 && this.client && this.client.createAnalyticsEvent({ eventName: "sdk_authenticate_siwe", payload: { connectorType: e7.meta.connectorType, walletClientType: e7.meta.walletClientType } });
  }
  async _link(e7) {
    try {
      let t8 = await e7.link(), r10 = t8.oauth_tokens, n6 = r10 ? { provider: r10.provider, accessToken: r10.access_token, accessTokenExpiresInSeconds: r10.access_token_expires_in_seconds, refreshToken: r10.refresh_token, refreshTokenExpiresInSeconds: r10.refresh_token_expires_in_seconds, scopes: r10.scopes } : void 0;
      return { user: h3(t8), oAuthTokens: n6 };
    } catch (e8) {
      throw console.warn("Error linking account"), o(e8);
    }
  }
  async _refresh() {
    if (!this.api) throw new _("Session has no API instance");
    if (!this.client) throw new _("Session has no PrivyClient instance");
    await this.client.getAccessToken({ disableAutoRefresh: true });
    let e7 = this.token, t8 = this.refreshToken;
    if (this.client.useServerCookies && !this.mightHaveServerCookies && this.token && window.location.origin === this.client.apiUrl) return this.destroyLocalState(), null;
    try {
      let r10;
      if (!(e7 && t8 || this.mightHaveServerCookies)) return null;
      {
        let n6 = {};
        e7 && (n6.authorization = `Bearer ${e7}`), r10 = await this.api.post(d, t8 ? { refresh_token: t8 } : {}, { headers: n6 });
      }
      return this.handleTokenResponse(r10), h3(r10.user);
    } catch (e8) {
      if (e8 instanceof t && e8.privyErrorCode === p.MISSING_OR_INVALID_TOKEN) return console.warn("Unable to refresh tokens - token is missing or no longer valid"), this.destroyLocalState(), null;
      throw o(e8);
    }
  }
  handleTokenResponse(e7) {
    e7.session_update_action && "set" !== e7.session_update_action ? "clear" === e7.session_update_action ? this.destroyLocalState() : "ignore" === e7.session_update_action && (e7.token && (this.storeCustomerAccessToken(e7.token), this.storePrivyAccessToken(e7.privy_access_token)), e7.identity_token && this.storeIdentityToken(e7.identity_token)) : this._storeAllTokens(e7);
  }
  _storeAllTokens(e7) {
    this.storeRefreshToken(e7.refresh_token), this.storeCustomerAccessToken(e7.token), this.storePrivyAccessToken(e7.privy_access_token), e7.identity_token && this.storeIdentityToken(e7.identity_token);
  }
  async _destroy() {
    try {
      await this.api?.post(v, { refresh_token: this.refreshToken });
    } catch (e7) {
      console.warn("Error destroying session");
    }
    this.destroyLocalState();
  }
  destroyLocalState() {
    this.storeRefreshToken(null), this.storeCustomerAccessToken(null), this.storePrivyAccessToken(null), this.clearIdentityToken();
  }
  storeCustomerAccessToken(e7) {
    if ("string" == typeof e7) {
      let t8 = ln.get(xn);
      if (ln.put(xn, e7), !this.client?.useServerCookies) {
        let t9 = co.parse(e7)?.expiration;
        api.set(kn, e7, { sameSite: "Strict", secure: Mo(), expires: t9 ? new Date(1e3 * t9) : void 0 });
      }
      t8 !== e7 && this.client?.onStoreCustomerAccessToken?.(e7);
    } else ln.del(xn), api.remove(kn), this.client?.onDeleteCustomerAccessToken?.();
  }
  storeRefreshToken(e7) {
    "string" == typeof e7 ? (ln.put(Tn, e7), this.client?.useServerCookies || api.set(Nn, "t", { sameSite: "Strict", secure: Mo(), expires: 30 })) : (ln.del(Tn), api.remove(An), api.remove(Nn));
  }
  storePrivyAccessToken(e7) {
    "string" == typeof e7 ? ln.put(In, e7) : ln.del(In);
  }
  storeIdentityToken(e7) {
    if (Fo.setState({ identityToken: e7 }), this.client?.useServerCookies) return;
    ln.put(Sn, e7);
    let t8 = co.parse(e7)?.expiration;
    api.set(En, e7, { sameSite: "Strict", secure: Mo(), expires: t8 ? new Date(1e3 * t8) : void 0 });
  }
  clearIdentityToken() {
    ln.del(Sn), Fo.setState({ identityToken: null }), api.remove(En);
  }
  constructor() {
    this.authenticateOnce = new mn((async (e7) => this._authenticate(e7))), this.linkOnce = new mn((async (e7) => this._link(e7))), this.refreshOnce = new mn(this._refresh.bind(this)), this.destroyOnce = new mn(this._destroy.bind(this));
  }
};
var Bo;
var jo = 0;
var Ho = "__private_" + jo++ + "__getOrGenerateClientAnalyticsId";
var Vo = class {
  getAppId() {
    return this.appId;
  }
  initializeConnectorManager({ walletConnectCloudProjectId: e7, rpcConfig: t8, chains: r10, defaultChain: n6, store: a3, walletList: i5, shouldEnforceDefaultChainOnConnect: o4, externalWalletConfig: s3, appName: l5, walletChainType: c2, setBaseAccountSdk: d2 }) {
    this.connectors || (this.connectors = new Io(this.appId, e7, t8, r10, n6, a3, i5, o4, s3, l5, d2, c2));
  }
  generateApi() {
    let e7 = new Uo({ appId: this.appId, appClientId: this.appClientId, client: this, defaults: { baseURL: this.apiUrl, timeout: this.timeout } });
    return this.session.api = e7, e7;
  }
  updateApiUrl(e7) {
    this.apiUrl = e7 || this.fallbackApiUrl, this.api = this.generateApi(), e7 && (this.useServerCookies = true);
  }
  authenticate() {
    if (!this.authFlow) throw new _("No auth flow in progress.");
    return this.session.authenticate(this.authFlow);
  }
  async link() {
    if (!this.authFlow) throw new _("No auth flow in progress.");
    let { oAuthTokens: e7 } = await this.session.link(this.authFlow);
    return { user: await this.getAuthenticatedUser(), oAuthTokens: e7 };
  }
  storeProviderAccessToken(e7, t8) {
    this.session.storeProviderAccessToken(e7, t8);
  }
  getProviderAccessToken(e7) {
    return this.session.getProviderAccessToken(e7);
  }
  async logout() {
    await this.session.destroy(), this.authFlow = void 0;
  }
  clearProviderAcccessTokens(e7) {
    e7.linkedAccounts.filter(((e8) => "cross_app" === e8.type)).forEach(((e8) => {
      this.storeProviderAccessToken(e8.providerApp.id, null);
    }));
  }
  startAuthFlow(e7) {
    return e7.api = this.api, this.authFlow = e7, this.authFlow;
  }
  async initMfaSmsVerification() {
    try {
      await this.api.post(ua, { action: "verify" });
    } catch (e7) {
      throw n(e7);
    }
  }
  async initMfaPasskeyVerification() {
    try {
      let e7 = await this.api.post(la, {});
      return No(e7.options);
    } catch (e7) {
      throw n(e7);
    }
  }
  async getCrossAppProviderDetails(e7) {
    try {
      return this._cachedProviderAppDetails[e7] || (this._cachedProviderAppDetails[e7] = await this.api.get(`/api/v1/apps/${e7}/cross-app/details`)), this._cachedProviderAppDetails[e7];
    } catch (e8) {
      console.error("Error fetching cross app provider details", e8);
    }
  }
  async acceptTerms() {
    try {
      let e7 = await this.api.post(ca, {});
      return h3(e7);
    } catch (e7) {
      throw o(e7);
    }
  }
  async unlinkEmail(e7) {
    try {
      let t8 = await this.api.post(x, { address: e7 });
      return await this.getAuthenticatedUser() ?? h3(t8);
    } catch (e8) {
      throw o(e8);
    }
  }
  async unlinkPhone(e7) {
    try {
      let t8 = await this.api.post(K, { phoneNumber: e7 });
      return await this.getAuthenticatedUser() ?? h3(t8);
    } catch (e8) {
      throw o(e8);
    }
  }
  async unlinkEthereumWallet(e7) {
    try {
      let t8 = await this.api.post(I, { address: e7 });
      return await this.getAuthenticatedUser() ?? h3(t8);
    } catch (e8) {
      throw o(e8);
    }
  }
  async unlinkSolanaWallet(e7) {
    try {
      let t8 = await this.api.post(w, { address: e7 });
      return await this.getAuthenticatedUser() ?? h3(t8);
    } catch (e8) {
      throw o(e8);
    }
  }
  async unlinkOAuth(e7, t8) {
    try {
      let r10 = await this.api.post(Q, { provider: e7, subject: t8 });
      return await this.getAuthenticatedUser() ?? h3(r10);
    } catch (e8) {
      throw o(e8);
    }
  }
  async unlinkFarcaster(e7) {
    try {
      let t8 = await this.api.post(k, { fid: e7 });
      return await this.getAuthenticatedUser() ?? h3(t8);
    } catch (e8) {
      throw o(e8);
    }
  }
  async unlinkTelegram(e7) {
    try {
      let t8 = await this.api.post(pa, { telegram_user_id: e7 });
      return await this.getAuthenticatedUser() ?? h3(t8);
    } catch (e8) {
      throw o(e8);
    }
  }
  async revokeDelegatedWallet() {
    try {
      await this.api.post(Oa, {});
    } catch (e7) {
      throw o(e7);
    }
  }
  async createAnalyticsEvent({ eventName: e7, payload: t8, timestamp: r10, options: n6 }) {
    if ("undefined" != typeof window) try {
      this.clientAnalyticsId || console.warn("No client analytics id set, refusing to send analytics event"), await this.api.post(da, { event_name: e7, client_id: this.clientAnalyticsId, payload: { ...t8 || {}, clientTimestamp: r10 ? r10.toISOString() : (/* @__PURE__ */ new Date()).toISOString() } }, { retry: -1, keepalive: n6?.keepAlive ?? false });
    } catch (e8) {
      console.log("Unable to submit event. This is not an issue.");
    }
  }
  async signMoonpayOnRampUrl(e7) {
    try {
      return this.api.post(Da, e7);
    } catch (e8) {
      throw o(e8);
    }
  }
  async initCoinbaseOnRamp(e7) {
    try {
      return this.api.post(Na, e7);
    } catch (e8) {
      throw o(e8);
    }
  }
  async getCoinbaseOnRampStatus({ partnerUserId: e7 }) {
    try {
      return this.api.get(`${Ia}?partnerUserId=${e7}`);
    } catch (e8) {
      throw o(e8);
    }
  }
  async getAuthenticatedUser() {
    return this.session.hasRefreshCredentials() ? this.session.refresh() : null;
  }
  async getAccessToken(e7) {
    return await this.getPrivyAccessToken(e7) || await this.getCustomerAccessToken(e7);
  }
  async getCustomerAccessToken(e7) {
    return await this._getToken(qo2.CUSTOMER, e7);
  }
  async getPrivyAccessToken(e7) {
    return await this._getToken(qo2.PRIVY, e7);
  }
  async _getToken(e7, t8) {
    return this.session.getToken(e7) ? this.session.hasActiveAccessToken(e7) ? this.session.hasRefreshCredentials(e7) ? uo.parse(this.session.getToken(e7))?.appId !== this.appId ? (await this.logout(), null) : this.session.getToken(e7) : (this.session.destroyLocalState(), null) : !t8?.disableAutoRefresh && this.session.hasRefreshCredentials(e7) ? (await this.session.refresh(), this.session.getToken(e7)) : null : null;
  }
  async getSmartWalletsConfig() {
    try {
      let e7 = {}, t8 = this.session.token;
      t8 && (e7.authorization = `Bearer ${t8}`);
      let r10 = await this.api.get(`/api/v1/apps/${this.appId}/smart_wallets`, { baseURL: this.fallbackApiUrl, headers: e7 });
      return r10.enabled ? { enabled: r10.enabled, smartWalletVersion: r10.smart_wallet_version, smartWalletType: r10.smart_wallet_type, configuredNetworks: r10.configured_networks.map(((e8) => ({ chainId: e8.chain_id, bundlerUrl: e8.bundler_url, paymasterUrl: e8.paymaster_url, paymasterContext: xo(e8.paymaster_url, e8.paymaster_context) }))) } : { enabled: r10.enabled };
    } catch (e7) {
      throw o(e7);
    }
  }
  async getUsdTokenPrice(e7) {
    try {
      return (await this.api.get(`/api/v1/token_price?chainId=${e7.id}&tokenSymbol=${e7.nativeCurrency.symbol}`)).usd;
    } catch (t8) {
      return void console.error(`Unable to fetch token price for chain with id ${e7.id}`);
    }
  }
  async getUsdPriceForSol() {
    try {
      return (await this.api.get("/api/v1/token_price?chainId=0&tokenSymbol=SOL")).usd;
    } catch (e7) {
      return void console.error("Unable to fetch token price for SOL");
    }
  }
  async getSplTokenMetadata({ mintAddress: e7, cluster: t8 }) {
    try {
      return await this.api.get(`/api/v1/spl_token_info?mint_address=${e7}&cluster=${t8}`);
    } catch (r10) {
      return void console.error(`Unable to fetch token metadata for ${t8}:${e7}`);
    }
  }
  async requestFarcasterSignerStatus(e7) {
    try {
      return await this.api.post("/api/v1/farcaster/signer/status", { ed25519_public_key: e7 });
    } catch (e8) {
      throw console.error("Unable to fetch Farcaster signer status"), e8;
    }
  }
  async generateSiweNonce({ address: e7, captchaToken: t8 }) {
    try {
      return (await this.api.post(A, { address: e7, token: t8 })).nonce;
    } catch (e8) {
      throw o(e8);
    }
  }
  async authenticateWithSiweInternal({ message: e7, signature: t8, chainId: r10, walletClientType: n6, connectorType: a3, mode: i5 }) {
    return await this.api.post(T, { message: e7, signature: t8, chainId: r10, walletClientType: n6, connectorType: a3, mode: i5 });
  }
  async linkWithSiweInternal({ message: e7, signature: t8, chainId: r10, walletClientType: n6, connectorType: a3 }) {
    return await this.api.post(D, { message: e7, signature: t8, chainId: r10, walletClientType: n6, connectorType: a3 });
  }
  async linkSmartWallet({ message: e7, signature: t8, smartWalletType: r10, smartWalletVersion: n6 }) {
    try {
      let a3 = await this.api.post(N, { message: e7, signature: t8, smart_wallet_type: r10, smart_wallet_version: n6 });
      return h3(a3);
    } catch (e8) {
      throw o(e8);
    }
  }
  async linkWithSiwe({ message: e7, signature: t8, chainId: r10, walletClientType: n6, connectorType: a3 }) {
    try {
      let i5 = await this.linkWithSiweInternal({ message: e7, signature: t8, chainId: r10, walletClientType: n6, connectorType: a3 });
      return h3(i5);
    } catch (e8) {
      throw o(e8);
    }
  }
  async generateSiwsNonce({ address: e7, captchaToken: t8 }) {
    try {
      return (await this.api.post(L, { address: e7, token: t8 })).nonce;
    } catch (e8) {
      throw o(e8);
    }
  }
  async authenticateWithSiwsInternal({ message: e7, signature: t8, walletClientType: r10, connectorType: n6, mode: a3, messageType: i5 = "plain" }) {
    return await this.api.post(R, { message: e7, signature: t8, walletClientType: r10, connectorType: n6, mode: a3, message_type: i5 });
  }
  async authenticateWithSiws({ message: e7, signature: t8, walletClientType: r10, connectorType: n6, mode: a3, messageType: i5 = "plain" }) {
    let o4 = await this.authenticateWithSiwsInternal({ message: e7, signature: t8, walletClientType: r10, connectorType: n6, mode: a3, messageType: i5 });
    this.session.handleTokenResponse(o4);
    let s3 = h3(o4.user);
    if (!s3) throw Error("Authentication failed - no user returned");
    return { user: s3, isNewUser: o4.is_new_user || false };
  }
  async sendAccountTransferRequest({ nonce: e7, account: t8, accountType: r10, externalWalletMetadata: n6, telegramAuthResult: a3, telegramWebAppData: i5, farcasterEmbeddedAddress: o4, oAuthUserInfo: s3 }) {
    try {
      let l5, c2;
      switch (r10) {
        case "email":
          l5 = H, c2 = { nonce: e7, email: t8 };
          break;
        case "sms":
          l5 = X, c2 = { nonce: e7, phoneNumber: t8 };
          break;
        case "siwe":
          if (l5 = O, !n6) throw Error("Wallet parameters must be defined");
          c2 = { nonce: e7, address: t8, ...n6 };
          break;
        case "farcaster":
          l5 = y, c2 = { nonce: e7, farcaster_id: t8, farcaster_embedded_address: o4 };
          break;
        case "telegram":
          l5 = Ea, c2 = { nonce: e7, telegram_auth_result: a3, telegram_web_app_data: i5 };
          break;
        case "siws":
          l5 = S, c2 = { nonce: e7, address: t8, ...n6 };
          break;
        case "custom":
        case "guest":
        case "passkey":
          throw Error("Invalid transfer account type");
        default:
          l5 = J, c2 = { nonce: e7, userInfo: s3 };
      }
      let d2 = await this.api.post(l5, c2);
      return await this.getAuthenticatedUser() ?? h3(d2);
    } catch (e8) {
      throw o(e8);
    }
  }
  async linkWithSiwsInternal({ message: e7, signature: t8, walletClientType: r10, connectorType: n6, messageType: a3 = "plain" }) {
    return await this.api.post(m, { message: e7, signature: t8, walletClientType: r10, connectorType: n6, message_type: a3 });
  }
  async linkWithSiws({ message: e7, signature: t8, walletClientType: r10, connectorType: n6, messageType: a3 = "plain" }) {
    try {
      let i5 = await this.linkWithSiwsInternal({ message: e7, signature: t8, walletClientType: r10, connectorType: n6, messageType: a3 });
      return h3(i5);
    } catch (e8) {
      throw o(e8);
    }
  }
  async updateUserAndIdToken() {
    try {
      let e7 = await this.api.get(La);
      return this.session.updateIdentityToken(e7.identity_token), h3(e7.user);
    } catch (e7) {
      throw o(e7);
    }
  }
  async scanTransaction(e7) {
    try {
      return await this.api.post(Ra, e7);
    } catch (e8) {
      throw o(e8);
    }
  }
  constructor({ apiUrl: e7 = fn, appId: t8, appClientId: r10, timeout: n6 = yn }) {
    Object.defineProperty(this, Ho, { value: $o2 }), this._cachedProviderAppDetails = {}, this.apiUrl = e7, this.fallbackApiUrl = this.apiUrl, this.useServerCookies = e7 !== fn && e7.startsWith("https://privy."), this.timeout = n6, this.appId = t8, this.appClientId = r10, this.clientAnalyticsId = (function(e8, t9) {
      if (!Object.prototype.hasOwnProperty.call(e8, t9)) throw TypeError("attempted to use private field on non-instance");
      return e8;
    })(this, Ho)[Ho](), Bo || (Bo = new zo()), this.session = Bo, this.api = this.generateApi(), this.session.client = this;
  }
};
function $o2() {
  if ("undefined" == typeof window) return null;
  try {
    let e8 = ln.get(_n);
    if ("string" == typeof e8 && e8.length > 0) return e8;
  } catch (e8) {
  }
  let e7 = v4_default();
  try {
    return ln.put(_n, e7), e7;
  } catch (t8) {
    return e7;
  }
}
var Ko2 = ({ delayedExecution: e7, ...r10 }) => {
  let { enabled: n6, siteKey: a3, appId: i5, setError: l5, setToken: c2, setExecuting: d2, ref: u2 } = _a2(), [, h7] = (0, import_react3.useMemo)((() => a3?.split("t:") || []), [a3]);
  if ((0, import_react3.useEffect)((() => u2.current?.remove), []), !n6) return null;
  if (!h7) throw Error("Unsupported captcha site key");
  return (0, import_jsx_runtime2.jsx)("div", { className: "hidden h-0 w-0", children: (0, import_jsx_runtime2.jsx)(Turnstile, { ...r10, ref: u2, siteKey: h7, options: { action: i5, size: "invisible", ...e7 ? { appearance: "execute", execution: "execute" } : { appearance: "always", execution: "render" } }, onUnsupported: () => {
    r10.onUnsupported?.(), console.warn("Browser does not support Turnstile.");
  }, onError: () => {
    r10.onError?.(), l5("Captcha failed"), d2(false);
  }, onSuccess: (e8) => {
    r10.onSuccess?.(e8), c2(e8), d2(false);
  }, onExpire: () => {
    r10.onExpire?.();
    try {
      u2.current?.reset(), l5(void 0), c2(void 0);
    } catch (e8) {
      l5("expired_and_failed_reset");
    }
  } }) });
};
function Go(e7) {
  qr("configureMfa", e7);
}
var Yo = dt.div.withConfig({ displayName: "AppLogoContainer", componentId: "sc-ba98f772-0" })(["display:flex;flex-direction:column;align-items:center;padding:0px 0px 30px;@media (max-width:440px){padding:10px 10px 20px;}"]);
var Zo = dt.div.withConfig({ displayName: "Title", componentId: "sc-ba98f772-1" })(["font-size:18px;line-height:30px;text-align:center;font-weight:600;margin-bottom:10px;"]);
var Jo = dt.div.withConfig({ displayName: "SubTitle", componentId: "sc-ba98f772-2" })(["font-size:0.875rem;text-align:center;"]);
var Xo2 = dt.div.withConfig({ displayName: "Container", componentId: "sc-ba98f772-3" })(["display:flex;flex-direction:column;align-items:center;gap:10px;flex-grow:1;padding:20px 0;@media (max-width:440px){padding:10px 10px 20px;}"]);
var Qo = dt.div.withConfig({ displayName: "List", componentId: "sc-ba98f772-4" })(["display:flex;flex-direction:column;align-items:stretch;gap:0.75rem;padding:1rem 0rem 0rem;flex-grow:1;width:100%;"]);
var es = dt.div.withConfig({ displayName: "ListItemIcon", componentId: "sc-ba98f772-5" })(["width:25px;display:flex;align-items:center;justify-content:flex-start;> svg{z-index:2;height:25px !important;width:25px !important;color:var(--privy-color-accent);}"]);
var ts = dt.div.withConfig({ displayName: "ListItem", componentId: "sc-ba98f772-6" })(["display:flex;align-items:center;gap:10px;font-size:0.875rem;line-height:1rem;text-align:left;"]);
var rs = dt.div.withConfig({ displayName: "BottomSection", componentId: "sc-ba98f772-7" })(["display:flex;flex-direction:column;gap:10px;padding-top:20px;"]);
var ns = dt.div.withConfig({ displayName: "MethodList", componentId: "sc-ba98f772-8" })(["display:flex;flex-direction:column;align-items:stretch;gap:1rem;padding:1rem 0rem 0rem;flex-grow:1;width:100%;"]);
var as = dt.div.withConfig({ displayName: "MethodListItem", componentId: "sc-ba98f772-9" })(["display:flex;gap:5px;width:100%;position:relative;"]);
var is = dt.button.withConfig({ displayName: "RemoveMethodButton", componentId: "sc-ba98f772-10" })(["&&{background-color:transparent;color:var(--privy-color-foreground-3);padding:0 0.75rem;display:flex;align-items:center;height:100%;> svg{z-index:2;height:20px !important;width:20px !important;}}&&:hover{color:var(--privy-color-error);}"]);
var os = dt.div.withConfig({ displayName: "MethodText", componentId: "sc-ba98f772-11" })(["display:flex;align-items:center;gap:0.5rem;> svg{z-index:2;height:20px !important;width:20px !important;}"]);
var ss = dt.div.withConfig({ displayName: "ExtraText", componentId: "sc-ba98f772-12" })(["display:flex;align-items:center;gap:6px;font-weight:400 !important;color:", ";> svg{z-index:2;height:18px !important;width:18px !important;display:flex !important;align-items:flex-end;}"], ((e7) => e7.$isAccent ? "var(--privy-color-accent)" : "var(--privy-color-foreground-3)"));
var ls = dt.div.withConfig({ displayName: "SmsInsecureText", componentId: "sc-ba98f772-13" })(["width:100%;display:flex;justify-content:space-between;"]);
var cs = dt.p.withConfig({ displayName: "TermsText", componentId: "sc-ba98f772-14" })(["text-align:left;width:100%;color:var(--privy-color-foreground-3) !important;"]);
var ds = dt.button.withConfig({ displayName: "PrimaryTextButton", componentId: "sc-ba98f772-15" })(["display:flex;flex-direction:row;align-items:center;justify-content:center;user-select:none;&{width:100%;cursor:pointer;border-radius:var(--privy-border-radius-md);font-size:0.875rem;line-height:1rem;font-style:normal;font-weight:500;line-height:22px;letter-spacing:-0.016px;}&&{color:", ";background-color:transparent;padding:0.5rem 0px;}&:hover{text-decoration:underline;}"], ((e7) => "dark" === e7.theme ? "var(--privy-color-foreground-2)" : "var(--privy-color-accent)"));
var us = dt.div.withConfig({ displayName: "IconWrapper", componentId: "sc-ba98f772-16" })(["display:flex;align-items:center;justify-content:center;color:var(--privy-color-accent);width:100%;> svg{z-index:2;width:3rem;height:3rem;}"]);
var hs = dt.div.withConfig({ displayName: "ErrorMessage", componentId: "sc-ba98f772-17" })(["color:var(--privy-color-error);"]);
var ps = ({ handleClose: e7, user: n6, onSelect: a3 }) => (0, import_jsx_runtime2.jsxs)(ho, { title: "Verify your identity", subtitle: "Choose a verification method", icon: ShieldCheckIcon_default, iconVariant: "subtle", onClose: e7, showClose: true, watermark: true, children: [(0, import_jsx_runtime2.jsxs)(ns, { children: [n6.mfaMethods.includes("totp") && (0, import_jsx_runtime2.jsxs)(ti, { onClick: () => a3("totp"), children: [(0, import_jsx_runtime2.jsx)(ni, { children: (0, import_jsx_runtime2.jsx)(DevicePhoneMobileIcon_default, {}) }), "Authenticator app"] }, "totp"), n6.mfaMethods.includes("sms") && (0, import_jsx_runtime2.jsxs)(ti, { onClick: () => a3("sms"), children: [(0, import_jsx_runtime2.jsx)(ni, { children: (0, import_jsx_runtime2.jsx)(PhoneIcon_default, {}) }), "SMS"] }, "sms"), n6.mfaMethods.includes("passkey") && (0, import_jsx_runtime2.jsxs)(ti, { onClick: () => a3("passkey"), children: [(0, import_jsx_runtime2.jsx)(ni, { children: (0, import_jsx_runtime2.jsx)(FingerPrintIcon_default, {}) }), "Passkey"] }, "passkey")] }), (0, import_jsx_runtime2.jsx)(pi, {})] });
var ms = ({ pendingTransaction: e7 }) => {
  let { wallets: r10 } = Nl(), { walletProxy: n6, rpcConfig: a3, chains: i5, appId: c2, nativeTokenSymbolForChainId: d2 } = s(), [u2, h7] = (0, import_react3.useState)(null), [p5, m4] = (0, import_react3.useState)(e7), { tokenPrice: w4 } = Sl(p5.chainId), y6 = d2(e7.chainId) || "ETH", g2 = (0, import_react3.useMemo)((() => r10.find(((e8) => "privy" === e8.walletClientType))), [r10]);
  return (0, import_react3.useEffect)((() => {
    (async function() {
      if (!n6 || !g2) return p5;
      let e8 = ua2(p5.chainId, i5, a3, { appId: c2 }), t8 = await _l(p5, e8, g2.address);
      return h7(toHex(BigInt(t8.gas ?? 0))), t8;
    })().then(m4).catch(console.error);
  }), [n6]), g2 ? (0, import_jsx_runtime2.jsx)(ws, { children: (0, import_jsx_runtime2.jsx)(kl, { from: g2.address, to: p5.to, txn: p5, gas: u2 ?? void 0, tokenPrice: w4, tokenSymbol: y6 }) }) : null;
};
var ws = dt.div.withConfig({ displayName: "TransactionInfoWrapper", componentId: "sc-8d9a2f57-0" })(["width:100%;padding:1rem 0;"]);
var ys = ({ style: e7, ...r10 }) => (0, import_jsx_runtime2.jsx)("svg", { x: 0, y: 0, width: "65", height: "64", viewBox: "0 0 65 64", style: { height: "64px", width: "65px", ...e7 }, fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...r10, children: (0, import_jsx_runtime2.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.71369 17.5625V10.375C3.71369 6.44625 6.85845 3.25 10.7238 3.25H17.7953C18.6783 3.25 19.3941 2.52244 19.3941 1.625C19.3941 0.727562 18.6783 0 17.7953 0H10.7238C5.09529 0 0.516113 4.65419 0.516113 10.375V17.5625C0.516113 18.4599 1.23194 19.1875 2.1149 19.1875C2.99787 19.1875 3.71369 18.4599 3.71369 17.5625ZM17.7953 60.7501C18.6783 60.7501 19.3941 61.4777 19.3941 62.3751C19.3941 63.2726 18.6783 64.0001 17.7953 64.0001H10.7238C5.09529 64.0001 0.516113 59.3459 0.516113 53.6251V46.4376C0.516113 45.5402 1.23194 44.8126 2.1149 44.8126C2.99787 44.8126 3.71369 45.5402 3.71369 46.4376V53.6251C3.71369 57.5538 6.85845 60.7501 10.7238 60.7501H17.7953ZM63.4839 46.4376V53.6251C63.4839 59.3459 58.9048 64.0001 53.2763 64.0001H46.2047C45.3217 64.0001 44.6059 63.2726 44.6059 62.3751C44.6059 61.4777 45.3217 60.7501 46.2047 60.7501H53.2763C57.1416 60.7501 60.2864 57.5538 60.2864 53.6251V46.4376C60.2864 45.5402 61.0022 44.8126 61.8851 44.8126C62.7681 44.8126 63.4839 45.5402 63.4839 46.4376ZM63.4839 10.375V17.5625C63.4839 18.4599 62.7681 19.1875 61.8851 19.1875C61.0022 19.1875 60.2864 18.4599 60.2864 17.5625V10.375C60.2864 6.44625 57.1416 3.25 53.2763 3.25H46.2047C45.3217 3.25 44.6059 2.52244 44.6059 1.625C44.6059 0.727562 45.3217 0 46.2047 0H53.2763C58.9048 0 63.4839 4.65419 63.4839 10.375ZM43.0331 47.3022C43.7067 46.6698 43.7483 45.6022 43.1262 44.9176C42.5039 44.233 41.4536 44.1906 40.78 44.823C38.3832 47.0732 35.265 48.3125 31.9997 48.3125C28.7344 48.3125 25.6162 47.0732 23.2194 44.823C22.5457 44.1906 21.4955 44.233 20.8732 44.9176C20.251 45.6022 20.2927 46.6698 20.9663 47.3022C23.9784 50.1301 27.8968 51.6875 31.9997 51.6875C36.1026 51.6875 40.021 50.1301 43.0331 47.3022ZM35.3207 24.1249V36.1249C35.3207 38.5029 33.4173 40.4374 31.0777 40.4374H29.7249C28.8079 40.4374 28.0646 39.6819 28.0646 38.7499C28.0646 37.8179 28.8079 37.0624 29.7249 37.0624H31.0777C31.5863 37.0624 32.0001 36.6419 32.0001 36.1249V24.1249C32.0001 23.1929 32.7434 22.4374 33.6604 22.4374C34.5774 22.4374 35.3207 23.1929 35.3207 24.1249ZM46.7581 28.8437V24.0312C46.7581 23.151 46.056 22.4374 45.19 22.4374C44.324 22.4374 43.622 23.151 43.622 24.0312V28.8437C43.622 29.7239 44.324 30.4374 45.19 30.4374C46.056 30.4374 46.7581 29.7239 46.7581 28.8437ZM17.6109 28.8437C17.6109 29.7239 18.313 30.4374 19.1789 30.4374C20.0449 30.4374 20.747 29.7239 20.747 28.8437V24.0312C20.747 23.151 20.0449 22.4374 19.1789 22.4374C18.313 22.4374 17.6109 23.151 17.6109 24.0312V28.8437Z" }) });
var gs = ({ hasBlockingError: e7, error: a3, onClose: i5, onBack: o4, handleSubmit: s3, account: l5, submitSuccess: c2 }) => {
  let { pendingTransaction: d2 } = s();
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Di, { onClose: i5 }, "header"), (0, import_jsx_runtime2.jsx)(Ml, { children: (0, import_jsx_runtime2.jsxs)("div", { children: [(0, import_jsx_runtime2.jsx)(ui, { success: c2, fail: !!a3 }), (0, import_jsx_runtime2.jsx)(a3 ? ExclamationTriangleIcon_default : ys, { style: { width: "38px", height: "38px" } })] }) }), (0, import_jsx_runtime2.jsx)(Zo, { style: { marginTop: "1rem" }, children: "Verifying with passkey" }), (0, import_jsx_runtime2.jsxs)(Qo, { children: [(0, import_jsx_runtime2.jsxs)(ts, { children: [(0, import_jsx_runtime2.jsx)(es, { children: (0, import_jsx_runtime2.jsx)(ShieldCheckIcon_default, {}) }), "Approve this action using your touch, face, PIN, or hardware key."] }), (0, import_jsx_runtime2.jsxs)(ts, { children: [(0, import_jsx_runtime2.jsx)(es, { children: (0, import_jsx_runtime2.jsx)(CalendarIcon_default, {}) }), "You last added a passkey on", " ", l5?.firstVerifiedAt?.toLocaleDateString(void 0, { month: "short", day: "numeric", year: "numeric" }), "."] })] }), d2 && (0, import_jsx_runtime2.jsx)(Xo2, { children: (0, import_jsx_runtime2.jsx)(ms, { pendingTransaction: d2 }) }), a3 && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(hs, { style: { marginTop: "1.25rem" }, children: a3.message }), (0, import_jsx_runtime2.jsx)(Ci, { disabled: e7, onClick: s3, style: { marginTop: "1.25rem" }, children: "Try again" })] }), o4 && (0, import_jsx_runtime2.jsx)(ds, { style: { marginTop: "1rem" }, onClick: o4, children: "Choose another method" }), (0, import_jsx_runtime2.jsx)(pi, {})] });
};
var fs = Array(6).fill("");
var vs;
var Cs = ((vs = Cs || {})[vs.RESET_AFTER_DELAY = 0] = "RESET_AFTER_DELAY", vs[vs.CLEAR_ON_NEXT_VALID_INPUT = 1] = "CLEAR_ON_NEXT_VALID_INPUT", vs);
function ks(e7) {
  return /^[0-9]{1}$/.test(e7);
}
function As(e7) {
  return 6 === e7.length && e7.every(ks);
}
var bs = ({ onChange: e7, disabled: a3, errorReasonOverride: i5, success: o4 }) => {
  let [s3, c2] = (0, import_react3.useState)(fs), [d2, u2] = (0, import_react3.useState)(null), [h7, p5] = (0, import_react3.useState)(null), m4 = async (t8) => {
    t8.preventDefault();
    let r10 = t8.currentTarget.value.replace(/\s+/g, "");
    if ("" === r10) return;
    let n6 = s3.reduce(((e8, t9) => e8 + Number(ks(t9))), 0), a4 = r10.split(""), i6 = !a4.every(ks), o5 = a4.length + n6 > 6;
    if (i6) return u2("Passcode can only be numbers"), void p5(1);
    if (o5) return u2("Passcode must be exactly 6 numbers"), void p5(1);
    u2(null), p5(null);
    let l5 = Number(t8.currentTarget.name?.charAt(4)), d3 = [...r10 || [""]].slice(0, 6 - l5), h8 = [...s3.slice(0, l5), ...d3, ...s3.slice(l5 + d3.length)];
    c2(h8);
    let m5 = Math.min(Math.max(l5 + d3.length, 0), 5), w5 = document.querySelector(`input[name=pin-${m5}]`);
    if (w5?.focus(), As(h8)) try {
      await e7(h8.join(""));
      let t9 = document.querySelector(`input[name=pin-${m5}]`);
      t9?.blur();
    } catch (t9) {
      p5(1), u2(t9.message);
    }
    else try {
      await e7(null);
    } catch (t9) {
      p5(1), u2(t9.message);
    }
  }, w4 = o4 ? "success" : !(!i5 && !d2) ? "fail" : "";
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: (0, import_jsx_runtime2.jsxs)(Ts, { children: [(0, import_jsx_runtime2.jsx)("div", { children: s3.map(((r10, n6) => (0, import_jsx_runtime2.jsx)("input", { name: `pin-${n6}`, type: "text", value: s3[n6], onChange: m4, onKeyUp: (t8) => {
    "Backspace" === t8.key && ((t9) => {
      1 === h7 && (u2(null), p5(null));
      let r11 = [...s3.slice(0, t9), "", ...s3.slice(t9 + 1)];
      if (c2(r11), t9 > 0) {
        let e8 = document.querySelector(`input[name=pin-${t9 - 1}]`);
        e8?.focus();
      }
      As(r11) ? e7(r11.join("")) : e7(null);
    })(n6);
  }, inputMode: "numeric", autoFocus: 0 === n6, pattern: "[0-9]", className: w4, autoComplete: import_react_device_detect.isMobile ? "one-time-code" : "off", disabled: a3 }, n6))) }), (0, import_jsx_runtime2.jsx)("div", { children: (0, import_jsx_runtime2.jsx)(_s, { $fail: !!i5 || !!d2, children: i5 || d2 }) })] }) });
};
var Ts = dt.div.withConfig({ displayName: "PinInputContainer", componentId: "sc-7a171f6-0" })(["display:flex;flex-direction:column;width:100%;gap:8px;@media (max-width:440px){margin-top:8px;margin-bottom:8px;}> div:nth-child(1){display:flex;justify-content:center;gap:0.5rem;width:100%;border-radius:var(--privy-border-radius-md);> input{border:1px solid var(--privy-color-foreground-4);background:var(--privy-color-background);border-radius:var(--privy-border-radius-md);padding:8px 10px;height:58px;width:46px;text-align:center;font-size:18px;}> input:disabled{background:var(--privy-color-background-2);}> input:focus{border:1px solid var(--privy-color-accent);}> input:invalid{border:1px solid var(--privy-color-error);}> input.success{border:1px solid var(--privy-color-success);}> input.fail{border:1px solid var(--privy-color-error);animation:shake 180ms;animation-iteration-count:2;}}@keyframes shake{0%{transform:translate(1px,0px);}33%{transform:translate(-1px,0px);}67%{transform:translate(-1px,0px);}100%{transform:translate(1px,0px);}}"]);
var _s = dt.div.withConfig({ displayName: "InputHelp", componentId: "sc-7a171f6-1" })(["line-height:20px;font-size:13px;display:flex;justify-content:flex-start;width:100%;color:", ";"], ((e7) => e7.$fail ? "var(--privy-color-error)" : "var(--privy-color-foreground-3)"));
var Es = ({ selectedMethod: e7, submitSuccess: a3, hasBlockingError: i5, onClose: o4, onBack: s3, handleSubmitCode: l5 }) => {
  let { app: c2 } = Or(), { pendingTransaction: d2 } = s();
  switch (e7) {
    case "sms":
      return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Di, { onClose: o4 }, "header"), (0, import_jsx_runtime2.jsx)(us, { style: { marginBottom: "1.5rem" }, children: (0, import_jsx_runtime2.jsx)(PhoneIcon_default, {}) }), (0, import_jsx_runtime2.jsx)(Zo, { children: "Enter verification code" }), (0, import_jsx_runtime2.jsxs)(Xo2, { children: [(0, import_jsx_runtime2.jsx)(bs, { success: a3, disabled: i5, onChange: l5 }), (0, import_jsx_runtime2.jsxs)(Jo, { children: ["To continue, please enter the 6-digit code sent to your ", (0, import_jsx_runtime2.jsx)("strong", { children: "mobile device" })] }), d2 && (0, import_jsx_runtime2.jsx)(ms, { pendingTransaction: d2 })] }), s3 && (0, import_jsx_runtime2.jsx)(ds, { theme: c2?.appearance.palette.colorScheme, onClick: s3, children: "Choose another method" }), (0, import_jsx_runtime2.jsx)(Ai, { onClick: o4, children: "Cancel" }), (0, import_jsx_runtime2.jsx)(pi, {})] });
    case "totp":
      return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Di, { onClose: o4 }, "header"), (0, import_jsx_runtime2.jsx)(us, { style: { marginBottom: "1.5rem" }, children: (0, import_jsx_runtime2.jsx)(DevicePhoneMobileIcon_default, {}) }), (0, import_jsx_runtime2.jsx)(Zo, { children: "Enter verification code" }), (0, import_jsx_runtime2.jsxs)(Xo2, { children: [(0, import_jsx_runtime2.jsx)(bs, { success: a3, disabled: i5, onChange: l5 }), (0, import_jsx_runtime2.jsxs)(Jo, { children: ["To continue, please enter the 6-digit code generated from your", " ", (0, import_jsx_runtime2.jsx)("strong", { children: "authenticator app" })] }), d2 && (0, import_jsx_runtime2.jsx)(ms, { pendingTransaction: d2 })] }), s3 && (0, import_jsx_runtime2.jsx)(ds, { theme: c2?.appearance.palette.colorScheme, onClick: s3, children: "Choose another method" }), (0, import_jsx_runtime2.jsx)(Ai, { onClick: o4, children: "Cancel" }), (0, import_jsx_runtime2.jsx)(pi, {})] });
    default:
      return null;
  }
};
var Is = (e7) => Bl(e7) ? { isBlocking: true, error: Error("You have exceeded the maximum number of attempts. Please close this window and try again in 10 seconds.") } : Rl(e7) ? { isBlocking: false, error: Error("The code you entered is not valid") } : Wl(e7) ? { isBlocking: true, error: Error("You have exceeded the time limit for code entry. Please try again in 30 seconds.") } : (console.error(e7), { isBlocking: false, error: Error("Something went wrong.") });
var Ss = { component: () => {
  let { user: e7 } = v2(), { data: r10 } = Or(), [n6, a3] = (0, import_react3.useState)(e7?.mfaMethods[0]), [i5, o4] = (0, import_react3.useState)(false), [c2, d2] = (0, import_react3.useState)(), [h7, p5] = (0, import_react3.useState)();
  if ((0, import_react3.useEffect)((() => {
    a3(e7?.mfaMethods[0]);
  }), [e7?.mfaMethods]), !r10?.mfaVerify) throw Error("Missing modal data for MFA verification screen.");
  let { onFailure: m4, onSuccess: w4, generateOptions: y6, verifyTotpCode: g2, verifyPasskey: f4, verifySmsCode: v5, sendSmsCode: C4 } = r10.mfaVerify, k3 = async (e8) => {
    if ("passkey" !== e8) try {
      a3(e8), "sms" === e8 && (a3(e8), await C4()), "totp" === e8 && a3(e8);
    } catch (e9) {
      console.error(e9);
    }
    else try {
      a3(e8);
      let t8 = await y6();
      if (!t8) throw Error("something went wrong");
      d2(t8), await f4(t8), o4(true), p5(void 0), w4();
    } catch (e9) {
      p5(Is(e9));
    }
  }, A2 = async (e8) => {
    p5(void 0);
    try {
      if (!e8 || !n6) return;
      if ("passkey" === n6) {
        if (!c2) throw Error("Missing passkey challenge");
        await f4(c2);
      } else "sms" === n6 ? await v5(e8) : "totp" === n6 && await g2(e8);
      p5(void 0), o4(true), w4();
    } catch (e9) {
      throw Is(e9).error;
    }
  }, b4 = () => {
    h7 || !i5 ? m4(h7?.error ?? Error("Canceled MFA verification.")) : w4();
  }, T2 = (0, import_react3.useRef)(false);
  return (0, import_react3.useEffect)((() => {
    !T2.current && n6 && (T2.current = true, k3(n6).finally((() => {
      T2.current = false;
    })));
  }), [open]), e7 ? "passkey" === n6 ? (0, import_jsx_runtime2.jsx)(gs, { account: e7.linkedAccounts.filter(((e8) => "passkey" === e8.type && e8.enrolledInMfa)).sort(((e8, t8) => t8.firstVerifiedAt.valueOf() - e8.firstVerifiedAt.valueOf()))[0], submitSuccess: i5, hasBlockingError: h7?.isBlocking ?? false, error: h7?.error, onClose: b4, onBack: () => {
    a3(void 0), p5(void 0);
  }, handleSubmit: () => A2(c2).catch(p5) }) : "sms" === n6 || "totp" === n6 ? (0, import_jsx_runtime2.jsx)(Es, { selectedMethod: n6, submitSuccess: i5, hasBlockingError: h7?.isBlocking ?? false, handleSubmitCode: A2, onClose: b4, onBack: e7.mfaMethods.length > 1 ? () => a3(void 0) : void 0 }) : (0, import_jsx_runtime2.jsx)(ps, { user: e7, onSelect: k3, handleClose: b4 }) : null;
} };
function Us() {
  let { promptMfa: e7, init: t8, submit: r10, cancel: n6, mfaMethods: a3 } = (0, import_react3.useContext)(k2);
  return { promptMfa: e7, init: t8, submit: r10, cancel: n6, mfaMethods: a3 };
}
var Ps = ({ onClose: e7 }) => {
  let { user: r10 } = v2(), [n6, a3] = (0, import_react3.useState)(r10?.mfaMethods[0] ?? null), { init: i5, cancel: o4, submit: c2 } = Us(), [d2, h7] = (0, import_react3.useState)(false), [p5, m4] = (0, import_react3.useState)(null), [w4, y6] = (0, import_react3.useState)();
  (0, import_react3.useEffect)((() => {
    a3(r10?.mfaMethods[0] ?? null);
  }), [r10?.mfaMethods]);
  let g2 = (0, import_react3.useRef)(false);
  async function f4(t8) {
    y6(void 0);
    try {
      if (!t8 || !n6) return;
      await c2(n6, t8), h7(true), y6(void 0), e7();
    } catch (t9) {
      throw Is(t9).error;
    }
  }
  async function v5(t8) {
    if ("passkey" !== t8) try {
      a3(t8), await i5(t8);
    } catch (t9) {
      console.error(t9);
    }
    else try {
      a3(t8);
      let r11 = await i5(t8);
      if (!r11) throw Error("something went wrong");
      m4(r11), await c2(t8, r11), h7(true), y6(void 0), e7();
    } catch (t9) {
      y6(Is(t9));
    }
  }
  (0, import_react3.useEffect)((() => {
    !g2.current && n6 && (g2.current = true, v5(n6).finally((() => {
      g2.current = false;
    })));
  }), []);
  let C4 = () => {
    a3(null), y6(void 0), o4(), e7();
  };
  return r10 ? "passkey" === n6 ? (0, import_jsx_runtime2.jsx)(gs, { account: r10.linkedAccounts.filter(((e8) => "passkey" === e8.type && e8.enrolledInMfa)).sort(((e8, t8) => t8.firstVerifiedAt.valueOf() - e8.firstVerifiedAt.valueOf()))[0], submitSuccess: d2, hasBlockingError: w4?.isBlocking ?? false, error: w4?.error, onClose: C4, onBack: () => {
    a3(null), y6(void 0);
  }, handleSubmit: () => f4(p5).catch(y6) }) : n6 ? (0, import_jsx_runtime2.jsx)(Es, { submitSuccess: d2, hasBlockingError: w4?.isBlocking ?? false, handleSubmitCode: f4, selectedMethod: n6, onClose: C4, onBack: r10.mfaMethods.length > 1 ? () => a3(null) : void 0 }) : (0, import_jsx_runtime2.jsx)(ps, { user: r10, onSelect: v5, handleClose: C4 }) : null;
};
var Ws = create((() => ({ inProgressMfaFlow: void 0 })));
var xs = ft([":root{", "};"], ((e7) => Ns(e7.palette)));
var Ns = (e7) => lt(["", ""], Object.entries((function(e8) {
  return { "--privy-color-background": e8.background, "--privy-color-background-2": e8.background2, "--privy-color-background-3": e8.background3, "--privy-color-foreground": e8.foreground, "--privy-color-foreground-2": e8.foreground2, "--privy-color-foreground-3": e8.foreground3, "--privy-color-foreground-4": e8.foreground4, "--privy-color-foreground-accent": e8.foregroundAccent, "--privy-color-accent": e8.accent, "--privy-color-accent-light": e8.accentLight, "--privy-color-accent-hover": e8.accentHover, "--privy-color-accent-dark": e8.accentDark, "--privy-color-accent-darkest": e8.accentDarkest, "--privy-color-success": e8.success, "--privy-color-success-dark": e8.successDark, "--privy-color-success-light": e8.successLight, "--privy-color-success-bg": e8.successBg, "--privy-color-error": e8.error, "--privy-color-error-light": e8.errorLight, "--privy-color-error-bg": e8.errorBg, "--privy-color-error-bg-hover": e8.errorBgHover, "--privy-color-warn": e8.warn, "--privy-color-warn-light": e8.warnLight, "--privy-color-warn-bg": e8.warnBg, "--privy-color-warning-dark": e8.warningDark, "--privy-color-error-dark": e8.errorDark, "--privy-color-info-bg": e8.infoBg, "--privy-color-info-bg-hover": e8.infoBgHover, "--privy-color-border-default": e8.borderDefault, "--privy-color-border-hover": e8.borderHover, "--privy-color-border-focus": e8.borderFocus, "--privy-color-border-error": e8.borderError, "--privy-color-border-success": e8.borderSuccess, "--privy-color-border-warning": e8.borderWarning, "--privy-color-border-info": e8.borderInfo, "--privy-color-border-interactive": e8.borderInteractive, "--privy-color-border-interactive-hover": e8.borderInteractiveHover, "--privy-color-background-hover": e8.backgroundHover, "--privy-color-background-clicked": e8.backgroundClicked, "--privy-color-background-disabled": e8.backgroundDisabled, "--privy-color-background-interactive": e8.backgroundInteractive, "--privy-color-background-interactive-hover": e8.backgroundInteractiveHover, "--privy-color-background-interactive-clicked": e8.backgroundInteractiveClicked, "--privy-color-background-interactive-disabled": e8.backgroundInteractiveDisabled, "--privy-color-foreground-hover": e8.foregroundHover, "--privy-color-foreground-clicked": e8.foregroundClicked, "--privy-color-foreground-disabled": e8.foregroundDisabled, "--privy-color-foreground-interactive": e8.foregroundInteractive, "--privy-color-foreground-interactive-hover": e8.foregroundInteractiveHover, "--privy-link-navigation-color": e8.linkNavigationColor, "--privy-link-navigation-decoration": e8.linkNavigationDecoration, "--privy-accent-has-good-contrast": e8.accentHasGoodContrast, "--privy-color-icon-default": e8.iconDefault, "--privy-color-icon-muted": e8.iconMuted, "--privy-color-icon-subtle": e8.iconSubtle, "--privy-color-icon-inverse": e8.iconInverse, "--privy-color-icon-success": e8.iconSuccess, "--privy-color-icon-warning": e8.iconWarning, "--privy-color-icon-error": e8.iconError, "--privy-color-icon-interactive": e8.iconInteractive, "--privy-color-icon-default-hover": e8.iconDefaultHover, "--privy-color-icon-muted-hover": e8.iconMutedHover, "--privy-color-icon-subtle-hover": e8.iconSubtleHover, "--privy-color-icon-default-clicked": e8.iconDefaultClicked, "--privy-color-icon-muted-clicked": e8.iconMutedClicked, "--privy-color-icon-subtle-clicked": e8.iconSubtleClicked, "--privy-color-icon-default-disabled": e8.iconDefaultDisabled, "--privy-color-icon-muted-disabled": e8.iconMutedDisabled, "--privy-color-icon-subtle-disabled": e8.iconSubtleDisabled, "--privy-color-icon-error-hover": e8.iconErrorHover, "--privy-color-icon-interactive-hover": e8.iconInteractiveHover, "--privy-color-icon-error-clicked": e8.iconErrorClicked, "--privy-color-icon-interactive-clicked": e8.iconInteractiveClicked, "--privy-color-icon-muted-disabled-alt": e8.iconMutedDisabledAlt, "--privy-color-icon-subtle-disabled-alt": e8.iconSubtleDisabledAlt, "--privy-border-radius-xs": "6px", "--privy-border-radius-sm": "8px", "--privy-border-radius-md": "12px", "--privy-border-radius-mdlg": "16px", "--privy-border-radius-lg": "24px", "--privy-border-radius-full": "9999px", "--privy-height-modal-full": "620px", "--privy-height-modal-compact": "480px" };
})(e7)).map((([e8, t8]) => `${e8}: ${t8};`)).join("\n"));
var Rs = dt.div.withConfig({ displayName: "StylesWrapper", componentId: "sc-188229e4-0" })(["", " color:var(--privy-color-foreground-2);h3{font-size:16px;line-height:24px;font-weight:500;color:var(--privy-color-foreground-2);}h4{font-size:14px;line-height:20px;font-weight:500;color:var(--privy-color-foreground);}p{font-size:13px;line-height:20px;color:var(--privy-color-foreground-2);}button:focus,input:focus,optgroup:focus,select:focus,textarea:focus{outline:none;border-color:var(--privy-color-accent-light);box-shadow:0 0 0 3px var(--privy-color-border-focus);}.mobile-only{@media (min-width:441px){display:none;}}@keyframes fadein{0%{opacity:0;}100%{opacity:1;}}"], "\n  *,\n  ::before,\n  ::after {\n    box-sizing: border-box;\n    border-width: 0;\n    border-style: solid;\n  }\n\n  line-height: 1.15;\n  -webkit-text-size-adjust: 100%;\n  -moz-tab-size: 4;\n  tab-size: 4;\n  font-feature-settings: normal;\n\n  margin: 0;\n  font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif,\n    'Apple Color Emoji', 'Segoe UI Emoji';\n\n  hr {\n    height: 0;\n    color: inherit;\n    border-top-width: 1px;\n  }\n\n  abbr:where([title]) {\n    text-decoration: underline dotted;\n  }\n\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6 {\n    font-size: inherit;\n    font-weight: inherit;\n    font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif,\n    'Apple Color Emoji', 'Segoe UI Emoji';\n    display: inline;\n  }\n\n  a {\n    color: inherit;\n    text-decoration: inherit;\n  }\n\n  b,\n  strong {\n    font-weight: bolder;\n  }\n\n  code,\n  kbd,\n  samp,\n  pre {\n    font-family: ui-monospace, SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;\n    font-size: 1em;\n  }\n\n  small {\n    font-size: 80%;\n  }\n\n  sub,\n  sup {\n    font-size: 75%;\n    line-height: 0;\n    position: relative;\n    vertical-align: baseline;\n  }\n\n  sub {\n    bottom: -0.25em;\n  }\n\n  sup {\n    top: -0.5em;\n  }\n\n  table {\n    text-indent: 0;\n    border-color: inherit;\n    border-collapse: collapse;\n  }\n\n  button,\n  input,\n  optgroup,\n  select,\n  textarea {\n    font-family: inherit;\n    font-size: 100%;\n    font-weight: inherit;\n    line-height: inherit;\n    color: inherit;\n    margin: 0;\n    padding: 0;\n  }\n\n  button,\n  select {\n    text-transform: none;\n  }\n\n  button,\n  [type='button'],\n  [type='reset'],\n  [type='submit'] {\n    -webkit-appearance: button;\n    background-color: transparent;\n    background-image: none;\n  }\n\n  ::-moz-focus-inner {\n    border-style: none;\n    padding: 0;\n  }\n\n  :-moz-focusring {\n    outline: 1px dotted ButtonText;\n  }\n\n  :-moz-ui-invalid {\n    box-shadow: none;\n  }\n\n  legend {\n    padding: 0;\n  }\n\n  progress {\n    vertical-align: baseline;\n  }\n\n  ::-webkit-inner-spin-button,\n  ::-webkit-outer-spin-button {\n    height: auto;\n  }\n\n  [type='search'] {\n    -webkit-appearance: textfield;\n    outline-offset: -2px;\n  }\n\n  ::-webkit-search-decoration {\n    -webkit-appearance: none;\n  }\n\n  ::-webkit-file-upload-button {\n    -webkit-appearance: button;\n    font: inherit;\n  }\n\n  summary {\n    display: list-item;\n  }\n\n  blockquote,\n  dl,\n  dd,\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6,\n  hr,\n  figure,\n  p,\n  pre {\n    margin: 0;\n  }\n\n  fieldset {\n    margin: 0;\n    padding: 0;\n  }\n\n  legend {\n    padding: 0;\n  }\n\n  ol,\n  ul,\n  menu {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n  }\n\n  textarea {\n    resize: vertical;\n  }\n\n  input::placeholder,\n  textarea::placeholder {\n    opacity: 1;\n    color: #9ca3af;\n  }\n\n  button,\n  [role='button'] {\n    cursor: pointer;\n  }\n\n  :disabled {\n    cursor: default;\n  }\n\n  img,\n  svg,\n  video,\n  canvas,\n  audio,\n  iframe,\n  embed,\n  object {\n    display: block;\n  }\n\n  img,\n  video {\n    max-width: 100%;\n    height: auto;\n  }\n\n  [hidden] {\n    display: none;\n  }\n");
var Os = ({ children: e7, open: n6, onClick: a3, ...o4 }) => (0, import_jsx_runtime2.jsx)(Ke, { show: n6, as: import_react3.default.Fragment, children: (0, import_jsx_runtime2.jsxs)(ht, { onClose: a3, ...o4, as: Fs, children: [(0, import_jsx_runtime2.jsx)(Oe, { as: import_react3.default.Fragment, enterFrom: "entering", leaveTo: "leaving", children: (0, import_jsx_runtime2.jsx)(Ms, { id: "privy-dialog-backdrop", "aria-hidden": "true" }) }), (0, import_jsx_runtime2.jsx)(Ls, { children: (0, import_jsx_runtime2.jsx)(Oe, { as: import_react3.default.Fragment, enterFrom: "entering", leaveTo: "leaving", children: (0, import_jsx_runtime2.jsx)(ze, { as: Ds, children: e7 }) }) })] }) });
var Ms = dt.div.withConfig({ displayName: "Backdrop", componentId: "sc-3cfde0b5-0" })(["position:fixed;inset:0;transition:backdrop-filter 100ms ease;backdrop-filter:blur(3px);-webkit-backdrop-filter:blur(3px);&.entering,&.leaving{backdrop-filter:unset;-webkit-backdrop-filter:unset;}"]);
var Fs = dt.div.withConfig({ displayName: "DialogWrapper", componentId: "sc-3cfde0b5-1" })(["position:relative;z-index:999999;"]);
var Ls = dt.div.withConfig({ displayName: "DialogContainer", componentId: "sc-3cfde0b5-2" })(["position:fixed;inset:0;display:flex;align-items:center;justify-content:center;width:100vw;min-height:100vh;"]);
var Ds = dt.div.withConfig({ displayName: "Panel", componentId: "sc-3cfde0b5-3" })(["padding:0;background:transparent;border:none;width:100%;pointer-events:auto;outline:none;display:block;@media (max-width:440px){opacity:1;transform:translate3d(0,0,0);transition:transform 200ms ease-in;position:fixed;bottom:0;&.entering,&.leaving{opacity:0;transform:translate3d(0,100%,0);transition:transform 150ms ease-in 0ms,opacity 0ms ease 150ms;}}@media (min-width:441px){opacity:1;transition:opacity 100ms ease-in;&.entering,&.leaving{opacity:0;transition-delay:5ms;}margin:auto;width:360px;box-shadow:0px 8px 36px rgba(55,65,81,0.15);border-radius:var(--privy-border-radius-lg);}"]);
var qs = dt.div.withConfig({ displayName: "CenterItem", componentId: "sc-3cfde0b5-4" })(["display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;"]);
var zs = () => {
  let { ready: e7, isModalOpen: a3 } = v2(), { headless: i5 } = Pr(), { currentScreen: o4 } = Or(), { status: l5, execute: c2, reset: d2, enabled: u2 } = _a2(), h7 = Ws(((e8) => e8.inProgressMfaFlow)), p5 = () => Ws.setState({ inProgressMfaFlow: void 0 }), m4 = a3 && o4 && o4.isCaptchaRequired && !i5 && "ready" === l5;
  return (0, import_react3.useEffect)((() => {
    m4 && c2();
  }), [m4]), (0, import_react3.useEffect)((() => {
    !a3 && u2 && d2();
  }), [a3, u2]), o4 && !e7 && o4.isShownBeforeReady ? (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Di, {}), (0, import_jsx_runtime2.jsx)(Ko, {}), (0, import_jsx_runtime2.jsx)(qs, { children: (0, import_jsx_runtime2.jsx)(mi, {}) }), (0, import_jsx_runtime2.jsx)(Xo, {}), (0, import_jsx_runtime2.jsx)(pi, {})] }) : o4 || "txn" !== h7 ? o4 ? (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(ai, { $if: !!h7, children: (0, import_jsx_runtime2.jsx)(o4.component, {}) }), "txn" === h7 && (0, import_jsx_runtime2.jsx)(Ps, { onClose: p5 }), "auth" === h7 && (0, import_jsx_runtime2.jsx)(Ss.component, {})] }) : null : (0, import_jsx_runtime2.jsx)(Ps, { onClose: p5 });
};
var Bs = () => {
  let e7 = (0, import_react3.useRef)(null);
  return (0, import_jsx_runtime2.jsx)(Vs, { style: { height: v3(e7) }, id: "privy-modal-content", children: (0, import_jsx_runtime2.jsx)("div", { ref: e7, children: (0, import_jsx_runtime2.jsx)(zs, {}) }) });
};
var js = ({ open: e7 }) => {
  let r10 = Pr(), { gracefulClosePrivyModal: n6 } = (() => {
    let { closePrivyModal: e8 } = s(), { onUserCloseViaDialogOrKeybindRef: t8 } = Or();
    return { gracefulClosePrivyModal: (0, import_react3.useCallback)((() => {
      if (!t8?.current) return e8({ shouldCallAuthOnSuccess: false });
      t8.current();
    }), [e8]) };
  })(), a3 = Ws(((e8) => e8.inProgressMfaFlow));
  return Go({ onMfaRequired: () => {
    r10.mfa.noPromptOnMfaRequired || Ws.setState({ inProgressMfaFlow: "txn" });
  } }), r10.render.standalone ? (0, import_jsx_runtime2.jsx)(Rs, { children: (0, import_jsx_runtime2.jsx)(Hs, { id: "privy-modal-content", children: (0, import_jsx_runtime2.jsx)(zs, {}) }) }) : (0, import_jsx_runtime2.jsx)(Os, { open: !(!e7 && !a3), id: "privy-dialog", "aria-label": "log in or sign up", "aria-labelledby": "privy-dialog-title", onClick: () => n6(), children: (0, import_jsx_runtime2.jsx)(Rs, { children: (0, import_jsx_runtime2.jsx)(Bs, {}) }) });
};
var Hs = dt.div.withConfig({ displayName: "ContentWrapper", componentId: "sc-b220e1ee-0" })(["display:flex;flex-direction:column;text-align:center;font-size:14px;line-height:20px;width:100%;background:var(--privy-color-background);padding:0 16px;"]);
var Vs = dt(Hs).withConfig({ displayName: "BaseModal", componentId: "sc-b220e1ee-1" })(["transition:height 150ms ease-out;overflow-x:hidden;overflow-y:auto;scrollbar-width:none;max-height:calc(100svh - 32px);border-radius:var(--privy-border-radius-lg) var(--privy-border-radius-lg) 0 0;box-shadow:0px 0px 36px rgba(55,65,81,0.15);@media (min-width:441px){box-shadow:0px 8px 36px rgba(55,65,81,0.15);border-radius:var(--privy-border-radius-lg);}"]);
function $s(e7) {
  let r10 = (0, import_react3.useRef)(null), n6 = (0, import_react3.useRef)();
  return (0, import_react3.useEffect)((() => {
    n6.current?.remove(), n6.current = (function({ botUsername: e8, scriptHost: t8 }) {
      let r11 = document.createElement("script"), { origin: n7 } = new URL(t8);
      return r11.async = true, r11.src = `${n7}/js/telegram-login.js`, r11.setAttribute("data-telegram-login", e8), r11.setAttribute("data-request-access", "write"), r11.setAttribute("data-lang", "en"), r11;
    })(e7), r10.current?.after(n6.current);
  }), [e7]), (0, import_jsx_runtime2.jsx)("div", { ref: r10, hidden: true });
}
var Ks = () => {
  let { ready: e7 } = Nl(), { client: t8 } = s();
  return (0, import_react3.useEffect)((() => {
    let r10 = () => {
      if (!t8.connectors || !e7) return;
      let r11 = t8.connectors.wallets.map(((e8) => ({ address: e8.address, connectorType: e8.connectorType, walletClientType: e8.walletClientType, connectedAt: e8.connectedAt, id: e8.meta.id })));
      ln.put(Bn, r11);
    };
    return t8.connectors?.on("walletsUpdated", r10), () => {
      t8.connectors?.off("walletsUpdated", r10);
    };
  }), [e7, t8.connectors]), null;
};
async function Gs(e7, t8, r10, n6, a3, i5 = false) {
  let o4 = i5, s3 = async (s4) => {
    if (o4 && t8 && t8.length > 0) {
      s4 === (i5 ? 0 : 1) ? a3("configureMfa", "onMfaRequired", { mfaMethods: t8 }) : n6.current?.reject(new Ll("missing_or_invalid_mfa", "MFA verification failed, retry."));
      let o5 = await new Promise(((e8, t9) => {
        r10.current = { resolve: e8, reject: t9 }, setTimeout((() => {
          let e9 = new Ll("mfa_timeout", "Timed out waiting for MFA code");
          n6.current?.reject(e9), t9(e9);
        }), 3e5);
      }));
      return await e7(o5);
    }
    return await e7();
  }, l5 = null;
  for (let e8 = 0; e8 < 4; e8++) try {
    l5 = await s3(e8), n6.current?.resolve(void 0);
    break;
  } catch (e9) {
    if ("missing_or_invalid_mfa" !== e9.type) throw n6.current?.resolve(void 0), e9;
    o4 = true;
  }
  if (null === l5) {
    let e8 = new Ll("mfa_verification_max_attempts_reached", "Max MFA verification attempts reached");
    throw n6.current?.reject(e8), e8;
  }
  return l5;
}
var Ys;
var Zs = (Ys = 0, () => "id-" + Ys++);
function Js(e7) {
  return void 0 !== e7.error;
}
var Xs = new class {
  enqueue(e7, t8) {
    this.callbacks[e7] = t8;
  }
  dequeue(e7, t8) {
    let r10 = this.callbacks[t8];
    if (!r10) throw Error(`cannot dequeue ${e7} event: no event found for id ${t8}`);
    switch (delete this.callbacks[t8], e7) {
      case "privy:iframe:ready":
      case "privy:user-signer:sign":
      case "privy:wallets:add":
      case "privy:wallets:import":
      case "privy:wallets:set-recovery":
      case "privy:wallets:connect":
      case "privy:wallets:recover":
      case "privy:wallets:rpc":
      case "privy:wallet:create":
      case "privy:mfa:verify":
      case "privy:mfa:init-enrollment":
      case "privy:mfa:submit-enrollment":
      case "privy:mfa:unenroll":
      case "privy:mfa:clear":
      case "privy:auth:unlink-passkey":
      case "privy:farcaster:init-signer":
      case "privy:farcaster:sign":
      case "privy:solana-wallet:create":
      case "privy:delegated-actions:consent":
        return r10;
      default:
        throw Error(`invalid wallet event type ${e7}`);
    }
  }
  constructor() {
    this.callbacks = {};
  }
}();
var Qs = /* @__PURE__ */ new Map();
var el = (e7, t8) => "bigint" == typeof t8 ? t8.toString() : t8;
function tl(e7, t8, r10, n6) {
  let a3 = r10.contentWindow;
  if (!a3) throw Error("iframe not initialized");
  let i5 = ((e8, t9) => `${e8}${JSON.stringify(t9, el)}`)(e7, t8);
  if ("privy:wallet:create" === e7) {
    let e8 = Qs.get(i5);
    if (e8) return e8;
  }
  let o4 = new Promise(((r11, i6) => {
    let o5 = Zs();
    Xs.enqueue(o5, { resolve: r11, reject: i6 }), a3.postMessage({ id: o5, event: e7, data: t8 }, n6);
  })).finally((() => {
    Qs.delete(i5);
  }));
  return Qs.set(i5, o4), o4;
}
function rl(e7) {
  let r10 = Wr(), n6 = (0, import_react3.useRef)(null), a3 = (0, import_react3.useRef)(e7.mfaMethods), i5 = Zr(), [o4, c2] = (0, import_react3.useState)(false);
  return (0, import_react3.useEffect)((() => {
    a3.current = e7.mfaMethods;
  }), [e7.mfaMethods]), (0, import_react3.useEffect)((() => {
    if (!o4) return;
    let t8 = n6.current;
    if (!t8) return;
    function r11(t9) {
      var r12;
      t9 && t9.origin === e7.origin && "string" == typeof (r12 = t9.data).event && /^privy:.+/.test(r12.event) && (function(e8) {
        switch (e8.event) {
          case "privy:iframe:ready":
            let t10 = Xs.dequeue(e8.event, e8.id);
            return Js(e8) ? t10.reject(new Ll(e8.error.type, e8.error.message)) : t10.resolve(e8.data);
          case "privy:user-signer:sign": {
            let t11 = Xs.dequeue(e8.event, e8.id);
            return Js(e8) ? t11.reject(new Ll(e8.error.type, e8.error.message)) : t11.resolve(e8.data);
          }
          case "privy:wallets:add": {
            let t11 = Xs.dequeue(e8.event, e8.id);
            return Js(e8) ? t11.reject(new Ll(e8.error.type, e8.error.message)) : t11.resolve(e8.data);
          }
          case "privy:wallets:set-recovery": {
            let t11 = Xs.dequeue(e8.event, e8.id);
            return Js(e8) ? t11.reject(new Ll(e8.error.type, e8.error.message)) : t11.resolve(e8.data);
          }
          case "privy:wallets:connect": {
            let t11 = Xs.dequeue(e8.event, e8.id);
            return Js(e8) ? t11.reject(new Ll(e8.error.type, e8.error.message)) : t11.resolve(e8.data);
          }
          case "privy:wallets:recover": {
            let t11 = Xs.dequeue(e8.event, e8.id);
            return Js(e8) ? t11.reject(new Ll(e8.error.type, e8.error.message)) : t11.resolve(e8.data);
          }
          case "privy:wallets:rpc": {
            let t11 = Xs.dequeue(e8.event, e8.id);
            return Js(e8) ? t11.reject(new Ll(e8.error.type, e8.error.message)) : t11.resolve(e8.data);
          }
          case "privy:wallet:create":
            let r13 = Xs.dequeue(e8.event, e8.id);
            return Js(e8) ? r13.reject(new Ll(e8.error.type, e8.error.message)) : r13.resolve(e8.data);
          case "privy:wallets:import":
            let n7 = Xs.dequeue(e8.event, e8.id);
            return Js(e8) ? n7.reject(new Ll(e8.error.type, e8.error.message)) : n7.resolve(e8.data);
          case "privy:mfa:verify":
            let a4 = Xs.dequeue(e8.event, e8.id);
            return Js(e8) ? a4.reject(new Ll(e8.error.type, e8.error.message)) : a4.resolve(e8.data);
          case "privy:mfa:init-enrollment": {
            let t11 = Xs.dequeue(e8.event, e8.id);
            return Js(e8) ? t11.reject(new Ll(e8.error.type, e8.error.message)) : t11.resolve(e8.data);
          }
          case "privy:mfa:submit-enrollment": {
            let t11 = Xs.dequeue(e8.event, e8.id);
            return Js(e8) ? t11.reject(new Ll(e8.error.type, e8.error.message)) : t11.resolve(e8.data);
          }
          case "privy:mfa:unenroll": {
            let t11 = Xs.dequeue(e8.event, e8.id);
            return Js(e8) ? t11.reject(new Ll(e8.error.type, e8.error.message)) : t11.resolve(e8.data);
          }
          case "privy:mfa:clear": {
            let t11 = Xs.dequeue(e8.event, e8.id);
            return Js(e8) ? t11.reject(new Ll(e8.error.type, e8.error.message)) : t11.resolve(e8.data);
          }
          case "privy:auth:unlink-passkey": {
            let t11 = Xs.dequeue(e8.event, e8.id);
            return Js(e8) ? t11.reject(new Ll(e8.error.type, e8.error.message)) : t11.resolve(e8.data);
          }
          case "privy:solana-wallet:create":
            let i6 = Xs.dequeue(e8.event, e8.id);
            return Js(e8) ? i6.reject(new Ll(e8.error.type, e8.error.message)) : i6.resolve(e8.data);
          case "privy:farcaster:init-signer": {
            let t11 = Xs.dequeue(e8.event, e8.id);
            return Js(e8) ? t11.reject(new Ll(e8.error.type, e8.error.message)) : t11.resolve(e8.data);
          }
          case "privy:farcaster:sign": {
            let t11 = Xs.dequeue(e8.event, e8.id);
            return Js(e8) ? t11.reject(new Ll(e8.error.type, e8.error.message)) : t11.resolve(e8.data);
          }
          case "privy:delegated-actions:consent": {
            let t11 = Xs.dequeue(e8.event, e8.id);
            return Js(e8) ? t11.reject(new Ll(e8.error.type, e8.error.message)) : t11.resolve(e8.data);
          }
          default:
            console.warn("Unsupported wallet proxy method:", e8);
        }
      })(t9.data);
    }
    let s3 = { signWithUserSigner: (r12) => Gs(((n7) => tl("privy:user-signer:sign", { ...r12, ...n7 }, t8, e7.origin)), a3.current, e7.mfaPromise, e7.mfaSubmitPromise, i5), addWallet: (r12) => Gs(((n7) => tl("privy:wallets:add", { ...r12, ...n7 }, t8, e7.origin)), a3.current, e7.mfaPromise, e7.mfaSubmitPromise, i5), setRecovery: (r12) => Gs(((n7) => tl("privy:wallets:set-recovery", { ...r12, ...n7 }, t8, e7.origin)), a3.current, e7.mfaPromise, e7.mfaSubmitPromise, i5), connect: (r12) => Gs(((n7) => tl("privy:wallets:connect", { ...r12, ...n7 }, t8, e7.origin)), a3.current, e7.mfaPromise, e7.mfaSubmitPromise, i5), recover: (r12) => Gs(((n7) => tl("privy:wallets:recover", { ...r12, ...n7 }, t8, e7.origin)), a3.current, e7.mfaPromise, e7.mfaSubmitPromise, i5, !r12.recoveryAccessToken && !r12.recoveryPassword && !r12.recoverySecretOverride), rpc: (r12) => Gs(((n7) => tl("privy:wallets:rpc", { ...r12, ...n7 }, t8, e7.origin)), a3.current, e7.mfaPromise, e7.mfaSubmitPromise, i5), create: (r12) => tl("privy:wallet:create", r12, t8, e7.origin), importWallet: (r12) => tl("privy:wallets:import", r12, t8, e7.origin), createSolana: (r12) => Gs(((n7) => tl("privy:solana-wallet:create", { ...r12, ...n7 }, t8, e7.origin)), a3.current, e7.mfaPromise, e7.mfaSubmitPromise, i5), createDelegatedAction: (r12) => tl("privy:delegated-actions:consent", r12, t8, e7.origin), verifyMfa: (r12) => Gs(((n7) => tl("privy:mfa:verify", { ...r12, ...n7 }, t8, e7.origin)), a3.current, e7.mfaPromise, e7.mfaSubmitPromise, i5, true), initEnrollMfa: (r12) => Gs(((n7) => tl("privy:mfa:init-enrollment", { ...r12, ...n7 }, t8, e7.origin)), a3.current, e7.mfaPromise, e7.mfaSubmitPromise, i5), submitEnrollMfa: (r12) => Gs(((n7) => tl("privy:mfa:submit-enrollment", { ...r12, ...n7 }, t8, e7.origin)), a3.current, e7.mfaPromise, e7.mfaSubmitPromise, i5), unenrollMfa: (r12) => Gs(((n7) => tl("privy:mfa:unenroll", { ...r12, ...n7 }, t8, e7.origin)), a3.current, e7.mfaPromise, e7.mfaSubmitPromise, i5), clearMfa: (r12) => tl("privy:mfa:clear", r12, t8, e7.origin), unlinkPasskeyAccount: (r12) => Gs(((n7) => tl("privy:auth:unlink-passkey", { ...r12, ...n7 }, t8, e7.origin)), a3.current, e7.mfaPromise, e7.mfaSubmitPromise, i5), initFarcasterSigner: (r12) => tl("privy:farcaster:init-signer", r12, t8, e7.origin), signFarcasterMessage: (r12) => tl("privy:farcaster:sign", r12, t8, e7.origin) };
    window.addEventListener("message", r11);
    let l5 = new AbortController();
    return wa((() => tl("privy:iframe:ready", {}, t8, e7.origin)), { abortSignal: l5.signal }).then((() => e7.onLoad(s3)), ((...t9) => {
      console.warn("Privy iframe failed to load: ", ...t9), e7.onLoadFailed();
    })), () => {
      window.removeEventListener("message", r11), l5.abort();
    };
  }), [o4]), r10 ? (0, import_jsx_runtime2.jsx)("iframe", { ref: n6, width: "0", height: "0", style: { display: "none", height: "0px", width: "0px" }, onLoad: () => c2(true), src: va2(e7.origin, `/apps/${e7.appId}/embedded-wallets`, { caid: e7.clientAnalyticsId, client_id: e7.appClientId }) }) : null;
}
var nl = ({ address: e7, user: t8 }) => {
  let r10 = t8.linkedAccounts.find(((t9) => "wallet" === t9.type && "privy" === t9.walletClientType && t9.address === e7));
  if (!r10) throw new _("Address to delegate is not associated with current user.");
  if (!M2(r10)) throw new _(`useDelegatedActions is not supported for ${r10.chainType} wallets. Use the useSessionSigners hook to provision server side access on behalf of your users.`);
  return { address: r10.address, chainType: r10.chainType, walletIndex: r10.walletIndex ?? 0 };
};
var al = ({ address: e7, user: t8 }) => {
  let r10 = t8.linkedAccounts.find(((t9) => "wallet" === t9.type && "privy" === t9.walletClientType && t9.address === e7));
  if (!r10) throw new _("Address to delegate is not associated with current user.");
  let n6 = r10.imported ? r10 : y2(t8);
  if (!n6) throw new _("Unable to determine root address for delegated address.");
  if (!M2(n6)) throw new _(`useDelegatedActions is not supported for ${n6.chainType} wallets. Use the useSessionSigners hook to provision server side access on behalf of your users.`);
  return { address: n6.address, chainType: n6.chainType, imported: n6.imported };
};
var il = (e7) => e7.linkedAccounts.filter(((e8) => "wallet" === e8.type && "privy" === e8.walletClientType && e8.delegated));
var ol = () => {
  let e7 = Pr();
  (0, import_react3.useEffect)((() => {
    (async (e8) => {
      let t8 = new URL("v3/wallets", "https://explorer-api.walletconnect.com");
      t8.searchParams.append("projectId", e8);
      let r10 = await fetch(t8);
      return r10.ok ? Object.values((await r10.json()).listings).sort((({ slug: e9 }, { slug: t9 }) => "rainbow" === e9 && "metamask" === t9 ? 1 : "metamask" === e9 || "rainbow" === e9 ? -1 : 1)) : (console.debug(`Failed to fetch WalletConnect listings: ${await r10.text().catch((() => "No response."))}`), []);
    })(e7.walletConnectCloudProjectId).then(((e8) => fr({ listings: e8 }))).catch(console.error);
  }), [e7.walletConnectCloudProjectId]);
};
var sl = "popup-privy-oauth";
var ll = "PRIVY_OAUTH_USE_BROADCAST_CHANNEL";
var cl = class {
  async authenticate() {
    if (!this.api) throw new _("Auth flow has no API instance");
    try {
      return await this.api.post(q, { authorization_code: this.meta.authorizationCode, state_code: this.meta.stateCode, code_verifier: this.meta.codeVerifier, provider: this.meta.provider });
    } catch (e7) {
      throw n(e7);
    }
  }
  async link() {
    if (!this.api) throw new _("Auth flow has no API instance");
    try {
      return await this.api.post(j, { authorization_code: this.meta.authorizationCode, state_code: this.meta.stateCode, code_verifier: this.meta.codeVerifier, provider: this.meta.provider });
    } catch (e7) {
      throw n(e7);
    }
  }
  constructor({ authorizationCode: e7, stateCode: t8, codeVerifier: r10, provider: n6 }) {
    this.meta = { authorizationCode: e7, stateCode: t8, codeVerifier: r10, provider: n6 };
  }
};
async function dl({ api: e7, requesterAppId: t8, providerAppId: r10 }) {
  let n6 = (await e7.get(`/api/v1/apps/${t8}/cross-app/connections`)).connections.find(((e8) => e8.provider_app_id === r10));
  if (!n6) throw new _("Invalid connected app");
  return { name: n6.provider_app_name, logoUrl: n6.provider_app_icon_url || void 0, apiUrl: n6.provider_app_custom_api_url, readOnly: n6.read_only, customAuthAuthorizeUrl: n6.provider_app_custom_auth_authorize_url, customAuthTransactUrl: n6.provider_app_custom_auth_transact_url };
}
var ul = async ({ user: e7, address: t8, client: r10, request: n6, requesterAppId: a3, reconnect: i5 }) => {
  r10.createAnalyticsEvent({ eventName: "cross_app_request_started", payload: { address: t8, method: n6.method } });
  let o4 = e7?.linkedAccounts.find(((e8) => "cross_app" === e8.type && (e8.embeddedWallets.some(((e9) => e9.address === t8)) || e8.smartWallets.some(((e9) => e9.address === t8)))));
  if (!e7 || !o4) throw r10.createAnalyticsEvent({ eventName: "cross_app_request_error", payload: { error: "Cannot request a signature with this wallet address", address: t8 } }), new _("Cannot request a signature with this wallet address");
  let s3 = r10.getProviderAccessToken(o4.providerApp.id), l5 = await dl({ api: r10.api, requesterAppId: a3, providerAppId: o4.providerApp.id });
  if (!s3) {
    if (l5.readOnly) throw console.error("cannot transact against a read-only provider app"), new _("Cannot transact against a read-only provider app");
    await i5({ appId: o4.providerApp.id, action: "link" }) && (s3 = r10.getProviderAccessToken(o4.providerApp.id));
  }
  if (!s3) throw r10.createAnalyticsEvent({ eventName: "cross_app_request_error", payload: { error: "Transactions require a valid token", address: t8 } }), new _("Transactions require a valid token");
  let c2 = zl();
  if (!c2) throw r10.createAnalyticsEvent({ eventName: "cross_app_request_error", payload: { error: "Missing token", address: t8 } }), new _("Failed to initialize signature request");
  let d2 = new URL(l5.customAuthTransactUrl || `${l5.apiUrl}/oauth/transact`);
  return d2.searchParams.set("token", s3 || ""), d2.searchParams.set("request", hl(n6)), c2.location = d2.href, new Promise(((e8, a4) => {
    let i6 = setTimeout((() => {
      d3(), a4(new _("Request timeout")), r10.createAnalyticsEvent({ eventName: "cross_app_request_error", payload: { error: "Request timeout", address: t8 } });
    }), 12e4), s4 = setInterval((() => {
      c2.closed && (d3(), a4(new _("User rejected request")), r10.createAnalyticsEvent({ eventName: "cross_app_request_error", payload: { error: "User rejected request", address: t8 } }));
    }), 300), l6 = (i7) => {
      i7.data && ("set" === i7.data.token?.action && void 0 !== i7.data.token?.value ? r10.storeProviderAccessToken(o4.providerApp.id, i7.data.token.value) : "clear" === i7.data.token?.action && r10.storeProviderAccessToken(o4.providerApp.id, null), "PRIVY_CROSS_APP_ACTION_RESPONSE" === i7.data.type && i7.data.result && (d3(), e8(i7.data.result), r10.createAnalyticsEvent({ eventName: "cross_app_request_success", payload: { address: t8, method: n6.method } })), "PRIVY_CROSS_APP_ACTION_ERROR" === i7.data.type && i7.data.error && (d3(), a4(i7.data.error), r10.createAnalyticsEvent({ eventName: "cross_app_request_error", payload: { error: i7.data.error, address: t8 } })));
    };
    window.addEventListener("message", l6);
    let d3 = () => {
      c2.close(), clearInterval(s4), clearTimeout(i6), window.removeEventListener("message", l6);
    };
  }));
};
var hl = (e7) => JSON.stringify({ content: { request: { request: pl(e7, toHex) } }, timestamp: Date.now(), callbackUrl: window.origin });
var pl = (e7, t8) => "bigint" == typeof e7 ? t8(e7) : Array.isArray(e7) ? e7.map(((e8) => pl(e8, t8))) : e7 && "object" == typeof e7 ? Object.fromEntries(Object.entries(e7).map((([e8, r10]) => [e8, pl(r10, t8)]))) : e7;
var ml = ({ passkeys: e7, isLoading: r10, errorReason: n6, success: a3, expanded: i5, onLinkPasskey: o4, onUnlinkPasskey: s3, onExpand: l5, onBack: c2, onClose: d2 }) => (0, import_jsx_runtime2.jsx)(ho, a3 ? { title: "Passkeys updated", icon: CircleCheckBig, iconVariant: "success", primaryCta: { label: "Done", onClick: d2 }, onClose: d2, watermark: true } : i5 ? { icon: Fingerprint, title: "Your passkeys", onBack: c2, onClose: d2, watermark: true, children: (0, import_jsx_runtime2.jsx)(yl, { passkeys: e7, expanded: i5, onUnlink: s3, onExpand: l5 }) } : { icon: Fingerprint, title: "Set up passkey verification", subtitle: "Verify with passkey", primaryCta: { label: "Add new passkey", onClick: o4, loading: r10 }, onClose: d2, watermark: true, helpText: n6 || void 0, children: 0 === e7.length ? (0, import_jsx_runtime2.jsx)(gl, {}) : (0, import_jsx_runtime2.jsx)(wl, { children: (0, import_jsx_runtime2.jsx)(yl, { passkeys: e7, expanded: i5, onUnlink: s3, onExpand: l5 }) }) });
var wl = dt.div.withConfig({ displayName: "ContentContainer", componentId: "sc-d4c46a0c-0" })(["margin-bottom:12px;"]);
var yl = ({ passkeys: e7, expanded: n6, onUnlink: a3, onExpand: i5 }) => {
  let [o4, s3] = (0, import_react3.useState)([]), c2 = n6 ? e7.length : 2, d2 = (e8) => e8.authenticatorName ? e8.createdWithBrowser ? `${e8.authenticatorName} on ${e8.createdWithBrowser}` : e8.authenticatorName : e8.createdWithBrowser ? e8.createdWithOs ? `${e8.createdWithBrowser} on ${e8.createdWithOs}` : `${e8.createdWithBrowser}` : "Unknown device";
  return (0, import_jsx_runtime2.jsxs)("div", { children: [(0, import_jsx_runtime2.jsx)(bl, { children: "Your passkeys" }), (0, import_jsx_runtime2.jsxs)(Al, { children: [e7.slice(0, c2).map(((e8) => (0, import_jsx_runtime2.jsxs)(El2, { children: [(0, import_jsx_runtime2.jsxs)("div", { children: [(0, import_jsx_runtime2.jsx)(Tl, { children: d2(e8) }), (0, import_jsx_runtime2.jsxs)(_l2, { children: ["Last used:", " ", (e8.latestVerifiedAt ?? e8.firstVerifiedAt)?.toLocaleString() ?? "N/A"] })] }), (0, import_jsx_runtime2.jsx)(Sl2, { disabled: o4.includes(e8.credentialId), onClick: () => (async (e9) => {
    s3(((t8) => t8.concat([e9]))), await a3(e9), s3(((t8) => t8.filter(((t9) => t9 !== e9))));
  })(e8.credentialId), children: o4.includes(e8.credentialId) ? (0, import_jsx_runtime2.jsx)(yi, {}) : (0, import_jsx_runtime2.jsx)(Trash2, { size: 16 }) })] }, e8.credentialId))), e7.length > 2 && !n6 && (0, import_jsx_runtime2.jsx)(kl2, { onClick: i5, children: "View all" })] })] });
};
var gl = () => (0, import_jsx_runtime2.jsxs)(th, { style: { color: "var(--privy-color-foreground)" }, children: [(0, import_jsx_runtime2.jsx)(nh, { children: "Verify with Touch ID, Face ID, PIN, or hardware key" }), (0, import_jsx_runtime2.jsx)(nh, { children: "Takes seconds to set up and use" }), (0, import_jsx_runtime2.jsx)(nh, { children: "Use your passkey to verify transactions and login to your account" })] });
var fl = { component: () => {
  let { user: e7, unlinkPasskey: r10 } = v2(), { linkWithPasskey: n6, closePrivyModal: a3 } = s(), i5 = e7?.linkedAccounts.filter(((e8) => "passkey" === e8.type)), [o4, c2] = (0, import_react3.useState)(false), [d2, u2] = (0, import_react3.useState)(""), [h7, p5] = (0, import_react3.useState)(false), [m4, w4] = (0, import_react3.useState)(false);
  return (0, import_react3.useEffect)((() => {
    0 === i5.length && w4(false);
  }), [i5.length]), (0, import_jsx_runtime2.jsx)(ml, { passkeys: i5, isLoading: o4, errorReason: d2, success: h7, expanded: m4, onLinkPasskey: () => {
    c2(true), n6().then((() => p5(true))).catch(((e8) => {
      if (e8 instanceof e) {
        if (e8.privyErrorCode === p.CANNOT_LINK_MORE_OF_TYPE) return void u2("Cannot link more passkeys to account.");
        if (e8.privyErrorCode === p.PASSKEY_NOT_ALLOWED) return void u2("Passkey request timed out or rejected by user.");
      }
      u2("Unknown error occurred.");
    })).finally((() => {
      c2(false);
    }));
  }, onUnlinkPasskey: async (e8) => (c2(true), await r10(e8).then((() => p5(true))).catch(((e9) => {
    e9 instanceof e && e9.privyErrorCode === p.MISSING_MFA_CREDENTIALS ? u2("Cannot unlink a passkey enrolled in MFA") : u2("Unknown error occurred.");
  })).finally((() => {
    c2(false);
  }))), onExpand: () => w4(true), onBack: () => w4(false), onClose: () => a3() });
} };
var vl = dt.div.withConfig({ displayName: "DoubleIconWrapper", componentId: "sc-d4c46a0c-1" })(["display:flex;align-items:center;justify-content:center;width:180px;height:90px;border-radius:50%;svg + svg{margin-left:12px;}> svg{z-index:2;color:var(--privy-color-accent) !important;stroke:var(--privy-color-accent) !important;fill:var(--privy-color-accent) !important;}"]);
var Cl = lt(["&&{width:100%;font-size:0.875rem;line-height:1rem;@media (min-width:440px){font-size:14px;}display:flex;gap:12px;justify-content:center;padding:6px 8px;background-color:var(--privy-color-background);transition:background-color 200ms ease;color:var(--privy-color-accent) !important;:focus{outline:none;box-shadow:none;}}"]);
var kl2 = dt.button.withConfig({ displayName: "LinkButton", componentId: "sc-d4c46a0c-2" })(["", ""], Cl);
var Al = dt.div.withConfig({ displayName: "List", componentId: "sc-d4c46a0c-3" })(["display:flex;flex-direction:column;align-items:stretch;gap:0.8rem;padding:0.5rem 0rem 0rem;flex-grow:1;width:100%;"]);
var bl = dt.div.withConfig({ displayName: "PasskeyListTitle", componentId: "sc-d4c46a0c-4" })(["line-height:20px;height:20px;font-size:1em;font-weight:450;display:flex;justify-content:flex-beginning;width:100%;"]);
var Tl = dt.div.withConfig({ displayName: "PasskeyItemTitle", componentId: "sc-d4c46a0c-5" })(["font-size:1em;line-height:1.3em;font-weight:500;color:var(--privy-color-foreground-2);padding:0.2em 0;"]);
var _l2 = dt.div.withConfig({ displayName: "PasskeyItemSubtitle", componentId: "sc-d4c46a0c-6" })(["font-size:0.875rem;line-height:1rem;color:#64668b;padding:0.2em 0;"]);
var El2 = dt.div.withConfig({ displayName: "PasskeyListItem", componentId: "sc-d4c46a0c-7" })(["display:flex;align-items:center;justify-content:space-between;padding:1em;gap:10px;font-size:0.875rem;line-height:1rem;text-align:left;border-radius:8px;border:1px solid #e2e3f0 !important;width:100%;height:5em;"]);
var Il = lt([":focus,:hover,:active{outline:none;}display:flex;width:2em;height:2em;justify-content:center;align-items:center;svg{color:var(--privy-color-error);}svg:hover{color:var(--privy-color-foreground-3);}"]);
var Sl2 = dt.button.withConfig({ displayName: "PasskeyItemUnlinkButton", componentId: "sc-d4c46a0c-8" })(["", ""], Il);
var Ul2 = /* @__PURE__ */ new Map([[vm, null], [Kg, "external"], [Gg, "external"], [Pf, "external"], [Yg, "external"], [bm, "manual"], [dm, "moonpay"]]);
var Pl2 = () => {
  let e7 = Pr(), { user: t8 } = v2(), { client: r10, refreshSessionAndUser: n6, walletProxy: a3 } = s();
  return { migrate: (0, import_react3.useCallback)((async () => {
    if ("legacy-embedded-wallets-only" === e7.embeddedWallets.mode) return { success: true };
    if (!t8) throw new _("User must be authenticated before migrating wallets", p.MUST_BE_AUTHENTICATED);
    let i5 = y2(t8);
    if (!i5 || b2(i5) || !M2(i5)) return { success: true };
    if (!a3) throw new _("Cannot connect to wallet proxy");
    let o4 = await r10.getAccessToken();
    if (!o4) throw new _("User must be authenticated before migrating wallets", p.MUST_BE_AUTHENTICATED);
    let s3 = i5.imported ? [i5] : t8.linkedAccounts.filter(((e8) => "wallet" === e8.type && "privy" === e8.walletClientType && !e8.imported)).filter(M2), { entropyId: l5, entropyIdVerifier: c2 } = Ra2(t8, i5);
    try {
      await a3.connect({ accessToken: o4, entropyId: l5, entropyIdVerifier: c2 });
    } catch (e8) {
      if (!Pl(e8) || "privy" !== i5.recoveryMethod) throw e8;
      await a3.recover({ accessToken: o4, entropyId: l5, entropyIdVerifier: c2 });
    }
    return await a3.createDelegatedAction({ accessToken: o4, rootWallet: { address: i5.address, chainType: i5.chainType, imported: i5.imported }, delegatedWallets: s3 }), await n6(), { success: true };
  }), [e7.embeddedWallets.mode, t8, a3, r10, n6]) };
};
var Wl2 = ({ disabled: e7 }) => {
  let { migrate: t8 } = Pl2(), { user: r10 } = v2(), { walletProxy: n6 } = s();
  return (0, import_react3.useEffect)((() => {
    !e7 && r10 && n6 && t8().catch(((e8) => {
      console.debug("Unable to migrate wallets: ", e8);
    }));
  }), [r10, n6, e7, t8]), null;
};
var xl = (e7) => ({ id: e7.id, raw_id: e7.rawId, response: { client_data_json: e7.response.clientDataJSON, authenticator_data: e7.response.authenticatorData, signature: e7.response.signature, user_handle: e7.response.userHandle }, authenticator_attachment: e7.authenticatorAttachment, client_extension_results: { app_id: e7.clientExtensionResults.appid, cred_props: e7.clientExtensionResults.credProps, hmac_create_secret: e7.clientExtensionResults.hmacCreateSecret }, type: e7.type });
var Nl2 = ({ providerApp: e7, success: r10, error: n6, onClose: a3 }) => {
  let { title: i5, subtitle: s3 } = (0, import_react3.useMemo)((() => r10 ? { title: `Successfully connected with ${e7.name}`, subtitle: "You're good to go!" } : n6 ? { title: "Authentication failed", subtitle: n6.message } : { title: `Connecting to ${e7.name}`, subtitle: `Please check the pop-up from ${e7.name} to continue` }), [r10, n6, e7.name]);
  return (0, import_jsx_runtime2.jsx)(ho, { title: i5, subtitle: s3, icon: e7.logoUrl, iconVariant: "loading", iconLoadingStatus: { success: r10, fail: !!n6 }, onBack: a3, watermark: true });
};
var Rl2 = { component: () => {
  let e7 = Pr(), { data: r10, navigate: n6, setModalData: a3, onUserCloseViaDialogOrKeybindRef: i5 } = Or(), { crossAppAuthFlow: o4, updateWallets: c2, closePrivyModal: d2, createAnalyticsEvent: u2 } = s(), { logout: h7 } = y4(), [p5, m4] = (0, import_react3.useState)({}), w4 = r10?.crossAppAuth, y6 = { id: w4.appId, name: w4.name, logoUrl: w4.logoUrl }, g2 = new _(`There was an issue connecting your ${y6.name} account. Please try again.`), f4 = new mn((async (e8) => {
    if (w4.popup) try {
      let t8 = await o4({ appId: e8, popup: w4.popup, action: w4.action });
      m4({ data: t8 });
    } catch (e9) {
      if (e9 instanceof _) m4({ error: e9 });
      else if (e9 instanceof t) {
        if (e9.privyErrorCode === p.ACCOUNT_TRANSFER_REQUIRED && e9.data?.data?.nonce) return a3({ accountTransfer: { nonce: e9.data?.data?.nonce, account: e9.data?.data?.subject, displayName: e9.data?.data?.account?.displayName, linkMethod: `privy:${y6.id}`, embeddedWalletAddress: e9.data?.data?.otherUser?.embeddedWalletAddress, oAuthUserInfo: e9.data?.data?.otherUser?.oAuthUserInfo } }), void n6(ed);
        w4.popup && w4.popup.close(), m4({ error: g2 });
      } else m4({ error: g2 });
    }
    else m4({ error: g2 });
  })), v5 = () => {
    p5.data && (c2(), w4.onSuccess(p5.data), d2({ shouldCallAuthOnSuccess: true, isSuccess: true })), w4.onError(p5.error ?? new _("User canceled flow")), d2({ shouldCallAuthOnSuccess: false, isSuccess: false });
  };
  return i5.current = v5, (0, import_react3.useEffect)((() => {
    y6.id.length && f4.execute(y6.id);
  }), [y6.id]), (0, import_react3.useEffect)((() => {
    if (!p5.data) return;
    let t8 = p5.data;
    if (e7.legal.requireUsersAcceptTerms && !t8.hasAcceptedTerms) {
      let e8 = setTimeout((() => {
        n6(id);
      }), wn);
      return () => clearTimeout(e8);
    }
    if (bc(t8, e7.embeddedWallets)) {
      let e8 = setTimeout((() => {
        a3({ createWallet: { onSuccess: () => {
        }, onFailure: (e9) => {
          console.error(e9), u2({ eventName: "embedded_wallet_creation_failure_logout", payload: { error: e9, provider: `privy:${y6.id}`, screen: "CrossAppAuthScreen" } }), h7();
        }, callAuthOnSuccessOnClose: true } }), n6(rd);
      }), wn);
      return () => clearTimeout(e8);
    }
    let r11 = setTimeout(v5, wn);
    return () => clearTimeout(r11);
  }), [p5.data]), (0, import_jsx_runtime2.jsx)(Nl2, { providerApp: y6, success: !!p5.data, error: p5.error, onClose: v5 });
} };
var Ol2 = ({ appName: e7, address: r10, success: n6, error: a3, onAccept: i5, onDecline: o4, onClose: s3 }) => (0, import_jsx_runtime2.jsx)(ho, n6 || a3 ? { title: a3 ? "Something went wrong" : "Success!", subtitle: a3 ? "Please try again." : `You've successfully granted delegated action permissions to ${e7}.`, icon: a3 ? CircleAlert : CircleCheckBig, iconVariant: a3 ? "error" : "success", onBack: s3, watermark: true } : { title: "Enable offline access", subtitle: `By confirming, ${e7} will be able to use your wallet for you even when you're not around. You can revoke this later.`, icon: CloudUpload, primaryCta: { label: "Accept", onClick: i5 }, secondaryCta: { label: "Not now", onClick: o4 }, onBack: s3, watermark: true, children: (0, import_jsx_runtime2.jsx)(Yh, { address: r10, title: "Wallet" }) });
var Ml2 = { component: () => {
  let { app: e7, data: r10 } = Or(), { closePrivyModal: n6 } = s(), [a3, i5] = (0, import_react3.useState)(false), [o4, c2] = (0, import_react3.useState)(), { address: d2, onDelegate: u2, onSuccess: h7, onError: p5 } = r10.delegatedActions.consent, m4 = async () => {
    a3 ? h7() : p5(o4 ?? new _("User declined delegating actions.")), n6({ shouldCallAuthOnSuccess: false });
  };
  return (0, import_react3.useEffect)((() => {
    if (!a3 && !o4) return;
    let e8 = setTimeout(m4, vn);
    return () => clearTimeout(e8);
  }), [a3, o4]), (0, import_jsx_runtime2.jsx)(Ol2, { appName: e7.name, address: d2, success: a3, error: o4, onAccept: async () => {
    try {
      await u2(), i5(true);
    } catch (e8) {
      c2(e8);
    }
  }, onDecline: () => {
    m4();
  }, onClose: m4 });
} };
var Fl = ({ appName: e7, success: r10, error: n6, onRevoke: a3, onDeny: i5, onClose: o4 }) => (0, import_jsx_runtime2.jsx)(ho, r10 || n6 ? { title: n6 ? "Something went wrong" : "Success!", subtitle: n6 ? "Please try again." : "You've successfully revoked permissions.", icon: n6 ? CircleAlert : CircleCheckBig, iconVariant: n6 ? "error" : "success", onBack: o4, watermark: true } : { title: "Revoke offline access to wallet", subtitle: `By confirming, ${e7} will no longer be able to use this wallet on your behalf when you are not online.`, icon: Ban, primaryCta: { label: "Confirm", onClick: a3 }, secondaryCta: { label: "Deny", onClick: i5 }, onBack: o4, watermark: true });
var Ll2 = { component: () => {
  let { app: e7, data: r10 } = Or(), { closePrivyModal: n6 } = s(), [a3, i5] = (0, import_react3.useState)(false), [o4, c2] = (0, import_react3.useState)(), { onRevoke: d2, onSuccess: u2, onError: h7 } = r10.delegatedActions.revoke, p5 = async () => {
    a3 ? u2() : h7(o4 ?? new _("User declined revoking access to their delegated wallet.")), n6({ shouldCallAuthOnSuccess: false });
  };
  return (0, import_react3.useEffect)((() => {
    if (!a3 && !o4) return;
    let e8 = setTimeout(p5, vn);
    return () => clearTimeout(e8);
  }), [a3, o4]), (0, import_jsx_runtime2.jsx)(Fl, { appName: e7.name, success: a3, error: o4, onRevoke: async () => {
    try {
      await d2(), i5(true);
    } catch (e8) {
      c2(e8);
    }
  }, onDeny: () => {
    p5();
  }, onClose: p5 });
} };
var Dl = "#8a63d2";
var ql = ({ appName: e7, loading: n6, success: a3, errorMessage: i5, connectUri: o4, onBack: s3, onClose: l5, onOpenFarcaster: c2 }) => (0, import_jsx_runtime2.jsx)(ho, import_react_device_detect.isMobile || n6 ? import_react_device_detect.isIOS ? { title: i5 ? i5.message : "Add a signer to Farcaster", subtitle: i5 ? i5.detail : `This will allow ${e7} to add casts, likes, follows, and more on your behalf.`, icon: Pp, iconVariant: "loading", iconLoadingStatus: { success: a3, fail: !!i5 }, primaryCta: o4 && c2 ? { label: "Open Farcaster app", onClick: c2 } : void 0, onBack: s3, onClose: l5, watermark: true } : { title: i5 ? i5.message : "Requesting signer from Farcaster", subtitle: i5 ? i5.detail : "This should only take a moment", icon: Pp, iconVariant: "loading", iconLoadingStatus: { success: a3, fail: !!i5 }, onBack: s3, onClose: l5, watermark: true, children: o4 && import_react_device_detect.isMobile && (0, import_jsx_runtime2.jsx)(zl2, { children: (0, import_jsx_runtime2.jsx)(Wp, { text: "Take me to Farcaster", url: o4, color: Dl }) }) } : { title: "Add a signer to Farcaster", subtitle: `This will allow ${e7} to add casts, likes, follows, and more on your behalf.`, onBack: s3, onClose: l5, watermark: true, children: (0, import_jsx_runtime2.jsxs)(Bl2, { children: [(0, import_jsx_runtime2.jsx)(jl, { children: o4 ? (0, import_jsx_runtime2.jsx)(xd, { url: o4, size: 275, squareLogoElement: Pp }) : (0, import_jsx_runtime2.jsx)($l, { children: (0, import_jsx_runtime2.jsx)(mi, {}) }) }), (0, import_jsx_runtime2.jsxs)(Hl, { children: [(0, import_jsx_runtime2.jsx)(Vl, { children: "Or copy this link and paste it into a phone browser to open the Farcaster app." }), o4 && (0, import_jsx_runtime2.jsx)(Zf, { text: o4, itemName: "link", color: Dl })] })] }) });
var zl2 = dt.div.withConfig({ displayName: "MobileLinkContainer", componentId: "sc-da518e1f-0" })(["margin-top:24px;"]);
var Bl2 = dt.div.withConfig({ displayName: "ContentContainer", componentId: "sc-da518e1f-1" })(["display:flex;flex-direction:column;align-items:center;gap:24px;"]);
var jl = dt.div.withConfig({ displayName: "QrContainer", componentId: "sc-da518e1f-2" })(["padding:24px;position:relative;display:flex;align-items:center;justify-content:center;min-height:275px;"]);
var Hl = dt.div.withConfig({ displayName: "InstructionsContainer", componentId: "sc-da518e1f-3" })(["display:flex;flex-direction:column;align-items:center;gap:16px;"]);
var Vl = dt.div.withConfig({ displayName: "InstructionText", componentId: "sc-da518e1f-4" })(["font-size:0.875rem;text-align:center;color:var(--privy-color-foreground-2);"]);
var $l = dt.div.withConfig({ displayName: "LoaderWrapper", componentId: "sc-da518e1f-5" })(["position:relative;width:82px;height:82px;"]);
var Kl = { component: () => {
  let { lastScreen: e7, navigateBack: r10, data: n6, app: a3 } = Or(), { requestFarcasterSignerStatus: i5, closePrivyModal: o4 } = s(), [c2, d2] = (0, import_react3.useState)(void 0), [h7, p5] = (0, import_react3.useState)(false), [m4, w4] = (0, import_react3.useState)(false), y6 = (0, import_react3.useRef)([]), g2 = n6?.farcasterSigner;
  (0, import_react3.useEffect)((() => {
    let e8 = Date.now(), t8 = setInterval((async () => {
      if (!g2?.public_key) return clearInterval(t8), void d2({ retryable: true, message: "Connect failed", detail: "Something went wrong. Please try again." });
      "approved" === g2.status && (clearInterval(t8), p5(false), w4(true), y6.current.push(setTimeout((() => o4({ shouldCallAuthOnSuccess: false, isSuccess: true })), wn)));
      let r11 = await i5(g2?.public_key), n7 = Date.now() - e8;
      "approved" === r11.status ? (clearInterval(t8), p5(false), w4(true), y6.current.push(setTimeout((() => o4({ shouldCallAuthOnSuccess: false, isSuccess: true })), wn))) : n7 > 3e5 ? (clearInterval(t8), d2({ retryable: true, message: "Connect failed", detail: "The request timed out. Try again." })) : "revoked" === r11.status && (clearInterval(t8), d2({ retryable: true, message: "Request rejected", detail: "The request was rejected. Please try again." }));
    }), 2e3);
    return () => {
      clearInterval(t8), y6.current.forEach(((e9) => clearTimeout(e9)));
    };
  }), []);
  let f4 = "pending_approval" === g2?.status ? g2.signer_approval_url : void 0;
  return (0, import_jsx_runtime2.jsx)(ql, { appName: a3.name, loading: h7, success: m4, errorMessage: c2, connectUri: f4, onBack: e7 ? r10 : void 0, onClose: o4, onOpenFarcaster: () => {
    f4 && (window.location.href = f4);
  } });
} };
var Gl = ({ onClose: e7 }) => (0, import_jsx_runtime2.jsx)(ho, { title: "Could not log in with provider", subtitle: "It looks like you're using an in-app browser. To log in, please try again using an external browser.", icon: ExternalLink, primaryCta: { label: "Close", onClick: e7 }, watermark: true });
var Yl = { component: () => {
  let { closePrivyModal: e7 } = s();
  return (0, import_jsx_runtime2.jsx)(Gl, { onClose: () => e7() });
} };
var Zl = ({ title: e7 = "Connect your email", subtitle: r10 = "Add your email to your account" }) => (0, import_jsx_runtime2.jsx)(ho, { title: e7, subtitle: r10, icon: EnvelopeIcon_default, watermark: true, children: (0, import_jsx_runtime2.jsx)($o, { children: (0, import_jsx_runtime2.jsx)(qu, { stacked: true }) }) });
var Jl = { component: () => {
  let { app: e7 } = Or();
  return (0, import_jsx_runtime2.jsx)(Zl, { subtitle: `Add your email to your ${e7?.name} account` });
} };
var Xl = ({ title: e7 = "Connect your phone", subtitle: r10 = "Add your number to your account", onSubmit: n6, isSubmitting: a3 = false }) => {
  let [i5, o4] = (0, import_react3.useState)(null), s3 = async () => {
    i5?.qualifiedPhoneNumber && await n6(i5);
  };
  return (0, import_jsx_runtime2.jsx)(ho, { title: e7, subtitle: r10, icon: PhoneIcon_default, primaryCta: { label: a3 ? "Submitting" : "Submit", onClick: s3, disabled: !i5?.isValid || a3 }, watermark: true, children: (0, import_jsx_runtime2.jsx)(du, { onChange: (e8) => {
    o4(e8);
  }, onSubmit: s3, noIncludeSubmitButton: true, hideRecent: true }) });
};
var Ql = { component: () => {
  let { app: e7, currentScreen: r10, data: n6, navigate: a3, setModalData: i5 } = Or(), { initLoginWithSms: o4 } = s(), [s3, c2] = (0, import_react3.useState)(false);
  return (0, import_jsx_runtime2.jsx)(Xl, { subtitle: `Add your number to your ${e7?.name} account`, onSubmit: async (e8) => {
    c2(true);
    try {
      await o4({ phoneNumber: e8.qualifiedPhoneNumber, withPrivyUi: true }), a3(Ou);
    } catch (e9) {
      i5({ errorModalData: { error: e9, previousScreen: n6?.errorModalData?.previousScreen || r10 || Ql } }), a3(zc);
    } finally {
      c2(false);
    }
  }, isSubmitting: s3 });
} };
var ec = ({ title: e7 = "Could not connect with wallet", subtitle: r10 = "Please check that Phantom multichain is enabled and try again.", primaryCtaText: n6 = "Try again", secondaryCtaText: a3 = "Cancel", onTryAgain: i5, onCancel: o4 }) => (0, import_jsx_runtime2.jsx)(ho, { title: e7, subtitle: r10, icon: CircleX, iconVariant: "error", primaryCta: { label: n6, onClick: i5 }, secondaryCta: { label: a3, onClick: o4 }, watermark: true });
var tc = { component: () => {
  let { closePrivyModal: e7 } = s(), { navigate: r10 } = Or();
  return (0, import_jsx_runtime2.jsx)(ec, { onTryAgain: () => {
    r10(Ch);
  }, onCancel: async () => {
    await e7();
  } });
} };
function rc2() {
  let { initEnrollmentWithSms: e7, initEnrollmentWithTotp: t8, initEnrollmentWithPasskey: r10, submitEnrollmentWithSms: n6, submitEnrollmentWithTotp: a3, submitEnrollmentWithPasskey: i5, unenroll: o4, enrollInMfa: s3 } = (0, import_react3.useContext)(k2);
  return { initEnrollmentWithSms: e7, initEnrollmentWithTotp: t8, initEnrollmentWithPasskey: r10, submitEnrollmentWithSms: n6, submitEnrollmentWithTotp: a3, submitEnrollmentWithPasskey: i5, unenrollWithSms: () => o4("sms"), unenrollWithTotp: () => o4("totp"), unenrollWithPasskey: (e8) => o4("passkey", e8), showMfaEnrollmentModal: () => s3(true), closeMfaEnrollmentModal: () => s3(false) };
}
var nc2 = (e7) => (0, import_jsx_runtime2.jsxs)(ac, { xmlns: "http://www.w3.org/2000/svg", fill: "none", width: "88", height: "89", viewBox: "0 0 88 89", ...e7, children: [(0, import_jsx_runtime2.jsx)("rect", { y: "0.666016", width: "88", height: "88", rx: "44" }), (0, import_jsx_runtime2.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M45.2463 20.9106C44.5473 20.2486 43.4527 20.2486 42.7537 20.9106C37.8798 25.5263 31.3034 28.3546 24.0625 28.3546C23.9473 28.3546 23.8323 28.3539 23.7174 28.3525C22.9263 28.3427 22.2202 28.8471 21.9731 29.5987C20.9761 32.6311 20.4375 35.8693 20.4375 39.2297C20.4375 53.5896 30.259 65.651 43.5482 69.0714C43.8446 69.1477 44.1554 69.1477 44.4518 69.0714C57.741 65.651 67.5625 53.5896 67.5625 39.2297C67.5625 35.8693 67.0239 32.6311 66.0269 29.5987C65.7798 28.8471 65.0737 28.3427 64.2826 28.3525C64.1677 28.3539 64.0527 28.3546 63.9375 28.3546C56.6966 28.3546 50.1202 25.5263 45.2463 20.9106ZM52.7249 40.2829C53.3067 39.4683 53.1181 38.3363 52.3035 37.7545C51.4889 37.1726 50.3569 37.3613 49.7751 38.1759L41.9562 49.1223L38.0316 45.1977C37.3238 44.4899 36.1762 44.4899 35.4684 45.1977C34.7605 45.9056 34.7605 47.0532 35.4684 47.761L40.9059 53.1985C41.2826 53.5752 41.806 53.7671 42.337 53.7232C42.868 53.6792 43.3527 53.4039 43.6624 52.9704L52.7249 40.2829Z" })] });
var ac = dt.svg.withConfig({ displayName: "StyledSvg", componentId: "sc-59fa943f-0" })(["height:90px;width:90px;> rect{", "}> path{fill:white;}"], ((e7) => "success" === e7.color ? "fill: var(--privy-color-success);" : "fill: var(--privy-color-accent);"));
var ic = ({ showIntro: e7, userMfaMethods: a3, appMfaMethods: i5, userHasAuthSms: o4, isTotpLoading: s3, isPasskeyLoading: l5, error: c2, onClose: d2, onBackToIntro: u2, handleSelectMethod: h7, setRemovingMfaMethod: p5 }) => {
  let m4 = a3.reduce(((e8, t8) => ({ ...e8, [t8]: true })), {}), w4 = i5.reduce(((e8, t8) => ({ ...e8, [t8]: true })), {});
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Di, { backFn: e7 ? u2 : void 0, onClose: d2 }, "header"), (0, import_jsx_runtime2.jsx)(us, { style: { marginBottom: "1.5rem" }, children: (0, import_jsx_runtime2.jsx)(ShieldCheckIcon_default, {}) }), (0, import_jsx_runtime2.jsx)(Zo, { children: "Choose a verification method" }), a3.length > 0 ? (0, import_jsx_runtime2.jsx)(Jo, { children: "To add or delete verification methods, verification is required." }) : (0, import_jsx_runtime2.jsx)(Jo, { children: "How would you like to verify your identity?" }), c2 && (0, import_jsx_runtime2.jsx)(hs, { style: { marginTop: "1.25rem" }, children: c2.message }), (0, import_jsx_runtime2.jsxs)(ns, { children: [(w4.passkey || m4.passkey) && (0, import_jsx_runtime2.jsxs)(as, { children: [(0, import_jsx_runtime2.jsx)(ti, { style: { justifyContent: "center" }, onClick: () => h7("passkey"), disabled: m4.passkey || l5, children: l5 ? (0, import_jsx_runtime2.jsx)(mi, { style: { height: 24, width: 24, borderWidth: 2 }, color: "var(--privy-color-foreground-3)" }) : (0, import_jsx_runtime2.jsxs)(ls, { children: [(0, import_jsx_runtime2.jsxs)(os, { children: [(0, import_jsx_runtime2.jsx)(FingerPrintIcon_default, {}), "Passkey"] }), m4.passkey ? (0, import_jsx_runtime2.jsx)(oc, { color: "green", children: "Enabled" }) : (0, import_jsx_runtime2.jsx)(ss, { $isAccent: true, children: (0, import_jsx_runtime2.jsx)(ChevronRightIcon_default, {}) })] }) }), m4.passkey && (0, import_jsx_runtime2.jsx)(is, { style: { position: "absolute", right: 0 }, onClick: () => p5("passkey"), children: (0, import_jsx_runtime2.jsx)(MinusCircleIcon_default, {}) })] }, "passkey"), (w4.totp || m4.totp) && (0, import_jsx_runtime2.jsxs)(as, { children: [(0, import_jsx_runtime2.jsx)(ti, { style: { justifyContent: "center" }, disabled: m4.totp || s3, onClick: () => h7("totp"), children: s3 ? (0, import_jsx_runtime2.jsx)(mi, { style: { height: 24, width: 24, borderWidth: 2 }, color: "var(--privy-color-foreground-3)" }) : (0, import_jsx_runtime2.jsxs)(ls, { children: [(0, import_jsx_runtime2.jsxs)(os, { children: [(0, import_jsx_runtime2.jsx)(DevicePhoneMobileIcon_default, {}), "Authenticator app"] }), m4.totp && (0, import_jsx_runtime2.jsx)(oc, { color: "green", children: "Enabled" })] }) }), m4.totp && (0, import_jsx_runtime2.jsx)(is, { style: { position: "absolute", right: 0 }, onClick: () => p5("totp"), children: (0, import_jsx_runtime2.jsx)(MinusCircleIcon_default, {}) })] }, "totp"), (w4.sms || m4.sms) && (0, import_jsx_runtime2.jsxs)(as, { children: [(0, import_jsx_runtime2.jsx)(ti, { disabled: m4.sms || o4, onClick: () => h7("sms"), children: (0, import_jsx_runtime2.jsxs)(ls, { children: [(0, import_jsx_runtime2.jsxs)(os, { children: [(0, import_jsx_runtime2.jsx)(PhoneIcon_default, {}), "SMS"] }), m4.sms && (0, import_jsx_runtime2.jsx)(oc, { color: "green", children: "Enabled" }), o4 && (0, import_jsx_runtime2.jsx)(ss, { children: "Disabled" })] }) }), m4.sms && (0, import_jsx_runtime2.jsx)(is, { style: { position: "absolute", right: 0 }, onClick: () => p5("sms"), children: (0, import_jsx_runtime2.jsx)(MinusCircleIcon_default, {}) })] }, "sms")] }), (0, import_jsx_runtime2.jsx)(sc, { children: "You can always change your selection later" }), (0, import_jsx_runtime2.jsx)(pi, {})] });
};
var oc = dt(Lp).withConfig({ displayName: "StyledChip", componentId: "sc-24f8b314-0" })(["margin-right:1.5rem;"]);
var sc = dt(cs).withConfig({ displayName: "StyledTerms", componentId: "sc-24f8b314-1" })(["&&{margin-top:1rem;}text-align:center;"]);
var lc = ({ style: e7, ...n6 }) => (0, import_jsx_runtime2.jsxs)("svg", { x: 0, y: 0, width: "65", height: "64", viewBox: "0 0 65 64", style: { height: "64px", width: "65px", ...e7 }, xmlns: "http://www.w3.org/2000/svg", ...n6, children: [(0, import_jsx_runtime2.jsxs)("g", { clipPath: "url(#clip0_113_33841)", children: [(0, import_jsx_runtime2.jsx)("path", { d: "M39.1193 0.943398C34.636 -0.174912 29.9185 -0.334713 25.328 0.656273C24.9732 0.732859 24.7477 1.08253 24.8243 1.43729C24.9009 1.79205 25.2506 2.01756 25.6053 1.94097C30.0015 0.991934 34.53 1.14842 38.8375 2.22802C49.1385 4.80983 57.7129 12.5548 60.9786 22.6718C62.2416 26.5843 62.7781 30.7505 62.8855 35.1167C62.8945 35.4795 63.1958 35.7664 63.5586 35.7575C63.9215 35.7485 64.2083 35.4472 64.1994 35.0843C64.0905 30.6582 63.5477 26.3849 62.2536 22.3432C58.8621 11.7515 49.9005 3.63265 39.1193 0.943398Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M21.9931 2.93163C22.343 2.83511 22.5484 2.47325 22.4518 2.12339C22.3553 1.77352 21.9935 1.56815 21.6436 1.66466C16.8429 2.98903 10.0898 7.56519 5.91628 13.6786C5.91465 13.681 5.91304 13.6834 5.91145 13.6858C2.24684 19.2083 -0.0503572 26.1484 0.591012 32.8828C0.591623 32.8892 0.592328 32.8956 0.593127 32.902C0.746837 34.1317 1.00488 35.3591 1.26323 36.5879C1.80735 39.1761 2.35282 41.7706 1.92765 44.4064C1.86986 44.7647 2.11347 45.102 2.47177 45.1598C2.83007 45.2176 3.16738 44.974 3.22518 44.6157C3.66961 41.8605 3.11776 39.173 2.56581 36.4851C2.31054 35.2419 2.05525 33.9987 1.89847 32.7486C1.29525 26.3851 3.46802 19.7466 7.00418 14.416C11.0189 8.5373 17.5201 4.16562 21.9931 2.93163Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M30.6166 4.39985C38.8671 3.89603 47.1159 7.26314 52.6556 13.7139C52.8921 13.9893 52.8605 14.4042 52.5852 14.6406C52.3099 14.8771 51.895 14.8455 51.6585 14.5702C46.3904 8.43576 38.541 5.23144 30.6927 5.71195C30.6899 5.71212 30.6871 5.71227 30.6843 5.71241C20.7592 6.19265 11.4643 12.9257 8.04547 22.3603C7.92183 22.7016 7.54498 22.8779 7.20375 22.7543C6.86253 22.6306 6.68616 22.2538 6.80981 21.9126C10.4114 11.9735 20.1717 4.90702 30.6166 4.39985Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M54.6576 16.5848C54.4553 16.2836 54.047 16.2033 53.7457 16.4057C53.4444 16.608 53.3642 17.0163 53.5665 17.3176C56.6376 21.8904 57.9074 26.8665 58.4094 32.7717C58.4401 33.1333 58.7582 33.4016 59.1199 33.3708C59.4815 33.3401 59.7497 33.022 59.719 32.6604C59.206 26.6261 57.8965 21.4076 54.6576 16.5848Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M59.2796 35.4504C59.6419 35.4277 59.9539 35.703 59.9765 36.0653C60.2242 40.0279 60.2265 44.5112 59.7881 47.8243C59.7405 48.1841 59.4102 48.4372 59.0504 48.3896C58.6906 48.342 58.4376 48.0117 58.4852 47.6519C58.9077 44.4586 58.91 40.0704 58.6648 36.1473C58.6421 35.785 58.9174 35.473 59.2796 35.4504Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M7.05311 25.5432C7.13829 25.1904 6.92135 24.8354 6.56855 24.7502C6.21576 24.665 5.86071 24.882 5.77553 25.2348C5.2932 27.2325 5.0428 29.2847 5.03288 31.3388C5.02266 33.4559 5.41742 35.5225 5.81234 37.5899C6.1354 39.2811 6.45855 40.9728 6.5602 42.6932C6.69373 44.9531 6.21839 47.2163 5.39698 49.3703C5.26766 49.7094 5.43774 50.0891 5.77685 50.2184C6.11596 50.3477 6.4957 50.1777 6.62502 49.8386C7.49325 47.5617 8.01954 45.1092 7.87221 42.6157C7.77126 40.9071 7.44813 39.2252 7.12512 37.5439C6.73099 35.4925 6.33704 33.442 6.34716 31.3451C6.35659 29.3933 6.59455 27.4425 7.05311 25.5432Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M24.2964 10.94C24.4317 11.2768 24.2683 11.6595 23.9315 11.7947C17.1187 14.5307 12.0027 20.7047 10.959 27.9852C10.523 31.0269 10.9941 34.0398 11.465 37.052C11.7303 38.7483 11.9954 40.4443 12.0985 42.1451C12.3221 45.833 11.902 49.8839 9.50192 53.5696C9.30387 53.8737 8.89677 53.9597 8.59264 53.7617C8.28851 53.5636 8.20251 53.1565 8.40056 52.8524C10.5873 49.4944 11.0012 45.7644 10.7867 42.2246C10.6821 40.499 10.4185 38.7833 10.1552 37.0686C9.68265 33.9923 9.21067 30.9195 9.65804 27.7987C10.7724 20.025 16.221 13.4748 23.4417 10.5751C23.7785 10.4399 24.1612 10.6032 24.2964 10.94Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M47.3662 14.6814C41.9915 9.64741 34.2017 7.89046 27.122 9.4433C26.7675 9.52105 26.5432 9.87147 26.6209 10.226C26.6987 10.5805 27.0491 10.8048 27.4036 10.7271C34.1075 9.25665 41.4426 10.934 46.4677 15.6406C50.7033 19.6077 53.1628 25.38 53.8066 31.6779C53.8435 32.0389 54.1661 32.3017 54.5272 32.2648C54.8883 32.2279 55.151 31.9053 55.1141 31.5442C54.4456 25.0047 51.8822 18.9111 47.3662 14.6814Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M54.9766 34.6738C55.3376 34.6368 55.6604 34.8994 55.6975 35.2604C56.3216 41.337 56.0526 47.9003 55.1104 54.2496C55.0571 54.6086 54.7229 54.8565 54.3639 54.8032C54.0049 54.7499 53.7571 54.4157 53.8103 54.0567C54.7394 47.7957 55.001 41.3439 54.39 35.3947C54.353 35.0336 54.6156 34.7109 54.9766 34.6738Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M32.0659 13.3553C21.9959 13.3553 13.814 21.3892 13.814 31.3219C13.814 32.3829 13.9081 33.4225 14.0876 34.4334C14.1511 34.7907 14.4922 35.029 14.8495 34.9655C15.2069 34.9021 15.4451 34.561 15.3817 34.2036C15.2155 33.2677 15.1283 32.305 15.1283 31.3219C15.1283 22.1352 22.7014 14.6696 32.0659 14.6696C36.2978 14.6696 40.1642 16.1949 43.1319 18.7152C43.4086 18.9501 43.8233 18.9163 44.0582 18.6396C44.2931 18.363 44.2593 17.9483 43.9827 17.7134C40.7847 14.9975 36.6188 13.3553 32.0659 13.3553Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M45.455 20.1635C45.717 19.9123 46.133 19.921 46.3842 20.183C49.2843 23.2072 50.2126 27.9605 50.8269 31.9494C51.5188 36.4426 51.6244 40.826 51.6244 42.8585C51.6244 43.2214 51.3302 43.5156 50.9673 43.5156C50.6044 43.5156 50.3101 43.2214 50.3101 42.8585C50.3101 40.8589 50.2055 36.5497 49.5279 32.1494C48.9577 28.4462 48.1356 23.9082 45.4356 21.0927C45.1844 20.8307 45.1931 20.4147 45.455 20.1635Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M51.4576 46.6219C51.4864 46.2601 51.2165 45.9435 50.8547 45.9146C50.493 45.8858 50.1763 46.1557 50.1474 46.5175C49.8247 50.5654 49.403 54.6088 48.5474 58.3439C48.4663 58.6977 48.6874 59.0502 49.0412 59.1312C49.3949 59.2123 49.7474 58.9912 49.8285 58.6374C50.7067 54.8039 51.134 50.6806 51.4576 46.6219Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M15.1454 36.852C15.5015 36.7819 15.847 37.0137 15.9171 37.3698C17.3066 44.4257 16.3467 50.8355 12.6672 56.4502C12.4682 56.7537 12.0609 56.8385 11.7573 56.6396C11.4538 56.4407 11.369 56.0333 11.5679 55.7298C15.0299 50.4469 15.9617 44.3985 14.6276 37.6238C14.5575 37.2677 14.7893 36.9221 15.1454 36.852Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M32.0659 17.631C25.5291 17.631 19.1165 22.691 18.462 29.0504C18.1754 31.8345 18.578 34.5769 18.9807 37.3204C19.3323 39.7159 19.684 42.1124 19.5772 44.5381C19.3328 50.0898 17.7039 54.6726 14.905 58.4471C14.6888 58.7386 14.7499 59.1502 15.0414 59.3663C15.333 59.5825 15.7445 59.5214 15.9607 59.2299C18.9293 55.2266 20.6354 50.386 20.8903 44.5959C20.9966 42.1811 20.6438 39.7923 20.2912 37.4051C19.888 34.6752 19.4851 31.9473 19.7694 29.1849C20.3444 23.5983 26.0946 18.9453 32.0659 18.9453C34.851 18.9453 42.057 20.4534 44.3492 27.9205C45.7856 32.5998 46.1774 38.9326 45.8295 45.0849C45.4816 51.2364 44.3994 57.12 42.9442 60.8928C42.8136 61.2314 42.9822 61.6118 43.3208 61.7424C43.6594 61.873 44.0398 61.7044 44.1704 61.3658C45.6929 57.4186 46.7895 51.386 47.1417 45.1591C47.4938 38.9329 47.1068 32.4249 45.6056 27.5348C43.0612 19.2461 35.0851 17.631 32.0659 17.631Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M21.9529 56.4512C22.2569 56.6494 22.3426 57.0566 22.1444 57.3606C21.7369 57.9854 21.3784 58.6391 21.0199 59.2928C20.6614 59.9465 20.3028 60.6004 19.8953 61.2253C19.697 61.5293 19.2898 61.615 18.9858 61.4167C18.6819 61.2184 18.5962 60.8113 18.7944 60.5073C19.2019 59.8825 19.5604 59.2288 19.9189 58.5751C20.2774 57.9213 20.636 57.2675 21.0435 56.6426C21.2418 56.3386 21.649 56.2529 21.9529 56.4512Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M27.5799 24.4525C27.8816 24.2508 27.9625 23.8426 27.7608 23.541C27.559 23.2393 27.1509 23.1583 26.8492 23.3601C24.247 25.1006 22.6505 27.494 22.6505 31.0002C22.6505 33.088 23.0203 34.7946 23.3997 36.5449C23.9674 39.1641 24.3524 41.7777 24.2832 44.468C24.1992 47.7349 23.56 50.7201 22.3313 53.564C22.1873 53.8971 22.3407 54.2839 22.6739 54.4278C23.0071 54.5718 23.3938 54.4184 23.5378 54.0852C24.8369 51.0784 25.509 47.9266 25.5971 44.5018C25.6689 41.7062 25.2732 38.9892 24.6845 36.267C24.3042 34.509 23.9648 32.9394 23.9648 31.0002C23.9648 27.9961 25.2863 25.9866 27.5799 24.4525Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M30.1447 22.1436C32.8717 21.5877 35.8061 22.2746 37.966 24.0228C41.8241 27.1455 42.3372 32.8403 42.753 37.4549L42.7742 37.69C43.3115 43.6385 42.6964 49.4163 41.4575 55.2186C41.3817 55.5736 41.0326 55.7999 40.6776 55.7241C40.3227 55.6483 40.0964 55.2991 40.1722 54.9442C41.3926 49.2288 41.9873 43.5885 41.4652 37.8082C41.4479 37.6169 41.4307 37.4228 41.4133 37.2264L41.4131 37.2235C41.0438 33.0534 40.5812 27.8304 37.1392 25.0444C35.2926 23.5498 32.7599 22.9518 30.4073 23.4314C30.0517 23.5039 29.7046 23.2744 29.6321 22.9188C29.5596 22.5632 29.7891 22.2161 30.1447 22.1436Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M40.5287 58.4885C40.6183 58.1368 40.4057 57.7791 40.054 57.6896C39.7023 57.6 39.3446 57.8126 39.2551 58.1643C38.8578 59.7247 38.2456 61.1333 37.4695 62.4301C37.2831 62.7415 37.3844 63.145 37.6958 63.3314C38.0072 63.5178 38.4108 63.4165 38.5972 63.1051C39.4336 61.7075 40.0977 60.1816 40.5287 58.4885Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M37.3152 48.9521C37.6756 48.9948 37.9332 49.3215 37.8906 49.682C37.2699 54.9267 35.8688 59.6042 33.6205 63.6613C33.4446 63.9787 33.0446 64.0934 32.7272 63.9175C32.4097 63.7416 32.295 63.3417 32.4709 63.0242C34.6226 59.1416 35.9811 54.6339 36.5854 49.5275C36.6281 49.1671 36.9548 48.9095 37.3152 48.9521Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M37.1798 30.6556C36.7242 28.2212 34.6349 26.3591 32.0985 26.3591C28.6638 26.3591 26.254 29.8212 27.1032 33.0422C28.54 38.7279 28.7759 44.2077 27.8032 49.4855L27.8025 49.4893C26.9584 54.228 25.3374 58.4908 23.1263 62.1031C22.9368 62.4127 23.0342 62.8172 23.3437 63.0067C23.6533 63.1962 24.0578 63.0988 24.2473 62.7893C26.5488 59.0292 28.2249 54.6109 29.0961 49.7218C30.106 44.2403 29.8558 38.5684 28.3765 32.7168L28.3748 32.7099C27.7378 30.3005 29.5133 27.6734 32.0985 27.6734C33.9641 27.6734 35.5393 29.0459 35.8871 30.8929C36.8436 36.4411 37.3418 41.5862 36.9871 46.016C36.9581 46.3778 37.2279 46.6945 37.5897 46.7235C37.9515 46.7525 38.2682 46.4827 38.2972 46.1209C38.6649 41.5294 38.1459 36.2576 37.1815 30.6648C37.1809 30.6617 37.1804 30.6586 37.1798 30.6556Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M30.1376 59.1171C30.4604 59.283 30.5876 59.6792 30.4217 60.002L28.6804 63.3906C28.5145 63.7134 28.1184 63.8406 27.7956 63.6747C27.4728 63.5088 27.3456 63.1127 27.5114 62.7899L29.2527 59.4013C29.4186 59.0785 29.8147 58.9513 30.1376 59.1171Z" }), (0, import_jsx_runtime2.jsx)("path", { d: "M32.5872 31.2892C32.5042 30.9359 32.1505 30.7168 31.7972 30.7998C31.4439 30.8828 31.2247 31.2365 31.3077 31.5898C33.5238 41.0232 33.2194 49.3066 30.5201 56.363C30.3905 56.702 30.5602 57.0819 30.8991 57.2115C31.2381 57.3412 31.618 57.1715 31.7477 56.8326C34.5622 49.475 34.8483 40.9141 32.5872 31.2892Z" })] }), (0, import_jsx_runtime2.jsx)("defs", { children: (0, import_jsx_runtime2.jsx)("clipPath", { id: "clip0_113_33841", children: (0, import_jsx_runtime2.jsx)("rect", { width: "64", height: "64", fill: "white", transform: "translate(0.483887)" }) }) })] });
var cc = ({ onClose: e7, onReset: r10, submitEnrollmentWithPasskey: n6 }) => {
  let { user: a3 } = v2(), { initLinkWithPasskey: i5, linkWithPasskey: s3 } = s(), { app: c2 } = Or(), [d2, u2] = (0, import_react3.useState)(false), [h7, p5] = (0, import_react3.useState)(false), [m4, w4] = (0, import_react3.useState)(null), y6 = (0, import_react3.useMemo)((() => a3?.linkedAccounts.filter(((e8) => "passkey" === e8.type)) ?? []), [a3]), g2 = async (e8) => {
    u2(true);
    try {
      await n6(e8);
    } catch (e9) {
      w4(e9);
    } finally {
      u2(false);
    }
  }, f4 = async () => {
    p5(true), w4(null);
    try {
      await i5();
      let e8 = await s3(), t8 = e8?.linkedAccounts.filter(((e9) => "passkey" === e9.type)).map(((e9) => e9.credentialId)) ?? [];
      await g2(t8);
    } catch (e8) {
      w4(e8);
    } finally {
      p5(false);
    }
  };
  return 0 === y6.length || h7 ? (0, import_jsx_runtime2.jsx)(dc, { onReset: r10, onClose: e7, onClick: f4, isCreating: h7 }) : m4 ? (0, import_jsx_runtime2.jsx)(Uc, { allowlistConfig: c2.allowlistConfig, error: m4, onBack: () => w4(null), onRetry: () => w4(null) }) : (0, import_jsx_runtime2.jsx)(uc, { passkeys: y6, isSubmitting: d2, isCreating: h7, onReset: r10, onClose: e7, onSubmitEnrollment: () => g2(y6.map(((e8) => e8.credentialId))), onAddPasskey: f4 });
};
var dc = ({ onReset: e7, onClose: a3, onClick: i5, isCreating: o4 }) => (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Di, { backFn: e7, onClose: a3 }, "header"), (0, import_jsx_runtime2.jsx)(Yo, { children: (0, import_jsx_runtime2.jsxs)(vl, { children: [(0, import_jsx_runtime2.jsx)(ys, {}), (0, import_jsx_runtime2.jsx)(lc, {})] }) }), (0, import_jsx_runtime2.jsx)(Zo, { children: "Set up passkey verification" }), (0, import_jsx_runtime2.jsxs)(Qo, { children: [(0, import_jsx_runtime2.jsxs)(ts, { children: [(0, import_jsx_runtime2.jsx)(es, { children: (0, import_jsx_runtime2.jsx)(ShieldCheckIcon_default, {}) }), "Verify with Touch ID, Face ID, PIN, or hardware key"] }), (0, import_jsx_runtime2.jsxs)(ts, { children: [(0, import_jsx_runtime2.jsx)(es, { children: (0, import_jsx_runtime2.jsx)(ClockIcon_default, {}) }), "Takes seconds to set up and use"] }), (0, import_jsx_runtime2.jsxs)(ts, { children: [(0, import_jsx_runtime2.jsx)(es, { children: (0, import_jsx_runtime2.jsx)(ArrowRightEndOnRectangleIcon_default, {}) }), "Use your passkey to verify transactions and login to your account"] })] }), (0, import_jsx_runtime2.jsx)(Ci, { style: { marginTop: "2.25rem" }, onClick: i5, loading: o4, children: "Add a new passkey" }), (0, import_jsx_runtime2.jsx)(pi, {})] });
var uc = ({ onReset: e7, onClose: a3, onAddPasskey: i5, onSubmitEnrollment: o4, passkeys: s3, isSubmitting: c2, isCreating: d2 }) => {
  let [u2, h7] = (0, import_react3.useState)(false), p5 = u2 ? s3.length : s3.length > 3 ? 2 : 3;
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Di, { backFn: u2 ? () => h7(false) : e7, onClose: a3 }, "header"), !u2 && (0, import_jsx_runtime2.jsx)(Yo, { children: (0, import_jsx_runtime2.jsxs)(vl, { children: [(0, import_jsx_runtime2.jsx)(ys, {}), (0, import_jsx_runtime2.jsx)(lc, {})] }) }), (0, import_jsx_runtime2.jsx)(Zo, { children: "Enable your passkeys for verification" }), (0, import_jsx_runtime2.jsxs)(Qo, { children: [s3.slice(0, p5).map(((e8) => (0, import_jsx_runtime2.jsxs)(hc, { children: [(0, import_jsx_runtime2.jsx)(pc, { children: wc2(e8) }), (0, import_jsx_runtime2.jsxs)(mc, { children: ["Last used: ", e8.latestVerifiedAt?.toLocaleString()] })] }, e8.credentialId))), !u2 && s3.length > 3 && (0, import_jsx_runtime2.jsx)(yc, { onClick: () => h7(true), children: "View All" })] }), (0, import_jsx_runtime2.jsx)(Ci, { style: { marginTop: "1.5rem" }, onClick: o4, loading: c2, children: "Enable passkeys" }), s3.length < 5 && (0, import_jsx_runtime2.jsx)(yc, { style: { marginTop: "0.5rem" }, onClick: i5, disabled: d2, children: d2 ? (0, import_jsx_runtime2.jsx)(mi, { style: { height: "1rem", width: "1rem", borderWidth: 2 } }) : "Add new passkey" }), (0, import_jsx_runtime2.jsx)(pi, {})] });
};
var hc = dt.div.withConfig({ displayName: "PasskeyItem", componentId: "sc-9b5fbdd5-0" })(["&&{padding:0.75rem 1rem;text-align:left;border-radius:0.5rem;border:1px solid var(--privy-color-foreground-4);width:100%;}"]);
var pc = dt.div.withConfig({ displayName: "PasskeyItemTitle", componentId: "sc-9b5fbdd5-1" })(["font-size:0.875rem;line-height:1.375rem;font-weight:500;color:var(--privy-color-foreground-1);"]);
var mc = dt.div.withConfig({ displayName: "PasskeyItemSubtitle", componentId: "sc-9b5fbdd5-2" })(["font-size:0.75rem;font-weight:400;line-height:1.125rem;color:var(--privy-color-foreground-2);"]);
var wc2 = (e7) => e7.authenticatorName ? e7.createdWithBrowser ? `${e7.authenticatorName} on ${e7.createdWithBrowser}` : e7.authenticatorName : e7.createdWithBrowser ? e7.createdWithOs ? `${e7.createdWithBrowser} on ${e7.createdWithOs}` : `${e7.createdWithBrowser}` : "Unknown device";
var yc = dt.button.withConfig({ displayName: "StyledLink", componentId: "sc-9b5fbdd5-3" })(["&&{width:100%;font-size:0.875rem;line-height:1rem;@media (min-width:440px){font-size:14px;}display:flex;gap:12px;justify-content:center;padding:0.75rem 1rem;background-color:var(--privy-color-background);transition:background-color 200ms ease;color:var(--privy-color-accent);:focus{outline:none;box-shadow:none;}}"]);
var gc = ({ appName: e7, onComplete: a3, onReset: i5, onClose: o4 }) => {
  let [s3, c2] = (0, import_react3.useState)(""), [d2, u2] = (0, import_react3.useState)(false), [h7, p5] = (0, import_react3.useState)(null), [m4, w4] = (0, import_react3.useState)("enroll"), { initEnrollmentWithSms: y6, submitEnrollmentWithSms: g2 } = rc2(), { app: f4, data: v5 } = Or();
  function C4() {
    v5?.mfaEnrollmentFlow?.onSuccess(), a3();
  }
  return h7 ? (0, import_jsx_runtime2.jsx)(Uc, { allowlistConfig: f4.allowlistConfig, error: h7, onBack: () => p5(null), onRetry: () => p5(null) }) : (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, "enroll" === m4 ? { children: [(0, import_jsx_runtime2.jsx)(Di, { backFn: i5, onClose: o4 }, "header"), (0, import_jsx_runtime2.jsx)(us, { style: { marginBottom: "1.5rem" }, children: (0, import_jsx_runtime2.jsx)(PhoneIcon_default, {}) }), (0, import_jsx_runtime2.jsx)(Zo, { children: "Set up SMS verification" }), (0, import_jsx_runtime2.jsxs)(Jo, { children: ["We'll text a verification code to this mobile device whenever you use your ", e7, " ", "wallet."] }), (0, import_jsx_runtime2.jsxs)(Xo2, { children: [(0, import_jsx_runtime2.jsx)(du, { onSubmit: async function({ qualifiedPhoneNumber: e8 }) {
    try {
      await y6({ phoneNumber: e8 }), c2(e8), w4("verify");
    } catch (e9) {
      p5(e9);
    }
  }, hideRecent: true }), (0, import_jsx_runtime2.jsxs)(cs, { children: ["By providing your mobile number, you agree to receive text messages from ", f4?.name, ". Some carrier charges may apply"] })] }), (0, import_jsx_runtime2.jsx)(pi, {})] } : d2 ? { children: [(0, import_jsx_runtime2.jsx)(Di, { onClose: C4 }, "header"), (0, import_jsx_runtime2.jsx)(us, { style: { marginBottom: "1.5rem" }, children: (0, import_jsx_runtime2.jsx)(CheckCircleIcon_default, {}) }), (0, import_jsx_runtime2.jsx)(Zo, { children: "SMS verification added" }), (0, import_jsx_runtime2.jsxs)(Jo, { children: ["From now on, you'll enter the verification code sent to your mobile device whenever you use your ", e7, " wallet."] }), (0, import_jsx_runtime2.jsx)(rs, { children: (0, import_jsx_runtime2.jsx)(Ci, { onClick: C4, children: "Done" }) }), (0, import_jsx_runtime2.jsx)(pi, {})] } : { children: [(0, import_jsx_runtime2.jsx)(Di, { backFn: function() {
    "verify" === m4 ? w4("enroll") : i5();
  }, onClose: o4 }, "header"), (0, import_jsx_runtime2.jsx)(us, { style: { marginBottom: "1.5rem" }, children: (0, import_jsx_runtime2.jsx)(PhoneIcon_default, {}) }), (0, import_jsx_runtime2.jsx)(Zo, { children: "Enter enrollment code" }), (0, import_jsx_runtime2.jsxs)(Xo2, { children: [(0, import_jsx_runtime2.jsx)(bs, { onChange: async function(e8) {
    try {
      if (!e8) return;
      await g2({ phoneNumber: s3, mfaCode: e8 }), u2(true);
    } catch (e9) {
      if (Ol(e9)) throw Error("You have exceeded the maximum number of attempts. Please close this window and try again in 10 seconds.");
      if (Rl(e9)) throw Error("The code you entered is not valid");
      if (Wl(e9)) throw Error("You have exceeded the time limit for code entry. Please try again in 30 seconds.");
      throw Ul(e9) ? Error("Verification canceled") : Error("Unknown error");
    }
  } }), (0, import_jsx_runtime2.jsxs)(Jo, { children: ["To continue, enter the 6-digit code sent to ", (0, import_jsx_runtime2.jsx)("strong", { children: p3(s3) })] })] }), (0, import_jsx_runtime2.jsx)(pi, {})] });
};
var fc2 = ({ size: e7, authUrl: r10 }) => (0, import_jsx_runtime2.jsx)(xd, { url: r10, squareLogoElement: ShieldCheckIcon_default2, size: e7, fgColor: "#1F1F1F" });
var vc = ({ onClose: e7, onReset: a3, totpInfo: i5, submitEnrollmentWithTotp: o4, error: s3 }) => {
  let [c2, d2] = (0, import_react3.useState)("enroll");
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, "enroll" === c2 ? { children: [(0, import_jsx_runtime2.jsx)(Di, { backFn: a3, onClose: e7 }, "header"), (0, import_jsx_runtime2.jsx)(Fh, { children: "Scan QR code" }), (0, import_jsx_runtime2.jsx)(Mh, { children: "Open your authenticator app and scan this code to continue" }), (0, import_jsx_runtime2.jsx)(qo, { children: (0, import_jsx_runtime2.jsx)(fc2, { authUrl: i5.authUrl, size: 240 }) }), (0, import_jsx_runtime2.jsx)(Bp, { style: { textAlign: "left" }, children: "Setup key" }), (0, import_jsx_runtime2.jsxs)(zh, { style: { marginTop: "0.25rem" }, children: [(0, import_jsx_runtime2.jsx)(W2, { children: "".repeat(16) }), (0, import_jsx_runtime2.jsx)(Zf, { itemName: " ", text: i5.secret })] }), (0, import_jsx_runtime2.jsx)(Ci, { style: { marginTop: "1rem" }, onClick: function() {
    d2("verify");
  }, children: "Continue" }), (0, import_jsx_runtime2.jsx)(pi, {})] } : { children: [(0, import_jsx_runtime2.jsx)(Di, { backFn: function() {
    "verify" === c2 ? d2("enroll") : a3();
  }, onClose: e7 }, "header"), (0, import_jsx_runtime2.jsx)(us, { style: { marginBottom: "1.5rem" }, children: (0, import_jsx_runtime2.jsx)(DevicePhoneMobileIcon_default, {}) }), (0, import_jsx_runtime2.jsx)(Fh, { children: "Enter enrollment code" }), (0, import_jsx_runtime2.jsx)(Mh, { children: "To continue, enter the 6-digit code generated from your authenticator app" }), (0, import_jsx_runtime2.jsx)(Xo2, { children: (0, import_jsx_runtime2.jsx)(bs, { onChange: async function(e8) {
    try {
      if (!e8) return;
      await o4({ mfaCode: e8 });
    } catch (e9) {
      if (Ol(e9)) throw Error("You have exceeded the maximum number of attempts. Please close this window and try again in 10 seconds.");
      if (Rl(e9)) throw Error("The code you entered is not valid");
      if (Wl(e9)) throw Error("You have exceeded the time limit for code entry. Please try again in 30 seconds.");
      throw Ul(e9) ? Error("Verification canceled") : Error("Unknown error");
    }
  }, errorReasonOverride: s3?.message }) }), (0, import_jsx_runtime2.jsx)(pi, {})] });
};
var Cc = { component: () => {
  let { user: e7, enrollInMfa: a3, ready: i5 } = v2(), [o4, c2] = (0, import_react3.useState)(null), { unenrollWithSms: d2, unenrollWithTotp: u2, unenrollWithPasskey: h7, submitEnrollmentWithTotp: p5, initEnrollmentWithPasskey: m4, submitEnrollmentWithPasskey: w4, initEnrollmentWithTotp: y6 } = rc2(), { app: g2, data: f4, onUserCloseViaDialogOrKeybindRef: v5 } = Or(), { closePrivyModal: C4 } = s(), { promptMfa: k3 } = Us(), [A2, b4] = (0, import_react3.useState)(false), [T2, _5] = (0, import_react3.useState)(null), [E2, I2] = (0, import_react3.useState)(null), S2 = () => {
    C4({ shouldCallAuthOnSuccess: true }), a3(false), setTimeout((() => {
      c2(null), _5(null);
    }), 500);
  }, [U2, P3] = (0, import_react3.useState)(false), [W3, x4] = (0, import_react3.useState)();
  v5.current = S2;
  let N2 = e7?.mfaMethods.includes("sms"), R2 = !!e7?.phone, O2 = e7?.mfaMethods.includes("totp"), M3 = e7?.mfaMethods.includes("passkey"), F3 = N2 || O2 || M3, L3 = e7?.linkedAccounts.filter(((e8) => "passkey" === e8.type)).map(((e8) => e8.credentialId)) ?? [];
  function D2() {
    c2(null), _5(null);
  }
  async function q3(e8 = L3) {
    P3(true);
    try {
      return await m4(), await w4({ credentialIds: e8 }, { removeForLogin: f4?.mfaEnrollmentFlow?.shouldUnlinkOnUnenrollMfa }), f4?.mfaEnrollmentFlow?.onSuccess(), S2();
    } catch (e9) {
      x4(e9);
    } finally {
      P3(false);
    }
  }
  if ((0, import_react3.useEffect)((() => {
    F3 && b4(true);
  }), [F3]), !i5 || !e7 || !g2) return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Di, { onClose: S2 }, "header"), (0, import_jsx_runtime2.jsx)(Yo, { children: (0, import_jsx_runtime2.jsx)(nc2, {}) }), (0, import_jsx_runtime2.jsx)(Xo2, { children: (0, import_jsx_runtime2.jsx)(mi, {}) }), (0, import_jsx_runtime2.jsx)(pi, {})] });
  if ("sms" === o4) return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Di, { backFn: D2, onClose: S2 }, "header"), (0, import_jsx_runtime2.jsx)(us, { style: { marginBottom: "1.5rem" }, children: (0, import_jsx_runtime2.jsx)(QuestionMarkCircleIcon_default, {}) }), (0, import_jsx_runtime2.jsx)(Zo, { children: "Remove SMS verification?" }), (0, import_jsx_runtime2.jsxs)(Jo, { children: ["MFA adds an extra layer of security to your ", g2?.name, " account. Make sure you have other methods to secure your account."] }), (0, import_jsx_runtime2.jsx)(rs, { children: (0, import_jsx_runtime2.jsx)(Ci, { $warn: true, onClick: async function() {
    c2(null);
    try {
      await d2();
    } catch (e8) {
      c2(null);
    }
  }, children: "Remove" }) }), (0, import_jsx_runtime2.jsx)(pi, {})] });
  if ("totp" === o4) return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Di, { backFn: D2, onClose: S2 }, "header"), (0, import_jsx_runtime2.jsx)(us, { style: { marginBottom: "1.5rem" }, children: (0, import_jsx_runtime2.jsx)(QuestionMarkCircleIcon_default, {}) }), (0, import_jsx_runtime2.jsx)(Zo, { children: "Remove authenticator app verification?" }), (0, import_jsx_runtime2.jsxs)(Jo, { children: ["MFA adds an extra layer of security to your ", g2?.name, " account. Make sure you have other methods to secure your account."] }), (0, import_jsx_runtime2.jsx)(rs, { children: (0, import_jsx_runtime2.jsx)(Ci, { $warn: true, onClick: async function() {
    c2(null);
    try {
      await u2();
    } catch (e8) {
      c2(null);
    }
  }, children: "Remove" }) }), (0, import_jsx_runtime2.jsx)(pi, {})] });
  if ("passkey" === o4) {
    let e8 = f4?.mfaEnrollmentFlow?.shouldUnlinkOnUnenrollMfa ?? true;
    return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Di, { backFn: D2, onClose: S2 }, "header"), (0, import_jsx_runtime2.jsx)(us, { style: { marginBottom: "1.5rem" }, children: (0, import_jsx_runtime2.jsx)(QuestionMarkCircleIcon_default, {}) }), (0, import_jsx_runtime2.jsx)(Zo, { children: "Are you sure you want to remove this passkey?" }), (0, import_jsx_runtime2.jsx)(Jo, { children: e8 ? "Removing your passkey will remove as both a verification method and a login method." : "Removing your passkey will remove as a verification method." }), (0, import_jsx_runtime2.jsx)(rs, { children: (0, import_jsx_runtime2.jsx)(Ci, { $warn: true, onClick: async function() {
      c2(null);
      try {
        await h7({ removeForLogin: f4?.mfaEnrollmentFlow?.shouldUnlinkOnUnenrollMfa });
      } catch (e9) {
        c2(null);
      }
    }, children: "Remove" }) }), (0, import_jsx_runtime2.jsx)(pi, {})] });
  }
  if (0 === f4.mfaEnrollmentFlow.mfaMethods.length && !F3) return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Di, { onClose: S2 }, "header"), (0, import_jsx_runtime2.jsx)(us, { style: { marginBottom: "1.5rem" }, children: (0, import_jsx_runtime2.jsx)(ShieldCheckIcon_default, {}) }), (0, import_jsx_runtime2.jsx)(Zo, { children: "Add more security" }), (0, import_jsx_runtime2.jsxs)(Jo, { children: [g2?.name, " does not have any verification methods enabled."] }), (0, import_jsx_runtime2.jsx)(rs, { children: (0, import_jsx_runtime2.jsx)(Ci, { onClick: S2, children: "Close" }) }), (0, import_jsx_runtime2.jsx)(pi, {})] });
  let z = !F3 && !A2;
  return z ? (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Di, { onClose: S2 }, "header"), (0, import_jsx_runtime2.jsx)(us, { style: { marginBottom: "1.5rem" }, children: (0, import_jsx_runtime2.jsx)(ShieldCheckIcon_default, {}) }), (0, import_jsx_runtime2.jsx)(Zo, { children: "Transaction Protection" }), (0, import_jsx_runtime2.jsx)(Jo, { children: "Set up transaction protection to add an extra layer of security to your account" }), (0, import_jsx_runtime2.jsxs)(Qo, { children: [(0, import_jsx_runtime2.jsxs)(ts, { children: [(0, import_jsx_runtime2.jsx)(es, { children: (0, import_jsx_runtime2.jsx)(CheckBadgeIcon_default, {}) }), "Enable 2-Step verification for your ", g2?.name, " wallet."] }), (0, import_jsx_runtime2.jsxs)(ts, { children: [(0, import_jsx_runtime2.jsx)(es, { children: (0, import_jsx_runtime2.jsx)(IdentificationIcon_default, {}) }), "You'll be prompted to authenticate to complete transactions."] })] }), (0, import_jsx_runtime2.jsxs)(rs, { children: [(0, import_jsx_runtime2.jsx)(Ci, { onClick: () => b4(true), children: "Continue" }), (0, import_jsx_runtime2.jsx)(Ai, { onClick: S2, children: "Not now" })] }), (0, import_jsx_runtime2.jsx)(pi, {})] }) : "sms" === T2 ? (0, import_jsx_runtime2.jsx)(gc, { appName: g2?.name || "Privy", onComplete: S2, onReset: D2, onClose: S2 }) : "totp" === T2 && E2 ? (0, import_jsx_runtime2.jsx)(vc, { onClose: S2, onReset: D2, submitEnrollmentWithTotp: ({ mfaCode: e8 }) => (async function(e9) {
    try {
      return x4(void 0), await p5({ mfaCode: e9 }), f4?.mfaEnrollmentFlow?.onSuccess(), S2();
    } catch (e10) {
      x4(e10);
    } finally {
      c2(null);
    }
  })(e8), totpInfo: { ...E2, appName: g2?.name || "Privy" } }) : "passkey" === T2 ? (0, import_jsx_runtime2.jsx)(cc, { onReset: D2, onClose: S2, submitEnrollmentWithPasskey: q3 }) : (0, import_jsx_runtime2.jsx)(ic, { showIntro: z, userMfaMethods: e7.mfaMethods, appMfaMethods: g2.mfa.methods, userHasAuthSms: R2, onBackToIntro: function() {
    b4(false);
  }, handleSelectMethod: async function(e8) {
    try {
      await k3();
    } catch (e9) {
      return void x4(e9);
    }
    return "totp" === e8 ? (_5(e8), I2(null), void y6().then(((e9) => {
      I2(e9);
    })).catch((() => {
      I2(null), D2();
    }))) : "passkey" === e8 && 1 === L3.length ? await q3() : void _5(e8);
  }, isTotpLoading: "totp" === T2 && !E2, isPasskeyLoading: U2, error: W3, onClose: S2, setRemovingMfaMethod: async (e8) => {
    try {
      await k3();
    } catch (e9) {
      return void x4(e9);
    }
    c2(e8);
  } });
} };
var kc = ({ providerName: e7, ProviderLogo: r10, success: n6, errorMessage: a3, onRetry: i5 }) => {
  let o4 = n6 ? `Successfully connected with ${e7}` : a3 ? a3.message : `Verifying connection to ${e7}`;
  return (0, import_jsx_runtime2.jsx)(ho, { title: o4, subtitle: n6 ? "You're good to go!" : a3 ? a3.detail : "Just a few moments more", icon: r10, iconVariant: "loading", iconLoadingStatus: { success: n6, fail: !!a3 }, secondaryCta: a3?.retryable && i5 ? { label: "Retry", onClick: i5 } : void 0, watermark: true });
};
var Ac = { component: () => {
  let { authenticated: e7, logout: r10, ready: n6, user: a3 } = v2(), { app: i5, setModalData: o4, navigate: c2, resetNavigation: d2 } = Or(), { getAuthMeta: u2, initLoginWithOAuth: h7, loginWithOAuth: p5, updateWallets: m4, setReadyToTrue: w4, closePrivyModal: y6, createAnalyticsEvent: g2 } = s(), [f4, v5] = (0, import_react3.useState)(false), [C4, k3] = (0, import_react3.useState)(void 0), A2 = u2()?.provider || "google", { name: b4, component: T2 } = ao(A2);
  return (0, import_react3.useEffect)((() => {
    p5(A2).then((() => {
      v5(true), w4(true);
    })).catch(((e8) => {
      if (w4(false), e8?.privyErrorCode === p.ALLOWLIST_REJECTED) return k3(void 0), d2(), void c2(hp);
      if (e8?.privyErrorCode === p.USER_LIMIT_REACHED) return console.error(new c(e8).toString()), k3(void 0), d2(), void c2(kp);
      if (e8?.privyErrorCode === p.USER_DOES_NOT_EXIST) return k3(void 0), d2(), void c2(xc);
      if (e8?.privyErrorCode === p.ACCOUNT_TRANSFER_REQUIRED && e8.data?.data?.nonce) return k3(void 0), d2(), o4({ accountTransfer: { nonce: e8.data?.data?.nonce, account: e8.data?.data?.subject, displayName: e8.data?.data?.account?.displayName, linkMethod: u2()?.provider, embeddedWalletAddress: e8.data?.data?.otherUser?.embeddedWalletAddress, oAuthUserInfo: e8.data?.data?.otherUser?.oAuthUserInfo } }), void c2(ed);
      let { retryable: t8, detail: r11 } = (function(e9, t9) {
        let r12 = { detail: "", retryable: false }, n7 = Gn(t9);
        if (e9?.privyErrorCode === p.LINKED_TO_ANOTHER_USER && (r12.detail = "This account has already been linked to another user."), e9?.privyErrorCode === p.INVALID_CREDENTIALS && (r12.retryable = true, r12.detail = "Something went wrong. Try again."), e9.privyErrorCode === p.OAUTH_USER_DENIED && (r12.detail = `Retry and check ${n7} to finish connecting your account.`, r12.retryable = true), e9?.privyErrorCode === p.TOO_MANY_REQUESTS && (r12.detail = "Too many requests. Please wait before trying again."), e9?.privyErrorCode === p.TOO_MANY_REQUESTS && e9.message.includes("provider rate limit")) {
          let e10 = ao(t9).name;
          r12.detail = `Request limit reached for ${e10}. Please wait a moment and try again.`;
        }
        if (e9?.privyErrorCode === p.OAUTH_ACCOUNT_SUSPENDED) {
          let e10 = ao(t9).name;
          r12.detail = `Your ${e10} account is suspended. Please try another login method.`;
        }
        return e9?.privyErrorCode === p.CANNOT_LINK_MORE_OF_TYPE && (r12.detail = "You cannot authorize more than one account for this user."), e9?.privyErrorCode === p.OAUTH_UNEXPECTED && t9.startsWith("privy:") && (r12.detail = "Something went wrong. Please try again."), r12;
      })(e8, A2);
      k3({ retryable: t8, detail: r11, message: "Authentication failed" });
    })).finally((() => {
      ra2();
    }));
  }), [b4, A2]), (0, import_react3.useEffect)((() => {
    if (n6 && e7 && f4 && a3) {
      if (i5?.legal.requireUsersAcceptTerms && !a3.hasAcceptedTerms) {
        let e8 = setTimeout((() => {
          c2(id);
        }), wn);
        return () => clearTimeout(e8);
      }
      if (bc(a3, i5.embeddedWallets)) {
        let e8 = setTimeout((() => {
          o4({ createWallet: { onSuccess: () => {
          }, onFailure: (e9) => {
            console.error(e9), g2({ eventName: "embedded_wallet_creation_failure_logout", payload: { error: e9, provider: A2, screen: "OAuthStatusScreen" } }), r10();
          }, callAuthOnSuccessOnClose: true } }), c2(rd);
        }), wn);
        return () => clearTimeout(e8);
      }
      {
        let e8 = setTimeout((() => y6({ shouldCallAuthOnSuccess: true, isSuccess: true })), wn);
        return m4(), () => clearTimeout(e8);
      }
    }
  }), [n6, e7, f4, a3]), (0, import_jsx_runtime2.jsx)(kc, { providerName: b4, ProviderLogo: T2, success: f4, errorMessage: C4, onRetry: C4?.retryable ? () => {
    ra2(), h7(A2), k3(void 0);
  } : void 0 });
} };
var bc2 = (0, import_react3.forwardRef)(((e7, a3) => {
  let [i5, o4] = (0, import_react3.useState)(""), [s3, c2] = (0, import_react3.useState)(""), [d2, u2] = (0, import_react3.useState)(false), { authenticated: h7, user: p5 } = v2(), { initUpdateEmail: m4 } = s(), { navigate: w4, setModalData: y6, currentScreen: g2 } = Or(), { enabled: f4, token: v5 } = _a2(), C4 = Pr(), k3 = ga(i5) && (C4.disablePlusEmails && i5.includes("+") ? (s3 || c2("Please enter a valid email address without a '+'."), false) : (s3 && c2(""), true)), A2 = d2 || !k3, b4 = () => {
    !f4 || v5 || h7 ? (async (e8) => {
      if (!p5?.email) throw Error("User is required to have an email address to update it.");
      u2(true);
      try {
        await m4({ oldAddress: p5.email.address, newAddress: i5, captchaToken: e8 }), w4(Ou);
      } catch (e9) {
        y6({ errorModalData: { error: e9, previousScreen: g2 || Ch } });
      }
      u2(false);
    })(v5) : (y6({ captchaModalData: { callback: (e8) => {
      if (!p5?.email) throw Error("User is required to have an email address to update it.");
      return m4({ oldAddress: p5.email.address, newAddress: i5, captchaToken: e8 });
    }, userIntentRequired: false, onSuccessNavigateTo: Ou, onErrorNavigateTo: zc } }), w4(mp));
  };
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsxs)(Tc, { children: [s3 && (0, import_jsx_runtime2.jsx)(kd, { style: { marginTop: "0.25rem", textAlign: "left" }, children: s3 }), (0, import_jsx_runtime2.jsxs)(_c, { $error: !!s3, children: [(0, import_jsx_runtime2.jsx)(EnvelopeIcon_default, {}), (0, import_jsx_runtime2.jsx)("input", { ref: a3, id: "email-input", type: "email", placeholder: "your@email.com", onChange: (e8) => o4(e8.target.value), onKeyUp: (e8) => {
    "Enter" === e8.key && b4();
  }, value: i5, autoComplete: "email" }), e7.stacked ? null : (0, import_jsx_runtime2.jsx)(Ni, { isSubmitting: d2, onClick: b4, disabled: A2, children: "Submit" })] })] }), e7.stacked ? (0, import_jsx_runtime2.jsx)(Ci, { loadingText: null, loading: d2, disabled: A2, onClick: b4, style: { width: "100%" }, children: "Submit" }) : null] });
}));
var Tc = Sd;
var _c = Ad;
var Ec = ({ title: e7 = "Update your email", subtitle: r10 = "Add the email address you'd like to use going forward. We'll send you a confirmation code" }) => (0, import_jsx_runtime2.jsx)(ho, { title: e7, subtitle: r10, icon: EnvelopeIcon_default, watermark: true, children: (0, import_jsx_runtime2.jsx)($o, { children: (0, import_jsx_runtime2.jsx)(bc2, { stacked: true }) }) });
var Ic = { component: () => (0, import_jsx_runtime2.jsx)(Ec, {}) };
var Sc = ({ title: e7 = "Update your phone number", subtitle: r10 = "Add the phone number you'd like to use going forward. We'll send you a confirmation code", onSubmit: n6, isSubmitting: a3 = false }) => {
  let [i5, o4] = (0, import_react3.useState)(null);
  return (0, import_jsx_runtime2.jsx)(ho, { title: e7, subtitle: r10, icon: PhoneIcon_default, primaryCta: { label: a3 ? "Submitting" : "Update", onClick: async () => {
    i5?.qualifiedPhoneNumber && await n6(i5);
  }, disabled: !i5?.isValid || a3 }, watermark: true, children: (0, import_jsx_runtime2.jsx)(du, { onChange: (e8) => {
    o4(e8);
  }, onSubmit: async () => {
  }, noIncludeSubmitButton: true, hideRecent: true }) });
};
var Uc2 = { component: () => {
  let { currentScreen: e7, data: r10, navigate: n6, setModalData: a3 } = Or(), { user: i5 } = v2(), { initUpdatePhone: o4 } = s(), [s3, c2] = (0, import_react3.useState)(false);
  return (0, import_jsx_runtime2.jsx)(Sc, { onSubmit: async (t8) => {
    c2(true);
    try {
      if (!i5?.phone?.number) throw Error("User is required to have an phone number to update it.");
      await o4(i5?.phone?.number, t8.qualifiedPhoneNumber), n6(Ou);
    } catch (t9) {
      a3({ errorModalData: { error: t9, previousScreen: r10?.errorModalData?.previousScreen || e7 || Ql } }), n6(zc);
    } finally {
      c2(false);
    }
  }, isSubmitting: s3 });
} };
function Pc({ subscribe: e7, getExternalJwt: t8, enabled: r10 = true, onAuthenticated: n6, onUnauthenticated: a3, onError: i5 }) {
  let { client: o4, onCustomAuthAuthenticated: c2 } = s(), { logout: d2, authenticated: h7, ready: p5 } = q2();
  if (!o4) throw new _("`useSyncJwtBasedAuthState` must be used within a `PrivyProvider`");
  let [m4, w4] = (0, import_react3.useState)({ status: "initial" }), y6 = (0, import_react3.useRef)(), g2 = (0, import_react3.useRef)(false), f4 = (0, import_react3.useRef)(t8);
  (0, import_react3.useEffect)((() => {
    f4.current = t8;
  }), [t8]);
  let v5 = (0, import_react3.useRef)(n6);
  (0, import_react3.useEffect)((() => {
    v5.current = n6;
  }), [n6]);
  let C4 = (0, import_react3.useRef)(a3);
  (0, import_react3.useEffect)((() => {
    C4.current = a3;
  }), [a3]);
  let k3 = (0, import_react3.useRef)(i5);
  return (0, import_react3.useEffect)((() => {
    k3.current = i5;
  }), [i5]), (0, import_react3.useEffect)((() => {
    if (!r10 || !p5) return;
    let t9 = async () => {
      if (!g2.current) {
        g2.current = true;
        try {
          w4({ status: "loading" });
          let e8 = await f4.current();
          if (void 0 !== y6.current && y6.current === e8) return void w4({ status: "done" });
          if (!e8) return h7 && (await d2(), C4.current?.()), y6.current = e8, void w4({ status: "done" });
          o4.startAuthFlow(new Ro(e8));
          let { user: t10, isNewUser: r11 = false } = await o4.authenticate();
          if (!t10) throw new _("Failed to sync with custom auth provider");
          v5.current?.({ user: t10, isNewUser: r11 }), c2(t10, r11), y6.current = e8, w4({ status: "done" });
        } catch (e8) {
          if (console.warn(e8), await d2().catch((() => {
          })), C4.current?.(), e8 instanceof t && e8.privyErrorCode === p.LINKED_TO_ANOTHER_USER) return w4({ status: "initial" }), void setTimeout((() => {
            t9();
          }), 0);
          k3.current?.(e8), w4({ status: "error", error: e8 });
        } finally {
          g2.current = false;
        }
      }
    };
    return t9(), e7(t9);
  }), [e7, o4, c2, h7, d2, r10, p5]), r10 ? { state: m4 } : { state: { status: "not-enabled" } };
}
var Wc = create((() => ({ jwtAuthFlowState: { status: "not-enabled" } })));
function xc2({ customAuth: e7 }) {
  let { jwtAuthFlowState: t8 } = (function({ customAuth: e8 }) {
    let t9 = Zr(), r10 = (0, import_react3.useRef)(), n6 = (0, import_react3.useCallback)(((e9) => (r10.current = e9, () => {
      r10.current = void 0;
    })), []), a3 = e8?.getCustomAccessToken ?? (() => Promise.resolve(void 0)), { state: i5 } = Pc({ enabled: true === e8?.enabled, subscribe: n6, getExternalJwt: a3, onAuthenticated: ({ user: e9, isNewUser: r11 }) => {
      t9("login", "onComplete", { user: e9, isNewUser: r11, wasAlreadyAuthenticated: false, loginMethod: "custom", loginAccount: null }), t9("customAuth", "onAuthenticated", { user: e9 });
    }, onUnauthenticated: () => {
      t9("customAuth", "onUnauthenticated");
    }, onError: (e9) => {
      t9("login", "onError", e9.privyErrorCode || p.UNKNOWN_AUTH_ERROR);
    } });
    return (0, import_react3.useEffect)((() => {
      (async () => {
        e8 && !e8.isLoading && r10.current?.();
      })();
    }), [e8?.enabled, e8?.getCustomAccessToken, e8?.isLoading]), { jwtAuthFlowState: i5 };
  })({ customAuth: e7 });
  return (0, import_react3.useEffect)((() => {
    Wc.setState({ jwtAuthFlowState: t8 });
  }), [t8]), null;
}
var Nc = (0, import_react3.createContext)(false);
var Rc;
var Oc;
var Mc;
var Fc;
var Lc;
var Dc;
function qc() {
  return Rc ? Rc.getCustomerAccessToken() : Promise.resolve(ln.get(xn) || null);
}
async function zc2() {
  return Rc ? Rc.getAccessToken() : Promise.resolve(ln.get(In) || ln.get(xn) || null);
}
var Bc = (e7, t8) => Oc(e7, t8);
var jc = (e7, t8) => Mc(e7, t8);
var Hc = (e7, t8) => Fc(e7, t8);
var Vc = (e7, t8) => Lc(e7, t8);
var $c = (e7) => Dc(e7);
var Kc = ({ config: e7, ...r10 }) => {
  var n6;
  if ((() => {
    if ((0, import_react3.useContext)(Nc)) throw new _("Multiple PrivyProvider instances found", "Found multiple instances of PrivyProvider, ensure there is only one mounted in your application tree.");
  })(), "undefined" != typeof window && 0 > ["localhost", "127.0.0.1"].indexOf(window.location.hostname) && "https:" !== window.location.protocol && "chrome-extension:" !== window.location.protocol) throw new _("Embedded wallet is only available over HTTPS");
  if ("string" != typeof (n6 = r10.appId) || 25 !== n6.length) throw new _("Cannot initialize the Privy provider with an invalid Privy app ID");
  Rc || (Rc = new Vo({ appId: r10.appId, appClientId: r10.clientId, apiUrl: r10.apiUrl }));
  let a3 = Object.assign({}, e7), i5 = (0, import_react3.useMemo)((() => new l({ appId: r10.appId, clientId: r10.clientId, storage: ln, baseUrl: r10.apiUrl, sdkVersion: "react-auth:3.0.1" })), []);
  return (0, import_jsx_runtime2.jsx)(Dr, { client: i5, legacyClient: Rc, appClientId: r10.clientId, clientConfig: a3, children: (0, import_jsx_runtime2.jsx)(sp, { children: (0, import_jsx_runtime2.jsx)(Gc, { ...r10, client: Rc, privy: i5 }) }) });
};
var Gc = (e7) => {
  let n6 = e7.client, i5 = e7.privy, c2 = dp();
  ol();
  let [d2, h7] = (0, import_react3.useState)(false), m4 = Ws(((e8) => e8.inProgressMfaFlow)), [w4, y6] = (0, import_react3.useState)(false), [g2, f4] = (0, import_react3.useState)(false), [v5, b4] = (0, import_react3.useState)(null), [E2, I2] = (0, import_react3.useState)([]), [S2, P3] = (0, import_react3.useState)(void 0), [W3, x4] = (0, import_react3.useState)(false), [N2, R2] = (0, import_react3.useState)(null), [M3, L3] = (0, import_react3.useState)(false), [D2, q3] = (0, import_react3.useState)({ status: "disconnected", connectedWallet: null, connectError: null, connector: null, connectRetry: i3 }), [z, B3] = (0, import_react3.useState)({ status: "initial" }), [j3, H2] = (0, import_react3.useState)({ status: "initial" }), [V2, K3] = (0, import_react3.useState)({ status: "initial" }), [Y2, Z] = (0, import_react3.useState)({ status: "initial" }), [J2, X2] = (0, import_react3.useState)({ status: "initial" }), [Q2, ee] = (0, import_react3.useState)({ status: "initial" }), [te, re] = (0, import_react3.useState)(null), ne = Pr(), ae = Wr(), [oe, se] = (0, import_react3.useState)({}), [le, ce] = (0, import_react3.useState)(null), de = (0, import_react3.useRef)(null), [ue, he] = (0, import_react3.useState)(false), [pe, me] = (0, import_react3.useState)(false), we = (0, import_react3.useRef)(null), ye = (0, import_react3.useRef)(null), ge = (0, import_react3.useRef)($r), [fe, ve] = (0, import_react3.useState)(false);
  n6.onStoreCustomerAccessToken = (e8) => {
    e8 && Gr(ge, "accessToken", "onAccessTokenGranted", { accessToken: e8 });
  }, n6.onDeleteCustomerAccessToken = () => {
    b4(null), f4(false), Gr(ge, "accessToken", "onAccessTokenRemoved");
  };
  let Ce = (0, import_react3.useRef)(null), ke = (0, import_react3.useRef)(null), Ae = (0, import_react3.useRef)(false), be = ({ showWalletUIs: e8 }) => Ae.current ? Ae.current : void 0 !== e8 ? !e8 : !ne.embeddedWallets.showWalletUIs, Te = (e8) => {
    R2(e8), setTimeout((() => {
      h7(true);
    }), 15);
  };
  (0, import_react3.useEffect)((() => {
    if (!v5) return void n6.connectors?.removeEmbeddedWalletConnectors();
    let t8 = l2(v5), r10 = n3(v5), a3 = o2(v5);
    t8 && r10.length || n6.connectors?.removeEmbeddedWalletConnectors(), a3 || n6.connectors?.removeImportedWalletConnector(), n6.connectors ? te ? (t8 && n6.connectors.addEmbeddedWalletConnectors({ walletProxy: te, user: v5, embeddedWallets: r10, defaultChain: ne.defaultChain, appId: e7.appId, privyClient: i5 }), a3 && n6.connectors.addImportedWalletConnector(te, a3.address, ne.defaultChain, e7.appId)) : console.debug("Failed to add embedded wallet connector: Wallet proxy not initialized") : console.debug("Failed to add embedded wallet connector: Client connectors not initialized");
  }), [te, v5]), (0, import_react3.useEffect)((() => {
    te && de.current?.(te);
  }), [te]);
  let _e = (0, import_react3.useCallback)(((e8, t8) => {
    b4(e8), x4(t8), f4(true), me(true);
  }), []);
  (0, import_react3.useEffect)((() => {
    pe && te && v5 && (async () => {
      let e8 = fc(v5, ne.embeddedWallets.ethereum.createOnLogin), t8 = wc(v5, ne.embeddedWallets.solana.createOnLogin), r10 = await zc2();
      if (r10) {
        if (e8 && t8) {
          let e9 = await te.create({ accessToken: r10 });
          return await te.createSolana({ accessToken: r10, ethereumAddress: e9?.address }), void me(false);
        }
        if (t8) return await te.createSolana({ accessToken: r10, ethereumAddress: l2(v5)?.address }), await je.refreshSessionAndUser(), void me(false);
        if (e8) return await te.create({ accessToken: r10 }), void me(false);
      }
    })().catch(console.error);
  }), [pe && te && v5]), (0, import_react3.useEffect)((() => {
    if (ne.externalWallets.solana.connectors) return ne.externalWallets.solana.connectors.onMount(), () => ne.externalWallets.solana.connectors?.onUnmount();
  }), [ne.externalWallets.solana.connectors]), (0, import_react3.useEffect)((() => {
    !w4 && ae && (async function() {
      let e8, t8 = Ee(), r10 = Ie(), i6 = createStore();
      n6.initializeConnectorManager({ walletConnectCloudProjectId: ne.walletConnectCloudProjectId, rpcConfig: ne.rpcConfig, chains: ne.chains, defaultChain: ne.defaultChain, store: i6, walletList: ne.appearance.walletList, shouldEnforceDefaultChainOnConnect: ne.shouldEnforceDefaultChainOnConnect, externalWalletConfig: ne.externalWallets, appName: ne.name ?? "Privy", walletChainType: ne.appearance.walletChainType, setBaseAccountSdk: P3 }), n6.connectors?.on("connectorInitialized", (() => {
        e8 && clearTimeout(e8);
        let t9 = n6.connectors.walletConnectors.length, r11 = n6.connectors.walletConnectors.reduce(((e9, t10) => e9 + (t10.initialized ? 1 : 0)), 0);
        r11 === t9 ? ve(true) : e8 = setTimeout((() => {
          console.debug({ message: "Unable to initialize all expected connectors before timeout", initialized: r11, expected: t9 }), ve(true);
        }), 1500);
      })), n6.connectors?.initialize().then((() => {
        xe();
      }));
      let o4 = await n6.getAuthenticatedUser(), s3 = !!o4;
      ne.legal.requireUsersAcceptTerms && o4 && !o4.hasAcceptedTerms ? (await n6.logout(), je.setReadyToTrue(true), Gr(ge, "logout", "onSuccess")) : (ne.customAuth?.enabled || (f4(!!o4), o4 && Gr(ge, "login", "onComplete", { user: o4, isNewUser: false, wasAlreadyAuthenticated: true, loginMethod: null, loginAccount: null }), b4(o4)), t8 ? ke.current = s3 ? "link" : "login" : r10 && !s3 ? (ke.current = "login", se({ telegramAuthModalData: { seamlessAuth: true } }), Te(vu)) : je.setReadyToTrue(!!o4));
    })();
  }), [n6, le, w4, ae]), (0, import_react3.useEffect)((() => {
    if (w4) {
      if (!v5 || !v5.linkedAccounts.find(((e8) => "wallet" === e8.type && "privy" === e8.walletClientType))) return void he(!!te);
      if ([...E2].some(((e8) => "privy" === e8.walletClientType))) return void he(true);
      he(!!te);
    }
  }), [w4, v5, E2, te]), (0, import_react3.useEffect)((() => {
    n6.connectors?.setWalletList(ne.appearance.walletList);
  }), [ne.appearance.walletList.join()]);
  let Ee = () => {
    let e8 = io();
    return e8.inProgress && e8.popupFlow ? window.opener.location.origin !== window.location.origin ? void window.opener.postMessage({ type: "PRIVY_OAUTH_ERROR", error: "Origins between parent and child windows do not match." }) : "error" === e8.authorizationCode ? void window.opener.postMessage({ type: "PRIVY_OAUTH_ERROR", error: "Something went wrong. Try again." }) : void window.opener.postMessage({ type: "PRIVY_OAUTH_RESPONSE", stateCode: e8.stateCode, authorizationCode: e8.authorizationCode }) : (e8.inProgress && (function(e9) {
      return e9.startsWith("privy:");
    })(e8.provider) && !e8.popupFlow && (new BroadcastChannel(sl).postMessage({ type: "PRIVY_OAUTH_RESPONSE", stateCode: e8.stateCode, authorizationCode: e8.authorizationCode }), window.close()), !!e8.inProgress && !!e8.withPrivyUi && (n6.startAuthFlow(new to({ ...e8, customOAuthRedirectUrl: ne.customOAuthRedirectUrl })), Te(Ac), true));
  }, Ie = () => {
    let e8 = La2();
    if (!e8 || !ne.loginMethods.telegram || !ne.loginConfig.telegramAuthConfiguration?.seamlessAuthEnabled) return;
    let t8 = new Ma();
    return n6.startAuthFlow(t8), "login-url" === e8.flowType && (t8.meta.telegramWebAppData = void 0, t8.meta.telegramAuthResult = e8.authData), "web-app" === e8.flowType && (t8.meta.telegramAuthResult = void 0, t8.meta.telegramWebAppData = e8.authData), true;
  }, Se = async (e8, t8, r10, a3) => {
    if ("solana_adapter" !== e8) Ue(await n6.connectors?.createEthereumWalletConnector({ connectorType: e8, walletClientType: t8 }) || null, t8, r10, a3);
    else {
      let e9 = n6.connectors?.findSolanaWalletConnector(t8);
      if (!e9) return;
      Ue(e9, t8, r10, a3);
    }
  };
  async function Ue(e8, t8, r10, n7) {
    if (!e8) return q3({ status: "disconnected", connectedWallet: null, connectError: new r("Unable to connect to wallet."), connector: null, connectRetry: i3 }), n7?.(null, r10);
    q3({ status: "disconnected", connectedWallet: null, connectError: null, connector: e8, connectRetry: i3 }), e8 instanceof Hr && t8 && await e8.resetConnection(t8), q3({ connector: e8, status: "connecting", connectedWallet: null, connectError: null, connectRetry: () => Ue(e8, t8, r10, n7) });
    try {
      let t9 = await e8.connect({ showPrompt: true });
      if ((!t9 || qa(t9)) && ne.shouldEnforceDefaultChainOnConnect && !ne.chains.find(((e9) => e9.id === Number(t9?.chainId.replace("eip155:", "")))) && ("wallet_connect_v2" !== t9?.connectorType || "metamask" !== t9?.walletClientType)) {
        q3(((t10) => ({ ...t10, connector: e8, status: "switching_to_supported_chain", connectedWallet: null, connectError: null, connectRetry: i3 })));
        try {
          await t9?.switchChain(ne.defaultChain.id), t9 && (t9.chainId = ka(toHex(ne.defaultChain.id)));
        } catch {
          console.warn(`Unable to switch to default chain: ${ne.defaultChain.id}`);
        }
      }
      return q3(((e9) => ({ ...e9, status: "connected", connectedWallet: t9, connectError: null, connectRetry: i3 }))), t9 && Gr(ge, "connectWallet", "onSuccess", { wallet: t9 }), n7?.(t9, r10);
    } catch (e9) {
      return e9 instanceof e ? (console.warn(e9.cause ? e9.cause : e9.message), Gr(ge, "connectWallet", "onError", e9.privyErrorCode || p.GENERIC_CONNECT_WALLET_ERROR)) : (console.warn(e9), Gr(ge, "connectWallet", "onError", p.UNKNOWN_CONNECT_WALLET_ERROR)), q3(((t9) => ({ ...t9, status: "disconnected", connectedWallet: null, connectError: e9 }))), n7?.(null, r10);
    }
  }
  let Pe = async (e8, t8, r10) => {
    if (null === e8 || !qa(e8)) return;
    let a3 = new oa(n6, e8, t8, r10);
    n6.startAuthFlow(a3);
  }, We = async (e8, t8, r10, a3 = "plain") => {
    let i6 = c2(pp);
    if ("transaction" === a3 && !i6) throw new _("useSolanaLedger plugin hook must be mounted");
    if (null === e8 || !gr(e8)) return;
    let o4 = new sa2(e8, n6, t8, r10, a3, i6);
    n6.startAuthFlow(o4);
  }, xe = () => {
    let e8 = new URLSearchParams(window.location.search), t8 = e8.get("privy_connector"), r10 = e8.get("privy_wallet_client"), a3 = "true" === e8.get("privy_connect_only");
    if (!t8 || !r10) return;
    let i6 = or({ connectorType: t8, walletClientType: r10 });
    if (!i6 || !i6.isInstalled) return Te(tc);
    if (!n6.connectors) throw new _("Connector not initialized");
    Te(a3 ? eh : Ip);
    let o4 = new URL(window.location.href);
    o4.searchParams.delete("privy_connector"), o4.searchParams.delete("privy_wallet_client"), o4.searchParams.delete("privy_connect_only"), window.history.pushState({}, "", o4), Se(t8, r10, void 0, a3 ? void 0 : "solana_adapter" === t8 ? We : Pe);
  };
  (0, import_react3.useEffect)((() => {
    w4 && g2 && null === v5 && n6.getAuthenticatedUser().then(b4);
  }), [w4, g2, v5, n6]);
  let Ne = (e8) => {
    if (!g2) throw Gr(ge, "linkAccount", "onError", p.MUST_BE_AUTHENTICATED, { linkMethod: e8 }), new _("User must be authenticated before linking an account.");
  }, Re = (e8) => {
    if (!g2 || !v5) return false;
    if ("privy" === e8.walletClientType) return true;
    for (let t8 of v5.linkedAccounts) if ("wallet" === t8.type && t8.address === e8.address && "privy" !== t8.walletClientType) return true;
    return false;
  }, Oe2 = () => {
    I2(((e8) => {
      let t8 = n6.connectors?.wallets.filter(qa).map(((e9) => ({ ...e9, linked: Re(e9), loginOrLink: async () => {
        if (!await e9.isConnected()) throw new _("Wallet is not connected");
        if ("embedded" === e9.connectorType && "privy" === e9.walletClientType) throw new _("Cannot link or login with embedded wallet");
        (async (e10) => {
          let t9;
          if (!n6.connectors) throw new _("Connector not initialized");
          t9 = "ethereum" === e10.type ? n6.connectors.findWalletConnector(e10.connectorType, e10.walletClientType) || null : n6.connectors.findSolanaWalletConnector(e10.walletClientType) || null, q3(((r10) => ({ ...r10, connector: t9, status: "connected", connectedWallet: e10, connectError: null, connectRetry: i3 }))), ne.captchaEnabled && !g2 ? (se({ captchaModalData: { callback: (t10) => qa(e10) ? Pe(e10, t10) : We(e10, t10), userIntentRequired: false, onSuccessNavigateTo: Ip, onErrorNavigateTo: zc } }), Te(mp)) : (qa(e10) ? await Pe(e10) : await We(e10), Te(Ip));
        })(e9);
      }, fund: async (t9) => {
        await je.fundWallet(e9.address, t9);
      }, unlink: async () => {
        if (!g2) throw new _("User is not authenticated.");
        if ("embedded" === e9.connectorType && "privy" === e9.walletClientType) throw new _("Cannot unlink an embedded wallet");
        b4(await n6.unlinkEthereumWallet(e9.address));
      } }))) || [];
      return Ga(e8, t8) ? e8 : t8;
    }));
  };
  (0, import_react3.useEffect)((() => {
    Oe2();
  }), [v5?.linkedAccounts, g2, w4]), (0, import_react3.useEffect)((() => {
    if (w4) {
      if (!n6.connectors) throw new _("Connector not initialized");
      Oe2(), n6.connectors.on("walletsUpdated", Oe2);
    }
  }), [w4]), (0, import_react3.useEffect)((() => {
    [...ne.loginMethodsAndOrder?.primary ?? [], ...ne.loginMethodsAndOrder?.overflow ?? []].filter(((e8) => e8.startsWith("privy:"))).forEach(((e8) => n6.getCrossAppProviderDetails(e8.replace("privy:", ""))));
  }), [!!n6]);
  let Me = ({ transaction: t8, sponsor: r10, uiOptions: a3, fundWalletConfig: o4, address: s3, signOnly: l5 }) => new Promise((async (c3, d3) => {
    let { requesterAppId: u2 } = a3 || {}, h8 = l5 ? "signTransaction" : "sendTransaction", p5 = s3 ? f2(v5, s3) : l2(v5);
    if (!p5 && s3) {
      let e8 = _2(E2, s3);
      if (e8) {
        if (r10) throw new _("Cannot sponsor transactions for externally connected wallet.");
        try {
          let r11 = await e8.getEthereumProvider(), n7 = { ...t8, from: s3, chainId: t8.chainId || Number(e8.chainId.replace("eip155:", "")), value: void 0 !== t8.value ? toHex(t8.value) : void 0 }, a4 = await r11.request({ method: "sendTransaction" === h8 ? "eth_sendTransaction" : "eth_signTransaction", params: [n7] });
          return Gr(ge, h8, "onSuccess", { hash: a4 }), void c3({ hash: a4 });
        } catch (e9) {
          return Gr(ge, h8, "onError", p.TRANSACTION_FAILURE), void d3(e9 ?? new Va("Unable to " + h8 + e9));
        }
      }
    }
    if (!p5) return Gr(ge, h8, "onError", p.EMBEDDED_WALLET_NOT_FOUND), void d3(new _("No embedded or connected wallet found for address."));
    if (!g2 || !v5) return Gr(ge, h8, "onError", p.MUST_BE_AUTHENTICATED), void d3(Error("User must be authenticated before signing with a Privy wallet"));
    let m5 = p5.address, w5 = p5.walletIndex ?? 0, { entropyId: y7, entropyIdVerifier: f5 } = Ra2(v5, p5), C4 = He.wallets.find(((e8) => "privy" === e8.walletClientType && getAddress(e8.address) === getAddress(m5)));
    if (!C4) return Gr(ge, h8, "onError", p.EMBEDDED_WALLET_NOT_FOUND), void d3(Error("Must have a Privy wallet before signing"));
    let k3 = await C4.getEthereumProvider(), b5 = await k3.request({ method: "eth_chainId" }), I3 = t8.chainId ? Number(t8.chainId) : _3(b5);
    ((e8) => {
      if (!ne.chains.map(((e9) => e9.id)).includes(e8)) throw new r(`Chain ID ${e8} is not supported. It must be added to the config.supportedChains property of the PrivyProvider.`, p.UNSUPPORTED_CHAIN_ID);
    })(I3);
    let S3 = { ...t8, from: t8.from ?? m5, chainId: I3 }, P4 = await zc2();
    if (!P4 || !te) return Gr(ge, h8, "onError", p.EMBEDDED_WALLET_NOT_FOUND), void d3(Error("Must have valid access token and Privy wallet to send transaction"));
    let W4 = ua2(S3.chainId, ne.chains, ne.rpcConfig, { appId: e7.appId }), x5 = b2(p5), N3 = async ({ transactionRequest: e8 }) => {
      try {
        let t9;
        if (!await je.recoverEmbeddedWallet({ address: m5 })) throw Gr(ge, h8, "onError", p.UNKNOWN_CONNECT_WALLET_ERROR), d3(Error("Unable to connect to wallet")), Error("Unable to connect to wallet");
        if (r10) {
          let t10 = await (async ({ transactionRequest: e9 }) => {
            if (!x5) throw new _("Sponsoring is only supported for wallets on the TEE stack");
            if (l5) throw new _("Cannot sponsor a sign transaction request");
            let t11 = (e10) => null == e10 ? void 0 : toHex(e10), r11 = await r4(i5, (async ({ message: e10 }) => await te.signWithUserSigner({ accessToken: P4, requesterAppId: u2, message: e10 })), { chain_type: "ethereum", method: "eth_sendTransaction", caip2: ka(toHex(e9.chainId)), sponsor: true, params: { transaction: { from: e9.from, to: e9.to, chain_id: t11(e9.chainId), data: isHex(e9.data) ? e9.data ? e9.data : toHex(Uint8Array.from(e9.data)) : void 0, value: t11(e9.value) } }, wallet_id: p5.id });
            if (r11.data && "hash" in r11.data) return r11.data.hash;
            throw new Va("Unable to sign transaction");
          })({ transactionRequest: e8 });
          return Gr(ge, "sendTransaction", "onSuccess", { hash: t10 }), t10;
        }
        if (x5) {
          let r11 = (e9) => null == e9 ? void 0 : toHex(e9), n7 = await r4(i5, (async ({ message: e9 }) => await te.signWithUserSigner({ accessToken: P4, requesterAppId: u2, message: e9 })), { chain_type: "ethereum", method: "eth_signTransaction", params: { transaction: { from: e8.from, to: e8.to, nonce: r11(e8.nonce), chain_id: r11(e8.chainId), data: isHex(e8.data) ? e8.data ? e8.data : toHex(Uint8Array.from(e8.data)) : void 0, value: r11(e8.value), type: e8.type, gas_limit: r11(e8.gasLimit ?? e8.gas), gas_price: r11(e8.gasPrice ?? e8.gas), max_fee_per_gas: r11(e8.maxFeePerGas), max_priority_fee_per_gas: r11(e8.maxPriorityFeePerGas) } }, wallet_id: p5.id });
          if (!n7.data || !("signed_transaction" in n7.data)) throw new Va("Unable to sign transaction");
          t9 = n7.data.signed_transaction;
        } else t9 = await (async function({ accessToken: e9, entropyId: t10, entropyIdVerifier: r11, transactingWalletIndex: n7, walletProxy: a4, transactionRequest: i6, requesterAppId: o5 }) {
          return (await a4.rpc({ entropyId: t10, entropyIdVerifier: r11, hdWalletIndex: n7 ?? 0, chainType: "ethereum", accessToken: e9, requesterAppId: o5, request: { method: "eth_signTransaction", params: [i6] } })).response.data;
        })({ accessToken: P4, entropyId: y7, entropyIdVerifier: f5, transactingWalletIndex: w5, walletProxy: te, transactionRequest: e8, requesterAppId: u2 });
        if (l5) return Gr(ge, "signTransaction", "onSuccess", { signature: t9 }), t9;
        {
          let e9 = await W4.sendRawTransaction({ serializedTransaction: t9 });
          return Gr(ge, "sendTransaction", "onSuccess", { hash: e9 }), e9;
        }
      } catch (e9) {
        throw Gr(ge, h8, "onError", p.TRANSACTION_FAILURE), e9;
      }
    };
    if (be({ showWalletUIs: a3?.showWalletUIs })) {
      let e8 = l5 || r10 ? S3 : await _l(S3, W4, S3.from);
      try {
        let t9 = await N3({ transactionRequest: e8 });
        l5 ? Gr(ge, "signTransaction", "onSuccess", { signature: t9 }) : Gr(ge, "sendTransaction", "onSuccess", { hash: t9 }), c3({ hash: t9 });
      } catch (e9) {
        Gr(ge, h8, "onError", p.TRANSACTION_FAILURE), d3(e9);
      }
    } else {
      let e8 = { connectingWalletAddress: m5, recoveryMethod: p5.recoveryMethod, entropyId: y7, entropyIdVerifier: f5, onCompleteNavigateTo: Lf, isUnifiedWallet: x5, onFailure: (e9) => {
        Gr(ge, h8, "onError", p.UNKNOWN_CONNECT_WALLET_ERROR), d3(e9);
      } }, t9 = ((e9) => !!e9.fundingConfig && P2(e9.fundingConfig.options).length >= 1)(ne) ? F2({ address: m5, appConfig: ne, fundWalletConfig: o4, methodScreen: vm, chainIdOverride: S3.chainId, comingFromSendTransactionScreen: true }) : void 0;
      se({ connectWallet: e8, sendTransaction: { transactionRequest: S3, transactingWalletIndex: w5, transactingWalletAddress: m5, entropyId: y7, entropyIdVerifier: f5, signOnly: l5, scanTransaction: async () => {
        let e9 = await _l(S3, W4, S3.from);
        return await n6.scanTransaction({ metadata: { domain: ne.embeddedWallets.transactionScanning.domain }, chain_id: e9.chainId.toString(), request: { method: "eth_sendTransaction", params: [{ from: e9.from, to: e9.to, value: e9.value?.toString(), gas: e9.gas?.toString(), gasPrice: e9.gasPrice?.toString(), nonce: e9.nonce?.toString(), data: e9.data }] } });
      }, getIsSponsored: async () => !!r10, onConfirm: ({ transactionRequest: e9 }) => N3({ transactionRequest: e9 }), onSuccess: (e9) => {
        l5 ? Gr(ge, "signTransaction", "onSuccess", { signature: e9.hash }) : Gr(ge, "sendTransaction", "onSuccess", { hash: e9.hash }), c3(e9);
      }, onFailure: (e9) => {
        Gr(ge, h8, "onError", p.TRANSACTION_FAILURE), d3(e9);
      }, uiOptions: a3 || {}, fundWalletConfig: o4, requesterAppId: u2 }, funding: t9 }), Te(qf);
    }
  }));
  function Fe() {
    return new Promise((async (e8, t8) => {
      let r10 = await zc2();
      if (!r10 || !te) throw Error("Must have valid access token to enroll in MFA");
      try {
        await te.verifyMfa({ accessToken: r10 }), e8();
      } catch (e9) {
        t8(e9);
      }
    }));
  }
  let Le = (e8) => e8?.linkedAccounts.filter(((e9) => null !== e9.latestVerifiedAt && !("wallet" === e9.type && "privy" === e9.walletClientType))).sort(((e9, t8) => t8.latestVerifiedAt.getTime() - e9.latestVerifiedAt.getTime()))[0], De = (e8) => {
    let t8 = v5?.linkedAccounts.filter(((t9) => t9.type === e8)).length ?? 0, { displayName: r10, loginMethod: n7 } = nc(e8);
    if ("passkey" === e8 && t8 >= 5 || "passkey" !== e8 && t8 >= 1) throw Gr(ge, "linkAccount", "onError", p.CANNOT_LINK_MORE_OF_TYPE, { linkMethod: n7 }), new _(`User already has an account of type ${r10} linked.`);
  };
  async function qe({ showAutomaticRecovery: e8 = false, legacySetWalletPasswordFlow: t8 = false }) {
    R2(null);
    let r10 = t8 ? "setWalletPassword" : "setWalletRecovery";
    if (!g2 || !v5) throw Gr(ge, r10, "onError", p.MUST_BE_AUTHENTICATED), Error("User must be authenticated before adding recovery method to Privy wallet");
    let n7 = y2(v5);
    if (!n7 || !te) throw Gr(ge, r10, "onError", p.EMBEDDED_WALLET_NOT_FOUND), Error("Must have a Privy wallet to add a recovery method");
    let a3 = b2(n7);
    if (a3) throw Gr(ge, r10, "onError", p.UNSUPPORTED_WALLET_TYPE), new _("User owned wallet recovery is only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");
    try {
      await Fe();
    } catch (e9) {
      throw Gr(ge, r10, "onError", p.MISSING_MFA_CREDENTIALS), e9;
    }
    return new Promise(((i6, o4) => {
      let s3 = "user-passcode" === n7.recoveryMethod, l5 = Ph({ walletAction: "update", availableRecoveryMethods: ne.embeddedWallets.userOwnedRecoveryOptions, legacySetWalletPasswordFlow: t8, isResettingPassword: s3, showAutomaticRecovery: e8 }), { entropyId: c3, entropyIdVerifier: d3 } = Ra2(v5), u2 = { recoveryMethod: n7.recoveryMethod, connectingWalletAddress: n7.address, onCompleteNavigateTo: l5, shouldForceMFA: false, entropyId: c3, isUnifiedWallet: a3, entropyIdVerifier: d3, onFailure: (e9) => {
        Gr(ge, r10, "onError", p.UNKNOWN_CONNECT_WALLET_ERROR), o4(e9);
      } };
      se({ setWalletPassword: { onSuccess: (e9) => {
        Gr(ge, r10, "onSuccess", { method: "user-passcode", wallet: e9 }), i6(e9);
      }, onFailure: (e9) => {
        Gr(ge, r10, "onError", p.USER_EXITED_SET_PASSWORD_FLOW), o4(e9);
      }, callAuthOnSuccessOnClose: false }, recoverWallet: { entropyId: c3, entropyIdVerifier: d3, onFailure: o4 }, connectWallet: u2, recoverySelection: { isInAccountCreateFlow: false, isResettingPassword: s3, shouldCreateEth: false, shouldCreateSol: false } }), Te(qf);
    }));
  }
  async function ze2({ appId: e8, action: t8 }) {
    let r10 = await zc2();
    if ("link" === t8 && !r10) throw Gr(ge, "linkAccount", "onError", p.MUST_BE_AUTHENTICATED, { linkMethod: `privy:${e8}` }), new _("User must be authenticated before linking an account.");
    if ("login" === t8 && r10) throw Gr(ge, "login", "onError", p.UNKNOWN_AUTH_ERROR), new _("Attempted to log in, but user is already logged in. Use a `link` helper instead.");
    Ce.current = `privy:${e8}`, ke.current = t8;
    let a3 = zl();
    return n6.createAnalyticsEvent({ eventName: "cross_app_auth_started", payload: { providerAppId: e8 } }), new Promise((async (r11, i6) => {
      let { name: o4, logoUrl: s3 } = await dl({ api: n6.api, providerAppId: e8, requesterAppId: ne.id });
      se({ crossAppAuth: { appId: e8, name: o4, logoUrl: s3, action: t8, popup: a3, onSuccess: r11, onError: i6 } }), Te(Rl2);
    }));
  }
  let Be = { ready: w4, authenticated: g2, user: v5, walletConnectors: n6.connectors || null, connectWallet: (e8) => {
    e8 && "target" in e8 && e8 && (e8 = void 0), se({ externalConnectWallet: { walletList: e8?.walletList && e8?.walletList.length > 0 ? e8.walletList : void 0, walletChainType: e8?.walletChainType, description: e8?.description } }), Te(Np);
  }, linkWallet: (e8) => {
    e8 && "target" in e8 && e8 && (e8 = void 0), Ne("siwe"), Ce.current = "siwe", ke.current = "link", se({ ...oe, externalConnectWallet: { ...oe.externalConnectWallet, walletList: e8?.walletList, walletChainType: e8?.walletChainType, description: e8?.description || `Link a wallet to your ${ne?.name} account` } }), Te(Ep);
  }, startCrossAppAuthFlow: ze2, linkEmail: () => {
    Ne("email"), De("email"), Ce.current = "email", ke.current = "link", Te(Jl);
  }, linkPhone: () => {
    Ne("sms"), De("phone"), Ce.current = "sms", ke.current = "link", Te(Ql);
  }, linkGoogle: async () => {
    Ne("google"), De("google_oauth"), ke.current = "link", await je.initLoginWithOAuth("google");
  }, linkTwitter: async () => {
    Ne("twitter"), De("twitter_oauth"), ke.current = "link", await je.initLoginWithOAuth("twitter");
  }, linkDiscord: async () => {
    Ne("discord"), De("discord_oauth"), ke.current = "link", await je.initLoginWithOAuth("discord");
  }, linkGithub: async () => {
    Ne("github"), De("github_oauth"), ke.current = "link", await je.initLoginWithOAuth("github");
  }, linkSpotify: async () => {
    Ne("spotify"), De("spotify_oauth"), ke.current = "link", await je.initLoginWithOAuth("spotify");
  }, linkInstagram: async () => {
    Ne("instagram"), De("instagram_oauth"), ke.current = "link", await je.initLoginWithOAuth("instagram");
  }, linkTiktok: async () => {
    Ne("tiktok"), De("tiktok_oauth"), ke.current = "link", await je.initLoginWithOAuth("tiktok");
  }, linkLine: async () => {
    Ne("line"), De("line_oauth"), ke.current = "link", await je.initLoginWithOAuth("line");
  }, linkLinkedIn: async () => {
    Ne("linkedin"), De("linkedin_oauth"), ke.current = "link", await je.initLoginWithOAuth("linkedin");
  }, linkApple: async () => {
    Ne("apple"), De("apple_oauth"), ke.current = "link", await je.initLoginWithOAuth("apple");
  }, linkPasskey: async () => {
    Ne("passkey"), De("passkey"), await je.initLinkWithPasskey(), Te(fl);
  }, linkTelegram: async (e8) => {
    if (Ne("telegram"), De("telegram"), ke.current = "link", Ce.current = "telegram", e8?.launchParams) if (e8.launchParams.initDataRaw) {
      let t8 = new Ma();
      n6.startAuthFlow(t8), t8.meta.telegramAuthResult = void 0, t8.meta.telegramWebAppData = Da2(e8.launchParams.initDataRaw), se({ telegramAuthModalData: { seamlessAuth: true } }), Te(vu);
    } else Gr(ge, "linkAccount", "onError", p.INVALID_DATA, { linkMethod: "telegram" });
    else await je.initLoginWithTelegram();
    Te(vu);
  }, linkFarcaster: async () => {
    Ne("farcaster"), De("farcaster"), await je.initLoginWithFarcaster(), ke.current = "link", Ce.current = "farcaster", Te(Zp);
  }, updateEmail: () => {
    if (Ne("email"), !v5?.email) throw new _("User does not have an email linked to their account.");
    ke.current = "update", Ce.current = "email", Te(Ic);
  }, updatePhone: () => {
    if (Ne("sms"), !v5?.phone) throw new _("User does not have a phone number linked to their account.");
    ke.current = "update", Ce.current = "sms", Te(Uc2);
  }, login: async (e8) => {
    e8 && "target" in e8 && e8 && (e8 = void 0);
    let t8 = "Attempted to log in, but user is already logged in. Use a `link` helper instead.";
    if (!w4) {
      let e9 = await new Promise(((e10) => {
        ce(((t9) => e10.bind(t9)));
      }));
      if (ce(null), e9) return void console.warn(t8);
    }
    !v5 || v5.isGuest ? (ke.current = "login", se({ login: e8 }), Te(Ch)) : console.warn(t8);
  }, connectOrCreateWallet: async () => {
    w4 || (await new Promise(((e8) => {
      ce((() => e8));
    })), ce(null)), g2 ? console.warn("User must be unauthenticated to `connectOrCreateWallet`") : (ke.current = "connect-or-create", Te(Mu));
  }, logout: async () => {
    if (ke.current = null, Ce.current = null, v5 && n6.clearProviderAcccessTokens(v5), R2(null), await n6.logout(), v5 && te) try {
      await te.clearMfa({ userId: v5.id });
    } catch (e8) {
    }
    b4(null), f4(false), Gr(ge, "logout", "onSuccess"), h7(false), ln.del(_n), ln.del(Mn(ne.id));
  }, getAccessToken: (0, import_react3.useCallback)((() => n6.getCustomerAccessToken()), [n6]), unlinkWallet: async (e8) => {
    let t8;
    return b4(t8 = e8.startsWith("0x") ? await n6.unlinkEthereumWallet(e8) : await n6.unlinkSolanaWallet(e8)), t8;
  }, unlinkEmail: async (e8) => {
    let t8 = await n6.unlinkEmail(e8);
    return b4(t8), t8;
  }, unlinkPhone: async (e8) => {
    let t8 = await n6.unlinkPhone(e8);
    return b4(t8), t8;
  }, unlinkGoogle: async (e8) => {
    let t8 = await n6.unlinkOAuth("google", e8);
    return b4(t8), t8;
  }, unlinkTwitter: async (e8) => {
    let t8 = await n6.unlinkOAuth("twitter", e8);
    return b4(t8), t8;
  }, unlinkDiscord: async (e8) => {
    let t8 = await n6.unlinkOAuth("discord", e8);
    return b4(t8), t8;
  }, unlinkGithub: async (e8) => {
    let t8 = await n6.unlinkOAuth("github", e8);
    return b4(t8), t8;
  }, unlinkSpotify: async (e8) => {
    let t8 = await n6.unlinkOAuth("spotify", e8);
    return b4(t8), t8;
  }, unlinkInstagram: async (e8) => {
    let t8 = await n6.unlinkOAuth("instagram", e8);
    return b4(t8), t8;
  }, unlinkTiktok: async (e8) => {
    let t8 = await n6.unlinkOAuth("tiktok", e8);
    return b4(t8), t8;
  }, unlinkLine: async (e8) => {
    let t8 = await n6.unlinkOAuth("line", e8);
    return b4(t8), t8;
  }, unlinkLinkedIn: async (e8) => {
    let t8 = await n6.unlinkOAuth("linkedin", e8);
    return b4(t8), t8;
  }, unlinkApple: async (e8) => {
    let t8 = await n6.unlinkOAuth("apple", e8);
    return b4(t8), t8;
  }, unlinkFarcaster: async (e8) => {
    let t8 = await n6.unlinkFarcaster(e8);
    return b4(t8), t8;
  }, unlinkTelegram: async (e8) => {
    let t8 = await n6.unlinkTelegram(e8);
    return b4(t8), t8;
  }, unlinkPasskey: async (e8) => {
    let t8 = await zc2();
    if (!t8) throw Error("Must have valid access token to enroll in MFA");
    if (!te) throw Error("Wallet proxy not initialized.");
    let r10 = ne.passkeys.shouldUnenrollMfaOnUnlink;
    await te.unlinkPasskeyAccount({ credentialId: e8, accessToken: t8, removeAsMfa: r10 });
    let a3 = await n6.getAuthenticatedUser();
    return b4(a3), a3;
  }, unlinkCrossAppAccount: async ({ subject: e8 }) => {
    let t8 = v5?.linkedAccounts.find(((t9) => "cross_app" === t9.type && t9.subject === e8))?.providerApp;
    if (!t8) throw new _("Invalid subject");
    n6.storeProviderAccessToken(t8.id, null);
    let r10 = await n6.unlinkOAuth(`privy:${t8.id}`, e8);
    return b4(r10), r10;
  }, setWalletRecovery: async (e8) => qe({ legacySetWalletPasswordFlow: false, showAutomaticRecovery: e8?.showAutomaticRecovery ?? false }), setWalletPassword: async () => qe({ legacySetWalletPasswordFlow: true, showAutomaticRecovery: false }), signMessage: (e8, t8) => new Promise((async (r10, a3) => {
    let { requesterAppId: o4 } = t8?.uiOptions || {}, s3 = e8.message, l5 = t8?.address ? f2(v5, t8.address) : l2(v5);
    if (!l5 && void 0 !== t8?.address) {
      let e9 = _2(E2, t8.address);
      if (e9) try {
        let t9 = await e9.getEthereumProvider(), n7 = await t9.request({ method: "personal_sign", params: [s3, e9.address] });
        return Gr(ge, "signMessage", "onSuccess", { signature: n7 }), void r10({ signature: n7 });
      } catch (e10) {
        return Gr(ge, "signMessage", "onError", p.UNABLE_TO_SIGN), void a3(e10 ?? new Va("Unable to sign message"));
      }
    }
    if (!l5) throw new _("No embedded or connected wallet found for address.");
    if (!g2 || !v5) return Gr(ge, "signMessage", "onError", p.MUST_BE_AUTHENTICATED), void a3(Error("User must be authenticated before signing with a Privy wallet"));
    let c3 = l5.address, d3 = l5.walletIndex ?? 0, { entropyId: u2, entropyIdVerifier: h8 } = Ra2(v5, l5), p5 = b2(l5);
    if ("string" != typeof s3 || s3.length < 1) return Gr(ge, "signMessage", "onError", p.INVALID_MESSAGE), void a3(Error("Message must be a non-empty string"));
    let m5 = async () => {
      let t9;
      if (!g2) throw Error("User must be authenticated before signing with a Privy wallet");
      let r11 = await zc2();
      if (!te || !r11 || !await je.recoverEmbeddedWallet({ address: c3 })) throw Error("Unable to connect to wallet");
      if (n6.createAnalyticsEvent({ eventName: "embedded_wallet_sign_message_started", payload: { walletAddress: c3, requesterAppId: o4 } }), p5) {
        let n7 = isHex(e8.message, { strict: true }), a4 = await r4(i5, (async ({ message: e9 }) => await te.signWithUserSigner({ accessToken: r11, requesterAppId: o4, message: e9 })), { chain_type: "ethereum", method: "personal_sign", params: n7 ? { message: s3.slice(2), encoding: "hex" } : { message: s3, encoding: "utf-8" }, wallet_id: l5.id });
        if (!a4.data || !("signature" in a4.data)) throw new Va("Unable to sign message");
        t9 = a4.data.signature;
      } else {
        let { response: e9 } = await te.rpc({ accessToken: r11, entropyId: u2, entropyIdVerifier: h8, chainType: "ethereum", hdWalletIndex: d3, requesterAppId: o4, request: { method: "personal_sign", params: [s3, c3] } });
        t9 = e9.data;
      }
      return n6.createAnalyticsEvent({ eventName: "embedded_wallet_sign_message_completed", payload: { walletAddress: c3, requesterAppId: o4 } }), t9;
    };
    if (be({ showWalletUIs: t8?.uiOptions?.showWalletUIs })) try {
      let e9 = await m5();
      Gr(ge, "signMessage", "onSuccess", { signature: e9 }), r10({ signature: e9 });
    } catch (e9) {
      Gr(ge, "signMessage", "onError", p.UNABLE_TO_SIGN), a3(e9 ?? new Va("Unable to sign message"));
    }
    else se({ signMessage: { method: "personal_sign", data: s3, confirmAndSign: m5, onSuccess: (e9) => {
      Gr(ge, "signMessage", "onSuccess", { signature: e9 }), r10({ signature: e9 });
    }, onFailure: (e9) => {
      Gr(ge, "signMessage", "onError", p.UNABLE_TO_SIGN), a3(e9);
    }, uiOptions: t8?.uiOptions || {} }, connectWallet: { recoveryMethod: l5.recoveryMethod, connectingWalletAddress: c3, entropyId: u2, entropyIdVerifier: h8, onCompleteNavigateTo: ny, isUnifiedWallet: p5, onFailure: (e9) => {
      Gr(ge, "signMessage", "onError", p.UNKNOWN_CONNECT_WALLET_ERROR), a3(e9);
    } } }), Te(qf);
  })), signTypedData: (e8, t8) => new Promise((async (r10, a3) => {
    let { requesterAppId: o4 } = t8?.uiOptions || {}, s3 = t8?.address ? f2(v5, t8.address) : l2(v5);
    if (!s3 && t8?.address) {
      let n7 = _2(E2, t8.address);
      if (n7) try {
        let t9 = await n7.getEthereumProvider(), a4 = Aa2(e8), i6 = await t9.request({ method: "eth_signTypedData_v4", params: [n7.address, a4] });
        return Gr(ge, "signTypedData", "onSuccess", { signature: i6 }), void r10({ signature: i6 });
      } catch (e9) {
        return Gr(ge, "signTypedData", "onError", p.UNABLE_TO_SIGN), void a3(e9 ?? new Va("Unable to sign typed data " + e9));
      }
    }
    if (!s3) throw new _("No embedded or connected wallet found for address.");
    if (!g2 || !v5) return Gr(ge, "signTypedData", "onError", p.MUST_BE_AUTHENTICATED), void a3(Error("User must be authenticated before signing with a Privy wallet"));
    let l5 = s3.address, c3 = s3.walletIndex ?? 0, { entropyId: d3, entropyIdVerifier: u2 } = Ra2(v5, s3), h8 = b2(s3), p5 = Aa2(e8), m5 = async () => {
      let e9;
      if (!g2) throw Error("User must be authenticated before signing with a Privy wallet");
      let t9 = await zc2();
      if (!te || !t9 || !await je.recoverEmbeddedWallet({ address: l5 })) throw Error("Unable to connect to wallet");
      if (n6.createAnalyticsEvent({ eventName: "embedded_wallet_sign_typed_data_started", payload: { walletAddress: l5, requesterAppId: o4 } }), h8) {
        let { domain: r11, types: n7, primaryType: a4, message: l6 } = p5, c4 = await r4(i5, (async ({ message: e10 }) => await te.signWithUserSigner({ accessToken: t9, requesterAppId: o4, message: e10 })), { chain_type: "ethereum", method: "eth_signTypedData_v4", params: { typed_data: { domain: r11, types: n7, primary_type: a4, message: l6 } }, wallet_id: s3.id });
        if (!c4.data || !("signature" in c4.data)) throw new Va("Unable to sign message");
        e9 = c4.data.signature;
      } else {
        let { response: r11 } = await te.rpc({ accessToken: t9, entropyId: d3, entropyIdVerifier: u2, chainType: "ethereum", hdWalletIndex: c3, requesterAppId: o4, request: { method: "eth_signTypedData_v4", params: [l5, p5] } });
        e9 = r11.data;
      }
      return n6.createAnalyticsEvent({ eventName: "embedded_wallet_sign_typed_data_completed", payload: { walletAddress: l5, requesterAppId: o4 } }), e9;
    };
    if (be({ showWalletUIs: t8?.uiOptions?.showWalletUIs })) try {
      let e9 = await m5();
      Gr(ge, "signTypedData", "onSuccess", { signature: e9 }), r10({ signature: e9 });
    } catch (e9) {
      Gr(ge, "signTypedData", "onError", p.UNABLE_TO_SIGN), a3(e9 ?? new Va("Unable to sign message"));
    }
    else se({ signMessage: { method: "eth_signTypedData_v4", data: p5, confirmAndSign: m5, onSuccess: (e9) => {
      Gr(ge, "signTypedData", "onSuccess", { signature: e9 }), r10({ signature: e9 });
    }, onFailure: (e9) => {
      Gr(ge, "signTypedData", "onError", p.UNABLE_TO_SIGN), a3(e9);
    }, uiOptions: t8?.uiOptions || {} }, connectWallet: { recoveryMethod: s3.recoveryMethod, connectingWalletAddress: s3.address, entropyId: d3, isUnifiedWallet: h8, entropyIdVerifier: u2, onCompleteNavigateTo: ny, onFailure: (e9) => {
      Gr(ge, "signMessage", "onError", p.UNKNOWN_CONNECT_WALLET_ERROR), a3(e9);
    } } }), Te(qf);
  })), sendTransaction: async (e8, t8) => await Me({ transaction: e8, sponsor: t8?.sponsor, uiOptions: t8?.uiOptions, fundWalletConfig: t8?.fundWalletConfig, address: t8?.address, signOnly: false }), signTransaction: async (e8, t8) => ({ signature: (await Me({ transaction: e8, uiOptions: t8?.uiOptions, address: t8?.address, signOnly: true })).hash }), exportWallet: (t8) => new Promise((async (r10, a3) => {
    if (!g2 || !v5) return void a3(Error("User must be authenticated before exporting their Privy wallet"));
    t8 && "target" in t8 && t8 && (t8 = void 0);
    let i6 = t8?.address ? f2(v5, t8.address) : l2(v5);
    if (!i6) return void a3(new _("User must have an embedded wallet."));
    let o4 = i6.address, { entropyId: s3, entropyIdVerifier: l5 } = Ra2(v5, i6), c3 = b2(i6);
    if (!o4) return void a3(Error("User does not have an HD Ethereum wallet. To export an imported wallet, pass the `address` of the wallet to `exportWallet`."));
    if (!isAddress(o4)) return void a3(Error("Must provide a valid Ethereum address."));
    let d3 = { recoveryMethod: i6.recoveryMethod, connectingWalletAddress: i6.address, isUnifiedWallet: c3, entropyId: s3, entropyIdVerifier: l5, onCompleteNavigateTo: Hf, onFailure: a3, shouldForceMFA: true };
    se(oe), await zc2() && te ? te ? M2(i6) ? (se({ keyExport: { appId: e7.appId, appClientId: e7.clientId, origin: n6.apiUrl, address: i6.address, entropyId: s3, entropyIdVerifier: l5, hdWalletIndex: i6.walletIndex, chainType: i6.chainType, walletId: i6.id, isUnifiedWallet: c3, imported: i6.imported, onSuccess: r10, onFailure: a3 }, connectWallet: d3 }), Te(qf)) : a3(Error(`Export is not supported for ${i6.chainType} wallets`)) : a3(Error("Must have a Privy wallet before exporting")) : a3(Error("Must have valid access token to enroll in MFA"));
  })), promptMfa: Fe, async init(e8) {
    switch (e8) {
      case "sms":
        return void await n6.initMfaSmsVerification();
      case "passkey":
        return await n6.initMfaPasskeyVerification();
      case "totp":
        return;
      default:
        throw Error(`Unsupported MFA method: ${e8}`);
    }
  }, async submit(e8, t8) {
    switch (e8) {
      case "totp":
      case "sms":
        if ("string" != typeof t8) throw new _("Invalid MFA code");
        we.current?.resolve({ mfaMethod: e8, mfaCode: t8, relyingParty: window.origin }), await new Promise(((e9, t9) => {
          ye.current = { resolve: e9, reject: t9 };
        }));
        break;
      case "passkey":
        if ("string" == typeof t8) throw new _("Invalid authenticator response");
        let r10 = await import("./bundle-O6MOEAL6.js"), n7 = xl(await r10.startAuthentication(t8));
        we.current?.resolve({ mfaMethod: e8, mfaCode: n7, relyingParty: window.origin }), await new Promise(((e9, t9) => {
          ye.current = { resolve: e9, reject: t9 };
        }));
        break;
      default:
        throw we.current?.reject(new _("Unsupported MFA method")), new _(`Unsupported MFA method: ${e8}`);
    }
  }, cancel() {
    we.current?.reject(new _("MFA canceled"));
  }, async initEnrollmentWithSms(e8) {
    let t8 = await zc2();
    if (!t8 || !te) throw Error("Must have valid access token to enroll in MFA");
    await te.initEnrollMfa({ method: "sms", accessToken: t8, phoneNumber: e8.phoneNumber });
  }, enrollInMfa: (e8) => new Promise(((t8, r10) => {
    if (!e8) return je.closePrivyModal(), void t8();
    ne.mfa.noPromptOnMfaRequired && console.warn("[Privy Warning] Triggering the 'showMfaEnrollmentModal' function when 'noPromptOnMfaRequired' is set to true is unexpected. If this is intentional, ensure that you are building custom UIs for MFA verification."), se({ mfaEnrollmentFlow: { mfaMethods: ne.mfa.methods, shouldUnlinkOnUnenrollMfa: ne.passkeys.shouldUnlinkOnUnenrollMfa, onSuccess: t8, onFailure: r10 } }), Te(Cc);
  })), async initEnrollmentWithTotp() {
    let e8 = await zc2();
    if (!e8 || !te) throw Error("Must have valid access token to enroll in MFA");
    let t8 = await te.initEnrollMfa({ method: "totp", accessToken: e8 });
    return { secret: t8.secret, authUrl: t8.authUrl };
  }, async submitEnrollmentWithSms(e8) {
    let t8 = await zc2();
    if (!t8 || !te) throw Error("Must have valid access token to enroll in MFA");
    await te.submitEnrollMfa({ method: "sms", accessToken: t8, phoneNumber: e8.phoneNumber, code: e8.mfaCode }), b4(await n6.getAuthenticatedUser());
  }, async submitEnrollmentWithTotp(e8) {
    let t8 = await zc2();
    if (!t8 || !te) throw Error("Must have valid access token to enroll in MFA");
    await te.submitEnrollMfa({ method: "totp", accessToken: t8, code: e8.mfaCode }), b4(await n6.getAuthenticatedUser());
  }, async initEnrollmentWithPasskey() {
  }, async submitEnrollmentWithPasskey({ credentialIds: e8 }, t8 = {}) {
    let r10 = await zc2();
    if (!r10 || !te) throw Error("Must have valid access token to enroll in MFA");
    await te.submitEnrollMfa({ method: "passkey", accessToken: r10, credentialIds: e8, removeForLogin: t8.removeForLogin }), b4(await n6.getAuthenticatedUser());
  }, async unenroll(e8, t8 = {}) {
    let r10 = await zc2();
    if (!r10 || !te) throw Error("Must have valid access token to remove MFA");
    "passkey" === e8 ? await te.submitEnrollMfa({ method: "passkey", accessToken: r10, credentialIds: [], removeForLogin: t8.removeForLogin }) : await te.unenrollMfa({ method: e8, accessToken: r10 }), b4(await n6.getAuthenticatedUser());
  }, requestFarcasterSignerFromWarpcast: async () => {
    let e8 = await zc2(), t8 = v5?.linkedAccounts.find(((e9) => "wallet" === e9.type && "privy" === e9.walletClientType));
    if (!e8) throw Error("Must have valid access token to connect with Farcaster");
    if (!te || !t8) throw Error("Must have an embedded wallet to use Farcaster signers");
    if (b2(t8)) throw new _("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");
    if (!v5?.farcaster?.fid) throw Error("Must have Farcaster account to use Farcaster signers");
    if (!await je.recoverEmbeddedWallet({ address: t8.address })) throw Error("Unable to connect to wallet");
    let r10 = await te.initFarcasterSigner({ address: t8.address, hdWalletIndex: null, accessToken: e8, mfaCode: null, mfaMethod: null, relyingParty: window.origin });
    "approved" === r10.status && b4(await n6.getAuthenticatedUser() || v5 || null), se({ farcasterSigner: r10 }), Te(Kl);
  }, getFarcasterSignerPublicKey: async () => {
    let e8, t8 = await zc2(), r10 = v5?.linkedAccounts.find(((e9) => "wallet" === e9.type && "privy" === e9.walletClientType));
    if (!t8) throw Error("Must have valid access token to connect with Farcaster");
    if (!te || !r10) throw Error("Must have an embedded wallet to use Farcaster signers");
    if (b2(r10)) throw new _("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");
    if (!v5?.farcaster?.fid) throw Error("Must have Farcaster account to use Farcaster signers");
    if (!await je.recoverEmbeddedWallet({ address: r10.address })) throw Error("Unable to connect to wallet");
    if (!v5.farcaster?.signerPublicKey) throw Error("Must have a Farcaster signer public key to sign");
    return e8 = v5.farcaster.signerPublicKey.slice(2), Uint8Array.from(e8.match(/.{1,2}/g).map(((e9) => parseInt(e9, 16))));
  }, signFarcasterMessage: async (e8) => {
    let t8 = await zc2(), r10 = v5?.linkedAccounts.find(((e9) => "wallet" === e9.type && "privy" === e9.walletClientType));
    if (!t8) throw Error("Must have valid access token to connect with Farcaster");
    if (!te || !r10) throw Error("Must have an embedded wallet to use Farcaster signers");
    if (b2(r10)) throw new _("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");
    if (!v5?.farcaster?.fid) throw Error("Must have Farcaster account to use Farcaster signers");
    if (!await je.recoverEmbeddedWallet({ address: r10.address })) throw Error("Unable to connect to wallet");
    if (!v5.farcaster?.signerPublicKey) throw Error("Must have a Farcaster signer public key to sign");
    let n7 = await import("./bundle-O6MOEAL6.js"), a3 = await te.signFarcasterMessage({ address: r10.address, hdWalletIndex: null, accessToken: t8, mfaCode: null, mfaMethod: null, payload: { hash: n7.bufferToBase64URLString(e8) }, fid: BigInt(v5.farcaster.fid), relyingParty: window.origin });
    return new Uint8Array(n7.base64URLStringToBuffer(a3.signature));
  }, signMessageWithCrossAppWallet(e8, { address: t8, chainId: r10 }) {
    let a3 = v5?.linkedAccounts.some(((e9) => "cross_app" === e9.type && e9.smartWallets.some(((e10) => e10.address === t8))));
    return ul({ user: v5, client: n6, address: t8, requesterAppId: ne.id, request: { method: a3 ? "privy_signSmartWalletMessage" : "personal_sign", params: [e8, t8], chainId: r10 }, reconnect: ze2 });
  }, signTypedDataWithCrossAppWallet(e8, { address: t8, chainId: r10 }) {
    let a3 = v5?.linkedAccounts.some(((e9) => "cross_app" === e9.type && e9.smartWallets.some(((e10) => e10.address === t8)))), i6 = Aa2(e8);
    return ul({ user: v5, client: n6, address: t8, requesterAppId: ne.id, request: { method: a3 ? "privy_signSmartWalletTypedData" : "eth_signTypedData_v4", params: [t8, i6], chainId: r10 }, reconnect: ze2 });
  }, sendTransactionWithCrossAppWallet(e8, { address: t8 }) {
    let r10 = v5?.linkedAccounts.some(((e9) => "cross_app" === e9.type && e9.smartWallets.some(((e10) => e10.address === t8))));
    return ul({ user: v5, client: n6, address: t8, requesterAppId: ne.id, request: { method: r10 ? "privy_sendSmartWalletTx" : "eth_sendTransaction", params: [e8], chainId: e8.chainId }, reconnect: ze2 });
  }, signTransactionWithCrossAppWallet(e8, { address: t8 }) {
    let r10 = v5?.linkedAccounts.some(((e9) => "cross_app" === e9.type && e9.smartWallets.some(((e10) => e10.address === t8))));
    return ul({ user: v5, client: n6, address: t8, requesterAppId: ne.id, request: { method: r10 ? "privy_signSmartWalletTx" : "eth_signTransaction", params: [e8], chainId: e8.chainId }, reconnect: ze2 });
  }, isModalOpen: d2 || !!m4, mfaMethods: ne.mfa.methods };
  Oc = Be.signMessage, Mc = Be.signTypedData, Lc = async (e8, t8) => await Me({ transaction: e8, ...t8, signOnly: false }), Fc = async (e8, t8) => ({ signature: (await Me({ transaction: e8, ...t8, signOnly: true })).hash });
  let je = { privy: i5, setAuthenticated: f4, setUser: b4, setIsNewUser: x4, isNewUserThisSession: W3, pendingTransaction: null, walletConnectionStatus: D2, setWalletConnectionStatus: q3, connectors: n6.connectors?.walletConnectors ?? [], rpcConfig: ne.rpcConfig, chains: ne.chains, appId: e7.appId, showFiatPrices: "native-token" !== ne.embeddedWallets.priceDisplay.primary, clientAnalyticsId: n6.clientAnalyticsId, onCustomAuthAuthenticated: _e, hideWalletUIs: Ae, isHeadlessSigning: (0, import_react3.useCallback)(be, [ne.embeddedWallets.showWalletUIs]), emailOtpState: j3, setEmailOtpState: H2, smsOtpState: V2, setSmsOtpState: K3, oAuthState: J2, setOAuthState: X2, telegramAuthState: Q2, setTelegramAuthState: ee, siweState: Y2, setSiweState: Z, isHeadlessOAuthLoading: M3, baseAccountSdk: S2, setBaseAccountSdk: P3, nativeTokenSymbolForChainId: (e8) => ne.chains.find(((t8) => t8.id === Number(e8)))?.nativeCurrency.symbol, initializeWalletProxy: async (e8) => {
    if (te) return te;
    let t8 = new Promise(((e9) => {
      de.current = e9;
    })), r10 = new Promise(((t9) => setTimeout((() => t9(null)), e8))), n7 = await Promise.race([t8, r10]);
    return de.current = null, n7;
  }, getAuthFlow: () => n6.authFlow, getAuthMeta: () => n6.authFlow?.meta, client: n6, closePrivyModal: async (t8 = { shouldCallAuthOnSuccess: true, isSuccess: false }) => {
    let r10, a3 = w4 && g2 && v5;
    a3 && Ce.current && (r10 = Le(v5)), "login" === ke.current ? t8.shouldCallAuthOnSuccess && a3 && Ce.current ? Gr(ge, "login", "onComplete", { user: v5, isNewUser: W3, wasAlreadyAuthenticated: false, loginMethod: Ce.current, loginAccount: r10 ?? null }) : Gr(ge, "login", "onError", p.USER_EXITED_AUTH_FLOW) : "link" === ke.current && r10 ? t8.isSuccess && a3 && Ce.current ? Gr(ge, "linkAccount", "onSuccess", { user: v5, linkMethod: Ce.current, linkedAccount: r10 }) : Ce.current && Gr(ge, "linkAccount", "onError", p.USER_EXITED_LINK_FLOW, { linkMethod: Ce.current }) : "update" === ke.current && r10 ? t8.isSuccess && a3 && Ce.current ? Gr(ge, "update", "onSuccess", { user: v5, updateMethod: Ce.current, updatedAccount: r10 }) : Ce.current && Gr(ge, "update", "onError", p.USER_EXITED_UPDATE_FLOW, { linkMethod: Ce.current }) : "connect-or-create" === ke.current && (E2[0] ? Gr(ge, "connectOrCreateWallet", "onSuccess", { wallet: E2[0] }) : Gr(ge, "connectOrCreateWallet", "onError", p.USER_EXITED_AUTH_FLOW));
    let i6 = N2 && Ul2.has(N2), o4 = N2 === zc && oe.errorModalData && Ul2.has(oe.errorModalData.previousScreen);
    if ((i6 || o4) && oe.funding) {
      let t9, r11 = Ul2.get(N2) ?? null;
      if ("solana" === oe.funding.chainType) {
        let e8 = ne.solanaRpcs[oe.funding.chain];
        if (!e8) return void console.warn("Unable to load solana rpc, skipping balance");
        if (c2(Zg)) try {
          t9 = await Xh({ rpc: e8.rpc, address: oe.funding.address });
        } catch {
          console.error("Unable to pull wallet balance");
        }
        else console.warn("Unable to load solana plugin, skipping balance");
        Gr(ge, "fundSolanaWallet", "onUserExited", { address: oe.funding.address, fundingMethod: r11, chain: oe.funding.chain, balance: t9 });
      } else {
        let n7 = ua2(oe.funding.chain.id, ne.chains, ne.rpcConfig, { appId: e7.appId });
        try {
          t9 = await n7.getBalance({ address: oe.funding.address });
        } catch {
          console.error("Unable to pull wallet balance");
        }
        Gr(ge, "fundWallet", "onUserExited", { address: oe.funding.address, chain: oe.funding.chain, fundingMethod: r11, balance: t9 });
      }
    }
    se(((e8) => ({ ...e8, externalConnectWallet: {} }))), ke.current = null, Ce.current = null, x4(false), h7(false), setTimeout((() => {
      n6.authFlow = void 0;
    }), 200);
  }, openPrivyModal: Te, connectWallet: Ue, initLoginWithWallet: async (e8, t8, r10, n7) => {
    qa(e8) ? (Ce.current = "siwe", Pe(e8, t8, r10)) : (Ce.current = "siws", We(e8, t8, r10, n7));
  }, loginWithWallet: async () => {
    let e8, t8, r10;
    if (!w4) throw new E();
    if (n6.authFlow instanceof oa ? e8 = "siwe" : n6.authFlow instanceof sa2 && (e8 = "siws"), !e8) throw new _("Must initialize SIWE/SIWS flow first.");
    if (null !== await n6.getAccessToken()) try {
      ({ user: t8 } = await n6.link()), Ce.current = e8;
    } catch (t9) {
      throw Gr(ge, "linkAccount", "onError", t9.privyErrorCode || p.FAILED_TO_LINK_ACCOUNT, { linkMethod: e8 }), t9;
    }
    else try {
      ({ user: t8, isNewUser: r10 } = await n6.authenticate()), Ce.current = e8;
    } catch (e9) {
      throw Gr(ge, "login", "onError", e9.privyErrorCode || p.GENERIC_CONNECT_WALLET_ERROR), e9;
    }
    b4(t8 || v5 || null), x4(r10 || false), f4(true);
  }, delegateWallet: async ({ address: e8, chainType: t8, showDelegationUIs: r10 }) => new Promise((async (n7, a3) => {
    let i6 = await zc2();
    if (!g2 || !v5 || !i6) throw new _("User must be authenticated and have an embedded wallet to delegate actions.");
    if ("solana" !== t8 && "ethereum" !== t8) throw new _("Only Solana and Ethereum embedded wallets are supported for delegation and revocation.");
    let o4 = je.walletProxy ?? await je.initializeWalletProxy(15e3);
    if (!o4) throw new _("Wallet proxy not initialized.");
    if ((({ address: e9, user: t9 }) => !!il(t9).find(((t10) => t10.address === e9)))({ address: e8, user: v5 })) return n7();
    let s3 = f2(v5, e8);
    if (!s3) throw new _("Address to delegate is not associated with current user.");
    if (b2(s3)) throw new _("useDelegatedActions is only supported for on-device execution and this app uses TEE execution. Use the useSessionSigners hook to provision server side access on behalf of your users. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");
    let l5 = nl({ address: e8, user: v5 }), c3 = al({ address: e8, user: v5 }), d3 = async () => {
      await o4.createDelegatedAction({ accessToken: i6, rootWallet: c3, delegatedWallets: [l5] }), await je.refreshSessionAndUser();
    };
    if (await je.recoverEmbeddedWallet({ address: e8 }), r10) se({ delegatedActions: { consent: { address: e8, onDelegate: d3, onSuccess: async () => {
      n7();
    }, onError: async (e9) => {
      a3(e9);
    } } } }), Te(Ml2);
    else try {
      await d3(), n7();
    } catch (e9) {
      a3(e9);
    }
  })), revokeDelegatedWallets: async ({ showDelegationUIs: e8 }) => new Promise((async (t8, r10) => {
    if (!g2 || !v5) throw new _("User must be authenticated and have an embedded wallet to revoke a delegated wallet.");
    let a3 = il(v5);
    if (0 === a3.length) throw new _("User has no delegated wallets to revoke.");
    if (a3.some(b2)) throw new _("useDelegatedActions is only supported for on-device execution and this app uses TEE execution. Use the useSessionSigners hook to provision server side access on behalf of your users. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");
    let i6 = async () => {
      await n6.revokeDelegatedWallet(), await je.refreshSessionAndUser();
    };
    if (e8) se({ delegatedActions: { revoke: { onRevoke: i6, onSuccess: async () => {
      t8();
    }, onError: async (e9) => {
      r10(e9);
    } } } }), Te(Ll2);
    else try {
      await i6(), t8();
    } catch (e9) {
      r10(e9);
    }
  })), initLoginWithFarcaster: async (e8, t8) => {
    let r10 = new Zi(e8, t8);
    n6.startAuthFlow(r10);
    try {
      Ce.current = "farcaster", await r10.initializeFarcasterConnect();
    } catch (e9) {
      throw "login" === ke.current ? Gr(ge, "login", "onError", e9.privyErrorCode || p.UNKNOWN_AUTH_ERROR) : "link" === ke.current && Gr(ge, "linkAccount", "onError", e9.privyErrorCode || p.UNKNOWN_AUTH_ERROR, { linkMethod: "farcaster" }), e9;
    }
  }, loginWithFarcaster: async () => {
    let e8, t8;
    if (!w4) throw new E();
    if (!(n6.authFlow instanceof Zi)) throw new _("Must initialize Farcaster flow first.");
    if (null !== await n6.getAccessToken()) try {
      ({ user: e8 } = await n6.link()), Ce.current = "farcaster";
    } catch (e9) {
      throw Gr(ge, "linkAccount", "onError", e9.privyErrorCode || p.FAILED_TO_LINK_ACCOUNT, { linkMethod: "farcaster" }), e9;
    }
    else try {
      ({ user: e8, isNewUser: t8 } = await n6.authenticate()), Ce.current = "farcaster";
    } catch (e9) {
      throw Gr(ge, "login", "onError", e9.privyErrorCode || p.UNKNOWN_AUTH_ERROR), e9;
    }
    b4(e8 || null), x4(t8 || false), f4(true);
  }, async crossAppAuthFlow({ appId: e8, popup: t8, action: r10 }) {
    let a3 = `privy:${e8}`;
    Ce.current = a3;
    let { url: i6, stateCode: o4, codeVerifier: s3 } = await (async function({ api: e9, appId: t9 }) {
      let r11 = $n(), n7 = Vn(), a4 = await jn(r11);
      try {
        let { url: i7 } = await e9.post($, { provider: `privy:${t9}`, redirect_to: window.location.href, code_challenge: a4, state_code: n7 });
        return { url: i7, stateCode: n7, codeVerifier: r11 };
      } catch (e10) {
        throw n(e10);
      }
    })({ api: n6.api, appId: e8 });
    if (!i6) throw n6.createAnalyticsEvent({ eventName: "cross_app_auth_error", payload: { error: "Unable to open cross-app auth popup", appId: e8 } }), new _("No authorization URL returned for cross-app auth.");
    try {
      let l5 = await (async function({ url: e9, popup: t9 }) {
        return t9.location = e9, new Promise(((e10, r11) => {
          let n7, a4 = setTimeout((() => {
            r11(new _("Authorization request timed out after 2 minutes.")), i7();
          }), 12e4);
          function i7() {
            t9?.close(), window.removeEventListener("message", s4);
          }
          let o5 = setInterval((() => {
            t9?.closed && !n7 && (i7(), clearInterval(o5), clearTimeout(a4), r11(new _("User rejected request")));
          }), 300);
          function s4(t10) {
            t10.data && ("PRIVY_OAUTH_RESPONSE" === t10.data.type && t10.data.stateCode && t10.data.authorizationCode && (clearTimeout(a4), e10(t10.data), i7()), "PRIVY_OAUTH_ERROR" === t10.data.type && (clearTimeout(a4), r11(new _(t10.data.error)), i7()), t10.data.type === ll && ((n7 = new BroadcastChannel(sl)).onmessage = s4));
          }
          window.addEventListener("message", s4);
        }));
      })({ url: i6, popup: t8, provider: a3 }), c3 = l5.stateCode, d3 = l5.authorizationCode;
      if (c3 !== o4) throw n6.createAnalyticsEvent({ eventName: "possible_phishing_attempt", payload: { provider: a3, storedStateCode: o4 ?? "", returnedStateCode: c3 ?? "" } }), new _("Unexpected auth flow. This may be a phishing attempt.", void 0, p.OAUTH_UNEXPECTED);
      let u2 = await (async function({ appId: e9, stateCode: t9, codeVerifier: r11, authorizationCode: n7, action: a4, client: i7 }) {
        if (!n7 || !t9) throw new _("[Cross-App AuthFlow] Authorization and state codes code must be set prior to calling authenicate.");
        if ("undefined" === n7) throw new _("User denied confirmation during cross-app auth flow");
        try {
          let o5 = new cl({ authorizationCode: n7, stateCode: t9, codeVerifier: r11, provider: `privy:${e9}` });
          i7.startAuthFlow(o5);
          let s4 = "link" === a4 ? await i7.link() : await i7.authenticate(), l6 = s4.oAuthTokens?.accessToken;
          return console.debug(), l6;
        } catch (e10) {
          let t10 = n(e10);
          if (t10.privyErrorCode === p.ACCOUNT_TRANSFER_REQUIRED) throw t10;
          if (t10.privyErrorCode) throw new _(t10.message || "Invalid code during cross-app auth flow.", void 0, t10.privyErrorCode);
          if ("User denied confirmation during cross-app auth flow" === t10.message) throw new _("Invalid code during cross-app auth flow.", void 0, p.OAUTH_USER_DENIED);
          throw new _("Invalid code during cross-app auth flow.", void 0, p.UNKNOWN_AUTH_ERROR);
        }
      })({ appId: e8, codeVerifier: s3, stateCode: c3, authorizationCode: d3, action: r10, client: n6 });
      u2 && n6.storeProviderAccessToken(e8, u2);
      let h8 = await je.refreshSessionAndUser();
      if (!h8) throw new _("Unable to update user");
      return n6.createAnalyticsEvent({ eventName: "cross_app_auth_completed", payload: { providerAppId: e8 } }), h8;
    } catch (e9) {
      throw n6.createAnalyticsEvent({ eventName: "cross_app_auth_error", payload: { error: e9.toString(), provider: a3 } }), e9;
    }
  }, async initLoginWithOAuth(e8, t8, r10) {
    if (Ce.current = e8, !on()) return void Te(Yl);
    if ("google" === e8 && Xu(window.navigator.userAgent)) return void Te(Yl);
    "twitter" === e8 && window.opener && window.opener.postMessage({ type: ll }, "*"), ln.del(Pn), ln.del(Wn);
    let a3 = new to({ provider: e8, disableSignup: !!r10, withPrivyUi: true, customOAuthRedirectUrl: ne.customOAuthRedirectUrl });
    t8 && a3.addCaptchaToken(t8), n6.startAuthFlow(a3);
    let i6 = await n6.authFlow.getAuthorizationUrl();
    if (i6 && i6.url) if ("twitter" === e8 && import_react_device_detect.isAndroid && (i6.url = i6.url.replace("x.com", "twitter.com")), "chrome-extension:" === window.location.protocol && Qi()) try {
      let { privyOAuthCode: e9, privyOAuthState: t9 } = await eo(i6.url);
      Te(Ac), a3.meta.stateCode = t9, a3.meta.authorizationCode = e9;
    } catch (e9) {
      throw console.error("OAuth in chrome extension flow failed:", e9), e9;
    }
    else window.location.assign(i6.url);
  }, async initLoginWithTelegram(e8, t8) {
    if (!w4) throw new E();
    Ce.current = "telegram";
    let r10 = new Ma(e8, t8);
    n6.startAuthFlow(r10), ee({ status: "loading" }), r10.meta.telegramWebAppData = void 0, r10.meta.telegramAuthResult = await new Promise(((e9, t9) => ne.loginConfig.telegramAuthConfiguration ? window.Telegram ? void window.Telegram.Login.auth({ bot_id: ne.loginConfig.telegramAuthConfiguration.botId, request_access: true }, ((r11) => r11 ? e9(r11) : t9(new _("Telegram auth failed or was canceled by the client")))) : t9(new _("Telegram was not initialized")) : t9(new _("Telegram Auth configuration is not loaded"))));
  }, async loginWithTelegram(e8) {
    let t8, r10;
    if (!(n6.authFlow instanceof Ma)) throw new _("Must initialize Telegram flow before calling loginWithTelegram");
    n6.authFlow.meta.captchaToken ||= e8?.captchaToken;
    let a3 = await zc2(), i6 = e8?.intent || ke.current;
    if ("login" === i6) try {
      let e9 = await n6.authenticate();
      t8 = e9.user, r10 = e9.isNewUser, Ce.current = "telegram";
    } catch (e9) {
      throw Gr(ge, "login", "onError", e9.privyErrorCode || p.UNKNOWN_AUTH_ERROR), e9;
    }
    else {
      if ("link" !== i6) throw new _("Unknown auth intent");
      try {
        t8 = (await n6.link()).user, Ce.current = "telegram";
      } catch (e9) {
        throw Gr(ge, "linkAccount", "onError", e9.privyErrorCode || p.FAILED_TO_LINK_ACCOUNT, { linkMethod: "telegram" }), e9;
      }
    }
    b4(t8), x4(r10 || false), f4(true), ee({ status: "done" });
    let o4 = t8?.linkedAccounts.find((({ type: e9 }) => "telegram" === e9)) || null;
    return { user: t8, isNewUser: r10 || false, wasAlreadyAuthenticated: !!a3, loginAccount: o4 };
  }, async loginWithOAuth(e8) {
    let t8, r10, a3;
    if (!(n6.authFlow instanceof to)) throw new _("Must initialize OAuth flow before calling loginWithOAuth");
    let i6 = ln.get(Ln), o4 = n6.authFlow.meta.stateCode;
    if (i6 !== o4) throw n6.createAnalyticsEvent({ eventName: "possible_phishing_attempt", payload: { provider: e8, storedStateCode: i6 ?? "", returnedStateCode: o4 ?? "" } }), new _("Unexpected auth flow. This may be a phishing attempt.", void 0, p.OAUTH_UNEXPECTED);
    if (null !== await n6.getAccessToken()) try {
      let r11 = await n6.link();
      t8 = r11.user, a3 = r11.oAuthTokens, Ce.current = e8;
    } catch (t9) {
      throw Gr(ge, "linkAccount", "onError", t9.privyErrorCode || p.FAILED_TO_LINK_ACCOUNT, { linkMethod: e8 }), t9;
    }
    else try {
      let i7 = await n6.authenticate();
      t8 = i7.user, r10 = i7.isNewUser, a3 = i7.oAuthTokens, Ce.current = e8;
    } catch (t9) {
      throw "login" === ke.current ? Gr(ge, "login", "onError", t9.privyErrorCode || p.UNKNOWN_AUTH_ERROR) : "link" === ke.current && Gr(ge, "linkAccount", "onError", t9.privyErrorCode || p.FAILED_TO_LINK_ACCOUNT, { linkMethod: e8 }), t9;
    }
    return b4(t8), x4(r10 || false), f4(true), a3 && t8 && Gr(ge, "oAuthAuthorization", "onOAuthTokenGrant", { oAuthTokens: a3, user: t8 }), a3;
  }, passkeyAuthState: z, setPasskeyAuthState: B3, async initSignupWithPasskey({ captchaToken: e8, withPrivyUi: t8 }) {
    let r10 = new oo({ captchaToken: e8, setPasskeyAuthState: B3 });
    n6.startAuthFlow(r10), ke.current = "login";
    try {
      Ce.current = "passkey", B3({ status: "generating-challenge" }), await r10.initRegisterFlow(t8), B3({ status: "awaiting-passkey" });
    } catch (e9) {
      throw B3({ status: "error", error: e9 }), Gr(ge, "login", "onError", e9.privyErrorCode || p.UNKNOWN_AUTH_ERROR), e9;
    }
  }, async signupWithPasskey() {
    let e8, t8;
    if (!w4) throw new E();
    if (!(n6.authFlow instanceof oo)) throw new _("Must initialize Passkey flow first.");
    if ("passkey" !== Ce.current) {
      let e9 = new _("Must init login with Passkey flow first.");
      throw B3({ status: "error", error: e9 }), e9;
    }
    let r10 = await zc2();
    try {
      Ce.current = "passkey", B3({ status: "awaiting-passkey" }), { user: e8, isNewUser: t8 } = await n6.authenticate();
    } catch (e9) {
      throw B3({ status: "error", error: e9 }), Gr(ge, "login", "onError", e9.privyErrorCode || p.UNKNOWN_AUTH_ERROR), e9;
    }
    b4(e8), x4(t8 || false), f4(true), B3({ status: "done" });
    let a3 = e8?.linkedAccounts.find((({ type: e9 }) => "passkey" === e9)) || null;
    return { user: e8, isNewUser: t8 || false, wasAlreadyAuthenticated: !!r10, loginAccount: a3 };
  }, async initLoginWithPasskey({ captchaToken: e8, withPrivyUi: t8 }) {
    let r10 = new oo({ captchaToken: e8, setPasskeyAuthState: B3 });
    n6.startAuthFlow(r10), ke.current = "login";
    try {
      Ce.current = "passkey", B3({ status: "generating-challenge" }), await r10.initAuthenticationFlow(t8), B3({ status: "awaiting-passkey" });
    } catch (e9) {
      throw B3({ status: "error", error: e9 }), Gr(ge, "login", "onError", e9.privyErrorCode || p.UNKNOWN_AUTH_ERROR), e9;
    }
  }, async loginWithPasskey(e8) {
    let t8, r10;
    if (!w4) throw new E();
    if (!(n6.authFlow instanceof oo)) throw new _("Must initialize Passkey flow first.");
    if (e8?.credentialIds && (n6.authFlow.meta.allowedCredentialsIds = e8.credentialIds), "passkey" !== Ce.current) {
      let e9 = new _("Must init login with Passkey flow first.");
      throw B3({ status: "error", error: e9 }), e9;
    }
    let a3 = await zc2();
    try {
      Ce.current = "passkey", B3({ status: "awaiting-passkey" }), { user: t8, isNewUser: r10 } = await n6.authenticate();
    } catch (e9) {
      throw B3({ status: "error", error: e9 }), Gr(ge, "login", "onError", e9.privyErrorCode || p.UNKNOWN_AUTH_ERROR), e9;
    }
    b4(t8), x4(r10 || false), f4(true), B3({ status: "done" });
    let i6 = t8?.linkedAccounts.find((({ type: e9 }) => "passkey" === e9)) || null;
    return { user: t8, isNewUser: r10 || false, wasAlreadyAuthenticated: !!a3, loginAccount: i6 };
  }, async initLinkWithPasskey(e8) {
    let t8 = new oo({ captchaToken: e8 });
    n6.startAuthFlow(t8), ke.current = "link", Ce.current = "passkey", B3({ status: "generating-challenge" });
    try {
      await t8.initLinkFlow(), B3({ status: "awaiting-passkey" });
    } catch (e9) {
      throw Gr(ge, "linkAccount", "onError", e9.privyErrorCode || p.UNKNOWN_AUTH_ERROR, { linkMethod: "passkey" }), B3({ status: "error", error: e9 }), e9;
    }
  }, async linkWithPasskey() {
    let e8;
    if (!w4) throw new E();
    if (!(n6.authFlow instanceof oo)) throw new _("Must initialize Passkey flow first.");
    if ("passkey" !== Ce.current) throw new _("Must init login with Passkey flow first.");
    try {
      Ce.current = "passkey", { user: e8 } = await n6.link();
    } catch (e9) {
      throw Gr(ge, "linkAccount", "onError", e9.privyErrorCode || p.FAILED_TO_LINK_ACCOUNT, { linkMethod: "passkey" }), e9;
    }
    return b4(e8 || v5 || null), B3({ status: "done" }), e8;
  }, async initLoginWithHeadlessOAuth(e8, t8, r10) {
    if (!on()) throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");
    if ("google" === e8 && Xu(window.navigator.userAgent)) throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");
    let a3 = new to({ provider: e8, withPrivyUi: false, disableSignup: r10 ?? false, customOAuthRedirectUrl: ne.customOAuthRedirectUrl });
    t8 && a3.addCaptchaToken(t8), X2({ status: "loading" });
    let i6 = await n6.startAuthFlow(a3).getAuthorizationUrl();
    if (i6?.url) if ("chrome-extension:" === window.location.protocol && Qi()) try {
      let { privyOAuthCode: e9, privyOAuthState: t9 } = await eo(i6.url);
      a3.meta.stateCode = t9, a3.meta.authorizationCode = e9, await this.loginWithHeadlessOAuth(a3.meta);
    } catch (e9) {
      throw X2({ status: "error", error: e9 }), e9;
    }
    else window.location.assign(i6.url);
  }, async loginWithHeadlessOAuth(e8) {
    let t8, r10, a3;
    L3(true), X2({ status: "loading" }), n6.startAuthFlow(new to({ ...e8, customOAuthRedirectUrl: ne.customOAuthRedirectUrl }));
    let i6 = ln.get(Ln), o4 = e8.stateCode;
    if (i6 !== o4) throw n6.createAnalyticsEvent({ eventName: "possible_phishing_attempt", payload: { provider: e8.provider, storedStateCode: i6 ?? "", returnedStateCode: o4 ?? "" } }), L3(false), new _("Unexpected auth flow. This may be a phishing attempt.", void 0, p.OAUTH_UNEXPECTED);
    if (null !== await n6.getAccessToken()) try {
      ({ user: t8, oAuthTokens: a3 } = await n6.link()), Ce.current = e8.provider;
      let r11 = Le(t8);
      t8 && r11 && Gr(ge, "linkAccount", "onSuccess", { user: t8, linkMethod: Ce.current, linkedAccount: r11 });
    } catch (t9) {
      throw L3(false), Gr(ge, "linkAccount", "onError", t9.privyErrorCode || p.FAILED_TO_LINK_ACCOUNT, { linkMethod: e8.provider }), t9;
    }
    else try {
      ({ user: t8, isNewUser: r10, oAuthTokens: a3 } = await n6.authenticate()), Ce.current = e8.provider;
      let i7 = Le(t8);
      t8 && i7 && void 0 !== r10 && Gr(ge, "login", "onComplete", { user: t8, isNewUser: r10, wasAlreadyAuthenticated: false, loginMethod: Ce.current, loginAccount: i7 });
    } catch (e9) {
      throw L3(false), X2({ status: "error", error: e9 }), Gr(ge, "login", "onError", e9.privyErrorCode || p.UNKNOWN_AUTH_ERROR), e9;
    }
    return b4(t8), x4(r10 || false), f4(true), L3(false), X2({ status: "done" }), a3 && t8 && Gr(ge, "oAuthAuthorization", "onOAuthTokenGrant", { oAuthTokens: a3, user: t8 }), t8 ?? void 0;
  }, initLoginWithEmail: async ({ email: e8, captchaToken: t8, disableSignup: r10, withPrivyUi: a3 }) => {
    let i6 = new Gi({ email: e8, captchaToken: t8, disableSignup: r10 });
    n6.startAuthFlow(i6);
    try {
      Ce.current = "email", H2({ status: "sending-code" }), await i6.sendCodeEmail({ withPrivyUi: a3 }), H2({ status: "awaiting-code-input" });
    } catch (e9) {
      throw H2({ status: "error", error: e9 }), "login" === ke.current ? Gr(ge, "login", "onError", e9.privyErrorCode || p.UNKNOWN_AUTH_ERROR) : "link" === ke.current && Gr(ge, "linkAccount", "onError", e9.privyErrorCode || p.FAILED_TO_LINK_ACCOUNT, { linkMethod: "email" }), e9;
    }
  }, initUpdateEmail: async ({ oldAddress: e8, newAddress: t8, captchaToken: r10 }) => {
    let a3 = new Yi(e8, t8, r10);
    n6.startAuthFlow(a3);
    try {
      await a3.sendCodeEmail({ withPrivyUi: true });
    } catch (e9) {
      Gr(ge, "update", "onError", e9.privyErrorCode || p.UNKNOWN_AUTH_ERROR, { linkMethod: Ce.current });
    }
  }, initUpdatePhone: async (e8, t8, r10) => {
    let a3 = new lo(e8, t8, r10);
    n6.startAuthFlow(a3);
    try {
      await a3.sendSmsCode({ withPrivyUi: true });
    } catch (e9) {
      Gr(ge, "update", "onError", e9.privyErrorCode || p.UNKNOWN_AUTH_ERROR, { linkMethod: Ce.current });
    }
  }, initLoginWithSms: async ({ phoneNumber: e8, captchaToken: t8, disableSignup: r10, withPrivyUi: a3 }) => {
    K3({ status: "sending-code" });
    let i6 = new so({ phoneNumber: e8, captchaToken: t8, disableSignup: r10 });
    n6.startAuthFlow(i6);
    try {
      Ce.current = "sms", await i6.sendSmsCode({ withPrivyUi: a3 }), K3({ status: "awaiting-code-input" });
    } catch (e9) {
      throw K3({ status: "error", error: e9 }), "login" === ke.current ? Gr(ge, "login", "onError", e9.privyErrorCode || p.UNKNOWN_AUTH_ERROR) : "link" === ke.current && Gr(ge, "linkAccount", "onError", e9.privyErrorCode || p.FAILED_TO_LINK_ACCOUNT, { linkMethod: "sms" }), e9;
    }
  }, resendEmailCode: async () => {
    await n6.authFlow?.sendCodeEmail({ withPrivyUi: true });
  }, resendSmsCode: async () => {
    await n6.authFlow?.sendSmsCode({ withPrivyUi: true });
  }, loginWithCode: async (e8) => {
    let t8, r10;
    function a3(e9) {
      n6.authFlow instanceof Gi ? H2(e9) : n6.authFlow instanceof so && K3(e9);
    }
    if (a3({ status: "submitting-code" }), !w4) {
      let e9 = new E();
      throw a3({ status: "error", error: e9 }), e9;
    }
    if (n6.authFlow instanceof Gi) n6.authFlow.meta.emailCode = e8.trim();
    else {
      if (!(n6.authFlow instanceof so)) {
        let e9 = new _("Must initialize a passwordless code flow first");
        throw a3({ status: "error", error: e9 }), e9;
      }
      n6.authFlow.meta.smsCode = e8.trim();
    }
    let i6 = await zc2();
    if ("link" === ke.current) try {
      ({ user: t8 } = await n6.link());
    } catch (e9) {
      throw a3({ status: "error", error: e9 }), Gr(ge, "linkAccount", "onError", e9.privyErrorCode || p.FAILED_TO_LINK_ACCOUNT, { linkMethod: Ce.current }), e9;
    }
    else if ("update" === ke.current) try {
      ({ user: t8 } = await n6.link());
    } catch (e9) {
      throw a3({ status: "error", error: e9 }), Gr(ge, "update", "onError", e9.privyErrorCode || p.FAILED_TO_UPDATE_ACCOUNT, { linkMethod: Ce.current }), e9;
    }
    else try {
      ({ user: t8, isNewUser: r10 } = await n6.authenticate());
    } catch (e9) {
      throw a3({ status: "error", error: e9 }), Gr(ge, "login", "onError", e9.privyErrorCode || p.UNKNOWN_AUTH_ERROR), e9;
    }
    let o4 = t8 || v5;
    b4(o4 || null), x4(r10 || false), f4(true), a3({ status: "done" });
    let s3 = null;
    return n6.authFlow instanceof Gi ? s3 = o4?.linkedAccounts.find((({ type: e9 }) => "email" === e9)) || null : n6.authFlow instanceof so && (s3 = o4?.linkedAccounts.find((({ type: e9 }) => "phone" === e9)) || null), { user: o4, isNewUser: r10 || false, wasAlreadyAuthenticated: !!i6, linkedAccount: s3 };
  }, generateSiweMessage: async ({ address: e8, chainId: t8, captchaToken: r10 }) => {
    ke.current = g2 ? "link" : "login", Ce.current = "siwe", Z({ status: "generating-message" });
    let a3 = await n6.generateSiweNonce({ address: e8, captchaToken: r10 });
    return Z({ status: "awaiting-signature" }), ia2({ address: e8, chainId: t8.replace("eip155:", ""), nonce: a3 });
  }, generateSiweMessageForSmartWallet: async ({ address: e8, chainId: t8 }) => {
    let r10 = await n6.generateSiweNonce({ address: e8 });
    return ia2({ address: e8, chainId: t8.replace("eip155:", ""), nonce: r10 });
  }, linkSmartWallet: async ({ message: e8, signature: t8, smartWalletType: r10, smartWalletVersion: a3 }) => {
    let i6;
    i6 = await n6.linkSmartWallet({ message: e8, signature: t8, smartWalletType: r10, smartWalletVersion: a3 }), b4((i6 = await je.refreshSessionAndUser() ?? i6) || v5 || null);
  }, loginWithSiwe: async ({ message: e8, signature: t8, captchaToken: r10, disableSignup: a3 }) => {
    let i6, o4 = null;
    try {
      if (v5) throw Error("User already authenticated");
      let s3 = new oa(n6, void 0, r10, a3, { message: e8, signature: t8 });
      n6.startAuthFlow(s3), Ce.current = "siwe", ke.current = "login", Z({ status: "submitting-signature" });
      let l5 = await n6.authenticate();
      if ({ user: o4, isNewUser: i6 } = l5, !o4) throw Error("Authentication failed - no user returned");
    } catch (e9) {
      throw Gr(ge, "login", "onError", e9.privyErrorCode || p.UNKNOWN_AUTH_ERROR), Z({ status: "error", error: e9 }), e9;
    }
    return b4(o4), x4(i6 || false), f4(true), Z({ status: "done" }), ke.current = null, Ce.current = null, o4;
  }, linkWithSiwe: async ({ message: e8, signature: t8, chainId: r10, walletClientType: a3, connectorType: i6 }) => {
    let o4;
    Ne("siwe");
    let s3 = null;
    try {
      Z({ status: "submitting-signature" }), o4 = await n6.linkWithSiwe({ message: e8, signature: t8, chainId: r10, walletClientType: a3, connectorType: i6 }), o4 = await je.refreshSessionAndUser() ?? o4, Z({ status: "done" }), (s3 = Le(o4) || null) && Gr(ge, "linkAccount", "onSuccess", { user: o4, linkMethod: "siwe", linkedAccount: s3 });
    } catch (e9) {
      throw Gr(ge, "linkAccount", "onError", e9.privyErrorCode || p.FAILED_TO_LINK_ACCOUNT, { linkMethod: "siwe" }), ke.current = null, Ce.current = null, Z({ status: "error", error: e9 }), e9;
    }
    let l5 = o4 || v5;
    return b4(l5 || null), ke.current = null, Ce.current = null, { user: l5, linkedAccount: s3 };
  }, refreshSessionAndUser: async () => {
    let e8 = await n6.getAuthenticatedUser();
    return f4(!!e8), b4(e8), e8;
  }, walletProxy: te, createAnalyticsEvent: ({ eventName: e8, payload: t8, timestamp: r10 }) => n6.createAnalyticsEvent({ eventName: e8, payload: t8, timestamp: r10 }), acceptTerms: async () => {
    let e8 = await n6.acceptTerms();
    return b4(e8), e8;
  }, getUsdTokenPrice: (e8) => n6.getUsdTokenPrice(e8), getUsdPriceForSol: () => n6.getUsdPriceForSol(), getSplTokenMetadata: (e8) => n6.getSplTokenMetadata(e8), recoverEmbeddedWallet: async (e8) => new Promise((async (t8, r10) => {
    if (!v5) return void t8(true);
    let a3 = e8?.address ? f2(v5, e8.address) : y2(v5) || o2(v5) || m2(v5);
    if (!a3 || b2(a3)) return void t8(true);
    let i6 = await zc2();
    if (!i6 || !te || !a3) return void r10(Error("Must have valid access token and Privy wallet to recover wallet"));
    let { entropyId: o4, entropyIdVerifier: s3 } = Ra2(v5, a3);
    try {
      await te.connect({ accessToken: i6, entropyId: o4, entropyIdVerifier: s3 }), t8(true);
    } catch (e9) {
      if (Pl(e9) && "privy" === a3.recoveryMethod) {
        let e10;
        n6.createAnalyticsEvent({ eventName: "embedded_wallet_pinless_recovery_started", payload: { walletAddress: a3.address } });
        try {
          e10 = await te.recover({ entropyId: o4, entropyIdVerifier: s3, accessToken: i6 });
        } catch (e11) {
          return void r10(e11);
        }
        e10.entropyId || r10(Error("Unable to recover wallet")), n6.createAnalyticsEvent({ eventName: "embedded_wallet_recovery_completed", payload: { walletAddress: a3.address } }), t8(true);
      } else Pl(e9) && "privy" !== a3.recoveryMethod && "privy-v2" !== a3.recoveryMethod ? (se({ recoverWallet: { entropyId: o4, entropyIdVerifier: s3, onFailure: r10, onSuccess: () => t8(true) }, recoveryOAuthStatus: { provider: a3.recoveryMethod, action: "recover", shouldCreateEth: false, shouldCreateSol: false } }), Te(Wh(a3.recoveryMethod))) : r10(e9);
    }
  })), setReadyToTrue: (e8) => {
    y6(true), le?.(e8);
  }, updateWallets: () => Oe2(), fundWallet: async (e8, t8) => {
    se({ funding: F2({ address: e8, appConfig: ne, fundWalletConfig: t8, methodScreen: vm }) }), Te(vm);
  }, openModal: Te, requestFarcasterSignerStatus: async (e8) => {
    let t8 = await zc2(), r10 = v5?.linkedAccounts.find(((e9) => "wallet" === e9.type && "privy" === e9.walletClientType));
    if (!t8) throw Error("Must have valid access token to connect with Farcaster");
    if (!te || !r10) throw Error("Must have an embedded wallet to use Farcaster signers");
    if (!v5?.farcaster?.fid) throw Error("Must have Farcaster account to use Farcaster signers");
    let a3 = await n6.requestFarcasterSignerStatus(e8);
    return "approved" === a3.status && b4(await n6.getAuthenticatedUser() || v5 || null), a3;
  }, connectCoinbaseSmartWallet: async () => {
    ne.externalWallets.coinbaseWallet.config.preference = { ...ne.externalWallets.coinbaseWallet.config.preference, options: "smartWalletOnly" };
    let e8 = n6.connectors?.findWalletConnector("coinbase_wallet", "coinbase_smart_wallet") || n6.connectors?.findWalletConnector("coinbase_wallet", "coinbase_wallet");
    if (e8) return e8.updateConnectionPreference("smartWalletOnly"), Ue(e8);
    await Se("coinbase_wallet", "coinbase_smart_wallet");
  }, connectBaseAccount: async () => {
    let e8 = n6.connectors?.findWalletConnector("base_account", "base_account");
    if (e8) return Ue(e8);
    await Se("base_account", "base_account");
  }, initiateAccountTransfer: async ({ nonce: e8, account: t8, accountType: r10, externalWalletMetadata: a3, telegramAuthResult: i6, telegramWebAppData: o4, farcasterEmbeddedAddress: s3, oAuthUserInfo: l5 }) => {
    let c3 = await n6.sendAccountTransferRequest({ nonce: e8, account: t8, accountType: r10, externalWalletMetadata: a3, telegramAuthResult: i6, telegramWebAppData: o4, farcasterEmbeddedAddress: s3, oAuthUserInfo: l5 });
    return b4(c3), c3;
  }, inProgressAuthFlowRef: ke, inProgressLoginOrLinkMethodRef: Ce };
  Dc = je.recoverEmbeddedWallet, je.recoverEmbeddedWallet;
  let He = (0, import_react3.useMemo)((() => ({ wallets: E2, ready: ue && fe })), [E2, ue, fe]), $e = n6.authFlow instanceof Ma, Ge = !ne.headless && ne.captchaEnabled && !g2 && (w4 || $e);
  return (0, import_jsx_runtime2.jsx)(Nc.Provider, { value: true, children: (0, import_jsx_runtime2.jsx)(k2.Provider, { value: Be, children: (0, import_jsx_runtime2.jsx)(Vr.Provider, { value: ge, children: (0, import_jsx_runtime2.jsx)(El.Provider, { value: He, children: (0, import_jsx_runtime2.jsx)(Na2, { ...ne, children: (0, import_jsx_runtime2.jsxs)(n2.Provider, { value: je, children: [(0, import_jsx_runtime2.jsx)(rc, { children: (0, import_jsx_runtime2.jsxs)(Br, { data: oe, setModalData: se, setInitialScreen: R2, initialScreen: N2, authenticated: g2, open: d2, children: [e7.children, (0, import_jsx_runtime2.jsx)(xc2, { customAuth: ne.customAuth }), Ge && (0, import_jsx_runtime2.jsx)(Ko2, { delayedExecution: false }), (0, import_jsx_runtime2.jsx)(Ks, {}), (0, import_jsx_runtime2.jsx)(Wl2, { disabled: ne.embeddedWallets.disableAutomaticMigration }), (0, import_jsx_runtime2.jsx)(xs, { palette: ne.appearance.palette || {} }), !ne.render.standalone && (0, import_jsx_runtime2.jsx)(js, { open: d2 })] }) }), (0, import_jsx_runtime2.jsx)(rl, { appId: e7.appId, appClientId: e7.clientId, clientAnalyticsId: n6.clientAnalyticsId, origin: n6.apiUrl, mfaMethods: v5?.mfaMethods, mfaPromise: we, mfaSubmitPromise: ye, onLoad: re, onLoadFailed: () => null }), ne.loginConfig.telegramAuthConfiguration && (0, import_jsx_runtime2.jsx)(ai, { $if: true, children: (0, import_jsx_runtime2.jsx)($s, { scriptHost: e7.apiUrl || fn, botUsername: ne.loginConfig.telegramAuthConfiguration.botName }) })] }) }) }) }) }) });
};
var Yc = () => {
  let { user: e7 } = v2(), { walletProxy: t8 } = s();
  return { recover: (0, import_react3.useCallback)((async (r10) => {
    if (!t8) throw Error("Wallet proxy is not ready");
    let n6 = await zc2();
    if (!e7 || !n6) throw new _("User must be logged in before attempting to modify the recovery method.");
    let { entropyId: a3, entropyIdVerifier: i5 } = Ra2(e7);
    try {
      await t8.recover({ entropyId: a3, entropyIdVerifier: i5, accessToken: n6, ...r10 });
    } catch {
      throw new _("Unable to recover wallets");
    }
  }), [t8, e7]) };
};
var Zc = () => {
  let { client: e7, setAuthenticated: t8, setUser: r10 } = s();
  return (0, import_react3.useMemo)((() => ({ init: async () => {
    if (!e7) throw new _("Must initialize Privy client first.");
    let t9 = new e5();
    return e7.startAuthFlow(t9), await t9.init();
  }, login: async ({ fid: n6, message: a3, signature: i5 }) => {
    if (!e7) throw new _("Must initialize Privy client first.");
    if (!(e7.authFlow instanceof e5)) throw new _("Must initialize Farcaster Mini App flow first.");
    e7.authFlow.setAuthData({ message: a3, signature: i5, fid: n6 });
    let { user: o4 } = await e7.authenticate();
    if (!o4) throw new _("Failed to login with Farcaster V2");
    return r10(o4), t8(true), { user: o4 };
  } })), [e7, r10, t8]);
};
var Jc = () => (0, import_react3.useMemo)((() => ({ getAccessTokenForProvider: ({ appId: e7 }) => {
  try {
    let t8 = ln.get(Fn(e7));
    if ("string" != typeof t8) return { token: null };
    {
      let r10 = new co(t8);
      return r10.isExpired() ? (ln.del(Fn(e7)), { token: null }) : { token: r10.value };
    }
  } catch (e8) {
    return console.error(e8), { token: null };
  }
} })), []);
var Xc = (e7) => {
  qr("login", e7);
  let t8 = _a2(), r10 = Wr(), { ready: n6, user: a3 } = v2(), { initLoginWithHeadlessOAuth: i5, loginWithHeadlessOAuth: o4, oAuthState: l5, setOAuthState: c2, isHeadlessOAuthLoading: d2 } = s(), u2 = (0, import_react3.useCallback)((async (e8) => {
    try {
      if (t8.enabled && "success" !== t8.status) throw new Ea2(t8.error, null, p.CAPTCHA_FAILURE);
      return await i5(e8.provider, t8.token, e8.disableSignup);
    } catch (e9) {
      throw c2({ status: "error", error: e9 }), e9;
    }
  }), [i5, t8]), h7 = (0, import_react3.useCallback)((async () => {
    let e8 = io();
    try {
      if (!e8.inProgress) throw Error("Cannot login with OAuth because no OAuth flow is in progress");
      if (a3 && a3[e8.provider]) return console.warn("User is already logged in with this OAuth provider"), a3;
      if (e8.popupFlow) return;
    } catch (e9) {
      throw c2({ status: "error", error: e9 }), e9;
    }
    try {
      return await o4(e8);
    } catch (e9) {
      throw c2({ status: "error", error: e9 }), e9;
    } finally {
      ra2();
    }
  }), [o4]);
  return (0, import_react3.useEffect)((() => {
    let e8 = io();
    n6 && r10 && e8.inProgress && !e8.withPrivyUi && !e8.popupFlow && h7().catch((() => {
    }));
  }), [n6, r10]), { initOAuth: u2, loading: d2, state: l5 };
};
var Qc = (e7) => {
  let t8 = _a2(), { emailOtpState: r10, setEmailOtpState: n6, initLoginWithEmail: a3, loginWithCode: i5 } = s();
  return { sendCode: (0, import_react3.useCallback)((async ({ email: r11, disableSignup: i6 }) => {
    try {
      let e8;
      if (!r11) throw Error("Email required to send OTP code");
      if (t8.enabled && "error" === t8.status) throw new Ea2(t8.error, null, p.CAPTCHA_FAILURE);
      return t8.enabled && "success" !== t8.status && (t8.execute(), e8 = await t8.waitForResult()), await a3({ email: r11, captchaToken: e8, disableSignup: i6, withPrivyUi: false });
    } catch (r12) {
      throw n6({ status: "error", error: r12 }), e7?.onError?.(r12.privyErrorCode || p.UNKNOWN_AUTH_ERROR), r12;
    }
  }), [a3]), loginWithCode: (0, import_react3.useCallback)((async ({ code: r11 }) => {
    try {
      if (t8.enabled && "error" === t8.status) throw new Ea2(t8.error, null, p.CAPTCHA_FAILURE);
      let { user: n7, isNewUser: a4, wasAlreadyAuthenticated: o4, linkedAccount: s3 } = await i5(r11);
      e7?.onComplete?.({ user: n7, isNewUser: a4, wasAlreadyAuthenticated: o4, loginMethod: "email", loginAccount: s3 });
    } catch (r12) {
      throw n6({ status: "error", error: r12 }), e7?.onError?.(r12.privyErrorCode || p.UNKNOWN_AUTH_ERROR), r12;
    }
  }), [i5, t8.status]), state: r10 };
};
var ed2 = (e7) => {
  let t8 = _a2(), { initSignupWithPasskey: r10, signupWithPasskey: n6, passkeyAuthState: a3, setPasskeyAuthState: i5 } = s();
  return { signupWithPasskey: (0, import_react3.useCallback)((async () => {
    try {
      let a4;
      if (t8.enabled && "error" === t8.status) throw new Ea2(t8.error, null, p.CAPTCHA_FAILURE);
      t8.enabled && "success" !== t8.status && (t8.execute(), a4 = await t8.waitForResult()), await r10({ captchaToken: a4, withPrivyUi: false });
      let { user: i6, isNewUser: o4, wasAlreadyAuthenticated: s3, loginAccount: l5 } = await n6();
      e7?.onComplete?.({ user: i6, isNewUser: o4, wasAlreadyAuthenticated: s3, loginMethod: "passkey", loginAccount: l5 });
    } catch (t9) {
      throw i5({ status: "error", error: t9 }), e7?.onError?.(t9.privyErrorCode || p.UNKNOWN_AUTH_ERROR), t9;
    }
  }), [n6, t8.status]), state: a3 };
};
var td = (e7) => {
  let t8 = _a2(), { initLoginWithPasskey: r10, loginWithPasskey: n6, passkeyAuthState: a3, setPasskeyAuthState: i5 } = s();
  return { loginWithPasskey: (0, import_react3.useCallback)((async (a4) => {
    try {
      let i6;
      if (t8.enabled && "error" === t8.status) throw new Ea2(t8.error, null, p.CAPTCHA_FAILURE);
      t8.enabled && "success" !== t8.status && (t8.execute(), i6 = await t8.waitForResult()), await r10({ captchaToken: i6, withPrivyUi: false });
      let { user: o4, isNewUser: s3, wasAlreadyAuthenticated: l5, loginAccount: c2 } = await n6(a4);
      e7?.onComplete?.({ user: o4, isNewUser: s3, wasAlreadyAuthenticated: l5, loginMethod: "passkey", loginAccount: c2 });
    } catch (a5) {
      throw i5({ status: "error", error: a5 }), e7?.onError?.(a5.privyErrorCode || p.UNKNOWN_AUTH_ERROR), a5;
    }
  }), [n6, t8.status]), state: a3 };
};
var rd2 = (e7) => {
  let { initLinkWithPasskey: t8, linkWithPasskey: r10, passkeyAuthState: n6, setPasskeyAuthState: a3 } = s();
  return { linkWithPasskey: (0, import_react3.useCallback)((async () => {
    try {
      await t8();
      let n7 = await r10();
      if (!n7) throw Error("Error, user not found");
      let a4 = n7.linkedAccounts.filter(((e8) => "passkey" === e8.type)).sort(((e8, t9) => t9.latestVerifiedAt.getTime() - e8.latestVerifiedAt.getTime()))[0];
      e7?.onSuccess?.({ user: n7, linkMethod: "passkey", linkedAccount: a4 });
    } catch (t9) {
      throw a3({ status: "error", error: t9 }), e7?.onError?.(t9.privyErrorCode || p.UNKNOWN_AUTH_ERROR, { linkMethod: "passkey" }), t9;
    }
  }), [r10]), state: n6 };
};
var nd = (e7) => {
  let t8 = _a2(), { smsOtpState: r10, setSmsOtpState: n6, initLoginWithSms: a3, loginWithCode: i5 } = s();
  return { sendCode: (0, import_react3.useCallback)((async ({ phoneNumber: r11, disableSignup: i6 }) => {
    try {
      let e8;
      if (!r11) throw Error("SMS required to send OTP code");
      if (t8.enabled && "error" === t8.status) throw new Ea2(t8.error, null, p.CAPTCHA_FAILURE);
      return t8.enabled && "success" !== t8.status && (t8.execute(), e8 = await t8.waitForResult()), await a3({ phoneNumber: r11, captchaToken: e8, disableSignup: i6, withPrivyUi: false });
    } catch (r12) {
      throw n6({ status: "error", error: r12 }), e7?.onError?.(r12.privyErrorCode || p.UNKNOWN_AUTH_ERROR), r12;
    }
  }), [a3]), loginWithCode: (0, import_react3.useCallback)((async ({ code: r11 }) => {
    try {
      if (t8.enabled && "error" === t8.status) throw new Ea2(t8.error, null, p.CAPTCHA_FAILURE);
      let { user: n7, isNewUser: a4, wasAlreadyAuthenticated: o4, linkedAccount: s3 } = await i5(r11);
      e7?.onComplete?.({ user: n7, isNewUser: a4, wasAlreadyAuthenticated: o4, loginMethod: "sms", loginAccount: s3 });
    } catch (r12) {
      throw n6({ status: "error", error: r12 }), e7?.onError?.(r12.privyErrorCode || p.UNKNOWN_AUTH_ERROR), r12;
    }
  }), [i5, t8.status]), state: r10 };
};
var ad = (e7) => {
  let { connectOrCreateWallet: t8 } = v2();
  return qr("connectOrCreateWallet", e7), { connectOrCreateWallet: t8 };
};
var id2 = (e7) => {
  let t8 = _a2(), { siweState: r10, setSiweState: n6, linkWithSiwe: a3, generateSiweMessage: i5 } = s();
  return { generateSiweMessage: (0, import_react3.useCallback)((async ({ address: t9, chainId: r11 }) => {
    try {
      if (!t9 || !r11) throw Error("wallet address and chainId required to generate nonce");
      return await i5({ address: t9, chainId: r11 }).then(((e8) => e8));
    } catch (t10) {
      throw n6({ status: "error", error: t10 }), e7?.onError?.(t10.privyErrorCode || p.UNKNOWN_AUTH_ERROR, { linkMethod: "siwe" }), t10;
    }
  }), [i5]), linkWithSiwe: (0, import_react3.useCallback)((async ({ signature: r11, message: i6, chainId: o4, walletClientType: s3, connectorType: l5 }) => {
    try {
      if (t8.enabled && "success" !== t8.status) throw new Ea2(t8.error, null, p.CAPTCHA_FAILURE);
      let { user: n7, linkedAccount: c2 } = await a3({ message: i6, signature: r11, chainId: o4, walletClientType: s3, connectorType: l5 });
      c2 && e7?.onSuccess?.({ user: n7, linkMethod: "siwe", linkedAccount: c2 });
    } catch (r12) {
      throw n6({ status: "error", error: r12 }), e7?.onError?.(r12.privyErrorCode || p.UNKNOWN_AUTH_ERROR, { linkMethod: "siwe" }), r12;
    }
  }), [a3, t8.status]), state: r10 };
};
var od = (e7) => {
  let t8 = _a2(), { siweState: r10, setSiweState: n6, client: a3, generateSiweMessage: i5, loginWithSiwe: o4 } = s();
  return { generateSiweNonce: (0, import_react3.useCallback)((async (r11) => {
    try {
      let e8;
      if (t8.enabled && "error" === t8.status) throw new Ea2(t8.error, null, p.CAPTCHA_FAILURE);
      t8.enabled && "success" !== t8.status && (t8.execute(), e8 = await t8.waitForResult()), n6({ status: "generating-message" });
      let i6 = await a3.generateSiweNonce({ address: r11?.address, captchaToken: e8 });
      return n6({ status: "awaiting-signature" }), i6;
    } catch (r12) {
      throw n6({ status: "error", error: r12 }), e7?.onError?.(r12.privyErrorCode || p.UNKNOWN_AUTH_ERROR), r12;
    }
  }), [a3, t8]), generateSiweMessage: (0, import_react3.useCallback)((async ({ address: r11, chainId: a4 }) => {
    try {
      let e8;
      if (t8.enabled && "error" === t8.status) throw new Ea2(t8.error, null, p.CAPTCHA_FAILURE);
      return t8.enabled && "success" !== t8.status && (t8.execute(), e8 = await t8.waitForResult()), await i5({ address: r11, chainId: a4, captchaToken: e8 });
    } catch (r12) {
      throw n6({ status: "error", error: r12 }), e7?.onError?.(r12.privyErrorCode || p.UNKNOWN_AUTH_ERROR), r12;
    }
  }), [i5, t8]), loginWithSiwe: (0, import_react3.useCallback)((async ({ message: r11, signature: a4, disableSignup: i6 }) => {
    try {
      let n7;
      if (t8.enabled && "error" === t8.status) throw new Ea2(t8.error, null, p.CAPTCHA_FAILURE);
      t8.enabled && "success" !== t8.status && (t8.execute(), n7 = await t8.waitForResult());
      let s3 = await o4({ message: r11, signature: a4, captchaToken: n7, disableSignup: i6 });
      return e7?.onComplete?.({ user: s3, isNewUser: false, wasAlreadyAuthenticated: false, loginMethod: "siwe", loginAccount: null }), s3;
    } catch (r12) {
      throw n6({ status: "error", error: r12 }), e7?.onError?.(r12.privyErrorCode || p.UNKNOWN_AUTH_ERROR), r12;
    }
  }), [o4, t8.status]), state: r10 };
};
var sd = () => {
  let e7 = _a2(), { client: t8, setAuthenticated: r10, setUser: n6, setIsNewUser: a3 } = s(), { authenticated: i5 } = q2();
  return { generateSiwsMessage: (0, import_react3.useCallback)((async ({ address: r11 }) => {
    let n7;
    if (e7.enabled && "error" === e7.status) throw new Ea2(e7.error, null, p.CAPTCHA_FAILURE);
    e7.enabled && "success" !== e7.status && (e7.execute(), n7 = await e7.waitForResult());
    let a4 = await t8.generateSiwsNonce({ address: r11, captchaToken: n7 });
    return la2({ address: r11, nonce: a4 });
  }), [e7, t8]), loginWithSiws: (0, import_react3.useCallback)((async ({ message: o4, signature: s3, disableSignup: l5 }) => {
    if (i5) throw Error("User already authenticated");
    if (e7.enabled && "error" === e7.status) throw new Ea2(e7.error, null, p.CAPTCHA_FAILURE);
    e7.enabled && "success" !== e7.status && (e7.execute(), await e7.waitForResult());
    let { user: c2, isNewUser: d2 } = await t8.authenticateWithSiws({ message: o4, signature: s3, mode: l5 ? "no-signup" : "login-or-sign-up", messageType: "plain" });
    if (!c2) throw Error("Authentication failed - no user returned");
    return n6(c2), a3(d2 || false), r10(true), c2;
  }), [i5, e7, t8, r10, n6, a3]) };
};
var ld = () => {
  let e7 = _a2(), { client: t8, setUser: r10, refreshSessionAndUser: n6 } = s(), { authenticated: a3 } = q2();
  return { generateSiwsMessage: (0, import_react3.useCallback)((async ({ address: r11 }) => {
    let n7;
    if (e7.enabled && "error" === e7.status) throw new Ea2(e7.error, null, p.CAPTCHA_FAILURE);
    e7.enabled && "success" !== e7.status && (e7.execute(), n7 = await e7.waitForResult());
    let a4 = await t8.generateSiwsNonce({ address: r11, captchaToken: n7 });
    return la2({ address: r11, nonce: a4 });
  }), [e7, t8]), linkWithSiws: (0, import_react3.useCallback)((async ({ signature: i5, message: o4, walletClientType: s3, connectorType: l5 }) => {
    if (!a3) throw Error("User must be authenticated before linking");
    if (e7.enabled && "error" === e7.status) throw new Ea2(e7.error, null, p.CAPTCHA_FAILURE);
    let c2 = await t8.linkWithSiws({ message: o4, signature: i5, walletClientType: s3, connectorType: l5, messageType: "plain" }), d2 = ((e8) => {
      if (!e8) return;
      let t9 = e8.linkedAccounts;
      return t9 && 0 !== t9.length ? t9[t9.length - 1] : void 0;
    })(c2 = await n6() ?? c2) || null;
    return r10(c2 || null), { user: c2, linkedAccount: d2 };
  }), [a3, e7, t8, n6, r10]) };
};
function cd() {
  let { signTransaction: e7 } = (0, import_react3.useContext)(k2);
  return { signTransaction: e7 };
}
function dd(e7) {
  let { linkEmail: t8, linkPhone: r10, linkWallet: n6, linkGoogle: a3, linkApple: i5, linkTwitter: o4, linkDiscord: s3, linkGithub: l5, linkLinkedIn: c2, linkTiktok: d2, linkLine: u2, linkSpotify: p5, linkInstagram: m4, linkTelegram: w4, linkFarcaster: y6, linkPasskey: g2 } = (0, import_react3.useContext)(k2);
  return qr("linkAccount", e7), { linkEmail: t8, linkPhone: r10, linkWallet: n6, linkGoogle: a3, linkApple: i5, linkTwitter: o4, linkDiscord: s3, linkGithub: l5, linkLinkedIn: c2, linkTiktok: d2, linkLine: u2, linkSpotify: p5, linkInstagram: m4, linkFarcaster: y6, linkTelegram: w4, linkPasskey: g2 };
}
function ud(e7) {
  let { updateEmail: t8, updatePhone: r10 } = (0, import_react3.useContext)(k2);
  return qr("update", e7), { updateEmail: t8, updatePhone: r10 };
}
var hd = (e7) => {
  let { user: t8 } = v2(), { loginWithCode: r10, emailOtpState: n6, setEmailOtpState: a3, client: i5, inProgressAuthFlowRef: o4, inProgressLoginOrLinkMethodRef: s3 } = s();
  return { state: n6, sendCode: (0, import_react3.useCallback)((async ({ newEmailAddress: r11 }) => {
    try {
      if (!t8?.email) throw Error("User is required to have an email address to update it.");
      let e8 = new Yi(t8.email.address, r11);
      i5.startAuthFlow(e8), await e8.sendCodeEmail({ withPrivyUi: false });
    } catch (r12) {
      a3({ status: "error", error: r12 }), e7?.onError?.(r12.privyErrorCode || p.UNKNOWN_AUTH_ERROR, { linkMethod: "email" });
    }
  }), [t8?.email]), verifyCode: (0, import_react3.useCallback)((async ({ code: n7 }) => {
    try {
      if (!t8?.email) throw Error("User is required to have an email address to update it.");
      o4.current = "update", s3.current = "email";
      let { user: a4, linkedAccount: i6 } = await r10(n7);
      return e7?.onSuccess?.({ user: a4, updateMethod: "email", updatedAccount: i6 }), { user: a4 };
    } catch (n8) {
      a3({ status: "error", error: n8 }), e7?.onError?.(n8.privyErrorCode || p.UNKNOWN_AUTH_ERROR, { linkMethod: "email" });
    }
  }), [t8?.email]) };
};
var pd = () => {
  let { connectCoinbaseSmartWallet: e7 } = s();
  return { connectCoinbaseSmartWallet: e7 };
};
var md = () => {
  let { connectBaseAccount: e7 } = s();
  return { connectBaseAccount: e7 };
};
var wd = () => {
  let { baseAccountSdk: e7 } = s();
  return { baseAccountSdk: e7 };
};
var yd = () => {
  let { setModalData: e7 } = Or(), { openModal: t8, privy: r10, closePrivyModal: n6 } = s(), { user: a3 } = v2();
  return (0, import_react3.useMemo)((() => ({ verify: async ({ standalone: i5 = true } = { standalone: true }) => new Promise(((o4, s3) => a3 ? 0 === a3.mfaMethods.length ? o4() : (e7(((e8) => ({ ...e8, mfaVerify: { onSuccess: async () => {
    i5 ? await n6({ shouldCallAuthOnSuccess: false, isSuccess: true }) : Ws.setState({ inProgressMfaFlow: void 0 }), o4();
  }, onFailure: async (e9) => {
    i5 ? await n6({ shouldCallAuthOnSuccess: false, isSuccess: false }) : Ws.setState({ inProgressMfaFlow: void 0 }), s3(e9);
  }, sendSmsCode: async () => {
    throw Error("Not enabled");
  }, verifySmsCode: async () => {
    throw Error("Not enabled");
  }, verifyTotpCode: async (e9) => {
    await r10.fetchPrivyRoute(a2, { body: { code: e9 } });
  }, generateOptions: async () => No((await r10.fetchPrivyRoute(a, { body: {} })).options), verifyPasskey: async (e9) => {
    let t9 = await import("./bundle-O6MOEAL6.js"), n7 = await t9.startAuthentication(e9);
    await r10.fetchPrivyRoute(t2, { body: { authenticator_response: xl(n7) } });
  } } }))), void (i5 ? t8(Ss) : Ws.setState({ inProgressMfaFlow: "auth" }))) : s3(Error("Must be logged in to verify MFA")))) })), [r10, e7, t8, n6]);
};
var gd = { component: () => {
  let { user: e7, ready: a3 } = v2(), { app: i5, data: o4, onUserCloseViaDialogOrKeybindRef: s3 } = Or(), [c2, d2] = (0, import_react3.useState)(null), [u2, h7] = (0, import_react3.useState)(null), [p5, m4] = (0, import_react3.useState)(null), [w4, y6] = (0, import_react3.useState)(false), [g2, f4] = (0, import_react3.useState)(false), [v5, C4] = (0, import_react3.useState)(), k3 = async () => {
    v5 ? A2(v5) : e7 ? await b4({ user: e7 }) : A2(Error("Must be logged in to manage MFA")), setTimeout((() => {
      d2(null), h7(null);
    }), 500);
  };
  if (s3.current = k3, !o4?.mfaEnroll) throw Error("Missing modal data for MFA enrollment screen.");
  let { onFailure: A2, onSuccess: b4, mfaMethods: T2, verify: _5, generateTotpSecret: E2, enrollTotp: I2, unenrollTotp: S2, enrollPasskey: U2 } = o4.mfaEnroll, P3 = e7?.mfaMethods.includes("sms"), W3 = e7?.mfaMethods.includes("totp"), x4 = e7?.mfaMethods.includes("passkey"), N2 = !!e7?.phone, R2 = e7?.linkedAccounts.filter(((e8) => "passkey" === e8.type)).map(((e8) => e8.credentialId)) ?? [];
  function O2() {
    d2(null), h7(null), C4(void 0);
  }
  async function M3(e8 = R2) {
    try {
      C4(void 0), f4(true);
      let t8 = await U2(e8);
      return await b4({ user: t8 });
    } catch (e9) {
      C4(e9);
    } finally {
      f4(false), y6(false);
    }
  }
  if (!a3 || !e7 || !i5) return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Di, { onClose: k3 }, "header"), (0, import_jsx_runtime2.jsx)(Yo, { children: (0, import_jsx_runtime2.jsx)(nc2, {}) }), (0, import_jsx_runtime2.jsx)(Xo2, { children: (0, import_jsx_runtime2.jsx)(mi, {}) }), (0, import_jsx_runtime2.jsx)(pi, {})] });
  if ("sms" === c2) return null;
  if ("totp" === c2) return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Di, { backFn: O2, onClose: k3 }, "header"), (0, import_jsx_runtime2.jsx)(us, { style: { marginBottom: "1.5rem" }, children: (0, import_jsx_runtime2.jsx)(QuestionMarkCircleIcon_default, {}) }), (0, import_jsx_runtime2.jsx)(Zo, { children: "Remove authenticator app verification?" }), (0, import_jsx_runtime2.jsxs)(Jo, { children: ["MFA adds an extra layer of security to your ", i5?.name, " account. Make sure you have other methods to secure your account."] }), (0, import_jsx_runtime2.jsx)(rs, { children: (0, import_jsx_runtime2.jsx)(Ci, { $warn: true, onClick: async function() {
    try {
      C4(void 0), f4(true);
      let e8 = await S2();
      return await b4({ user: e8 });
    } catch (e8) {
      C4(e8);
    } finally {
      f4(false), d2(null);
    }
  }, loading: g2, children: "Remove" }) }), (0, import_jsx_runtime2.jsx)(pi, {})] });
  if ("passkey" === c2) {
    let e8 = o4.mfaEnroll.shouldUnlinkOnUnenrollMfa ?? true;
    return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Di, { backFn: O2, onClose: k3 }, "header"), (0, import_jsx_runtime2.jsx)(us, { style: { marginBottom: "1.5rem" }, children: (0, import_jsx_runtime2.jsx)(QuestionMarkCircleIcon_default, {}) }), (0, import_jsx_runtime2.jsx)(Zo, { children: "Are you sure you want to remove this passkey?" }), (0, import_jsx_runtime2.jsx)(Jo, { children: e8 ? "Removing your passkey will remove as both a verification method and a login method." : "Removing your passkey will remove as a verification method." }), (0, import_jsx_runtime2.jsx)(rs, { children: (0, import_jsx_runtime2.jsx)(Ci, { $warn: true, onClick: async function() {
      try {
        C4(void 0), f4(true);
        let e9 = await U2([]);
        return await b4({ user: e9 });
      } catch (e9) {
        C4(e9);
      } finally {
        f4(false), d2(null);
      }
    }, loading: g2, children: "Remove" }) }), (0, import_jsx_runtime2.jsx)(pi, {})] });
  }
  return 0 !== T2.length || P3 || W3 || x4 ? "sms" === u2 ? null : "totp" === u2 && p5 ? (0, import_jsx_runtime2.jsx)(vc, { onClose: k3, onReset: O2, submitEnrollmentWithTotp: (e8) => (async function(e9) {
    try {
      C4(void 0), f4(true);
      let t8 = await I2(e9);
      return await b4({ user: t8 });
    } catch (e10) {
      C4(e10);
    } finally {
      f4(false), d2(null);
    }
  })(e8.mfaCode), error: v5, totpInfo: { ...p5, appName: i5?.name || "Privy" } }) : "passkey" === u2 ? (0, import_jsx_runtime2.jsx)(cc, { onReset: O2, onClose: k3, submitEnrollmentWithPasskey: M3 }) : (0, import_jsx_runtime2.jsx)(ic, { showIntro: false, userMfaMethods: e7.mfaMethods, appMfaMethods: i5.mfa.methods, userHasAuthSms: N2, onBackToIntro: () => {
  }, handleSelectMethod: async function(e8) {
    C4(void 0);
    try {
      await _5();
    } catch (e9) {
      return void C4(e9);
    }
    return "totp" === e8 ? (h7(e8), m4(null), void E2().then((({ totpSecret: e9, totpAuthUrl: t8 }) => {
      m4({ authUrl: t8, secret: e9 });
    })).catch((() => {
      m4(null), O2();
    }))) : "passkey" === e8 && 1 === R2.length ? await M3() : void h7(e8);
  }, isTotpLoading: "totp" === u2 && !p5, isPasskeyLoading: w4, error: v5, onClose: k3, setRemovingMfaMethod: async function(e8) {
    C4(void 0);
    try {
      await _5();
    } catch (e9) {
      return void C4(e9);
    }
    d2(e8);
  } }) : (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Di, { onClose: k3 }, "header"), (0, import_jsx_runtime2.jsx)(us, { style: { marginBottom: "1.5rem" }, children: (0, import_jsx_runtime2.jsx)(ShieldCheckIcon_default, {}) }), (0, import_jsx_runtime2.jsx)(Zo, { children: "Add more security" }), (0, import_jsx_runtime2.jsxs)(Jo, { children: [i5?.name, " does not have any verification methods enabled."] }), (0, import_jsx_runtime2.jsx)(rs, { children: (0, import_jsx_runtime2.jsx)(Ci, { onClick: k3, children: "Close" }) }), (0, import_jsx_runtime2.jsx)(pi, {})] });
} };
var fd = () => {
  let e7 = Pr(), { setModalData: t8 } = Or(), { verify: r10 } = yd(), { openModal: n6, privy: a3, closePrivyModal: i5, refreshSessionAndUser: s3, setUser: l5 } = s();
  return (0, import_react3.useMemo)((() => ({ enroll: async () => new Promise(((o4, c2) => {
    t8({ mfaEnroll: { onSuccess: async (e8) => {
      await i5({ shouldCallAuthOnSuccess: false, isSuccess: true }), o4(e8);
    }, onFailure: async (e8) => {
      await i5({ shouldCallAuthOnSuccess: false, isSuccess: false }), c2(e8);
    }, verify: () => r10({ standalone: false }), shouldUnlinkOnUnenrollMfa: true, mfaMethods: e7.mfa.methods, sendSmsCode: async () => {
      throw Error("Not enabled");
    }, enrollSms: async () => {
      throw Error("Not enabled");
    }, unenrollSms: async () => {
      throw Error("Not enabled");
    }, generateTotpSecret: async () => await a3.fetchPrivyRoute(p2, { body: {} }), enrollTotp: async (e8) => {
      await a3.fetchPrivyRoute(t3, { body: { code: e8 } });
      let t9 = await s3();
      return l5(t9), t9;
    }, unenrollTotp: async () => {
      await a3.fetchPrivyRoute(h2, { body: {} });
      let e8 = await s3();
      return l5(e8), e8;
    }, enrollPasskey: async (e8) => {
      await a3.fetchPrivyRoute(e2, { body: { credential_ids: e8, remove_for_login: true } });
      let t9 = await s3();
      return l5(t9), t9;
    } } }), n6(gd);
  })) })), [a3, t8, n6, i5]);
};
var vd = () => {
  let { startCrossAppAuthFlow: e7, unlinkCrossAppAccount: t8, signMessageWithCrossAppWallet: r10, signTypedDataWithCrossAppWallet: n6, sendTransactionWithCrossAppWallet: a3, signTransactionWithCrossAppWallet: i5 } = v2();
  return { loginWithCrossAppAccount: ({ appId: t9 }) => e7({ appId: t9, action: "login" }), linkCrossAppAccount: ({ appId: t9 }) => e7({ appId: t9, action: "link" }), unlinkCrossAppAccount: t8, signMessage: r10, signTypedData: n6, sendTransaction: a3, signTransaction: i5 };
};
function Cd(e7) {
  let { sendTransaction: t8 } = (0, import_react3.useContext)(k2);
  return qr("sendTransaction", e7), { sendTransaction: t8 };
}
function kd2() {
  let e7 = Pr(), t8 = Zr(), { client: r10, setUser: n6, setAuthenticated: a3, setIsNewUser: i5, initializeWalletProxy: o4 } = s(), { create: s3 } = L2();
  return { createGuestAccount: async () => {
    if (!e7.id || !r10) throw Error("SDK not yet ready");
    r10.startAuthFlow(new Oo(e7.id));
    try {
      let l5 = await r10.authenticate(), c2 = l5.user, d2 = l5.isNewUser ?? false;
      if (!c2) throw new _("Unable to authenticate guest account");
      let u2 = await r10.getAccessToken(), h7 = await o4(Un);
      if (u2 && h7) try {
        let t9 = fc(c2, e7.embeddedWallets.ethereum.createOnLogin), r11 = wc(c2, e7.embeddedWallets.solana.createOnLogin);
        t9 && r11 ? (c2 = (await s3({ chainType: "ethereum", latestUser: c2 })).user, c2 = (await s3({ chainType: "solana", latestUser: c2 })).user) : r11 ? c2 = (await s3({ chainType: "solana", latestUser: c2 })).user : t9 ? c2 = (await s3({ chainType: "ethereum", latestUser: c2 })).user : n6(c2);
      } catch (e8) {
        n6(c2), console.warn("Unable to create embedded wallet for guest account");
      }
      return i5(d2), a3(true), t8("login", "onComplete", { user: c2, isNewUser: d2, wasAlreadyAuthenticated: false, loginMethod: "guest", loginAccount: null }), c2;
    } catch (e8) {
      throw t8("login", "onError", e8.privyErrorCode || p.UNKNOWN_AUTH_ERROR), e8;
    }
  } };
}
function Ad2(e7) {
  let { setWalletRecovery: t8 } = (0, import_react3.useContext)(k2);
  return qr("setWalletRecovery", e7), { setWalletRecovery: t8 };
}
function bd(e7) {
  let { signMessage: t8 } = (0, import_react3.useContext)(k2);
  return qr("signMessage", e7), { signMessage: t8 };
}
var Td = () => {
  let { ready: e7, wallets: t8 } = Nl(), { user: r10 } = v2(), { rpcConfig: n6, chains: a3, appId: i5 } = s();
  return { signAuthorization: (0, import_react3.useCallback)((async (o4, s3) => {
    let l5;
    if (!r10) throw Error("User must be authenticated before signing with a Privy wallet");
    if (!e7) throw Error("Wallets are not ready");
    let c2 = s3?.address ?? l2(r10)?.address ?? zeroAddress, d2 = t8.find(((e8) => getAddress(e8.address) === getAddress(c2)));
    if (!d2) throw Error("Signing wallet not found.");
    let u2 = o4.chainId ?? Number(d2.chainId.split(":")[1]);
    if (0 === u2) l5 = { chainId: 0, address: o4.contractAddress, nonce: o4.nonce ?? 0 };
    else {
      let e8 = a3.find(((e9) => e9.id === u2));
      if (!e8) throw Error("Error, chain not configured in PrivyProvider config");
      let t9 = createWalletClient({ account: c2, chain: e8, transport: http(ha(e8, n6, i5)) });
      l5 = await t9.prepareAuthorization({ ...o4 });
    }
    let h7 = await d2.getEthereumProvider(), p5 = await h7.request({ method: "secp256k1_sign", params: [hashAuthorization(l5)] });
    return { ...l5, ...parseSignature(p5) };
  }), [e7, t8, r10, a3]) };
};
function _d(e7) {
  let { signTypedData: t8 } = (0, import_react3.useContext)(k2);
  return qr("signTypedData", e7), { signTypedData: t8 };
}
var Ed = () => {
  let { isModalOpen: e7 } = (0, import_react3.useContext)(k2);
  return { isOpen: e7 };
};
function Id(e7) {
  let { getAccessToken: t8 } = (0, import_react3.useContext)(k2);
  return qr("accessToken", e7), { getAccessToken: t8 };
}
function Sd2(e7) {
  let { authenticated: t8, user: r10 } = v2(), { initLoginWithOAuth: n6 } = s(), a3 = Zr();
  return qr("oAuthAuthorization", e7), { reauthorize: (e8) => Ud(t8, r10, n6, a3, e8.provider) };
}
var Ud = async (e7, t8, r10, n6, a3) => {
  if (!e7) throw n6("linkAccount", "onError", p.MUST_BE_AUTHENTICATED, { linkMethod: a3 }), new _("User must be authenticated before linking an account.");
  if (!t8?.linkedAccounts.some(((e8) => e8.type.includes(a3)))) throw new _(`OAuth account of type ${a3} not linked to the account.`);
  await r10(a3);
};
function Pd(e7) {
  let { client: t8 } = s(), [r10, n6] = (0, import_react3.useState)({ status: "initial" });
  return { linkWithCustomJwt: (0, import_react3.useCallback)((async (r11) => {
    try {
      n6({ status: "initial" }), t8.startAuthFlow(new Ro(r11)), n6({ status: "loading" });
      let { user: a3 } = await t8.link();
      if (!a3) throw Error("Error, user not found");
      let i5 = a3.linkedAccounts.filter(((e8) => "custom_auth" === e8.type)).sort(((e8, t9) => t9.latestVerifiedAt.getTime() - e8.latestVerifiedAt.getTime())).at(0);
      return n6({ status: "done" }), e7?.onSuccess?.({ user: a3, linkMethod: "custom", linkedAccount: i5 }), { user: a3 };
    } catch (r12) {
      throw n6({ status: "error", error: r12 }), e7?.onError?.(r12.privyErrorCode || p.UNKNOWN_AUTH_ERROR, { linkMethod: "custom" }), r12;
    }
  }), [t8.startAuthFlow, t8.link]), state: r10 };
}
var Wd = (e7) => {
  let t8 = Wc(((e8) => e8.jwtAuthFlowState));
  return qr("customAuth", e7), { status: t8 };
};
function xd2({ isAuthenticated: e7, isLoading: t8, ...r10 }) {
  let n6 = (0, import_react3.useRef)();
  (0, import_react3.useEffect)((() => {
    t8 || n6.current?.();
  }), [e7, t8]);
  let a3 = (0, import_react3.useCallback)(((e8) => (n6.current = e8, () => {
    n6.current = void 0;
  })), []);
  return Pc({ ...r10, subscribe: a3 });
}
function Nd() {
  let { getFarcasterSignerPublicKey: e7, signFarcasterMessage: t8, requestFarcasterSignerFromWarpcast: r10 } = v2();
  return { getFarcasterSignerPublicKey: e7, signFarcasterMessage: t8, requestFarcasterSignerFromWarpcast: r10 };
}
var Rd = () => {
  let { revokeDelegatedWallets: e7, delegateWallet: t8 } = s();
  return { delegateWallet: async ({ address: e8, chainType: r10 }) => await t8({ address: e8, chainType: r10, showDelegationUIs: true }), revokeWallets: async () => await e7({ showDelegationUIs: true }) };
};
var Od2 = () => {
  let { addSessionSignersInternal: e7, removeSessionSignersInternal: t8 } = (() => {
    let { user: e8 } = v2(), t9 = s(), { signWithUserSigner: r10 } = r6(), n6 = async ({ wallet: n7, additional_signers: a3 }) => {
      let i5 = await t9.client.getAccessToken();
      if (!e8 || !i5) throw new _("User must be authenticated and have an embedded wallet to delegate actions.");
      if (!n7.id) throw new _("Wallet to add signers to must have ID on server");
      if (!t9.walletProxy) throw new _("Wallet proxy not initialized.");
      await r5(t9.privy, { wallet_id: n7.id }, r10, { additional_signers: a3 });
    };
    return { addSessionSignersInternal: async ({ address: r11, signers: a3 }) => {
      let i5 = await t9.client.getAccessToken();
      if (!e8 || !i5) throw new _("User must be authenticated and have an embedded wallet to add a session signer.");
      let o4 = t9.walletProxy ?? await t9.initializeWalletProxy(15e3);
      if (!o4) throw new _("Wallet proxy not initialized.");
      let s3 = f2(e8, r11);
      if (!s3) throw new _("Address to add signers too is not associated with current user.");
      if (b2(s3)) {
        if (0 === a3.length) throw new _("Must specify at least one signer to add.");
        let e9 = [...(await t4(t9.privy, { wallet_id: s3.id })).additional_signers, ...Ia2(a3)];
        await n6({ wallet: s3, additional_signers: e9 });
      } else {
        if (s3.delegated) return { user: e8 };
        if (a3.length > 0) throw new _("Specifying signers in addSessionSigners is only supported for TEE execution and this app uses On-device execution. Pass an empty array for signers instead. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");
        let n7 = nl({ address: r11, user: e8 }), l6 = al({ address: r11, user: e8 });
        await t9.recoverEmbeddedWallet({ address: r11 }), await o4.createDelegatedAction({ accessToken: i5, rootWallet: l6, delegatedWallets: [n7] });
      }
      let l5 = await t9.refreshSessionAndUser();
      if (!l5) throw Error("Could not refresh user");
      return { user: l5 };
    }, removeSessionSignersInternal: async ({ address: r11 }) => {
      let a3 = await t9.client.getAccessToken();
      if (!e8 || !a3) throw new _("User must be authenticated and have an embedded wallet to delegate actions.");
      if (!(t9.walletProxy ?? await t9.initializeWalletProxy(15e3))) throw new _("Wallet proxy not initialized.");
      let i5 = f2(e8, r11);
      if (!i5) throw new _("Address to remove signers from is not associated with current user.");
      b2(i5) ? await n6({ wallet: i5, additional_signers: [] }) : await t9.client.revokeDelegatedWallet();
      let o4 = await t9.refreshSessionAndUser();
      if (!o4) throw Error("Could not refresh user");
      return { user: o4 };
    } };
  })();
  return { addSessionSigners: async ({ address: t9, signers: r10 }) => e7({ address: t9, signers: r10 }), removeSessionSigners: async ({ address: e8 }) => t8({ address: e8 }) };
};
var Md = () => {
  let { signWithUserSigner: e7 } = r6();
  return (0, import_react3.useMemo)((() => ({ async generateAuthorizationSignature(t8) {
    let { signature: r10 } = await i2(e7, t8);
    return { signature: r10 };
  } })), [e7]);
};
var Fd = () => {
  let { setUser: e7, client: t8 } = (0, import_react3.useContext)(n2), { user: r10 } = (0, import_react3.useContext)(k2);
  return { user: r10, refreshUser: (0, import_react3.useCallback)((async () => {
    let r11 = await t8?.updateUserAndIdToken();
    return e7(r11 ?? null), r11;
  }), [t8, e7]) };
};
var Ld = (e7) => {
  let t8 = _a2(), { initLoginWithTelegram: r10, loginWithTelegram: n6, telegramAuthState: a3, setTelegramAuthState: i5 } = s();
  return { login: (0, import_react3.useCallback)((async (a4) => {
    try {
      if (t8.enabled && "success" !== t8.status) throw new Ea2(t8.error, null, p.CAPTCHA_FAILURE);
      await r10(t8.token, a4?.disableSignup);
      let { user: i6, isNewUser: o4, loginAccount: s3, wasAlreadyAuthenticated: l5 } = await n6({ intent: "login" });
      e7?.onComplete?.({ user: i6, isNewUser: o4, wasAlreadyAuthenticated: l5, loginMethod: "telegram", loginAccount: s3 });
    } catch (a5) {
      throw i5({ status: "error", error: a5 }), e7?.onError?.(a5.privyErrorCode || p.UNKNOWN_AUTH_ERROR), a5;
    }
  }), [r10, n6, t8]), state: a3 };
};
var Dd = () => {
  let { revokeDelegatedWallets: e7, delegateWallet: t8 } = s();
  return { delegateWallet: async ({ address: e8, chainType: r10 }) => await t8({ address: e8, chainType: r10, showDelegationUIs: false }), revokeWallets: async () => await e7({ showDelegationUIs: false }) };
};
var qd = async ({ wallet: e7 }) => {
  let t8 = await e7.getEthereumProvider();
  return toAccount({ address: e7.address, sign: async ({ hash: r10 }) => {
    if ("privy" !== e7.walletClientType) throw new e3({ error: "Unprefixed signing is not supported by external wallets.", code: "unsupported_wallet_type" });
    return await t8.request({ method: "secp256k1_sign", params: [r10] });
  }, signMessage: async ({ message: r10 }) => await t8.request({ method: "personal_sign", params: [r10, e7.address] }), signTypedData: async (r10) => await t8.request({ method: "eth_signTypedData_v4", params: [e7.address, r10] }), signTransaction: async (e8) => await t8.request({ method: "eth_signTransaction", params: [e8] }) });
};
export {
  Ko2 as Captcha,
  Io as ConnectorManager,
  Ka as EthereumWalletConnector,
  js as LoginModal,
  Vo as PrivyClient,
  Kc as PrivyProvider,
  w2 as SUPPORTED_CHAINS,
  Cn as VERSION,
  Za as WalletConnector,
  r2 as addPrivyRpcToChain,
  r3 as addRpcUrlOverrideToChain,
  Bl as errorIndicatesMaxMfaRetries,
  Wl as errorIndicatesMfaTimeout,
  Rl as errorIndicatesMfaVerificationFailed,
  qc as getAccessToken,
  e6 as getEmbeddedConnectedWallet,
  qd as toViemAccount,
  C2 as useActiveWallet,
  yd as useAuthMfa,
  fd as useAuthMfaEnrollment,
  Md as useAuthorizationSignature,
  wd as useBaseAccountSdk,
  md as useConnectBaseAccount,
  pd as useConnectCoinbaseSmartWallet,
  ad as useConnectOrCreateWallet,
  x3 as useConnectWallet,
  K2 as useCreateWallet,
  vd as useCrossAppAccounts,
  Wd as useCustomAuth,
  Rd as useDelegatedActions,
  Nd as useFarcasterSigner,
  b3 as useFundWallet,
  Jc as useGetAccessTokenForProvider,
  kd2 as useGuestAccounts,
  Dd as useHeadlessDelegatedActions,
  Lo as useIdentityToken,
  j2 as useImportWallet,
  dd as useLinkAccount,
  Pd as useLinkJwtAccount,
  rd2 as useLinkWithPasskey,
  id2 as useLinkWithSiwe,
  ld as useLinkWithSiws,
  h5 as useLogin,
  Qc as useLoginWithEmail,
  Zc as useLoginWithFarcasterV2,
  Xc as useLoginWithOAuth,
  td as useLoginWithPasskey,
  od as useLoginWithSiwe,
  sd as useLoginWithSiws,
  nd as useLoginWithSms,
  Ld as useLoginWithTelegram,
  y4 as useLogout,
  Us as useMfa,
  rc2 as useMfaEnrollment,
  Pl2 as useMigrateWallets,
  Ed as useModalStatus,
  Sd2 as useOAuthTokens,
  q2 as usePrivy,
  Yc as useRecoverEmbeddedWallet,
  Go as useRegisterMfaListener,
  Cd as useSendTransaction,
  Od2 as useSessionSigners,
  Ad2 as useSetWalletRecovery,
  Td as useSign7702Authorization,
  bd as useSignMessage,
  cd as useSignTransaction,
  _d as useSignTypedData,
  ed2 as useSignupWithPasskey,
  xd2 as useSubscribeToJwtAuthWithFlag,
  Pc as useSyncJwtBasedAuthState,
  Id as useToken,
  ud as useUpdateAccount,
  hd as useUpdateEmail,
  Fd as useUser,
  Nl as useWallets
};
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@privy-io_react-auth.js.map
