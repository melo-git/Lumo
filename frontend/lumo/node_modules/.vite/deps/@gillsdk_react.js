import {
  addDecoderSizePrefix,
  address,
  assertAccountExists,
  assertIsAddress,
  createSolanaClient,
  decodeAccount,
  fetchEncodedAccount,
  fixDecoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getBooleanDecoder,
  getBytesDecoder,
  getConstantDecoder,
  getDiscriminatedUnionDecoder,
  getEnumDecoder,
  getF64Decoder,
  getHiddenPrefixDecoder,
  getI16Decoder,
  getMapDecoder,
  getOptionDecoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getU16Decoder,
  getU32Decoder,
  getU64Decoder,
  getU8Decoder,
  getU8Encoder,
  getUnitDecoder,
  getUtf8Decoder,
  isAddress,
  padLeftEncoder
} from "./chunk-3GLOOJD3.js";
import {
  require_jsx_runtime
} from "./chunk-RCILDZKZ.js";
import {
  require_react
} from "./chunk-PEG7TMOV.js";
import {
  __toESM,
  import_process,
  init_shim
} from "./chunk-HEPQZC56.js";

// node_modules/@gillsdk/react/dist/index.browser.mjs
init_shim();
var import_react = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/index.js
init_shim();

// node_modules/@tanstack/query-core/build/modern/index.js
init_shim();

// node_modules/@tanstack/query-core/build/modern/focusManager.js
init_shim();

// node_modules/@tanstack/query-core/build/modern/subscribable.js
init_shim();
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};

// node_modules/@tanstack/query-core/build/modern/utils.js
init_shim();

// node_modules/@tanstack/query-core/build/modern/timeoutManager.js
init_shim();
var defaultTimeoutProvider = {
  // We need the wrapper function syntax below instead of direct references to
  // global setTimeout etc.
  //
  // BAD: `setTimeout: setTimeout`
  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`
  //
  // If we use direct references here, then anything that wants to spy on or
  // replace the global setTimeout (like tests) won't work since we'll already
  // have a hard reference to the original implementation at the time when this
  // file was imported.
  setTimeout: (callback, delay) => setTimeout(callback, delay),
  clearTimeout: (timeoutId) => clearTimeout(timeoutId),
  setInterval: (callback, delay) => setInterval(callback, delay),
  clearInterval: (intervalId) => clearInterval(intervalId)
};
var TimeoutManager = class {
  // We cannot have TimeoutManager<T> as we must instantiate it with a concrete
  // type at app boot; and if we leave that type, then any new timer provider
  // would need to support ReturnType<typeof setTimeout>, which is infeasible.
  //
  // We settle for type safety for the TimeoutProvider type, and accept that
  // this class is unsafe internally to allow for extension.
  #provider = defaultTimeoutProvider;
  #providerCalled = false;
  setTimeoutProvider(provider) {
    if (import_process.default.env.NODE_ENV !== "production") {
      if (this.#providerCalled && provider !== this.#provider) {
        console.error(
          `[timeoutManager]: Switching provider after calls to previous provider might result in unexpected behavior.`,
          { previous: this.#provider, provider }
        );
      }
    }
    this.#provider = provider;
    if (import_process.default.env.NODE_ENV !== "production") {
      this.#providerCalled = false;
    }
  }
  setTimeout(callback, delay) {
    if (import_process.default.env.NODE_ENV !== "production") {
      this.#providerCalled = true;
    }
    return this.#provider.setTimeout(callback, delay);
  }
  clearTimeout(timeoutId) {
    this.#provider.clearTimeout(timeoutId);
  }
  setInterval(callback, delay) {
    if (import_process.default.env.NODE_ENV !== "production") {
      this.#providerCalled = true;
    }
    return this.#provider.setInterval(callback, delay);
  }
  clearInterval(intervalId) {
    this.#provider.clearInterval(intervalId);
  }
};
var timeoutManager = new TimeoutManager();
function systemSetTimeoutZero(callback) {
  setTimeout(callback, 0);
}

// node_modules/@tanstack/query-core/build/modern/utils.js
var isServer = typeof window === "undefined" || "Deno" in globalThis;
function noop() {
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function resolveStaleTime(staleTime, query) {
  return typeof staleTime === "function" ? staleTime(query) : staleTime;
}
function resolveEnabled(enabled, query) {
  return typeof enabled === "function" ? enabled(query) : enabled;
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (queryKey) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const { exact, status, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status && mutation.state.status !== status) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = options?.queryKeyHashFn || hashKey;
  return hashFn(queryKey);
}
function hashKey(queryKey) {
  return JSON.stringify(
    queryKey,
    (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {
      result[key] = val[key];
      return result;
    }, {}) : val
  );
}
function partialMatchKey(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (a && b && typeof a === "object" && typeof b === "object") {
    return Object.keys(b).every((key) => partialMatchKey(a[key], b[key]));
  }
  return false;
}
var hasOwn = Object.prototype.hasOwnProperty;
function replaceEqualDeep(a, b) {
  if (a === b) {
    return a;
  }
  const array = isPlainArray(a) && isPlainArray(b);
  if (!array && !(isPlainObject(a) && isPlainObject(b))) return b;
  const aItems = array ? a : Object.keys(a);
  const aSize = aItems.length;
  const bItems = array ? b : Object.keys(b);
  const bSize = bItems.length;
  const copy = array ? new Array(bSize) : {};
  let equalItems = 0;
  for (let i = 0; i < bSize; i++) {
    const key = array ? i : bItems[i];
    const aItem = a[key];
    const bItem = b[key];
    if (aItem === bItem) {
      copy[key] = aItem;
      if (array ? i < aSize : hasOwn.call(a, key)) equalItems++;
      continue;
    }
    if (aItem === null || bItem === null || typeof aItem !== "object" || typeof bItem !== "object") {
      copy[key] = bItem;
      continue;
    }
    const v = replaceEqualDeep(aItem, bItem);
    copy[key] = v;
    if (v === aItem) equalItems++;
  }
  return aSize === bSize && equalItems === aSize ? a : copy;
}
function shallowEqualObjects(a, b) {
  if (!b || Object.keys(a).length !== Object.keys(b).length) {
    return false;
  }
  for (const key in a) {
    if (a[key] !== b[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function sleep(timeout) {
  return new Promise((resolve) => {
    timeoutManager.setTimeout(resolve, timeout);
  });
}
function replaceData(prevData, data, options) {
  if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data);
  } else if (options.structuralSharing !== false) {
    if (import_process.default.env.NODE_ENV !== "production") {
      try {
        return replaceEqualDeep(prevData, data);
      } catch (error) {
        console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`
        );
        throw error;
      }
    }
    return replaceEqualDeep(prevData, data);
  }
  return data;
}
function addToEnd(items, item, max = 0) {
  const newItems = [...items, item];
  return max && newItems.length > max ? newItems.slice(1) : newItems;
}
function addToStart(items, item, max = 0) {
  const newItems = [item, ...items];
  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;
}
var skipToken = Symbol();
function ensureQueryFn(options, fetchOptions) {
  if (import_process.default.env.NODE_ENV !== "production") {
    if (options.queryFn === skipToken) {
      console.error(
        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`
      );
    }
  }
  if (!options.queryFn && fetchOptions?.initialPromise) {
    return () => fetchOptions.initialPromise;
  }
  if (!options.queryFn || options.queryFn === skipToken) {
    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));
  }
  return options.queryFn;
}
function shouldThrowError(throwOnError, params) {
  if (typeof throwOnError === "function") {
    return throwOnError(...params);
  }
  return !!throwOnError;
}

// node_modules/@tanstack/query-core/build/modern/focusManager.js
var FocusManager = class extends Subscribable {
  #focused;
  #cleanup;
  #setup;
  constructor() {
    super();
    this.#setup = (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.#cleanup) {
      this.setEventListener(this.#setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.#cleanup?.();
      this.#cleanup = void 0;
    }
  }
  setEventListener(setup) {
    this.#setup = setup;
    this.#cleanup?.();
    this.#cleanup = setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    });
  }
  setFocused(focused) {
    const changed = this.#focused !== focused;
    if (changed) {
      this.#focused = focused;
      this.onFocus();
    }
  }
  onFocus() {
    const isFocused = this.isFocused();
    this.listeners.forEach((listener) => {
      listener(isFocused);
    });
  }
  isFocused() {
    if (typeof this.#focused === "boolean") {
      return this.#focused;
    }
    return globalThis.document?.visibilityState !== "hidden";
  }
};
var focusManager = new FocusManager();

// node_modules/@tanstack/query-core/build/modern/hydration.js
init_shim();

// node_modules/@tanstack/query-core/build/modern/thenable.js
init_shim();
function pendingThenable() {
  let resolve;
  let reject;
  const thenable = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  thenable.status = "pending";
  thenable.catch(() => {
  });
  function finalize(data) {
    Object.assign(thenable, data);
    delete thenable.resolve;
    delete thenable.reject;
  }
  thenable.resolve = (value) => {
    finalize({
      status: "fulfilled",
      value
    });
    resolve(value);
  };
  thenable.reject = (reason) => {
    finalize({
      status: "rejected",
      reason
    });
    reject(reason);
  };
  return thenable;
}

// node_modules/@tanstack/query-core/build/modern/infiniteQueryObserver.js
init_shim();

// node_modules/@tanstack/query-core/build/modern/queryObserver.js
init_shim();

// node_modules/@tanstack/query-core/build/modern/notifyManager.js
init_shim();
var defaultScheduler = systemSetTimeoutZero;
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = defaultScheduler;
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  return {
    batch: (callback) => {
      let result;
      transactions++;
      try {
        result = callback();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    },
    schedule,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (fn) => {
      notifyFn = fn;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (fn) => {
      batchNotifyFn = fn;
    },
    setScheduler: (fn) => {
      scheduleFn = fn;
    }
  };
}
var notifyManager = createNotifyManager();

// node_modules/@tanstack/query-core/build/modern/query.js
init_shim();

// node_modules/@tanstack/query-core/build/modern/retryer.js
init_shim();

// node_modules/@tanstack/query-core/build/modern/onlineManager.js
init_shim();
var OnlineManager = class extends Subscribable {
  #online = true;
  #cleanup;
  #setup;
  constructor() {
    super();
    this.#setup = (onOnline) => {
      if (!isServer && window.addEventListener) {
        const onlineListener = () => onOnline(true);
        const offlineListener = () => onOnline(false);
        window.addEventListener("online", onlineListener, false);
        window.addEventListener("offline", offlineListener, false);
        return () => {
          window.removeEventListener("online", onlineListener);
          window.removeEventListener("offline", offlineListener);
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.#cleanup) {
      this.setEventListener(this.#setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.#cleanup?.();
      this.#cleanup = void 0;
    }
  }
  setEventListener(setup) {
    this.#setup = setup;
    this.#cleanup?.();
    this.#cleanup = setup(this.setOnline.bind(this));
  }
  setOnline(online) {
    const changed = this.#online !== online;
    if (changed) {
      this.#online = online;
      this.listeners.forEach((listener) => {
        listener(online);
      });
    }
  }
  isOnline() {
    return this.#online;
  }
};
var onlineManager = new OnlineManager();

// node_modules/@tanstack/query-core/build/modern/retryer.js
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class extends Error {
  constructor(options) {
    super("CancelledError");
    this.revert = options?.revert;
    this.silent = options?.silent;
  }
};
function createRetryer(config) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let continueFn;
  const thenable = pendingThenable();
  const isResolved = () => thenable.status !== "pending";
  const cancel = (cancelOptions) => {
    if (!isResolved()) {
      const error = new CancelledError(cancelOptions);
      reject(error);
      config.onCancel?.(error);
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const canContinue = () => focusManager.isFocused() && (config.networkMode === "always" || onlineManager.isOnline()) && config.canRun();
  const canStart = () => canFetch(config.networkMode) && config.canRun();
  const resolve = (value) => {
    if (!isResolved()) {
      continueFn?.();
      thenable.resolve(value);
    }
  };
  const reject = (value) => {
    if (!isResolved()) {
      continueFn?.();
      thenable.reject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      continueFn = (value) => {
        if (isResolved() || canContinue()) {
          continueResolve(value);
        }
      };
      config.onPause?.();
    }).then(() => {
      continueFn = void 0;
      if (!isResolved()) {
        config.onContinue?.();
      }
    });
  };
  const run = () => {
    if (isResolved()) {
      return;
    }
    let promiseOrValue;
    const initialPromise = failureCount === 0 ? config.initialPromise : void 0;
    try {
      promiseOrValue = initialPromise ?? config.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      if (isResolved()) {
        return;
      }
      const retry = config.retry ?? (isServer ? 0 : 3);
      const retryDelay = config.retryDelay ?? defaultRetryDelay;
      const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      config.onFail?.(failureCount, error);
      sleep(delay).then(() => {
        return canContinue() ? void 0 : pause();
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  };
  return {
    promise: thenable,
    status: () => thenable.status,
    cancel,
    continue: () => {
      continueFn?.();
      return thenable;
    },
    cancelRetry,
    continueRetry,
    canStart,
    start: () => {
      if (canStart()) {
        run();
      } else {
        pause().then(run);
      }
      return thenable;
    }
  };
}

// node_modules/@tanstack/query-core/build/modern/removable.js
init_shim();
var Removable = class {
  #gcTimeout;
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.gcTime)) {
      this.#gcTimeout = timeoutManager.setTimeout(() => {
        this.optionalRemove();
      }, this.gcTime);
    }
  }
  updateGcTime(newGcTime) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    if (this.#gcTimeout) {
      timeoutManager.clearTimeout(this.#gcTimeout);
      this.#gcTimeout = void 0;
    }
  }
};

// node_modules/@tanstack/query-core/build/modern/query.js
var Query = class extends Removable {
  #initialState;
  #revertState;
  #cache;
  #client;
  #retryer;
  #defaultOptions;
  #abortSignalConsumed;
  constructor(config) {
    super();
    this.#abortSignalConsumed = false;
    this.#defaultOptions = config.defaultOptions;
    this.setOptions(config.options);
    this.observers = [];
    this.#client = config.client;
    this.#cache = this.#client.getQueryCache();
    this.queryKey = config.queryKey;
    this.queryHash = config.queryHash;
    this.#initialState = getDefaultState(this.options);
    this.state = config.state ?? this.#initialState;
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return this.#retryer?.promise;
  }
  setOptions(options) {
    this.options = { ...this.#defaultOptions, ...options };
    this.updateGcTime(this.options.gcTime);
    if (this.state && this.state.data === void 0) {
      const defaultState = getDefaultState(this.options);
      if (defaultState.data !== void 0) {
        this.setData(defaultState.data, {
          updatedAt: defaultState.dataUpdatedAt,
          manual: true
        });
        this.#initialState = defaultState;
      }
    }
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      this.#cache.remove(this);
    }
  }
  setData(newData, options) {
    const data = replaceData(this.state.data, newData, this.options);
    this.#dispatch({
      data,
      type: "success",
      dataUpdatedAt: options?.updatedAt,
      manual: options?.manual
    });
    return data;
  }
  setState(state, setStateOptions) {
    this.#dispatch({ type: "setState", state, setStateOptions });
  }
  cancel(options) {
    const promise = this.#retryer?.promise;
    this.#retryer?.cancel(options);
    return promise ? promise.then(noop).catch(noop) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({ silent: true });
  }
  reset() {
    this.destroy();
    this.setState(this.#initialState);
  }
  isActive() {
    return this.observers.some(
      (observer) => resolveEnabled(observer.options.enabled, this) !== false
    );
  }
  isDisabled() {
    if (this.getObserversCount() > 0) {
      return !this.isActive();
    }
    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => resolveStaleTime(observer.options.staleTime, this) === "static"
      );
    }
    return false;
  }
  isStale() {
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => observer.getCurrentResult().isStale
      );
    }
    return this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(staleTime = 0) {
    if (this.state.data === void 0) {
      return true;
    }
    if (staleTime === "static") {
      return false;
    }
    if (this.state.isInvalidated) {
      return true;
    }
    return !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());
    observer?.refetch({ cancelRefetch: false });
    this.#retryer?.continue();
  }
  onOnline() {
    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());
    observer?.refetch({ cancelRefetch: false });
    this.#retryer?.continue();
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      this.#cache.notify({ type: "observerAdded", query: this, observer });
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x) => x !== observer);
      if (!this.observers.length) {
        if (this.#retryer) {
          if (this.#abortSignalConsumed) {
            this.#retryer.cancel({ revert: true });
          } else {
            this.#retryer.cancelRetry();
          }
        }
        this.scheduleGc();
      }
      this.#cache.notify({ type: "observerRemoved", query: this, observer });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      this.#dispatch({ type: "invalidate" });
    }
  }
  async fetch(options, fetchOptions) {
    if (this.state.fetchStatus !== "idle" && // If the promise in the retyer is already rejected, we have to definitely
    // re-start the fetch; there is a chance that the query is still in a
    // pending state when that happens
    this.#retryer?.status() !== "rejected") {
      if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {
        this.cancel({ silent: true });
      } else if (this.#retryer) {
        this.#retryer.continueRetry();
        return this.#retryer.promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x) => x.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    if (import_process.default.env.NODE_ENV !== "production") {
      if (!Array.isArray(this.options.queryKey)) {
        console.error(
          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`
        );
      }
    }
    const abortController = new AbortController();
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          this.#abortSignalConsumed = true;
          return abortController.signal;
        }
      });
    };
    const fetchFn = () => {
      const queryFn = ensureQueryFn(this.options, fetchOptions);
      const createQueryFnContext = () => {
        const queryFnContext2 = {
          client: this.#client,
          queryKey: this.queryKey,
          meta: this.meta
        };
        addSignalProperty(queryFnContext2);
        return queryFnContext2;
      };
      const queryFnContext = createQueryFnContext();
      this.#abortSignalConsumed = false;
      if (this.options.persister) {
        return this.options.persister(
          queryFn,
          queryFnContext,
          this
        );
      }
      return queryFn(queryFnContext);
    };
    const createFetchContext = () => {
      const context2 = {
        fetchOptions,
        options: this.options,
        queryKey: this.queryKey,
        client: this.#client,
        state: this.state,
        fetchFn
      };
      addSignalProperty(context2);
      return context2;
    };
    const context = createFetchContext();
    this.options.behavior?.onFetch(context, this);
    this.#revertState = this.state;
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== context.fetchOptions?.meta) {
      this.#dispatch({ type: "fetch", meta: context.fetchOptions?.meta });
    }
    this.#retryer = createRetryer({
      initialPromise: fetchOptions?.initialPromise,
      fn: context.fetchFn,
      onCancel: (error) => {
        if (error instanceof CancelledError && error.revert) {
          this.setState({
            ...this.#revertState,
            fetchStatus: "idle"
          });
        }
        abortController.abort();
      },
      onFail: (failureCount, error) => {
        this.#dispatch({ type: "failed", failureCount, error });
      },
      onPause: () => {
        this.#dispatch({ type: "pause" });
      },
      onContinue: () => {
        this.#dispatch({ type: "continue" });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode,
      canRun: () => true
    });
    try {
      const data = await this.#retryer.start();
      if (data === void 0) {
        if (import_process.default.env.NODE_ENV !== "production") {
          console.error(
            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
          );
        }
        throw new Error(`${this.queryHash} data is undefined`);
      }
      this.setData(data);
      this.#cache.config.onSuccess?.(data, this);
      this.#cache.config.onSettled?.(
        data,
        this.state.error,
        this
      );
      return data;
    } catch (error) {
      if (error instanceof CancelledError) {
        if (error.silent) {
          return this.#retryer.promise;
        } else if (error.revert) {
          if (this.state.data === void 0) {
            throw error;
          }
          return this.state.data;
        }
      }
      this.#dispatch({
        type: "error",
        error
      });
      this.#cache.config.onError?.(
        error,
        this
      );
      this.#cache.config.onSettled?.(
        this.state.data,
        error,
        this
      );
      throw error;
    } finally {
      this.scheduleGc();
    }
  }
  #dispatch(action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            fetchFailureCount: action.failureCount,
            fetchFailureReason: action.error
          };
        case "pause":
          return {
            ...state,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...state,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...state,
            ...fetchState(state.data, this.options),
            fetchMeta: action.meta ?? null
          };
        case "success":
          const newState = {
            ...state,
            data: action.data,
            dataUpdateCount: state.dataUpdateCount + 1,
            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
            error: null,
            isInvalidated: false,
            status: "success",
            ...!action.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
          this.#revertState = action.manual ? newState : void 0;
          return newState;
        case "error":
          const error = action.error;
          return {
            ...state,
            error,
            errorUpdateCount: state.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: state.fetchFailureCount + 1,
            fetchFailureReason: error,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...state,
            isInvalidated: true
          };
        case "setState":
          return {
            ...state,
            ...action.state
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onQueryUpdate();
      });
      this.#cache.notify({ query: this, type: "updated", action });
    });
  }
};
function fetchState(data, options) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused",
    ...data === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function getDefaultState(options) {
  const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = data !== void 0;
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle"
  };
}

// node_modules/@tanstack/query-core/build/modern/queryObserver.js
var QueryObserver = class extends Subscribable {
  constructor(client, options) {
    super();
    this.options = options;
    this.#client = client;
    this.#selectError = null;
    this.#currentThenable = pendingThenable();
    this.bindMethods();
    this.setOptions(options);
  }
  #client;
  #currentQuery = void 0;
  #currentQueryInitialState = void 0;
  #currentResult = void 0;
  #currentResultState;
  #currentResultOptions;
  #currentThenable;
  #selectError;
  #selectFn;
  #selectResult;
  // This property keeps track of the last query with defined data.
  // It will be used to pass the previous data and query to the placeholder function between renders.
  #lastQueryWithDefinedData;
  #staleTimeoutId;
  #refetchIntervalId;
  #currentRefetchInterval;
  #trackedProps = /* @__PURE__ */ new Set();
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.size === 1) {
      this.#currentQuery.addObserver(this);
      if (shouldFetchOnMount(this.#currentQuery, this.options)) {
        this.#executeFetch();
      } else {
        this.updateResult();
      }
      this.#updateTimers();
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(
      this.#currentQuery,
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(
      this.#currentQuery,
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set();
    this.#clearStaleTimeout();
    this.#clearRefetchInterval();
    this.#currentQuery.removeObserver(this);
  }
  setOptions(options) {
    const prevOptions = this.options;
    const prevQuery = this.#currentQuery;
    this.options = this.#client.defaultQueryOptions(options);
    if (this.options.enabled !== void 0 && typeof this.options.enabled !== "boolean" && typeof this.options.enabled !== "function" && typeof resolveEnabled(this.options.enabled, this.#currentQuery) !== "boolean") {
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    }
    this.#updateQuery();
    this.#currentQuery.setOptions(this.options);
    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {
      this.#client.getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: this.#currentQuery,
        observer: this
      });
    }
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(
      this.#currentQuery,
      prevQuery,
      this.options,
      prevOptions
    )) {
      this.#executeFetch();
    }
    this.updateResult();
    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || resolveStaleTime(this.options.staleTime, this.#currentQuery) !== resolveStaleTime(prevOptions.staleTime, this.#currentQuery))) {
      this.#updateStaleTimeout();
    }
    const nextRefetchInterval = this.#computeRefetchInterval();
    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {
      this.#updateRefetchInterval(nextRefetchInterval);
    }
  }
  getOptimisticResult(options) {
    const query = this.#client.getQueryCache().build(this.#client, options);
    const result = this.createResult(query, options);
    if (shouldAssignObserverCurrentProperties(this, result)) {
      this.#currentResult = result;
      this.#currentResultOptions = this.options;
      this.#currentResultState = this.#currentQuery.state;
    }
    return result;
  }
  getCurrentResult() {
    return this.#currentResult;
  }
  trackResult(result, onPropTracked) {
    return new Proxy(result, {
      get: (target, key) => {
        this.trackProp(key);
        onPropTracked?.(key);
        if (key === "promise" && !this.options.experimental_prefetchInRender && this.#currentThenable.status === "pending") {
          this.#currentThenable.reject(
            new Error(
              "experimental_prefetchInRender feature flag is not enabled"
            )
          );
        }
        return Reflect.get(target, key);
      }
    });
  }
  trackProp(key) {
    this.#trackedProps.add(key);
  }
  getCurrentQuery() {
    return this.#currentQuery;
  }
  refetch({ ...options } = {}) {
    return this.fetch({
      ...options
    });
  }
  fetchOptimistic(options) {
    const defaultedOptions = this.#client.defaultQueryOptions(options);
    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    return this.#executeFetch({
      ...fetchOptions,
      cancelRefetch: fetchOptions.cancelRefetch ?? true
    }).then(() => {
      this.updateResult();
      return this.#currentResult;
    });
  }
  #executeFetch(fetchOptions) {
    this.#updateQuery();
    let promise = this.#currentQuery.fetch(
      this.options,
      fetchOptions
    );
    if (!fetchOptions?.throwOnError) {
      promise = promise.catch(noop);
    }
    return promise;
  }
  #updateStaleTimeout() {
    this.#clearStaleTimeout();
    const staleTime = resolveStaleTime(
      this.options.staleTime,
      this.#currentQuery
    );
    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {
      return;
    }
    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime);
    const timeout = time + 1;
    this.#staleTimeoutId = timeoutManager.setTimeout(() => {
      if (!this.#currentResult.isStale) {
        this.updateResult();
      }
    }, timeout);
  }
  #computeRefetchInterval() {
    return (typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;
  }
  #updateRefetchInterval(nextInterval) {
    this.#clearRefetchInterval();
    this.#currentRefetchInterval = nextInterval;
    if (isServer || resolveEnabled(this.options.enabled, this.#currentQuery) === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {
      return;
    }
    this.#refetchIntervalId = timeoutManager.setInterval(() => {
      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
        this.#executeFetch();
      }
    }, this.#currentRefetchInterval);
  }
  #updateTimers() {
    this.#updateStaleTimeout();
    this.#updateRefetchInterval(this.#computeRefetchInterval());
  }
  #clearStaleTimeout() {
    if (this.#staleTimeoutId) {
      timeoutManager.clearTimeout(this.#staleTimeoutId);
      this.#staleTimeoutId = void 0;
    }
  }
  #clearRefetchInterval() {
    if (this.#refetchIntervalId) {
      timeoutManager.clearInterval(this.#refetchIntervalId);
      this.#refetchIntervalId = void 0;
    }
  }
  createResult(query, options) {
    const prevQuery = this.#currentQuery;
    const prevOptions = this.options;
    const prevResult = this.#currentResult;
    const prevResultState = this.#currentResultState;
    const prevResultOptions = this.#currentResultOptions;
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;
    const { state } = query;
    let newState = { ...state };
    let isPlaceholderData = false;
    let data;
    if (options._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        newState = {
          ...newState,
          ...fetchState(state.data, query.options)
        };
      }
      if (options._optimisticResults === "isRestoring") {
        newState.fetchStatus = "idle";
      }
    }
    let { error, errorUpdatedAt, status } = newState;
    data = newState.data;
    let skipSelect = false;
    if (options.placeholderData !== void 0 && data === void 0 && status === "pending") {
      let placeholderData;
      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {
        placeholderData = prevResult.data;
        skipSelect = true;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData(
          this.#lastQueryWithDefinedData?.state.data,
          this.#lastQueryWithDefinedData
        ) : options.placeholderData;
      }
      if (placeholderData !== void 0) {
        status = "success";
        data = replaceData(
          prevResult?.data,
          placeholderData,
          options
        );
        isPlaceholderData = true;
      }
    }
    if (options.select && data !== void 0 && !skipSelect) {
      if (prevResult && data === prevResultState?.data && options.select === this.#selectFn) {
        data = this.#selectResult;
      } else {
        try {
          this.#selectFn = options.select;
          data = options.select(data);
          data = replaceData(prevResult?.data, data, options);
          this.#selectResult = data;
          this.#selectError = null;
        } catch (selectError) {
          this.#selectError = selectError;
        }
      }
    }
    if (this.#selectError) {
      error = this.#selectError;
      data = this.#selectResult;
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = newState.fetchStatus === "fetching";
    const isPending = status === "pending";
    const isError = status === "error";
    const isLoading = isPending && isFetching;
    const hasData = data !== void 0;
    const result = {
      status,
      fetchStatus: newState.fetchStatus,
      isPending,
      isSuccess: status === "success",
      isError,
      isInitialLoading: isLoading,
      isLoading,
      data,
      dataUpdatedAt: newState.dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: newState.fetchFailureCount,
      failureReason: newState.fetchFailureReason,
      errorUpdateCount: newState.errorUpdateCount,
      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && !isPending,
      isLoadingError: isError && !hasData,
      isPaused: newState.fetchStatus === "paused",
      isPlaceholderData,
      isRefetchError: isError && hasData,
      isStale: isStale(query, options),
      refetch: this.refetch,
      promise: this.#currentThenable,
      isEnabled: resolveEnabled(options.enabled, query) !== false
    };
    const nextResult = result;
    if (this.options.experimental_prefetchInRender) {
      const finalizeThenableIfPossible = (thenable) => {
        if (nextResult.status === "error") {
          thenable.reject(nextResult.error);
        } else if (nextResult.data !== void 0) {
          thenable.resolve(nextResult.data);
        }
      };
      const recreateThenable = () => {
        const pending = this.#currentThenable = nextResult.promise = pendingThenable();
        finalizeThenableIfPossible(pending);
      };
      const prevThenable = this.#currentThenable;
      switch (prevThenable.status) {
        case "pending":
          if (query.queryHash === prevQuery.queryHash) {
            finalizeThenableIfPossible(prevThenable);
          }
          break;
        case "fulfilled":
          if (nextResult.status === "error" || nextResult.data !== prevThenable.value) {
            recreateThenable();
          }
          break;
        case "rejected":
          if (nextResult.status !== "error" || nextResult.error !== prevThenable.reason) {
            recreateThenable();
          }
          break;
      }
    }
    return nextResult;
  }
  updateResult() {
    const prevResult = this.#currentResult;
    const nextResult = this.createResult(this.#currentQuery, this.options);
    this.#currentResultState = this.#currentQuery.state;
    this.#currentResultOptions = this.options;
    if (this.#currentResultState.data !== void 0) {
      this.#lastQueryWithDefinedData = this.#currentQuery;
    }
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    this.#currentResult = nextResult;
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const { notifyOnChangeProps } = this.options;
      const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
      if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !this.#trackedProps.size) {
        return true;
      }
      const includedProps = new Set(
        notifyOnChangePropsValue ?? this.#trackedProps
      );
      if (this.options.throwOnError) {
        includedProps.add("error");
      }
      return Object.keys(this.#currentResult).some((key) => {
        const typedKey = key;
        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    this.#notify({ listeners: shouldNotifyListeners() });
  }
  #updateQuery() {
    const query = this.#client.getQueryCache().build(this.#client, this.options);
    if (query === this.#currentQuery) {
      return;
    }
    const prevQuery = this.#currentQuery;
    this.#currentQuery = query;
    this.#currentQueryInitialState = query.state;
    if (this.hasListeners()) {
      prevQuery?.removeObserver(this);
      query.addObserver(this);
    }
  }
  onQueryUpdate() {
    this.updateResult();
    if (this.hasListeners()) {
      this.#updateTimers();
    }
  }
  #notify(notifyOptions) {
    notifyManager.batch(() => {
      if (notifyOptions.listeners) {
        this.listeners.forEach((listener) => {
          listener(this.#currentResult);
        });
      }
      this.#client.getQueryCache().notify({
        query: this.#currentQuery,
        type: "observerResultsUpdated"
      });
    });
  }
};
function shouldLoadOnMount(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (resolveEnabled(options.enabled, query) !== false && resolveStaleTime(options.staleTime, query) !== "static") {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}

// node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js
init_shim();
function infiniteQueryBehavior(pages) {
  return {
    onFetch: (context, query) => {
      const options = context.options;
      const direction = context.fetchOptions?.meta?.fetchMore?.direction;
      const oldPages = context.state.data?.pages || [];
      const oldPageParams = context.state.data?.pageParams || [];
      let result = { pages: [], pageParams: [] };
      let currentPage = 0;
      const fetchFn = async () => {
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              if (context.signal.aborted) {
                cancelled = true;
              } else {
                context.signal.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };
        const queryFn = ensureQueryFn(context.options, context.fetchOptions);
        const fetchPage = async (data, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data.pages.length) {
            return Promise.resolve(data);
          }
          const createQueryFnContext = () => {
            const queryFnContext2 = {
              client: context.client,
              queryKey: context.queryKey,
              pageParam: param,
              direction: previous ? "backward" : "forward",
              meta: context.options.meta
            };
            addSignalProperty(queryFnContext2);
            return queryFnContext2;
          };
          const queryFnContext = createQueryFnContext();
          const page = await queryFn(queryFnContext);
          const { maxPages } = context.options;
          const addTo = previous ? addToStart : addToEnd;
          return {
            pages: addTo(data.pages, page, maxPages),
            pageParams: addTo(data.pageParams, param, maxPages)
          };
        };
        if (direction && oldPages.length) {
          const previous = direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options, oldData);
          result = await fetchPage(oldData, param, previous);
        } else {
          const remainingPages = pages ?? oldPages.length;
          do {
            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);
            if (currentPage > 0 && param == null) {
              break;
            }
            result = await fetchPage(result, param);
            currentPage++;
          } while (currentPage < remainingPages);
        }
        return result;
      };
      if (context.options.persister) {
        context.fetchFn = () => {
          return context.options.persister?.(
            fetchFn,
            {
              client: context.client,
              queryKey: context.queryKey,
              meta: context.options.meta,
              signal: context.signal
            },
            query
          );
        };
      } else {
        context.fetchFn = fetchFn;
      }
    }
  };
}
function getNextPageParam(options, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return pages.length > 0 ? options.getNextPageParam(
    pages[lastIndex],
    pages,
    pageParams[lastIndex],
    pageParams
  ) : void 0;
}
function getPreviousPageParam(options, { pages, pageParams }) {
  return pages.length > 0 ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams) : void 0;
}

// node_modules/@tanstack/query-core/build/modern/mutationCache.js
init_shim();

// node_modules/@tanstack/query-core/build/modern/mutation.js
init_shim();
var Mutation = class extends Removable {
  #client;
  #observers;
  #mutationCache;
  #retryer;
  constructor(config) {
    super();
    this.#client = config.client;
    this.mutationId = config.mutationId;
    this.#mutationCache = config.mutationCache;
    this.#observers = [];
    this.state = config.state || getDefaultState2();
    this.setOptions(config.options);
    this.scheduleGc();
  }
  setOptions(options) {
    this.options = options;
    this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(observer) {
    if (!this.#observers.includes(observer)) {
      this.#observers.push(observer);
      this.clearGcTimeout();
      this.#mutationCache.notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    this.#observers = this.#observers.filter((x) => x !== observer);
    this.scheduleGc();
    this.#mutationCache.notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!this.#observers.length) {
      if (this.state.status === "pending") {
        this.scheduleGc();
      } else {
        this.#mutationCache.remove(this);
      }
    }
  }
  continue() {
    return this.#retryer?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(variables) {
    const onContinue = () => {
      this.#dispatch({ type: "continue" });
    };
    const mutationFnContext = {
      client: this.#client,
      meta: this.options.meta,
      mutationKey: this.options.mutationKey
    };
    this.#retryer = createRetryer({
      fn: () => {
        if (!this.options.mutationFn) {
          return Promise.reject(new Error("No mutationFn found"));
        }
        return this.options.mutationFn(variables, mutationFnContext);
      },
      onFail: (failureCount, error) => {
        this.#dispatch({ type: "failed", failureCount, error });
      },
      onPause: () => {
        this.#dispatch({ type: "pause" });
      },
      onContinue,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => this.#mutationCache.canRun(this)
    });
    const restored = this.state.status === "pending";
    const isPaused = !this.#retryer.canStart();
    try {
      if (restored) {
        onContinue();
      } else {
        this.#dispatch({ type: "pending", variables, isPaused });
        await this.#mutationCache.config.onMutate?.(
          variables,
          this,
          mutationFnContext
        );
        const context = await this.options.onMutate?.(
          variables,
          mutationFnContext
        );
        if (context !== this.state.context) {
          this.#dispatch({
            type: "pending",
            context,
            variables,
            isPaused
          });
        }
      }
      const data = await this.#retryer.start();
      await this.#mutationCache.config.onSuccess?.(
        data,
        variables,
        this.state.context,
        this,
        mutationFnContext
      );
      await this.options.onSuccess?.(
        data,
        variables,
        this.state.context,
        mutationFnContext
      );
      await this.#mutationCache.config.onSettled?.(
        data,
        null,
        this.state.variables,
        this.state.context,
        this,
        mutationFnContext
      );
      await this.options.onSettled?.(
        data,
        null,
        variables,
        this.state.context,
        mutationFnContext
      );
      this.#dispatch({ type: "success", data });
      return data;
    } catch (error) {
      try {
        await this.#mutationCache.config.onError?.(
          error,
          variables,
          this.state.context,
          this,
          mutationFnContext
        );
        await this.options.onError?.(
          error,
          variables,
          this.state.context,
          mutationFnContext
        );
        await this.#mutationCache.config.onSettled?.(
          void 0,
          error,
          this.state.variables,
          this.state.context,
          this,
          mutationFnContext
        );
        await this.options.onSettled?.(
          void 0,
          error,
          variables,
          this.state.context,
          mutationFnContext
        );
        throw error;
      } finally {
        this.#dispatch({ type: "error", error });
      }
    } finally {
      this.#mutationCache.runNext(this);
    }
  }
  #dispatch(action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            failureCount: action.failureCount,
            failureReason: action.error
          };
        case "pause":
          return {
            ...state,
            isPaused: true
          };
        case "continue":
          return {
            ...state,
            isPaused: false
          };
        case "pending":
          return {
            ...state,
            context: action.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: action.isPaused,
            status: "pending",
            variables: action.variables,
            submittedAt: Date.now()
          };
        case "success":
          return {
            ...state,
            data: action.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: false
          };
        case "error":
          return {
            ...state,
            data: void 0,
            error: action.error,
            failureCount: state.failureCount + 1,
            failureReason: action.error,
            isPaused: false,
            status: "error"
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.#observers.forEach((observer) => {
        observer.onMutationUpdate(action);
      });
      this.#mutationCache.notify({
        mutation: this,
        type: "updated",
        action
      });
    });
  }
};
function getDefaultState2() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}

// node_modules/@tanstack/query-core/build/modern/mutationCache.js
var MutationCache = class extends Subscribable {
  constructor(config = {}) {
    super();
    this.config = config;
    this.#mutations = /* @__PURE__ */ new Set();
    this.#scopes = /* @__PURE__ */ new Map();
    this.#mutationId = 0;
  }
  #mutations;
  #scopes;
  #mutationId;
  build(client, options, state) {
    const mutation = new Mutation({
      client,
      mutationCache: this,
      mutationId: ++this.#mutationId,
      options: client.defaultMutationOptions(options),
      state
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    this.#mutations.add(mutation);
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const scopedMutations = this.#scopes.get(scope);
      if (scopedMutations) {
        scopedMutations.push(mutation);
      } else {
        this.#scopes.set(scope, [mutation]);
      }
    }
    this.notify({ type: "added", mutation });
  }
  remove(mutation) {
    if (this.#mutations.delete(mutation)) {
      const scope = scopeFor(mutation);
      if (typeof scope === "string") {
        const scopedMutations = this.#scopes.get(scope);
        if (scopedMutations) {
          if (scopedMutations.length > 1) {
            const index = scopedMutations.indexOf(mutation);
            if (index !== -1) {
              scopedMutations.splice(index, 1);
            }
          } else if (scopedMutations[0] === mutation) {
            this.#scopes.delete(scope);
          }
        }
      }
    }
    this.notify({ type: "removed", mutation });
  }
  canRun(mutation) {
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const mutationsWithSameScope = this.#scopes.get(scope);
      const firstPendingMutation = mutationsWithSameScope?.find(
        (m) => m.state.status === "pending"
      );
      return !firstPendingMutation || firstPendingMutation === mutation;
    } else {
      return true;
    }
  }
  runNext(mutation) {
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const foundMutation = this.#scopes.get(scope)?.find((m) => m !== mutation && m.state.isPaused);
      return foundMutation?.continue() ?? Promise.resolve();
    } else {
      return Promise.resolve();
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.#mutations.forEach((mutation) => {
        this.notify({ type: "removed", mutation });
      });
      this.#mutations.clear();
      this.#scopes.clear();
    });
  }
  getAll() {
    return Array.from(this.#mutations);
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (mutation) => matchMutation(defaultedFilters, mutation)
    );
  }
  findAll(filters = {}) {
    return this.getAll().filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.getAll().filter((x) => x.state.isPaused);
    return notifyManager.batch(
      () => Promise.all(
        pausedMutations.map((mutation) => mutation.continue().catch(noop))
      )
    );
  }
};
function scopeFor(mutation) {
  return mutation.options.scope?.id;
}

// node_modules/@tanstack/query-core/build/modern/mutationObserver.js
init_shim();
var MutationObserver = class extends Subscribable {
  #client;
  #currentResult = void 0;
  #currentMutation;
  #mutateOptions;
  constructor(client, options) {
    super();
    this.#client = client;
    this.setOptions(options);
    this.bindMethods();
    this.#updateResult();
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    const prevOptions = this.options;
    this.options = this.#client.defaultMutationOptions(options);
    if (!shallowEqualObjects(this.options, prevOptions)) {
      this.#client.getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: this.#currentMutation,
        observer: this
      });
    }
    if (prevOptions?.mutationKey && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {
      this.reset();
    } else if (this.#currentMutation?.state.status === "pending") {
      this.#currentMutation.setOptions(this.options);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.#currentMutation?.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    this.#updateResult();
    this.#notify(action);
  }
  getCurrentResult() {
    return this.#currentResult;
  }
  reset() {
    this.#currentMutation?.removeObserver(this);
    this.#currentMutation = void 0;
    this.#updateResult();
    this.#notify();
  }
  mutate(variables, options) {
    this.#mutateOptions = options;
    this.#currentMutation?.removeObserver(this);
    this.#currentMutation = this.#client.getMutationCache().build(this.#client, this.options);
    this.#currentMutation.addObserver(this);
    return this.#currentMutation.execute(variables);
  }
  #updateResult() {
    const state = this.#currentMutation?.state ?? getDefaultState2();
    this.#currentResult = {
      ...state,
      isPending: state.status === "pending",
      isSuccess: state.status === "success",
      isError: state.status === "error",
      isIdle: state.status === "idle",
      mutate: this.mutate,
      reset: this.reset
    };
  }
  #notify(action) {
    notifyManager.batch(() => {
      if (this.#mutateOptions && this.hasListeners()) {
        const variables = this.#currentResult.variables;
        const onMutateResult = this.#currentResult.context;
        const context = {
          client: this.#client,
          meta: this.options.meta,
          mutationKey: this.options.mutationKey
        };
        if (action?.type === "success") {
          this.#mutateOptions.onSuccess?.(
            action.data,
            variables,
            onMutateResult,
            context
          );
          this.#mutateOptions.onSettled?.(
            action.data,
            null,
            variables,
            onMutateResult,
            context
          );
        } else if (action?.type === "error") {
          this.#mutateOptions.onError?.(
            action.error,
            variables,
            onMutateResult,
            context
          );
          this.#mutateOptions.onSettled?.(
            void 0,
            action.error,
            variables,
            onMutateResult,
            context
          );
        }
      }
      this.listeners.forEach((listener) => {
        listener(this.#currentResult);
      });
    });
  }
};

// node_modules/@tanstack/query-core/build/modern/queriesObserver.js
init_shim();

// node_modules/@tanstack/query-core/build/modern/queryCache.js
init_shim();
var QueryCache = class extends Subscribable {
  constructor(config = {}) {
    super();
    this.config = config;
    this.#queries = /* @__PURE__ */ new Map();
  }
  #queries;
  build(client, options, state) {
    const queryKey = options.queryKey;
    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        client,
        queryKey,
        queryHash,
        options: client.defaultQueryOptions(options),
        state,
        defaultOptions: client.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!this.#queries.has(query.queryHash)) {
      this.#queries.set(query.queryHash, query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = this.#queries.get(query.queryHash);
    if (queryInMap) {
      query.destroy();
      if (queryInMap === query) {
        this.#queries.delete(query.queryHash);
      }
      this.notify({ type: "removed", query });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return this.#queries.get(queryHash);
  }
  getAll() {
    return [...this.#queries.values()];
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (query) => matchQuery(defaultedFilters, query)
    );
  }
  findAll(filters = {}) {
    const queries = this.getAll();
    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onOnline();
      });
    });
  }
};

// node_modules/@tanstack/query-core/build/modern/queryClient.js
init_shim();
var QueryClient = class {
  #queryCache;
  #mutationCache;
  #defaultOptions;
  #queryDefaults;
  #mutationDefaults;
  #mountCount;
  #unsubscribeFocus;
  #unsubscribeOnline;
  constructor(config = {}) {
    this.#queryCache = config.queryCache || new QueryCache();
    this.#mutationCache = config.mutationCache || new MutationCache();
    this.#defaultOptions = config.defaultOptions || {};
    this.#queryDefaults = /* @__PURE__ */ new Map();
    this.#mutationDefaults = /* @__PURE__ */ new Map();
    this.#mountCount = 0;
  }
  mount() {
    this.#mountCount++;
    if (this.#mountCount !== 1) return;
    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {
      if (focused) {
        await this.resumePausedMutations();
        this.#queryCache.onFocus();
      }
    });
    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {
      if (online) {
        await this.resumePausedMutations();
        this.#queryCache.onOnline();
      }
    });
  }
  unmount() {
    this.#mountCount--;
    if (this.#mountCount !== 0) return;
    this.#unsubscribeFocus?.();
    this.#unsubscribeFocus = void 0;
    this.#unsubscribeOnline?.();
    this.#unsubscribeOnline = void 0;
  }
  isFetching(filters) {
    return this.#queryCache.findAll({ ...filters, fetchStatus: "fetching" }).length;
  }
  isMutating(filters) {
    return this.#mutationCache.findAll({ ...filters, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(queryKey) {
    const options = this.defaultQueryOptions({ queryKey });
    return this.#queryCache.get(options.queryHash)?.state.data;
  }
  ensureQueryData(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    const query = this.#queryCache.build(this, defaultedOptions);
    const cachedData = query.state.data;
    if (cachedData === void 0) {
      return this.fetchQuery(options);
    }
    if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {
      void this.prefetchQuery(defaultedOptions);
    }
    return Promise.resolve(cachedData);
  }
  getQueriesData(filters) {
    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {
      const data = state.data;
      return [queryKey, data];
    });
  }
  setQueryData(queryKey, updater, options) {
    const defaultedOptions = this.defaultQueryOptions({ queryKey });
    const query = this.#queryCache.get(
      defaultedOptions.queryHash
    );
    const prevData = query?.state.data;
    const data = functionalUpdate(updater, prevData);
    if (data === void 0) {
      return void 0;
    }
    return this.#queryCache.build(this, defaultedOptions).setData(data, { ...options, manual: true });
  }
  setQueriesData(filters, updater, options) {
    return notifyManager.batch(
      () => this.#queryCache.findAll(filters).map(({ queryKey }) => [
        queryKey,
        this.setQueryData(queryKey, updater, options)
      ])
    );
  }
  getQueryState(queryKey) {
    const options = this.defaultQueryOptions({ queryKey });
    return this.#queryCache.get(
      options.queryHash
    )?.state;
  }
  removeQueries(filters) {
    const queryCache = this.#queryCache;
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(filters, options) {
    const queryCache = this.#queryCache;
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(
        {
          type: "active",
          ...filters
        },
        options
      );
    });
  }
  cancelQueries(filters, cancelOptions = {}) {
    const defaultedCancelOptions = { revert: true, ...cancelOptions };
    const promises = notifyManager.batch(
      () => this.#queryCache.findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
    );
    return Promise.all(promises).then(noop).catch(noop);
  }
  invalidateQueries(filters, options = {}) {
    return notifyManager.batch(() => {
      this.#queryCache.findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if (filters?.refetchType === "none") {
        return Promise.resolve();
      }
      return this.refetchQueries(
        {
          ...filters,
          type: filters?.refetchType ?? filters?.type ?? "active"
        },
        options
      );
    });
  }
  refetchQueries(filters, options = {}) {
    const fetchOptions = {
      ...options,
      cancelRefetch: options.cancelRefetch ?? true
    };
    const promises = notifyManager.batch(
      () => this.#queryCache.findAll(filters).filter((query) => !query.isDisabled() && !query.isStatic()).map((query) => {
        let promise = query.fetch(void 0, fetchOptions);
        if (!fetchOptions.throwOnError) {
          promise = promise.catch(noop);
        }
        return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
      })
    );
    return Promise.all(promises).then(noop);
  }
  fetchQuery(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    if (defaultedOptions.retry === void 0) {
      defaultedOptions.retry = false;
    }
    const query = this.#queryCache.build(this, defaultedOptions);
    return query.isStaleByTime(
      resolveStaleTime(defaultedOptions.staleTime, query)
    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(options) {
    return this.fetchQuery(options).then(noop).catch(noop);
  }
  fetchInfiniteQuery(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.fetchQuery(options);
  }
  prefetchInfiniteQuery(options) {
    return this.fetchInfiniteQuery(options).then(noop).catch(noop);
  }
  ensureInfiniteQueryData(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.ensureQueryData(options);
  }
  resumePausedMutations() {
    if (onlineManager.isOnline()) {
      return this.#mutationCache.resumePausedMutations();
    }
    return Promise.resolve();
  }
  getQueryCache() {
    return this.#queryCache;
  }
  getMutationCache() {
    return this.#mutationCache;
  }
  getDefaultOptions() {
    return this.#defaultOptions;
  }
  setDefaultOptions(options) {
    this.#defaultOptions = options;
  }
  setQueryDefaults(queryKey, options) {
    this.#queryDefaults.set(hashKey(queryKey), {
      queryKey,
      defaultOptions: options
    });
  }
  getQueryDefaults(queryKey) {
    const defaults = [...this.#queryDefaults.values()];
    const result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(queryKey, queryDefault.queryKey)) {
        Object.assign(result, queryDefault.defaultOptions);
      }
    });
    return result;
  }
  setMutationDefaults(mutationKey, options) {
    this.#mutationDefaults.set(hashKey(mutationKey), {
      mutationKey,
      defaultOptions: options
    });
  }
  getMutationDefaults(mutationKey) {
    const defaults = [...this.#mutationDefaults.values()];
    const result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
        Object.assign(result, queryDefault.defaultOptions);
      }
    });
    return result;
  }
  defaultQueryOptions(options) {
    if (options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...this.#defaultOptions.queries,
      ...this.getQueryDefaults(options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(
        defaultedOptions.queryKey,
        defaultedOptions
      );
    }
    if (defaultedOptions.refetchOnReconnect === void 0) {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (defaultedOptions.throwOnError === void 0) {
      defaultedOptions.throwOnError = !!defaultedOptions.suspense;
    }
    if (!defaultedOptions.networkMode && defaultedOptions.persister) {
      defaultedOptions.networkMode = "offlineFirst";
    }
    if (defaultedOptions.queryFn === skipToken) {
      defaultedOptions.enabled = false;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options?._defaulted) {
      return options;
    }
    return {
      ...this.#defaultOptions.mutations,
      ...options?.mutationKey && this.getMutationDefaults(options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    this.#queryCache.clear();
    this.#mutationCache.clear();
  }
};

// node_modules/@tanstack/query-core/build/modern/streamedQuery.js
init_shim();

// node_modules/@tanstack/query-core/build/modern/types.js
init_shim();
var dataTagSymbol = Symbol("dataTagSymbol");
var dataTagErrorSymbol = Symbol("dataTagErrorSymbol");
var unsetMarker = Symbol("unsetMarker");

// node_modules/@tanstack/react-query/build/modern/types.js
init_shim();

// node_modules/@tanstack/react-query/build/modern/useQueries.js
init_shim();
var React5 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js
init_shim();
var React = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var QueryClientContext = React.createContext(
  void 0
);
var useQueryClient = (queryClient) => {
  const client = React.useContext(QueryClientContext);
  if (queryClient) {
    return queryClient;
  }
  if (!client) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return client;
};
var QueryClientProvider = ({
  client,
  children
}) => {
  React.useEffect(() => {
    client.mount();
    return () => {
      client.unmount();
    };
  }, [client]);
  return (0, import_jsx_runtime.jsx)(QueryClientContext.Provider, { value: client, children });
};

// node_modules/@tanstack/react-query/build/modern/IsRestoringProvider.js
init_shim();
var React2 = __toESM(require_react(), 1);
var IsRestoringContext = React2.createContext(false);
var useIsRestoring = () => React2.useContext(IsRestoringContext);
var IsRestoringProvider = IsRestoringContext.Provider;

// node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js
init_shim();
var React3 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = React3.createContext(createValue());
var useQueryErrorResetBoundary = () => React3.useContext(QueryErrorResetBoundaryContext);

// node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js
init_shim();
var React4 = __toESM(require_react(), 1);
var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
  if (options.suspense || options.throwOnError || options.experimental_prefetchInRender) {
    if (!errorResetBoundary.isReset()) {
      options.retryOnMount = false;
    }
  }
};
var useClearResetErrorBoundary = (errorResetBoundary) => {
  React4.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
};
var getHasError = ({
  result,
  errorResetBoundary,
  throwOnError,
  query,
  suspense
}) => {
  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (suspense && result.data === void 0 || shouldThrowError(throwOnError, [result.error, query]));
};

// node_modules/@tanstack/react-query/build/modern/suspense.js
init_shim();
var ensureSuspenseTimers = (defaultedOptions) => {
  if (defaultedOptions.suspense) {
    const MIN_SUSPENSE_TIME_MS = 1e3;
    const clamp = (value) => value === "static" ? value : Math.max(value ?? MIN_SUSPENSE_TIME_MS, MIN_SUSPENSE_TIME_MS);
    const originalStaleTime = defaultedOptions.staleTime;
    defaultedOptions.staleTime = typeof originalStaleTime === "function" ? (...args) => clamp(originalStaleTime(...args)) : clamp(originalStaleTime);
    if (typeof defaultedOptions.gcTime === "number") {
      defaultedOptions.gcTime = Math.max(
        defaultedOptions.gcTime,
        MIN_SUSPENSE_TIME_MS
      );
    }
  }
};
var willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
var shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;
var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {
  errorResetBoundary.clearReset();
});

// node_modules/@tanstack/react-query/build/modern/useQuery.js
init_shim();

// node_modules/@tanstack/react-query/build/modern/useBaseQuery.js
init_shim();
var React6 = __toESM(require_react(), 1);
function useBaseQuery(options, Observer, queryClient) {
  if (import_process.default.env.NODE_ENV !== "production") {
    if (typeof options !== "object" || Array.isArray(options)) {
      throw new Error(
        'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
      );
    }
  }
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const client = useQueryClient(queryClient);
  const defaultedOptions = client.defaultQueryOptions(options);
  client.getDefaultOptions().queries?._experimental_beforeQuery?.(
    defaultedOptions
  );
  if (import_process.default.env.NODE_ENV !== "production") {
    if (!defaultedOptions.queryFn) {
      console.error(
        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`
      );
    }
  }
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  ensureSuspenseTimers(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
  useClearResetErrorBoundary(errorResetBoundary);
  const isNewCacheEntry = !client.getQueryCache().get(defaultedOptions.queryHash);
  const [observer] = React6.useState(
    () => new Observer(
      client,
      defaultedOptions
    )
  );
  const result = observer.getOptimisticResult(defaultedOptions);
  const shouldSubscribe = !isRestoring && options.subscribed !== false;
  React6.useSyncExternalStore(
    React6.useCallback(
      (onStoreChange) => {
        const unsubscribe = shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop;
        observer.updateResult();
        return unsubscribe;
      },
      [observer, shouldSubscribe]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  React6.useEffect(() => {
    observer.setOptions(defaultedOptions);
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    throwOnError: defaultedOptions.throwOnError,
    query: client.getQueryCache().get(defaultedOptions.queryHash),
    suspense: defaultedOptions.suspense
  })) {
    throw result.error;
  }
  ;
  client.getDefaultOptions().queries?._experimental_afterQuery?.(
    defaultedOptions,
    result
  );
  if (defaultedOptions.experimental_prefetchInRender && !isServer && willFetch(result, isRestoring)) {
    const promise = isNewCacheEntry ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      fetchOptimistic(defaultedOptions, observer, errorResetBoundary)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      client.getQueryCache().get(defaultedOptions.queryHash)?.promise
    );
    promise?.catch(noop).finally(() => {
      observer.updateResult();
    });
  }
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}

// node_modules/@tanstack/react-query/build/modern/useQuery.js
function useQuery(options, queryClient) {
  return useBaseQuery(options, QueryObserver, queryClient);
}

// node_modules/@tanstack/react-query/build/modern/useSuspenseQuery.js
init_shim();

// node_modules/@tanstack/react-query/build/modern/useSuspenseInfiniteQuery.js
init_shim();

// node_modules/@tanstack/react-query/build/modern/useSuspenseQueries.js
init_shim();

// node_modules/@tanstack/react-query/build/modern/usePrefetchQuery.js
init_shim();

// node_modules/@tanstack/react-query/build/modern/usePrefetchInfiniteQuery.js
init_shim();

// node_modules/@tanstack/react-query/build/modern/queryOptions.js
init_shim();

// node_modules/@tanstack/react-query/build/modern/infiniteQueryOptions.js
init_shim();

// node_modules/@tanstack/react-query/build/modern/HydrationBoundary.js
init_shim();
var React7 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/useIsFetching.js
init_shim();
var React8 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/useMutationState.js
init_shim();
var React9 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/useMutation.js
init_shim();
var React10 = __toESM(require_react(), 1);
function useMutation(options, queryClient) {
  const client = useQueryClient(queryClient);
  const [observer] = React10.useState(
    () => new MutationObserver(
      client,
      options
    )
  );
  React10.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = React10.useSyncExternalStore(
    React10.useCallback(
      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),
      [observer]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  const mutate = React10.useCallback(
    (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop);
    },
    [observer]
  );
  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {
    throw result.error;
  }
  return { ...result, mutate, mutateAsync: result.mutate };
}

// node_modules/@tanstack/react-query/build/modern/mutationOptions.js
init_shim();

// node_modules/@tanstack/react-query/build/modern/useInfiniteQuery.js
init_shim();

// node_modules/gill/dist/programs/token/index.node.mjs
init_shim();

// node_modules/gill/dist/chunk-ZYQZBNRK.node.mjs
init_shim();

// node_modules/gill/dist/chunk-VC6NKDS2.node.mjs
init_shim();
function checkedAddress(input) {
  return typeof input == "string" ? input : input.address;
}

// node_modules/gill/node_modules/@solana-program/token-2022/dist/src/index.mjs
init_shim();

// node_modules/gill/node_modules/@solana/sysvars/dist/index.browser.mjs
init_shim();
var BITVEC_NUM_BITS = 1024 * 1024;
var BITVEC_LENGTH = BITVEC_NUM_BITS / 64;
var SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE = 1 + // Discriminator
8 + // bitvector length (u64)
BITVEC_LENGTH * 8 + 8 + // Number of bits (u64)
8;

// node_modules/gill/node_modules/@solana-program/token-2022/dist/src/index.mjs
var AccountState = ((AccountState2) => {
  AccountState2[AccountState2["Uninitialized"] = 0] = "Uninitialized";
  AccountState2[AccountState2["Initialized"] = 1] = "Initialized";
  AccountState2[AccountState2["Frozen"] = 2] = "Frozen";
  return AccountState2;
})(AccountState || {});
function getAccountStateDecoder() {
  return getEnumDecoder(AccountState);
}
var AuthorityType = ((AuthorityType2) => {
  AuthorityType2[AuthorityType2["MintTokens"] = 0] = "MintTokens";
  AuthorityType2[AuthorityType2["FreezeAccount"] = 1] = "FreezeAccount";
  AuthorityType2[AuthorityType2["AccountOwner"] = 2] = "AccountOwner";
  AuthorityType2[AuthorityType2["CloseAccount"] = 3] = "CloseAccount";
  AuthorityType2[AuthorityType2["TransferFeeConfig"] = 4] = "TransferFeeConfig";
  AuthorityType2[AuthorityType2["WithheldWithdraw"] = 5] = "WithheldWithdraw";
  AuthorityType2[AuthorityType2["CloseMint"] = 6] = "CloseMint";
  AuthorityType2[AuthorityType2["InterestRate"] = 7] = "InterestRate";
  AuthorityType2[AuthorityType2["PermanentDelegate"] = 8] = "PermanentDelegate";
  AuthorityType2[AuthorityType2["ConfidentialTransferMint"] = 9] = "ConfidentialTransferMint";
  AuthorityType2[AuthorityType2["TransferHookProgramId"] = 10] = "TransferHookProgramId";
  AuthorityType2[AuthorityType2["ConfidentialTransferFeeConfig"] = 11] = "ConfidentialTransferFeeConfig";
  AuthorityType2[AuthorityType2["MetadataPointer"] = 12] = "MetadataPointer";
  AuthorityType2[AuthorityType2["GroupPointer"] = 13] = "GroupPointer";
  AuthorityType2[AuthorityType2["GroupMemberPointer"] = 14] = "GroupMemberPointer";
  AuthorityType2[AuthorityType2["ScaledUiAmount"] = 15] = "ScaledUiAmount";
  AuthorityType2[AuthorityType2["Pause"] = 16] = "Pause";
  return AuthorityType2;
})(AuthorityType || {});
function getDecryptableBalanceDecoder() {
  return fixDecoderSize(getBytesDecoder(), 36);
}
function getEncryptedBalanceDecoder() {
  return fixDecoderSize(getBytesDecoder(), 64);
}
function getExtensionDecoder() {
  return getDiscriminatedUnionDecoder(
    [
      ["Uninitialized", getUnitDecoder()],
      [
        "TransferFeeConfig",
        addDecoderSizePrefix(
          getStructDecoder([
            ["transferFeeConfigAuthority", getAddressDecoder()],
            ["withdrawWithheldAuthority", getAddressDecoder()],
            ["withheldAmount", getU64Decoder()],
            ["olderTransferFee", getTransferFeeDecoder()],
            ["newerTransferFee", getTransferFeeDecoder()]
          ]),
          getU16Decoder()
        )
      ],
      [
        "TransferFeeAmount",
        addDecoderSizePrefix(
          getStructDecoder([["withheldAmount", getU64Decoder()]]),
          getU16Decoder()
        )
      ],
      [
        "MintCloseAuthority",
        addDecoderSizePrefix(
          getStructDecoder([["closeAuthority", getAddressDecoder()]]),
          getU16Decoder()
        )
      ],
      [
        "ConfidentialTransferMint",
        addDecoderSizePrefix(
          getStructDecoder([
            [
              "authority",
              getOptionDecoder(getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            ["autoApproveNewAccounts", getBooleanDecoder()],
            [
              "auditorElgamalPubkey",
              getOptionDecoder(getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ]
          ]),
          getU16Decoder()
        )
      ],
      [
        "ConfidentialTransferAccount",
        addDecoderSizePrefix(
          getStructDecoder([
            ["approved", getBooleanDecoder()],
            ["elgamalPubkey", getAddressDecoder()],
            ["pendingBalanceLow", getEncryptedBalanceDecoder()],
            ["pendingBalanceHigh", getEncryptedBalanceDecoder()],
            ["availableBalance", getEncryptedBalanceDecoder()],
            ["decryptableAvailableBalance", getDecryptableBalanceDecoder()],
            ["allowConfidentialCredits", getBooleanDecoder()],
            ["allowNonConfidentialCredits", getBooleanDecoder()],
            ["pendingBalanceCreditCounter", getU64Decoder()],
            ["maximumPendingBalanceCreditCounter", getU64Decoder()],
            ["expectedPendingBalanceCreditCounter", getU64Decoder()],
            ["actualPendingBalanceCreditCounter", getU64Decoder()]
          ]),
          getU16Decoder()
        )
      ],
      [
        "DefaultAccountState",
        addDecoderSizePrefix(
          getStructDecoder([["state", getAccountStateDecoder()]]),
          getU16Decoder()
        )
      ],
      [
        "ImmutableOwner",
        addDecoderSizePrefix(getStructDecoder([]), getU16Decoder())
      ],
      [
        "MemoTransfer",
        addDecoderSizePrefix(
          getStructDecoder([
            ["requireIncomingTransferMemos", getBooleanDecoder()]
          ]),
          getU16Decoder()
        )
      ],
      [
        "NonTransferable",
        addDecoderSizePrefix(getStructDecoder([]), getU16Decoder())
      ],
      [
        "InterestBearingConfig",
        addDecoderSizePrefix(
          getStructDecoder([
            ["rateAuthority", getAddressDecoder()],
            ["initializationTimestamp", getU64Decoder()],
            ["preUpdateAverageRate", getI16Decoder()],
            ["lastUpdateTimestamp", getU64Decoder()],
            ["currentRate", getI16Decoder()]
          ]),
          getU16Decoder()
        )
      ],
      [
        "CpiGuard",
        addDecoderSizePrefix(
          getStructDecoder([["lockCpi", getBooleanDecoder()]]),
          getU16Decoder()
        )
      ],
      [
        "PermanentDelegate",
        addDecoderSizePrefix(
          getStructDecoder([["delegate", getAddressDecoder()]]),
          getU16Decoder()
        )
      ],
      [
        "NonTransferableAccount",
        addDecoderSizePrefix(getStructDecoder([]), getU16Decoder())
      ],
      [
        "TransferHook",
        addDecoderSizePrefix(
          getStructDecoder([
            ["authority", getAddressDecoder()],
            ["programId", getAddressDecoder()]
          ]),
          getU16Decoder()
        )
      ],
      [
        "TransferHookAccount",
        addDecoderSizePrefix(
          getStructDecoder([["transferring", getBooleanDecoder()]]),
          getU16Decoder()
        )
      ],
      [
        "ConfidentialTransferFee",
        addDecoderSizePrefix(
          getStructDecoder([
            [
              "authority",
              getOptionDecoder(getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            ["elgamalPubkey", getAddressDecoder()],
            ["harvestToMintEnabled", getBooleanDecoder()],
            ["withheldAmount", getEncryptedBalanceDecoder()]
          ]),
          getU16Decoder()
        )
      ],
      [
        "ConfidentialTransferFeeAmount",
        addDecoderSizePrefix(
          getStructDecoder([["withheldAmount", getEncryptedBalanceDecoder()]]),
          getU16Decoder()
        )
      ],
      [
        "MetadataPointer",
        addDecoderSizePrefix(
          getStructDecoder([
            [
              "authority",
              getOptionDecoder(getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            [
              "metadataAddress",
              getOptionDecoder(getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ]
          ]),
          getU16Decoder()
        )
      ],
      [
        "TokenMetadata",
        addDecoderSizePrefix(
          getStructDecoder([
            [
              "updateAuthority",
              getOptionDecoder(getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            ["mint", getAddressDecoder()],
            ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
            ["symbol", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
            ["uri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
            [
              "additionalMetadata",
              getMapDecoder(
                addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()),
                addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
              )
            ]
          ]),
          getU16Decoder()
        )
      ],
      [
        "GroupPointer",
        addDecoderSizePrefix(
          getStructDecoder([
            [
              "authority",
              getOptionDecoder(getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            [
              "groupAddress",
              getOptionDecoder(getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ]
          ]),
          getU16Decoder()
        )
      ],
      [
        "TokenGroup",
        addDecoderSizePrefix(
          getStructDecoder([
            [
              "updateAuthority",
              getOptionDecoder(getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            ["mint", getAddressDecoder()],
            ["size", getU64Decoder()],
            ["maxSize", getU64Decoder()]
          ]),
          getU16Decoder()
        )
      ],
      [
        "GroupMemberPointer",
        addDecoderSizePrefix(
          getStructDecoder([
            [
              "authority",
              getOptionDecoder(getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            [
              "memberAddress",
              getOptionDecoder(getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ]
          ]),
          getU16Decoder()
        )
      ],
      [
        "TokenGroupMember",
        addDecoderSizePrefix(
          getStructDecoder([
            ["mint", getAddressDecoder()],
            ["group", getAddressDecoder()],
            ["memberNumber", getU64Decoder()]
          ]),
          getU16Decoder()
        )
      ],
      ["ConfidentialMintBurn", getUnitDecoder()],
      [
        "ScaledUiAmountConfig",
        addDecoderSizePrefix(
          getStructDecoder([
            ["authority", getAddressDecoder()],
            ["multiplier", getF64Decoder()],
            ["newMultiplierEffectiveTimestamp", getU64Decoder()],
            ["newMultiplier", getF64Decoder()]
          ]),
          getU16Decoder()
        )
      ],
      [
        "PausableConfig",
        addDecoderSizePrefix(
          getStructDecoder([
            [
              "authority",
              getOptionDecoder(getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            ["paused", getBooleanDecoder()]
          ]),
          getU16Decoder()
        )
      ],
      ["PausableAccount", getUnitDecoder()]
    ],
    { size: getU16Decoder() }
  );
}
var ExtensionType = ((ExtensionType2) => {
  ExtensionType2[ExtensionType2["Uninitialized"] = 0] = "Uninitialized";
  ExtensionType2[ExtensionType2["TransferFeeConfig"] = 1] = "TransferFeeConfig";
  ExtensionType2[ExtensionType2["TransferFeeAmount"] = 2] = "TransferFeeAmount";
  ExtensionType2[ExtensionType2["MintCloseAuthority"] = 3] = "MintCloseAuthority";
  ExtensionType2[ExtensionType2["ConfidentialTransferMint"] = 4] = "ConfidentialTransferMint";
  ExtensionType2[ExtensionType2["ConfidentialTransferAccount"] = 5] = "ConfidentialTransferAccount";
  ExtensionType2[ExtensionType2["DefaultAccountState"] = 6] = "DefaultAccountState";
  ExtensionType2[ExtensionType2["ImmutableOwner"] = 7] = "ImmutableOwner";
  ExtensionType2[ExtensionType2["MemoTransfer"] = 8] = "MemoTransfer";
  ExtensionType2[ExtensionType2["NonTransferable"] = 9] = "NonTransferable";
  ExtensionType2[ExtensionType2["InterestBearingConfig"] = 10] = "InterestBearingConfig";
  ExtensionType2[ExtensionType2["CpiGuard"] = 11] = "CpiGuard";
  ExtensionType2[ExtensionType2["PermanentDelegate"] = 12] = "PermanentDelegate";
  ExtensionType2[ExtensionType2["NonTransferableAccount"] = 13] = "NonTransferableAccount";
  ExtensionType2[ExtensionType2["TransferHook"] = 14] = "TransferHook";
  ExtensionType2[ExtensionType2["TransferHookAccount"] = 15] = "TransferHookAccount";
  ExtensionType2[ExtensionType2["ConfidentialTransferFee"] = 16] = "ConfidentialTransferFee";
  ExtensionType2[ExtensionType2["ConfidentialTransferFeeAmount"] = 17] = "ConfidentialTransferFeeAmount";
  ExtensionType2[ExtensionType2["ScaledUiAmountConfig"] = 18] = "ScaledUiAmountConfig";
  ExtensionType2[ExtensionType2["PausableConfig"] = 19] = "PausableConfig";
  ExtensionType2[ExtensionType2["PausableAccount"] = 20] = "PausableAccount";
  ExtensionType2[ExtensionType2["MetadataPointer"] = 21] = "MetadataPointer";
  ExtensionType2[ExtensionType2["TokenMetadata"] = 22] = "TokenMetadata";
  ExtensionType2[ExtensionType2["GroupPointer"] = 23] = "GroupPointer";
  ExtensionType2[ExtensionType2["TokenGroup"] = 24] = "TokenGroup";
  ExtensionType2[ExtensionType2["GroupMemberPointer"] = 25] = "GroupMemberPointer";
  ExtensionType2[ExtensionType2["TokenGroupMember"] = 26] = "TokenGroupMember";
  return ExtensionType2;
})(ExtensionType || {});
function getTransferFeeDecoder() {
  return getStructDecoder([
    ["epoch", getU64Decoder()],
    ["maximumFee", getU64Decoder()],
    ["transferFeeBasisPoints", getU16Decoder()]
  ]);
}
function getMintDecoder() {
  return getStructDecoder([
    [
      "mintAuthority",
      getOptionDecoder(getAddressDecoder(), {
        prefix: getU32Decoder(),
        noneValue: "zeroes"
      })
    ],
    ["supply", getU64Decoder()],
    ["decimals", getU8Decoder()],
    ["isInitialized", getBooleanDecoder()],
    [
      "freezeAuthority",
      getOptionDecoder(getAddressDecoder(), {
        prefix: getU32Decoder(),
        noneValue: "zeroes"
      })
    ],
    [
      "extensions",
      getOptionDecoder(
        getHiddenPrefixDecoder(
          getArrayDecoder(getExtensionDecoder(), { size: "remainder" }),
          [getConstantDecoder(padLeftEncoder(getU8Encoder(), 83).encode(1))]
        ),
        { prefix: null }
      )
    ]
  ]);
}
function decodeMint(encodedAccount) {
  return decodeAccount(
    encodedAccount,
    getMintDecoder()
  );
}
async function fetchMint(rpc, address2, config) {
  const maybeAccount = await fetchMaybeMint(rpc, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeMint(rpc, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc, address2, config);
  return decodeMint(maybeAccount);
}
function getTokenDecoder() {
  return getStructDecoder([
    ["mint", getAddressDecoder()],
    ["owner", getAddressDecoder()],
    ["amount", getU64Decoder()],
    [
      "delegate",
      getOptionDecoder(getAddressDecoder(), {
        prefix: getU32Decoder(),
        noneValue: "zeroes"
      })
    ],
    ["state", getAccountStateDecoder()],
    [
      "isNative",
      getOptionDecoder(getU64Decoder(), {
        prefix: getU32Decoder(),
        noneValue: "zeroes"
      })
    ],
    ["delegatedAmount", getU64Decoder()],
    [
      "closeAuthority",
      getOptionDecoder(getAddressDecoder(), {
        prefix: getU32Decoder(),
        noneValue: "zeroes"
      })
    ],
    [
      "extensions",
      getOptionDecoder(
        getHiddenPrefixDecoder(
          getArrayDecoder(getExtensionDecoder(), { size: "remainder" }),
          [getConstantDecoder(getU8Encoder().encode(2))]
        ),
        { prefix: null }
      )
    ]
  ]);
}
function decodeToken(encodedAccount) {
  return decodeAccount(
    encodedAccount,
    getTokenDecoder()
  );
}
var AssociatedTokenInstruction = ((AssociatedTokenInstruction2) => {
  AssociatedTokenInstruction2[AssociatedTokenInstruction2["CreateAssociatedToken"] = 0] = "CreateAssociatedToken";
  AssociatedTokenInstruction2[AssociatedTokenInstruction2["CreateAssociatedTokenIdempotent"] = 1] = "CreateAssociatedTokenIdempotent";
  AssociatedTokenInstruction2[AssociatedTokenInstruction2["RecoverNestedAssociatedToken"] = 2] = "RecoverNestedAssociatedToken";
  return AssociatedTokenInstruction2;
})(AssociatedTokenInstruction || {});
var TOKEN_2022_PROGRAM_ADDRESS = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
var Token2022Account = ((Token2022Account2) => {
  Token2022Account2[Token2022Account2["Mint"] = 0] = "Mint";
  Token2022Account2[Token2022Account2["Token"] = 1] = "Token";
  Token2022Account2[Token2022Account2["Multisig"] = 2] = "Multisig";
  return Token2022Account2;
})(Token2022Account || {});
var Token2022Instruction = ((Token2022Instruction2) => {
  Token2022Instruction2[Token2022Instruction2["InitializeMint"] = 0] = "InitializeMint";
  Token2022Instruction2[Token2022Instruction2["InitializeAccount"] = 1] = "InitializeAccount";
  Token2022Instruction2[Token2022Instruction2["InitializeMultisig"] = 2] = "InitializeMultisig";
  Token2022Instruction2[Token2022Instruction2["Transfer"] = 3] = "Transfer";
  Token2022Instruction2[Token2022Instruction2["Approve"] = 4] = "Approve";
  Token2022Instruction2[Token2022Instruction2["Revoke"] = 5] = "Revoke";
  Token2022Instruction2[Token2022Instruction2["SetAuthority"] = 6] = "SetAuthority";
  Token2022Instruction2[Token2022Instruction2["MintTo"] = 7] = "MintTo";
  Token2022Instruction2[Token2022Instruction2["Burn"] = 8] = "Burn";
  Token2022Instruction2[Token2022Instruction2["CloseAccount"] = 9] = "CloseAccount";
  Token2022Instruction2[Token2022Instruction2["FreezeAccount"] = 10] = "FreezeAccount";
  Token2022Instruction2[Token2022Instruction2["ThawAccount"] = 11] = "ThawAccount";
  Token2022Instruction2[Token2022Instruction2["TransferChecked"] = 12] = "TransferChecked";
  Token2022Instruction2[Token2022Instruction2["ApproveChecked"] = 13] = "ApproveChecked";
  Token2022Instruction2[Token2022Instruction2["MintToChecked"] = 14] = "MintToChecked";
  Token2022Instruction2[Token2022Instruction2["BurnChecked"] = 15] = "BurnChecked";
  Token2022Instruction2[Token2022Instruction2["InitializeAccount2"] = 16] = "InitializeAccount2";
  Token2022Instruction2[Token2022Instruction2["SyncNative"] = 17] = "SyncNative";
  Token2022Instruction2[Token2022Instruction2["InitializeAccount3"] = 18] = "InitializeAccount3";
  Token2022Instruction2[Token2022Instruction2["InitializeMultisig2"] = 19] = "InitializeMultisig2";
  Token2022Instruction2[Token2022Instruction2["InitializeMint2"] = 20] = "InitializeMint2";
  Token2022Instruction2[Token2022Instruction2["GetAccountDataSize"] = 21] = "GetAccountDataSize";
  Token2022Instruction2[Token2022Instruction2["InitializeImmutableOwner"] = 22] = "InitializeImmutableOwner";
  Token2022Instruction2[Token2022Instruction2["AmountToUiAmount"] = 23] = "AmountToUiAmount";
  Token2022Instruction2[Token2022Instruction2["UiAmountToAmount"] = 24] = "UiAmountToAmount";
  Token2022Instruction2[Token2022Instruction2["InitializeMintCloseAuthority"] = 25] = "InitializeMintCloseAuthority";
  Token2022Instruction2[Token2022Instruction2["InitializeTransferFeeConfig"] = 26] = "InitializeTransferFeeConfig";
  Token2022Instruction2[Token2022Instruction2["TransferCheckedWithFee"] = 27] = "TransferCheckedWithFee";
  Token2022Instruction2[Token2022Instruction2["WithdrawWithheldTokensFromMint"] = 28] = "WithdrawWithheldTokensFromMint";
  Token2022Instruction2[Token2022Instruction2["WithdrawWithheldTokensFromAccounts"] = 29] = "WithdrawWithheldTokensFromAccounts";
  Token2022Instruction2[Token2022Instruction2["HarvestWithheldTokensToMint"] = 30] = "HarvestWithheldTokensToMint";
  Token2022Instruction2[Token2022Instruction2["SetTransferFee"] = 31] = "SetTransferFee";
  Token2022Instruction2[Token2022Instruction2["InitializeConfidentialTransferMint"] = 32] = "InitializeConfidentialTransferMint";
  Token2022Instruction2[Token2022Instruction2["UpdateConfidentialTransferMint"] = 33] = "UpdateConfidentialTransferMint";
  Token2022Instruction2[Token2022Instruction2["ConfigureConfidentialTransferAccount"] = 34] = "ConfigureConfidentialTransferAccount";
  Token2022Instruction2[Token2022Instruction2["ApproveConfidentialTransferAccount"] = 35] = "ApproveConfidentialTransferAccount";
  Token2022Instruction2[Token2022Instruction2["EmptyConfidentialTransferAccount"] = 36] = "EmptyConfidentialTransferAccount";
  Token2022Instruction2[Token2022Instruction2["ConfidentialDeposit"] = 37] = "ConfidentialDeposit";
  Token2022Instruction2[Token2022Instruction2["ConfidentialWithdraw"] = 38] = "ConfidentialWithdraw";
  Token2022Instruction2[Token2022Instruction2["ConfidentialTransfer"] = 39] = "ConfidentialTransfer";
  Token2022Instruction2[Token2022Instruction2["ApplyConfidentialPendingBalance"] = 40] = "ApplyConfidentialPendingBalance";
  Token2022Instruction2[Token2022Instruction2["EnableConfidentialCredits"] = 41] = "EnableConfidentialCredits";
  Token2022Instruction2[Token2022Instruction2["DisableConfidentialCredits"] = 42] = "DisableConfidentialCredits";
  Token2022Instruction2[Token2022Instruction2["EnableNonConfidentialCredits"] = 43] = "EnableNonConfidentialCredits";
  Token2022Instruction2[Token2022Instruction2["DisableNonConfidentialCredits"] = 44] = "DisableNonConfidentialCredits";
  Token2022Instruction2[Token2022Instruction2["ConfidentialTransferWithFee"] = 45] = "ConfidentialTransferWithFee";
  Token2022Instruction2[Token2022Instruction2["InitializeDefaultAccountState"] = 46] = "InitializeDefaultAccountState";
  Token2022Instruction2[Token2022Instruction2["UpdateDefaultAccountState"] = 47] = "UpdateDefaultAccountState";
  Token2022Instruction2[Token2022Instruction2["Reallocate"] = 48] = "Reallocate";
  Token2022Instruction2[Token2022Instruction2["EnableMemoTransfers"] = 49] = "EnableMemoTransfers";
  Token2022Instruction2[Token2022Instruction2["DisableMemoTransfers"] = 50] = "DisableMemoTransfers";
  Token2022Instruction2[Token2022Instruction2["CreateNativeMint"] = 51] = "CreateNativeMint";
  Token2022Instruction2[Token2022Instruction2["InitializeNonTransferableMint"] = 52] = "InitializeNonTransferableMint";
  Token2022Instruction2[Token2022Instruction2["InitializeInterestBearingMint"] = 53] = "InitializeInterestBearingMint";
  Token2022Instruction2[Token2022Instruction2["UpdateRateInterestBearingMint"] = 54] = "UpdateRateInterestBearingMint";
  Token2022Instruction2[Token2022Instruction2["EnableCpiGuard"] = 55] = "EnableCpiGuard";
  Token2022Instruction2[Token2022Instruction2["DisableCpiGuard"] = 56] = "DisableCpiGuard";
  Token2022Instruction2[Token2022Instruction2["InitializePermanentDelegate"] = 57] = "InitializePermanentDelegate";
  Token2022Instruction2[Token2022Instruction2["InitializeTransferHook"] = 58] = "InitializeTransferHook";
  Token2022Instruction2[Token2022Instruction2["UpdateTransferHook"] = 59] = "UpdateTransferHook";
  Token2022Instruction2[Token2022Instruction2["InitializeConfidentialTransferFee"] = 60] = "InitializeConfidentialTransferFee";
  Token2022Instruction2[Token2022Instruction2["WithdrawWithheldTokensFromMintForConfidentialTransferFee"] = 61] = "WithdrawWithheldTokensFromMintForConfidentialTransferFee";
  Token2022Instruction2[Token2022Instruction2["WithdrawWithheldTokensFromAccountsForConfidentialTransferFee"] = 62] = "WithdrawWithheldTokensFromAccountsForConfidentialTransferFee";
  Token2022Instruction2[Token2022Instruction2["HarvestWithheldTokensToMintForConfidentialTransferFee"] = 63] = "HarvestWithheldTokensToMintForConfidentialTransferFee";
  Token2022Instruction2[Token2022Instruction2["EnableHarvestToMint"] = 64] = "EnableHarvestToMint";
  Token2022Instruction2[Token2022Instruction2["DisableHarvestToMint"] = 65] = "DisableHarvestToMint";
  Token2022Instruction2[Token2022Instruction2["WithdrawExcessLamports"] = 66] = "WithdrawExcessLamports";
  Token2022Instruction2[Token2022Instruction2["InitializeMetadataPointer"] = 67] = "InitializeMetadataPointer";
  Token2022Instruction2[Token2022Instruction2["UpdateMetadataPointer"] = 68] = "UpdateMetadataPointer";
  Token2022Instruction2[Token2022Instruction2["InitializeGroupPointer"] = 69] = "InitializeGroupPointer";
  Token2022Instruction2[Token2022Instruction2["UpdateGroupPointer"] = 70] = "UpdateGroupPointer";
  Token2022Instruction2[Token2022Instruction2["InitializeGroupMemberPointer"] = 71] = "InitializeGroupMemberPointer";
  Token2022Instruction2[Token2022Instruction2["UpdateGroupMemberPointer"] = 72] = "UpdateGroupMemberPointer";
  Token2022Instruction2[Token2022Instruction2["InitializeScaledUiAmountMint"] = 73] = "InitializeScaledUiAmountMint";
  Token2022Instruction2[Token2022Instruction2["UpdateMultiplierScaledUiMint"] = 74] = "UpdateMultiplierScaledUiMint";
  Token2022Instruction2[Token2022Instruction2["InitializePausableConfig"] = 75] = "InitializePausableConfig";
  Token2022Instruction2[Token2022Instruction2["Pause"] = 76] = "Pause";
  Token2022Instruction2[Token2022Instruction2["Resume"] = 77] = "Resume";
  Token2022Instruction2[Token2022Instruction2["InitializeTokenMetadata"] = 78] = "InitializeTokenMetadata";
  Token2022Instruction2[Token2022Instruction2["UpdateTokenMetadataField"] = 79] = "UpdateTokenMetadataField";
  Token2022Instruction2[Token2022Instruction2["RemoveTokenMetadataKey"] = 80] = "RemoveTokenMetadataKey";
  Token2022Instruction2[Token2022Instruction2["UpdateTokenMetadataUpdateAuthority"] = 81] = "UpdateTokenMetadataUpdateAuthority";
  Token2022Instruction2[Token2022Instruction2["EmitTokenMetadata"] = 82] = "EmitTokenMetadata";
  Token2022Instruction2[Token2022Instruction2["InitializeTokenGroup"] = 83] = "InitializeTokenGroup";
  Token2022Instruction2[Token2022Instruction2["UpdateTokenGroupMaxSize"] = 84] = "UpdateTokenGroupMaxSize";
  Token2022Instruction2[Token2022Instruction2["UpdateTokenGroupUpdateAuthority"] = 85] = "UpdateTokenGroupUpdateAuthority";
  Token2022Instruction2[Token2022Instruction2["InitializeTokenGroupMember"] = 86] = "InitializeTokenGroupMember";
  return Token2022Instruction2;
})(Token2022Instruction || {});
var ASSOCIATED_TOKEN_ERROR__INVALID_OWNER = 0;
var associatedTokenErrorMessages;
if (import_process.default.env.NODE_ENV !== "production") {
  associatedTokenErrorMessages = {
    [ASSOCIATED_TOKEN_ERROR__INVALID_OWNER]: `Associated token account owner does not match address derivation`
  };
}
var TOKEN_2022_ERROR__NOT_RENT_EXEMPT = 0;
var TOKEN_2022_ERROR__INSUFFICIENT_FUNDS = 1;
var TOKEN_2022_ERROR__INVALID_MINT = 2;
var TOKEN_2022_ERROR__MINT_MISMATCH = 3;
var TOKEN_2022_ERROR__OWNER_MISMATCH = 4;
var TOKEN_2022_ERROR__FIXED_SUPPLY = 5;
var TOKEN_2022_ERROR__ALREADY_IN_USE = 6;
var TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS = 7;
var TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS = 8;
var TOKEN_2022_ERROR__UNINITIALIZED_STATE = 9;
var TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED = 10;
var TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE = 11;
var TOKEN_2022_ERROR__INVALID_INSTRUCTION = 12;
var TOKEN_2022_ERROR__INVALID_STATE = 13;
var TOKEN_2022_ERROR__OVERFLOW = 14;
var TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED = 15;
var TOKEN_2022_ERROR__MINT_CANNOT_FREEZE = 16;
var TOKEN_2022_ERROR__ACCOUNT_FROZEN = 17;
var TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH = 18;
var TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED = 19;
var token2022ErrorMessages;
if (import_process.default.env.NODE_ENV !== "production") {
  token2022ErrorMessages = {
    [TOKEN_2022_ERROR__ACCOUNT_FROZEN]: `Account is frozen`,
    [TOKEN_2022_ERROR__ALREADY_IN_USE]: `Already in use`,
    [TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED]: `Account does not support specified authority type`,
    [TOKEN_2022_ERROR__FIXED_SUPPLY]: `Fixed supply`,
    [TOKEN_2022_ERROR__INSUFFICIENT_FUNDS]: `Insufficient funds`,
    [TOKEN_2022_ERROR__INVALID_INSTRUCTION]: `Invalid instruction`,
    [TOKEN_2022_ERROR__INVALID_MINT]: `Invalid Mint`,
    [TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS]: `Invalid number of provided signers`,
    [TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS]: `Invalid number of required signers`,
    [TOKEN_2022_ERROR__INVALID_STATE]: `State is invalid for requested operation`,
    [TOKEN_2022_ERROR__MINT_CANNOT_FREEZE]: `This token mint cannot freeze accounts`,
    [TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH]: `The provided decimals value different from the Mint decimals`,
    [TOKEN_2022_ERROR__MINT_MISMATCH]: `Account not associated with this Mint`,
    [TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED]: `Instruction does not support native tokens`,
    [TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE]: `Non-native account can only be closed if its balance is zero`,
    [TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED]: `Instruction does not support non-native tokens`,
    [TOKEN_2022_ERROR__NOT_RENT_EXEMPT]: `Lamport balance below rent-exempt threshold`,
    [TOKEN_2022_ERROR__OVERFLOW]: `Operation overflowed`,
    [TOKEN_2022_ERROR__OWNER_MISMATCH]: `Owner does not match`,
    [TOKEN_2022_ERROR__UNINITIALIZED_STATE]: `State is unititialized`
  };
}
async function findAssociatedTokenPda(seeds, config = {}) {
  const {
    programAddress = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
  } = config;
  return await getProgramDerivedAddress({
    programAddress,
    seeds: [
      getAddressEncoder().encode(seeds.owner),
      getAddressEncoder().encode(seeds.tokenProgram),
      getAddressEncoder().encode(seeds.mint)
    ]
  });
}
var EMIT_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([
  250,
  166,
  180,
  250,
  13,
  12,
  184,
  70
]);
var INITIALIZE_TOKEN_GROUP_DISCRIMINATOR = new Uint8Array([
  121,
  113,
  108,
  39,
  54,
  51,
  0,
  4
]);
var INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR = new Uint8Array([
  152,
  32,
  222,
  176,
  223,
  237,
  116,
  134
]);
var INITIALIZE_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([
  210,
  225,
  30,
  162,
  88,
  184,
  77,
  141
]);
var REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR = new Uint8Array([
  234,
  18,
  32,
  56,
  89,
  141,
  37,
  181
]);
var UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR = new Uint8Array([
  108,
  37,
  171,
  143,
  248,
  30,
  18,
  110
]);
var UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR = new Uint8Array(
  [161, 105, 88, 1, 237, 221, 216, 203]
);
var UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR = new Uint8Array([
  221,
  233,
  49,
  45,
  181,
  202,
  220,
  200
]);
var UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR = new Uint8Array([215, 228, 166, 228, 84, 100, 86, 123]);
var SECONDS_PER_YEAR = 60 * 60 * 24 * 365.24;

// node_modules/gill/node_modules/@solana-program/system/dist/src/index.mjs
init_shim();
var NonceState = ((NonceState2) => {
  NonceState2[NonceState2["Uninitialized"] = 0] = "Uninitialized";
  NonceState2[NonceState2["Initialized"] = 1] = "Initialized";
  return NonceState2;
})(NonceState || {});
var NonceVersion = ((NonceVersion2) => {
  NonceVersion2[NonceVersion2["Legacy"] = 0] = "Legacy";
  NonceVersion2[NonceVersion2["Current"] = 1] = "Current";
  return NonceVersion2;
})(NonceVersion || {});
var SystemAccount = ((SystemAccount2) => {
  SystemAccount2[SystemAccount2["Nonce"] = 0] = "Nonce";
  return SystemAccount2;
})(SystemAccount || {});
var SystemInstruction = ((SystemInstruction2) => {
  SystemInstruction2[SystemInstruction2["CreateAccount"] = 0] = "CreateAccount";
  SystemInstruction2[SystemInstruction2["Assign"] = 1] = "Assign";
  SystemInstruction2[SystemInstruction2["TransferSol"] = 2] = "TransferSol";
  SystemInstruction2[SystemInstruction2["CreateAccountWithSeed"] = 3] = "CreateAccountWithSeed";
  SystemInstruction2[SystemInstruction2["AdvanceNonceAccount"] = 4] = "AdvanceNonceAccount";
  SystemInstruction2[SystemInstruction2["WithdrawNonceAccount"] = 5] = "WithdrawNonceAccount";
  SystemInstruction2[SystemInstruction2["InitializeNonceAccount"] = 6] = "InitializeNonceAccount";
  SystemInstruction2[SystemInstruction2["AuthorizeNonceAccount"] = 7] = "AuthorizeNonceAccount";
  SystemInstruction2[SystemInstruction2["Allocate"] = 8] = "Allocate";
  SystemInstruction2[SystemInstruction2["AllocateWithSeed"] = 9] = "AllocateWithSeed";
  SystemInstruction2[SystemInstruction2["AssignWithSeed"] = 10] = "AssignWithSeed";
  SystemInstruction2[SystemInstruction2["TransferSolWithSeed"] = 11] = "TransferSolWithSeed";
  SystemInstruction2[SystemInstruction2["UpgradeNonceAccount"] = 12] = "UpgradeNonceAccount";
  return SystemInstruction2;
})(SystemInstruction || {});
var SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE = 0;
var SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS = 1;
var SYSTEM_ERROR__INVALID_PROGRAM_ID = 2;
var SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH = 3;
var SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4;
var SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH = 5;
var SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES = 6;
var SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED = 7;
var SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE = 8;
var systemErrorMessages;
if (import_process.default.env.NODE_ENV !== "production") {
  systemErrorMessages = {
    [SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE]: `an account with the same address already exists`,
    [SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH]: `provided address does not match addressed derived from seed`,
    [SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH]: `cannot allocate account data of this length`,
    [SYSTEM_ERROR__INVALID_PROGRAM_ID]: `cannot assign account to this program id`,
    [SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED]: `length of requested seed is too long`,
    [SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED]: `stored nonce is still in recent_blockhashes`,
    [SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES]: `advancing stored nonce requires a populated RecentBlockhashes sysvar`,
    [SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE]: `specified nonce does not match stored nonce`,
    [SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS]: `account does not have enough SOL to perform the operation`
  };
}

// node_modules/gill/dist/chunk-ZYQZBNRK.node.mjs
var TOKEN_PROGRAM_ADDRESS = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
async function getAssociatedTokenAccountAddress(mint, owner, tokenProgram) {
  return (await findAssociatedTokenPda({
    mint: checkedAddress(mint),
    owner: checkedAddress(owner),
    tokenProgram: checkedTokenProgramAddress(tokenProgram)
  }))[0];
}
function parseTokenProgramAddressOrMoniker(tokenProgram) {
  if (!isAddress(tokenProgram)) {
    tokenProgram = tokenProgram.toLowerCase();
  }
  switch (tokenProgram) {
    case "legacy":
    case "token":
    case TOKEN_PROGRAM_ADDRESS: {
      return TOKEN_PROGRAM_ADDRESS;
    }
    case "token22":
    case "token2022":
    case "tokenextension":
    case "tokenextensions":
    case TOKEN_2022_PROGRAM_ADDRESS: {
      return TOKEN_2022_PROGRAM_ADDRESS;
    }
    default:
      throw Error("Unsupported token program. Try 'TOKEN_PROGRAM_ADDRESS' or 'TOKEN_2022_PROGRAM_ADDRESS'");
  }
}
function assertIsSupportedTokenProgram(tokenProgram) {
  if (tokenProgram !== TOKEN_PROGRAM_ADDRESS && tokenProgram !== TOKEN_2022_PROGRAM_ADDRESS) {
    throw Error("Unsupported token program. Try 'TOKEN_PROGRAM_ADDRESS' or 'TOKEN_2022_PROGRAM_ADDRESS'");
  }
}
function checkedTokenProgramAddress(tokenProgram) {
  if (!tokenProgram) return TOKEN_PROGRAM_ADDRESS;
  tokenProgram = parseTokenProgramAddressOrMoniker(tokenProgram);
  assertIsSupportedTokenProgram(tokenProgram);
  return tokenProgram;
}
var UseMethod = ((UseMethod2) => {
  UseMethod2[UseMethod2["Burn"] = 0] = "Burn";
  UseMethod2[UseMethod2["Multiple"] = 1] = "Multiple";
  UseMethod2[UseMethod2["Single"] = 2] = "Single";
  return UseMethod2;
})(UseMethod || {});
var TokenMetadataAccount = ((TokenMetadataAccount2) => {
  TokenMetadataAccount2[TokenMetadataAccount2["CollectionAuthorityRecord"] = 0] = "CollectionAuthorityRecord";
  TokenMetadataAccount2[TokenMetadataAccount2["MetadataDelegateRecord"] = 1] = "MetadataDelegateRecord";
  TokenMetadataAccount2[TokenMetadataAccount2["HolderDelegateRecord"] = 2] = "HolderDelegateRecord";
  TokenMetadataAccount2[TokenMetadataAccount2["Edition"] = 3] = "Edition";
  TokenMetadataAccount2[TokenMetadataAccount2["EditionMarker"] = 4] = "EditionMarker";
  TokenMetadataAccount2[TokenMetadataAccount2["EditionMarkerV2"] = 5] = "EditionMarkerV2";
  TokenMetadataAccount2[TokenMetadataAccount2["TokenOwnedEscrow"] = 6] = "TokenOwnedEscrow";
  TokenMetadataAccount2[TokenMetadataAccount2["MasterEditionV2"] = 7] = "MasterEditionV2";
  TokenMetadataAccount2[TokenMetadataAccount2["MasterEditionV1"] = 8] = "MasterEditionV1";
  TokenMetadataAccount2[TokenMetadataAccount2["Metadata"] = 9] = "Metadata";
  TokenMetadataAccount2[TokenMetadataAccount2["TokenRecord"] = 10] = "TokenRecord";
  TokenMetadataAccount2[TokenMetadataAccount2["ReservationListV2"] = 11] = "ReservationListV2";
  TokenMetadataAccount2[TokenMetadataAccount2["ReservationListV1"] = 12] = "ReservationListV1";
  TokenMetadataAccount2[TokenMetadataAccount2["UseAuthorityRecord"] = 13] = "UseAuthorityRecord";
  return TokenMetadataAccount2;
})(TokenMetadataAccount || {});
var TokenMetadataInstruction = ((TokenMetadataInstruction2) => {
  TokenMetadataInstruction2[TokenMetadataInstruction2["CreateMetadataAccount"] = 0] = "CreateMetadataAccount";
  TokenMetadataInstruction2[TokenMetadataInstruction2["UpdateMetadataAccount"] = 1] = "UpdateMetadataAccount";
  TokenMetadataInstruction2[TokenMetadataInstruction2["DeprecatedCreateMasterEdition"] = 2] = "DeprecatedCreateMasterEdition";
  TokenMetadataInstruction2[TokenMetadataInstruction2["DeprecatedMintNewEditionFromMasterEditionViaPrintingToken"] = 3] = "DeprecatedMintNewEditionFromMasterEditionViaPrintingToken";
  TokenMetadataInstruction2[TokenMetadataInstruction2["UpdatePrimarySaleHappenedViaToken"] = 4] = "UpdatePrimarySaleHappenedViaToken";
  TokenMetadataInstruction2[TokenMetadataInstruction2["DeprecatedSetReservationList"] = 5] = "DeprecatedSetReservationList";
  TokenMetadataInstruction2[TokenMetadataInstruction2["DeprecatedCreateReservationList"] = 6] = "DeprecatedCreateReservationList";
  TokenMetadataInstruction2[TokenMetadataInstruction2["SignMetadata"] = 7] = "SignMetadata";
  TokenMetadataInstruction2[TokenMetadataInstruction2["DeprecatedMintPrintingTokensViaToken"] = 8] = "DeprecatedMintPrintingTokensViaToken";
  TokenMetadataInstruction2[TokenMetadataInstruction2["DeprecatedMintPrintingTokens"] = 9] = "DeprecatedMintPrintingTokens";
  TokenMetadataInstruction2[TokenMetadataInstruction2["CreateMasterEdition"] = 10] = "CreateMasterEdition";
  TokenMetadataInstruction2[TokenMetadataInstruction2["MintNewEditionFromMasterEditionViaToken"] = 11] = "MintNewEditionFromMasterEditionViaToken";
  TokenMetadataInstruction2[TokenMetadataInstruction2["ConvertMasterEditionV1ToV2"] = 12] = "ConvertMasterEditionV1ToV2";
  TokenMetadataInstruction2[TokenMetadataInstruction2["MintNewEditionFromMasterEditionViaVaultProxy"] = 13] = "MintNewEditionFromMasterEditionViaVaultProxy";
  TokenMetadataInstruction2[TokenMetadataInstruction2["PuffMetadata"] = 14] = "PuffMetadata";
  TokenMetadataInstruction2[TokenMetadataInstruction2["UpdateMetadataAccountV2"] = 15] = "UpdateMetadataAccountV2";
  TokenMetadataInstruction2[TokenMetadataInstruction2["CreateMetadataAccountV2"] = 16] = "CreateMetadataAccountV2";
  TokenMetadataInstruction2[TokenMetadataInstruction2["CreateMasterEditionV3"] = 17] = "CreateMasterEditionV3";
  TokenMetadataInstruction2[TokenMetadataInstruction2["VerifyCollection"] = 18] = "VerifyCollection";
  TokenMetadataInstruction2[TokenMetadataInstruction2["Utilize"] = 19] = "Utilize";
  TokenMetadataInstruction2[TokenMetadataInstruction2["ApproveUseAuthority"] = 20] = "ApproveUseAuthority";
  TokenMetadataInstruction2[TokenMetadataInstruction2["RevokeUseAuthority"] = 21] = "RevokeUseAuthority";
  TokenMetadataInstruction2[TokenMetadataInstruction2["UnverifyCollection"] = 22] = "UnverifyCollection";
  TokenMetadataInstruction2[TokenMetadataInstruction2["ApproveCollectionAuthority"] = 23] = "ApproveCollectionAuthority";
  TokenMetadataInstruction2[TokenMetadataInstruction2["RevokeCollectionAuthority"] = 24] = "RevokeCollectionAuthority";
  TokenMetadataInstruction2[TokenMetadataInstruction2["SetAndVerifyCollection"] = 25] = "SetAndVerifyCollection";
  TokenMetadataInstruction2[TokenMetadataInstruction2["FreezeDelegatedAccount"] = 26] = "FreezeDelegatedAccount";
  TokenMetadataInstruction2[TokenMetadataInstruction2["ThawDelegatedAccount"] = 27] = "ThawDelegatedAccount";
  TokenMetadataInstruction2[TokenMetadataInstruction2["RemoveCreatorVerification"] = 28] = "RemoveCreatorVerification";
  TokenMetadataInstruction2[TokenMetadataInstruction2["BurnNft"] = 29] = "BurnNft";
  TokenMetadataInstruction2[TokenMetadataInstruction2["VerifySizedCollectionItem"] = 30] = "VerifySizedCollectionItem";
  TokenMetadataInstruction2[TokenMetadataInstruction2["UnverifySizedCollectionItem"] = 31] = "UnverifySizedCollectionItem";
  TokenMetadataInstruction2[TokenMetadataInstruction2["SetAndVerifySizedCollectionItem"] = 32] = "SetAndVerifySizedCollectionItem";
  TokenMetadataInstruction2[TokenMetadataInstruction2["CreateMetadataAccountV3"] = 33] = "CreateMetadataAccountV3";
  TokenMetadataInstruction2[TokenMetadataInstruction2["SetCollectionSize"] = 34] = "SetCollectionSize";
  TokenMetadataInstruction2[TokenMetadataInstruction2["SetTokenStandard"] = 35] = "SetTokenStandard";
  TokenMetadataInstruction2[TokenMetadataInstruction2["BubblegumSetCollectionSize"] = 36] = "BubblegumSetCollectionSize";
  TokenMetadataInstruction2[TokenMetadataInstruction2["BurnEditionNft"] = 37] = "BurnEditionNft";
  TokenMetadataInstruction2[TokenMetadataInstruction2["CreateEscrowAccount"] = 38] = "CreateEscrowAccount";
  TokenMetadataInstruction2[TokenMetadataInstruction2["CloseEscrowAccount"] = 39] = "CloseEscrowAccount";
  TokenMetadataInstruction2[TokenMetadataInstruction2["TransferOutOfEscrow"] = 40] = "TransferOutOfEscrow";
  TokenMetadataInstruction2[TokenMetadataInstruction2["Burn"] = 41] = "Burn";
  TokenMetadataInstruction2[TokenMetadataInstruction2["Create"] = 42] = "Create";
  TokenMetadataInstruction2[TokenMetadataInstruction2["Mint"] = 43] = "Mint";
  TokenMetadataInstruction2[TokenMetadataInstruction2["Delegate"] = 44] = "Delegate";
  TokenMetadataInstruction2[TokenMetadataInstruction2["Revoke"] = 45] = "Revoke";
  TokenMetadataInstruction2[TokenMetadataInstruction2["Lock"] = 46] = "Lock";
  TokenMetadataInstruction2[TokenMetadataInstruction2["Unlock"] = 47] = "Unlock";
  TokenMetadataInstruction2[TokenMetadataInstruction2["Migrate"] = 48] = "Migrate";
  TokenMetadataInstruction2[TokenMetadataInstruction2["Transfer"] = 49] = "Transfer";
  TokenMetadataInstruction2[TokenMetadataInstruction2["Update"] = 50] = "Update";
  TokenMetadataInstruction2[TokenMetadataInstruction2["Use"] = 51] = "Use";
  TokenMetadataInstruction2[TokenMetadataInstruction2["Verify"] = 52] = "Verify";
  TokenMetadataInstruction2[TokenMetadataInstruction2["Unverify"] = 53] = "Unverify";
  TokenMetadataInstruction2[TokenMetadataInstruction2["Collect"] = 54] = "Collect";
  TokenMetadataInstruction2[TokenMetadataInstruction2["Print"] = 55] = "Print";
  TokenMetadataInstruction2[TokenMetadataInstruction2["Resize"] = 56] = "Resize";
  TokenMetadataInstruction2[TokenMetadataInstruction2["CloseAccounts"] = 57] = "CloseAccounts";
  return TokenMetadataInstruction2;
})(TokenMetadataInstruction || {});

// node_modules/@gillsdk/react/dist/index.browser.mjs
var GILL_NAME = "gill";
var GILL_HOOK_CLIENT_KEY = "gill-client";
function SolanaProvider({
  client,
  children,
  queryClient = new QueryClient()
}) {
  queryClient.setQueryData([GILL_HOOK_CLIENT_KEY], client);
  return import_react.default.createElement(QueryClientProvider, { client: queryClient }, children);
}
function useSolanaClient() {
  const { data: config } = useQuery({
    queryKey: [GILL_HOOK_CLIENT_KEY],
    staleTime: Infinity,
    // fallback data should not be reached if used within `SolanaProvider`
    // since we set the initial value. but just in case => devnet
    initialData: createSolanaClient({
      urlOrMoniker: "devnet"
    })
  });
  return config;
}
function useUpdateSolanaClient() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async (newClient) => {
      queryClient.setQueryData([GILL_HOOK_CLIENT_KEY], newClient);
      return newClient;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [GILL_HOOK_CLIENT_KEY] });
      queryClient.prefetchQuery({ queryKey: [GILL_HOOK_CLIENT_KEY] });
      queryClient.refetchQueries({
        queryKey: [GILL_HOOK_CLIENT_KEY]
      });
    }
  });
}
function useAccount({ options, config, abortSignal, address: address2, decoder }) {
  const { rpc } = useSolanaClient();
  if (abortSignal) {
    config = {
      ...config || {},
      abortSignal
    };
  }
  const { data, ...rest } = useQuery({
    networkMode: "offlineFirst",
    ...options,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getAccountInfo", address2],
    queryFn: async () => {
      const account = await fetchEncodedAccount(rpc, address2, config);
      assertAccountExists(account);
      if (decoder) return decodeAccount(account, decoder);
      return account;
    },
    enabled: !!address2
  });
  return {
    ...rest,
    account: data
  };
}
function useBalance({
  options,
  config,
  abortSignal,
  address: address2
}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = useQuery({
    networkMode: "offlineFirst",
    ...options,
    enabled: !!address2,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getBalance", address2],
    queryFn: async () => {
      const { value } = await rpc.getBalance(address2, config).send({ abortSignal });
      return value;
    }
  });
  return {
    ...rest,
    balance: data
  };
}
function useLatestBlockhash({
  options,
  config,
  abortSignal
} = {}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = useQuery({
    ...options,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getLatestBlockhash"],
    queryFn: async () => {
      const { value } = await rpc.getLatestBlockhash(config).send({ abortSignal });
      return value;
    }
  });
  return {
    ...rest,
    latestBlockhash: data
  };
}
function useProgramAccounts({
  options,
  config,
  abortSignal,
  program
}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = useQuery({
    ...options,
    enabled: !!program,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getProgramAccounts", program],
    queryFn: async () => {
      const accounts = await rpc.getProgramAccounts(program, config).send({ abortSignal });
      return accounts;
    }
  });
  return {
    ...rest,
    accounts: data
  };
}
function useRecentPrioritizationFees({
  options,
  abortSignal,
  addresses
} = {}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = useQuery({
    ...options,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getRecentPrioritizationFees", addresses],
    queryFn: async () => {
      const fees = await rpc.getRecentPrioritizationFees(addresses).send({ abortSignal });
      return fees;
    }
  });
  return {
    ...rest,
    fees: data
  };
}
function useSignatureStatuses({
  options,
  config,
  abortSignal,
  signatures
}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = useQuery({
    ...options,
    enabled: signatures && signatures.length > 0,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getSignatureStatuses", signatures],
    queryFn: async () => {
      const { value } = await rpc.getSignatureStatuses(signatures, config).send({ abortSignal });
      return value;
    }
  });
  return {
    ...rest,
    statuses: data
  };
}
function useSignaturesForAddress({
  options,
  config,
  abortSignal,
  address: address2
}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = useQuery({
    networkMode: "offlineFirst",
    ...options,
    enabled: !!address2,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getSignaturesForAddress", address2],
    queryFn: async () => {
      const signatures = await rpc.getSignaturesForAddress(address2, config).send({ abortSignal });
      return signatures;
    }
  });
  return {
    ...rest,
    signatures: data
  };
}
function useSlot({
  options,
  config,
  abortSignal
} = {}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = useQuery({
    ...options,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getSlot"],
    queryFn: async () => {
      const slot = await rpc.getSlot(config).send({ abortSignal });
      return slot;
    }
  });
  return {
    ...rest,
    slot: data
  };
}
function hasDeclaredAta(input) {
  return input.ata !== void 0;
}
function useTokenAccount({
  options,
  config,
  abortSignal,
  // tokenProgram,
  ...tokenAccountOptions
}) {
  const { rpc } = useSolanaClient();
  if (abortSignal) {
    config = {
      ...config || {},
      abortSignal
    };
  }
  const { data, ...rest } = useQuery({
    networkMode: "offlineFirst",
    ...options,
    enabled: hasDeclaredAta(tokenAccountOptions) ? !!tokenAccountOptions.ata : Boolean(tokenAccountOptions.mint && tokenAccountOptions.owner),
    queryFn: async () => {
      let ata;
      if (hasDeclaredAta(tokenAccountOptions)) {
        ata = tokenAccountOptions.ata;
      } else {
        if (!tokenAccountOptions.tokenProgram) {
          const mint = await fetchMint(rpc, address(tokenAccountOptions.mint));
          tokenAccountOptions.tokenProgram = mint.programAddress;
        }
        checkedTokenProgramAddress(tokenAccountOptions.tokenProgram);
        ata = await getAssociatedTokenAccountAddress(
          tokenAccountOptions.mint,
          tokenAccountOptions.owner,
          tokenAccountOptions.tokenProgram
        );
      }
      assertIsAddress(ata);
      const account = await fetchEncodedAccount(rpc, ata, config);
      assertAccountExists(account);
      return decodeToken(account);
    },
    queryKey: [
      GILL_HOOK_CLIENT_KEY,
      "getTokenAccount",
      hasDeclaredAta(tokenAccountOptions) ? [{ ata: tokenAccountOptions.ata }] : [
        {
          mint: tokenAccountOptions.mint,
          owner: tokenAccountOptions.owner
        }
      ]
    ]
  });
  return {
    ...rest,
    account: data
  };
}
function useTokenMint({
  options,
  config,
  abortSignal,
  mint
}) {
  const { rpc } = useSolanaClient();
  if (abortSignal) {
    config = {
      ...config || {},
      abortSignal
    };
  }
  const { data, ...rest } = useQuery({
    networkMode: "offlineFirst",
    ...options,
    enabled: !!mint,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getMintAccount", mint],
    queryFn: async () => {
      const account = await fetchEncodedAccount(rpc, mint, config);
      assertAccountExists(account);
      return decodeMint(account);
    }
  });
  return {
    ...rest,
    account: data
  };
}
function useTransaction({
  options,
  config,
  abortSignal,
  signature
}) {
  const { rpc } = useSolanaClient();
  const { data, ...rest } = useQuery({
    networkMode: "offlineFirst",
    ...options,
    enabled: !!signature,
    queryKey: [GILL_HOOK_CLIENT_KEY, "getTransaction", signature],
    queryFn: async () => {
      const response = await rpc.getTransaction(signature, {
        // set default values for better DX
        maxSupportedTransactionVersion: 0,
        encoding: "json",
        ...config || {}
      }).send({ abortSignal });
      return response;
    }
  });
  return {
    ...rest,
    transaction: data
  };
}
if (BigInt.prototype.toJSON === void 0) {
  BigInt.prototype.toJSON = function() {
    return String(this);
  };
}
export {
  GILL_HOOK_CLIENT_KEY,
  GILL_NAME,
  SolanaProvider,
  useAccount,
  useBalance,
  useLatestBlockhash,
  useProgramAccounts,
  useRecentPrioritizationFees,
  useSignatureStatuses,
  useSignaturesForAddress,
  useSlot,
  useSolanaClient,
  useTokenAccount,
  useTokenMint,
  useTransaction,
  useUpdateSolanaClient
};
//# sourceMappingURL=@gillsdk_react.js.map
