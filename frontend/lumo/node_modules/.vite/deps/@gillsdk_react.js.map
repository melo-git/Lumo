{
  "version": 3,
  "sources": ["../../@tanstack/query-core/src/subscribable.ts", "../../@tanstack/query-core/src/timeoutManager.ts", "../../@tanstack/query-core/src/utils.ts", "../../@tanstack/query-core/src/focusManager.ts", "../../@tanstack/query-core/src/thenable.ts", "../../@tanstack/query-core/src/notifyManager.ts", "../../@tanstack/query-core/src/onlineManager.ts", "../../@tanstack/query-core/src/retryer.ts", "../../@tanstack/query-core/src/removable.ts", "../../@tanstack/query-core/src/query.ts", "../../@tanstack/query-core/src/queryObserver.ts", "../../@tanstack/query-core/src/infiniteQueryBehavior.ts", "../../@tanstack/query-core/src/mutation.ts", "../../@tanstack/query-core/src/mutationCache.ts", "../../@tanstack/query-core/src/mutationObserver.ts", "../../@tanstack/query-core/src/queryCache.ts", "../../@tanstack/query-core/src/queryClient.ts", "../../@tanstack/query-core/src/types.ts", "../../@tanstack/react-query/build/modern/types.js", "../../@tanstack/react-query/src/useQueries.ts", "../../@tanstack/react-query/src/QueryClientProvider.tsx", "../../@tanstack/react-query/src/IsRestoringProvider.ts", "../../@tanstack/react-query/src/QueryErrorResetBoundary.tsx", "../../@tanstack/react-query/src/errorBoundaryUtils.ts", "../../@tanstack/react-query/src/suspense.ts", "../../@tanstack/react-query/src/useBaseQuery.ts", "../../@tanstack/react-query/src/useQuery.ts", "../../@tanstack/react-query/src/HydrationBoundary.tsx", "../../@tanstack/react-query/src/useIsFetching.ts", "../../@tanstack/react-query/src/useMutationState.ts", "../../@tanstack/react-query/src/useMutation.ts", "../../gill/dist/programs/token/index.node.mjs", "../../gill/src/core/debug.ts", "../../gill/src/core/const.ts", "../../gill/src/core/utils.ts", "../../gill/src/core/rpc.ts", "../../gill/src/core/explorer.ts", "../../gill/src/core/create-transaction.ts", "../../gill/src/core/send-and-confirm-transaction-with-signers.ts", "../../gill/src/programs/compute-budget/utils.ts", "../../gill/src/core/base64-to-transaction.ts", "../../gill/src/core/prepare-transaction.ts", "../../gill/src/core/simulate-transaction.ts", "../../gill/src/core/create-solana-client.ts", "../../gill/src/core/accounts.ts", "../../gill/src/core/keypairs-extractable.ts", "../../gill/src/core/keypairs-base58.ts", "../../gill/src/core/base64-from-transaction.ts", "../../gill/src/core/get-oldest-signature.ts", "../../gill/src/core/insert-reference-key.ts", "../../gill/src/core/create-codama-config.ts", "../../gill/node_modules/@solana/sysvars/src/sysvar.ts", "../../gill/node_modules/@solana/sysvars/src/clock.ts", "../../gill/node_modules/@solana/sysvars/src/epoch-rewards.ts", "../../gill/node_modules/@solana/sysvars/src/epoch-schedule.ts", "../../gill/node_modules/@solana/sysvars/src/last-restart-slot.ts", "../../gill/node_modules/@solana/sysvars/src/recent-blockhashes.ts", "../../gill/node_modules/@solana/sysvars/src/rent.ts", "../../gill/node_modules/@solana/sysvars/src/slot-hashes.ts", "../../gill/node_modules/@solana/sysvars/src/slot-history.ts", "../../gill/node_modules/@solana/sysvars/src/stake-history.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/types/accountState.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/types/authorityType.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/types/decryptableBalance.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/types/encryptedBalance.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/types/extension.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/types/extensionType.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/types/tokenMetadataField.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/types/transferFee.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/accounts/mint.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/accounts/multisig.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/accounts/token.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/programs/associatedToken.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/programs/token2022.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/errors/associatedToken.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/errors/token2022.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/shared/index.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/amountToUiAmount.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/applyConfidentialPendingBalance.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/approve.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/approveChecked.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/approveConfidentialTransferAccount.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/burn.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/burnChecked.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/closeAccount.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/confidentialDeposit.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/confidentialTransfer.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/confidentialTransferWithFee.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/confidentialWithdraw.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/configureConfidentialTransferAccount.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/pdas/associatedToken.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/createAssociatedToken.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/createAssociatedTokenIdempotent.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/createNativeMint.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/disableConfidentialCredits.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/disableCpiGuard.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/disableHarvestToMint.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/disableMemoTransfers.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/disableNonConfidentialCredits.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/emitTokenMetadata.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/emptyConfidentialTransferAccount.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/enableConfidentialCredits.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/enableCpiGuard.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/enableHarvestToMint.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/enableMemoTransfers.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/enableNonConfidentialCredits.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/freezeAccount.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/getAccountDataSize.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/harvestWithheldTokensToMint.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/harvestWithheldTokensToMintForConfidentialTransferFee.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeAccount.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeAccount2.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeAccount3.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeConfidentialTransferFee.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeConfidentialTransferMint.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeDefaultAccountState.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeGroupMemberPointer.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeGroupPointer.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeImmutableOwner.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeInterestBearingMint.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeMetadataPointer.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeMint.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeMint2.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeMintCloseAuthority.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeMultisig.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeMultisig2.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeNonTransferableMint.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializePausableConfig.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializePermanentDelegate.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeScaledUiAmountMint.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeTokenGroup.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeTokenGroupMember.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeTokenMetadata.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeTransferFeeConfig.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/initializeTransferHook.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/mintTo.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/mintToChecked.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/pause.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/reallocate.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/recoverNestedAssociatedToken.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/removeTokenMetadataKey.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/resume.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/revoke.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/setAuthority.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/setTransferFee.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/syncNative.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/thawAccount.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/transfer.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/transferChecked.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/transferCheckedWithFee.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/uiAmountToAmount.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/updateConfidentialTransferMint.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/updateDefaultAccountState.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/updateGroupMemberPointer.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/updateGroupPointer.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/updateMetadataPointer.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/updateMultiplierScaledUiMint.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/updateRateInterestBearingMint.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/updateTokenGroupMaxSize.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/updateTokenGroupUpdateAuthority.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/updateTokenMetadataField.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/updateTokenMetadataUpdateAuthority.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/updateTransferHook.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/withdrawExcessLamports.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/withdrawWithheldTokensFromAccounts.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/withdrawWithheldTokensFromAccountsForConfidentialTransferFee.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/withdrawWithheldTokensFromMint.ts", "../../gill/node_modules/@solana-program/token-2022/src/generated/instructions/withdrawWithheldTokensFromMintForConfidentialTransferFee.ts", "../../gill/node_modules/@solana-program/token-2022/src/amountToUiAmount.ts", "../../gill/node_modules/@solana-program/token-2022/src/getInitializeInstructionsForExtensions.ts", "../../gill/node_modules/@solana-program/token-2022/src/getTokenSize.ts", "../../gill/node_modules/@solana-program/token-2022/src/getMintSize.ts", "../../gill/node_modules/@solana-program/system/src/generated/types/nonceState.ts", "../../gill/node_modules/@solana-program/system/src/generated/types/nonceVersion.ts", "../../gill/node_modules/@solana-program/system/src/generated/accounts/nonce.ts", "../../gill/node_modules/@solana-program/system/src/generated/programs/system.ts", "../../gill/node_modules/@solana-program/system/src/generated/errors/system.ts", "../../gill/node_modules/@solana-program/system/src/generated/shared/index.ts", "../../gill/node_modules/@solana-program/system/src/generated/instructions/advanceNonceAccount.ts", "../../gill/node_modules/@solana-program/system/src/generated/instructions/allocate.ts", "../../gill/node_modules/@solana-program/system/src/generated/instructions/allocateWithSeed.ts", "../../gill/node_modules/@solana-program/system/src/generated/instructions/assign.ts", "../../gill/node_modules/@solana-program/system/src/generated/instructions/assignWithSeed.ts", "../../gill/node_modules/@solana-program/system/src/generated/instructions/authorizeNonceAccount.ts", "../../gill/node_modules/@solana-program/system/src/generated/instructions/createAccount.ts", "../../gill/node_modules/@solana-program/system/src/generated/instructions/createAccountWithSeed.ts", "../../gill/node_modules/@solana-program/system/src/generated/instructions/initializeNonceAccount.ts", "../../gill/node_modules/@solana-program/system/src/generated/instructions/transferSol.ts", "../../gill/node_modules/@solana-program/system/src/generated/instructions/transferSolWithSeed.ts", "../../gill/node_modules/@solana-program/system/src/generated/instructions/upgradeNonceAccount.ts", "../../gill/node_modules/@solana-program/system/src/generated/instructions/withdrawNonceAccount.ts", "../../gill/src/programs/token/addresses.ts", "../../gill/src/programs/token-metadata/generated/types/collection.ts", "../../gill/src/programs/token-metadata/generated/types/collectionDetails.ts", "../../gill/src/programs/token-metadata/generated/types/creator.ts", "../../gill/src/programs/token-metadata/generated/types/dataV2.ts", "../../gill/src/programs/token-metadata/generated/types/uses.ts", "../../gill/src/programs/token-metadata/generated/types/useMethod.ts", "../../gill/src/programs/token-metadata/generated/programs/tokenMetadata.ts", "../../gill/src/programs/shared/index.ts", "../../gill/src/programs/token-metadata/generated/instructions/createMetadataAccountV3.ts", "../../gill/src/programs/token-metadata/addresses.ts", "../../gill/src/programs/token/instructions/create-token.ts", "../../gill/src/programs/token/instructions/mint-tokens.ts", "../../gill/src/programs/token/instructions/transfer-tokens.ts", "../../gill/src/programs/token/transactions/create-token.ts", "../../gill/src/programs/token/transactions/mint-tokens.ts", "../../gill/src/programs/token/transactions/transfer-tokens.ts", "../../gill/src/programs/token/ui-amount.ts", "../../@gillsdk/react/src/const.ts", "../../@gillsdk/react/src/providers.tsx", "../../@gillsdk/react/src/hooks/client.ts", "../../@gillsdk/react/src/hooks/account.ts", "../../@gillsdk/react/src/hooks/balance.ts", "../../@gillsdk/react/src/hooks/latest-blockhash.ts", "../../@gillsdk/react/src/hooks/program-accounts.ts", "../../@gillsdk/react/src/hooks/recent-prioritization-fees.ts", "../../@gillsdk/react/src/hooks/signature-statuses.ts", "../../@gillsdk/react/src/hooks/signatures-for-address.ts", "../../@gillsdk/react/src/hooks/slot.ts", "../../@gillsdk/react/src/hooks/token-account.ts", "../../@gillsdk/react/src/hooks/token-mint.ts", "../../@gillsdk/react/src/hooks/transaction.ts", "../../@gillsdk/react/src/index.ts"],
  "sourcesContent": ["export class Subscribable<TListener extends Function> {\n  protected listeners = new Set<TListener>()\n\n  constructor() {\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  subscribe(listener: TListener): () => void {\n    this.listeners.add(listener)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners.delete(listener)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.size > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n", "/**\n * {@link TimeoutManager} does not support passing arguments to the callback.\n *\n * `(_: void)` is the argument type inferred by TypeScript's default typings for\n * `setTimeout(cb, number)`.\n * If we don't accept a single void argument, then\n * `new Promise(resolve => timeoutManager.setTimeout(resolve, N))` is a type error.\n */\nexport type TimeoutCallback = (_: void) => void\n\n/**\n * Wrapping `setTimeout` is awkward from a typing perspective because platform\n * typings may extend the return type of `setTimeout`. For example, NodeJS\n * typings add `NodeJS.Timeout`; but a non-default `timeoutManager` may not be\n * able to return such a type.\n */\nexport type ManagedTimerId = number | { [Symbol.toPrimitive]: () => number }\n\n/**\n * Backend for timer functions.\n */\nexport type TimeoutProvider<TTimerId extends ManagedTimerId = ManagedTimerId> =\n  {\n    readonly setTimeout: (callback: TimeoutCallback, delay: number) => TTimerId\n    readonly clearTimeout: (timeoutId: TTimerId | undefined) => void\n\n    readonly setInterval: (callback: TimeoutCallback, delay: number) => TTimerId\n    readonly clearInterval: (intervalId: TTimerId | undefined) => void\n  }\n\nexport const defaultTimeoutProvider: TimeoutProvider<\n  ReturnType<typeof setTimeout>\n> = {\n  // We need the wrapper function syntax below instead of direct references to\n  // global setTimeout etc.\n  //\n  // BAD: `setTimeout: setTimeout`\n  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`\n  //\n  // If we use direct references here, then anything that wants to spy on or\n  // replace the global setTimeout (like tests) won't work since we'll already\n  // have a hard reference to the original implementation at the time when this\n  // file was imported.\n  setTimeout: (callback, delay) => setTimeout(callback, delay),\n  clearTimeout: (timeoutId) => clearTimeout(timeoutId),\n\n  setInterval: (callback, delay) => setInterval(callback, delay),\n  clearInterval: (intervalId) => clearInterval(intervalId),\n}\n\n/**\n * Allows customization of how timeouts are created.\n *\n * @tanstack/query-core makes liberal use of timeouts to implement `staleTime`\n * and `gcTime`. The default TimeoutManager provider uses the platform's global\n * `setTimeout` implementation, which is known to have scalability issues with\n * thousands of timeouts on the event loop.\n *\n * If you hit this limitation, consider providing a custom TimeoutProvider that\n * coalesces timeouts.\n */\nexport class TimeoutManager implements Omit<TimeoutProvider, 'name'> {\n  // We cannot have TimeoutManager<T> as we must instantiate it with a concrete\n  // type at app boot; and if we leave that type, then any new timer provider\n  // would need to support ReturnType<typeof setTimeout>, which is infeasible.\n  //\n  // We settle for type safety for the TimeoutProvider type, and accept that\n  // this class is unsafe internally to allow for extension.\n  #provider: TimeoutProvider<any> = defaultTimeoutProvider\n  #providerCalled = false\n\n  setTimeoutProvider<TTimerId extends ManagedTimerId>(\n    provider: TimeoutProvider<TTimerId>,\n  ): void {\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.#providerCalled && provider !== this.#provider) {\n        // After changing providers, `clearTimeout` will not work as expected for\n        // timeouts from the previous provider.\n        //\n        // Since they may allocate the same timeout ID, clearTimeout may cancel an\n        // arbitrary different timeout, or unexpected no-op.\n        //\n        // We could protect against this by mixing the timeout ID bits\n        // deterministically with some per-provider bits.\n        //\n        // We could internally queue `setTimeout` calls to `TimeoutManager` until\n        // some API call to set the initial provider.\n        console.error(\n          `[timeoutManager]: Switching provider after calls to previous provider might result in unexpected behavior.`,\n          { previous: this.#provider, provider },\n        )\n      }\n    }\n\n    this.#provider = provider\n    if (process.env.NODE_ENV !== 'production') {\n      this.#providerCalled = false\n    }\n  }\n\n  setTimeout(callback: TimeoutCallback, delay: number): ManagedTimerId {\n    if (process.env.NODE_ENV !== 'production') {\n      this.#providerCalled = true\n    }\n    return this.#provider.setTimeout(callback, delay)\n  }\n\n  clearTimeout(timeoutId: ManagedTimerId | undefined): void {\n    this.#provider.clearTimeout(timeoutId)\n  }\n\n  setInterval(callback: TimeoutCallback, delay: number): ManagedTimerId {\n    if (process.env.NODE_ENV !== 'production') {\n      this.#providerCalled = true\n    }\n    return this.#provider.setInterval(callback, delay)\n  }\n\n  clearInterval(intervalId: ManagedTimerId | undefined): void {\n    this.#provider.clearInterval(intervalId)\n  }\n}\n\nexport const timeoutManager = new TimeoutManager()\n\n/**\n * In many cases code wants to delay to the next event loop tick; this is not\n * mediated by {@link timeoutManager}.\n *\n * This function is provided to make auditing the `tanstack/query-core` for\n * incorrect use of system `setTimeout` easier.\n */\nexport function systemSetTimeoutZero(callback: TimeoutCallback): void {\n  setTimeout(callback, 0)\n}\n", "import { timeoutManager } from './timeoutManager'\nimport type {\n  DefaultError,\n  Enabled,\n  FetchStatus,\n  MutationKey,\n  MutationStatus,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n  StaleTime,\n  StaleTimeFunction,\n} from './types'\nimport type { Mutation } from './mutation'\nimport type { FetchOptions, Query } from './query'\n\n// TYPES\n\nexport interface QueryFilters<TQueryKey extends QueryKey = QueryKey> {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: TQueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TOnMutateResult = unknown,\n> {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (\n    mutation: Mutation<TData, TError, TVariables, TOnMutateResult>,\n  ) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Filter by mutation status\n   */\n  status?: MutationStatus\n}\n\nexport type Updater<TInput, TOutput> = TOutput | ((input: TInput) => TOutput)\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in globalThis\n\nexport function noop(): void\nexport function noop(): undefined\nexport function noop() {}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as (_: TInput) => TOutput)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function resolveStaleTime<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  staleTime:\n    | undefined\n    | StaleTimeFunction<TQueryFnData, TError, TData, TQueryKey>,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n): StaleTime | undefined {\n  return typeof staleTime === 'function' ? staleTime(query) : staleTime\n}\n\nexport function resolveEnabled<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  enabled: undefined | Enabled<TQueryFnData, TError, TData, TQueryKey>,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n): boolean | undefined {\n  return typeof enabled === 'function' ? enabled(query) : enabled\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, status, predicate, mutationKey } = filters\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (status && mutation.state.status !== status) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: Pick<QueryOptions<any, any, any, any>, 'queryKeyHashFn'>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query & mutation keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashKey(queryKey: QueryKey | MutationKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean\nexport function partialMatchKey(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return Object.keys(b).every((key) => partialMatchKey(a[key], b[key]))\n  }\n\n  return false\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (!array && !(isPlainObject(a) && isPlainObject(b))) return b\n\n  const aItems = array ? a : Object.keys(a)\n  const aSize = aItems.length\n  const bItems = array ? b : Object.keys(b)\n  const bSize = bItems.length\n  const copy: any = array ? new Array(bSize) : {}\n\n  let equalItems = 0\n\n  for (let i = 0; i < bSize; i++) {\n    const key: any = array ? i : bItems[i]\n    const aItem = a[key]\n    const bItem = b[key]\n\n    if (aItem === bItem) {\n      copy[key] = aItem\n      if (array ? i < aSize : hasOwn.call(a, key)) equalItems++\n      continue\n    }\n\n    if (\n      aItem === null ||\n      bItem === null ||\n      typeof aItem !== 'object' ||\n      typeof bItem !== 'object'\n    ) {\n      copy[key] = bItem\n      continue\n    }\n\n    const v = replaceEqualDeep(aItem, bItem)\n    copy[key] = v\n    if (v === aItem) equalItems++\n  }\n\n  return aSize === bSize && equalItems === aSize ? a : copy\n}\n\n/**\n * Shallow compare objects.\n */\nexport function shallowEqualObjects<T extends Record<string, any>>(\n  a: T,\n  b: T | undefined,\n): boolean {\n  if (!b || Object.keys(a).length !== Object.keys(b).length) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown): value is Array<unknown> {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Record<PropertyKey, unknown> {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has no constructor\n  const ctor = o.constructor\n  if (ctor === undefined) {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Handles Objects created by Object.create(<arbitrary prototype>)\n  if (Object.getPrototypeOf(o) !== Object.prototype) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise((resolve) => {\n    timeoutManager.setTimeout(resolve, timeout)\n  })\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data) as TData\n  } else if (options.structuralSharing !== false) {\n    if (process.env.NODE_ENV !== 'production') {\n      try {\n        return replaceEqualDeep(prevData, data)\n      } catch (error) {\n        console.error(\n          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`,\n        )\n\n        // Prevent the replaceEqualDeep from being called again down below.\n        throw error\n      }\n    }\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n\nexport function keepPreviousData<T>(\n  previousData: T | undefined,\n): T | undefined {\n  return previousData\n}\n\nexport function addToEnd<T>(items: Array<T>, item: T, max = 0): Array<T> {\n  const newItems = [...items, item]\n  return max && newItems.length > max ? newItems.slice(1) : newItems\n}\n\nexport function addToStart<T>(items: Array<T>, item: T, max = 0): Array<T> {\n  const newItems = [item, ...items]\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems\n}\n\nexport const skipToken = Symbol()\nexport type SkipToken = typeof skipToken\n\nexport function ensureQueryFn<\n  TQueryFnData = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: {\n    queryFn?: QueryFunction<TQueryFnData, TQueryKey> | SkipToken\n    queryHash?: string\n  },\n  fetchOptions?: FetchOptions<TQueryFnData>,\n): QueryFunction<TQueryFnData, TQueryKey> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (options.queryFn === skipToken) {\n      console.error(\n        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`,\n      )\n    }\n  }\n\n  // if we attempt to retry a fetch that was triggered from an initialPromise\n  // when we don't have a queryFn yet, we can't retry, so we just return the already rejected initialPromise\n  // if an observer has already mounted, we will be able to retry with that queryFn\n  if (!options.queryFn && fetchOptions?.initialPromise) {\n    return () => fetchOptions.initialPromise!\n  }\n\n  if (!options.queryFn || options.queryFn === skipToken) {\n    return () =>\n      Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`))\n  }\n\n  return options.queryFn\n}\n\nexport function shouldThrowError<T extends (...args: Array<any>) => boolean>(\n  throwOnError: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow throwOnError function to override throwing behavior on a per-error basis\n  if (typeof throwOnError === 'function') {\n    return throwOnError(...params)\n  }\n\n  return !!throwOnError\n}\n", "import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype Listener = (focused: boolean) => void\n\ntype SetupFn = (\n  setFocused: (focused?: boolean) => void,\n) => (() => void) | undefined\n\nexport class FocusManager extends Subscribable<Listener> {\n  #focused?: boolean\n  #cleanup?: () => void\n\n  #setup: SetupFn\n\n  constructor() {\n    super()\n    this.#setup = (onFocus) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus()\n        // Listen to visibilitychange\n        window.addEventListener('visibilitychange', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener)\n        }\n      }\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.()\n      this.#cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.#setup = setup\n    this.#cleanup?.()\n    this.#cleanup = setup((focused) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    const changed = this.#focused !== focused\n    if (changed) {\n      this.#focused = focused\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    const isFocused = this.isFocused()\n    this.listeners.forEach((listener) => {\n      listener(isFocused)\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.#focused === 'boolean') {\n      return this.#focused\n    }\n\n    // document global can be unavailable in react native\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return globalThis.document?.visibilityState !== 'hidden'\n  }\n}\n\nexport const focusManager = new FocusManager()\n", "/**\n * Thenable types which matches React's types for promises\n *\n * React seemingly uses `.status`, `.value` and `.reason` properties on a promises to optimistically unwrap data from promises\n *\n * @see https://github.com/facebook/react/blob/main/packages/shared/ReactTypes.js#L112-L138\n * @see https://github.com/facebook/react/blob/4f604941569d2e8947ce1460a0b2997e835f37b9/packages/react-debug-tools/src/ReactDebugHooks.js#L224-L227\n */\n\nimport { noop } from './utils'\n\ninterface Fulfilled<T> {\n  status: 'fulfilled'\n  value: T\n}\ninterface Rejected {\n  status: 'rejected'\n  reason: unknown\n}\ninterface Pending<T> {\n  status: 'pending'\n\n  /**\n   * Resolve the promise with a value.\n   * Will remove the `resolve` and `reject` properties from the promise.\n   */\n  resolve: (value: T) => void\n  /**\n   * Reject the promise with a reason.\n   * Will remove the `resolve` and `reject` properties from the promise.\n   */\n  reject: (reason: unknown) => void\n}\n\nexport type FulfilledThenable<T> = Promise<T> & Fulfilled<T>\nexport type RejectedThenable<T> = Promise<T> & Rejected\nexport type PendingThenable<T> = Promise<T> & Pending<T>\n\nexport type Thenable<T> =\n  | FulfilledThenable<T>\n  | RejectedThenable<T>\n  | PendingThenable<T>\n\nexport function pendingThenable<T>(): PendingThenable<T> {\n  let resolve: Pending<T>['resolve']\n  let reject: Pending<T>['reject']\n  // this could use `Promise.withResolvers()` in the future\n  const thenable = new Promise((_resolve, _reject) => {\n    resolve = _resolve\n    reject = _reject\n  }) as PendingThenable<T>\n\n  thenable.status = 'pending'\n  thenable.catch(() => {\n    // prevent unhandled rejection errors\n  })\n\n  function finalize(data: Fulfilled<T> | Rejected) {\n    Object.assign(thenable, data)\n\n    // clear pending props props to avoid calling them twice\n    delete (thenable as Partial<PendingThenable<T>>).resolve\n    delete (thenable as Partial<PendingThenable<T>>).reject\n  }\n\n  thenable.resolve = (value) => {\n    finalize({\n      status: 'fulfilled',\n      value,\n    })\n\n    resolve(value)\n  }\n  thenable.reject = (reason) => {\n    finalize({\n      status: 'rejected',\n      reason,\n    })\n\n    reject(reason)\n  }\n\n  return thenable\n}\n\n/**\n * This function takes a Promise-like input and detects whether the data\n * is synchronously available or not.\n *\n * It does not inspect .status, .value or .reason properties of the promise,\n * as those are not always available, and the .status of React's promises\n * should not be considered part of the public API.\n */\nexport function tryResolveSync(promise: Promise<unknown> | Thenable<unknown>) {\n  let data: unknown\n\n  promise\n    .then((result) => {\n      data = result\n      return result\n    }, noop)\n    // .catch can be unavailable on certain kinds of thenable's\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    ?.catch(noop)\n\n  if (data !== undefined) {\n    return { data }\n  }\n\n  return undefined\n}\n", "// TYPES\n\nimport { systemSetTimeoutZero } from './timeoutManager'\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\ntype BatchCallsCallback<T extends Array<unknown>> = (...args: T) => void\n\ntype ScheduleFunction = (callback: () => void) => void\n\nexport const defaultScheduler: ScheduleFunction = systemSetTimeoutZero\n\nexport function createNotifyManager() {\n  let queue: Array<NotifyCallback> = []\n  let transactions = 0\n  let notifyFn: NotifyFunction = (callback) => {\n    callback()\n  }\n  let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {\n    callback()\n  }\n  let scheduleFn = defaultScheduler\n\n  const schedule = (callback: NotifyCallback): void => {\n    if (transactions) {\n      queue.push(callback)\n    } else {\n      scheduleFn(() => {\n        notifyFn(callback)\n      })\n    }\n  }\n  const flush = (): void => {\n    const originalQueue = queue\n    queue = []\n    if (originalQueue.length) {\n      scheduleFn(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  return {\n    batch: <T>(callback: () => T): T => {\n      let result\n      transactions++\n      try {\n        result = callback()\n      } finally {\n        transactions--\n        if (!transactions) {\n          flush()\n        }\n      }\n      return result\n    },\n    /**\n     * All calls to the wrapped function will be batched.\n     */\n    batchCalls: <T extends Array<unknown>>(\n      callback: BatchCallsCallback<T>,\n    ): BatchCallsCallback<T> => {\n      return (...args) => {\n        schedule(() => {\n          callback(...args)\n        })\n      }\n    },\n    schedule,\n    /**\n     * Use this method to set a custom notify function.\n     * This can be used to for example wrap notifications with `React.act` while running tests.\n     */\n    setNotifyFunction: (fn: NotifyFunction) => {\n      notifyFn = fn\n    },\n    /**\n     * Use this method to set a custom function to batch notifications together into a single tick.\n     * By default React Query will use the batch function provided by ReactDOM or React Native.\n     */\n    setBatchNotifyFunction: (fn: BatchNotifyFunction) => {\n      batchNotifyFn = fn\n    },\n    setScheduler: (fn: ScheduleFunction) => {\n      scheduleFn = fn\n    },\n  } as const\n}\n\n// SINGLETON\nexport const notifyManager = createNotifyManager()\n", "import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype Listener = (online: boolean) => void\ntype SetupFn = (setOnline: Listener) => (() => void) | undefined\n\nexport class OnlineManager extends Subscribable<Listener> {\n  #online = true\n  #cleanup?: () => void\n\n  #setup: SetupFn\n\n  constructor() {\n    super()\n    this.#setup = (onOnline) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const onlineListener = () => onOnline(true)\n        const offlineListener = () => onOnline(false)\n        // Listen to online\n        window.addEventListener('online', onlineListener, false)\n        window.addEventListener('offline', offlineListener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', onlineListener)\n          window.removeEventListener('offline', offlineListener)\n        }\n      }\n\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.()\n      this.#cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.#setup = setup\n    this.#cleanup?.()\n    this.#cleanup = setup(this.setOnline.bind(this))\n  }\n\n  setOnline(online: boolean): void {\n    const changed = this.#online !== online\n\n    if (changed) {\n      this.#online = online\n      this.listeners.forEach((listener) => {\n        listener(online)\n      })\n    }\n  }\n\n  isOnline(): boolean {\n    return this.#online\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n", "import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { pendingThenable } from './thenable'\nimport { isServer, sleep } from './utils'\nimport type { Thenable } from './thenable'\nimport type { CancelOptions, DefaultError, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = DefaultError> {\n  fn: () => TData | Promise<TData>\n  initialPromise?: Promise<TData>\n  onCancel?: (error: TError) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n  canRun: () => boolean\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n  canStart: () => boolean\n  start: () => Promise<TData>\n  status: () => 'pending' | 'resolved' | 'rejected'\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError extends Error {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    super('CancelledError')\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\n/**\n * @deprecated Use instanceof `CancelledError` instead.\n */\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = DefaultError>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let continueFn: ((value?: unknown) => void) | undefined\n\n  const thenable = pendingThenable<TData>()\n\n  const isResolved = () =>\n    (thenable.status as Thenable<TData>['status']) !== 'pending'\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved()) {\n      const error = new CancelledError(cancelOptions) as TError\n      reject(error)\n\n      config.onCancel?.(error)\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const canContinue = () =>\n    focusManager.isFocused() &&\n    (config.networkMode === 'always' || onlineManager.isOnline()) &&\n    config.canRun()\n\n  const canStart = () => canFetch(config.networkMode) && config.canRun()\n\n  const resolve = (value: any) => {\n    if (!isResolved()) {\n      continueFn?.()\n      thenable.resolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved()) {\n      continueFn?.()\n      thenable.reject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        if (isResolved() || canContinue()) {\n          continueResolve(value)\n        }\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved()) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved()) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // we can re-use config.initialPromise on the first call of run()\n    const initialPromise =\n      failureCount === 0 ? config.initialPromise : undefined\n\n    // Execute query\n    try {\n      promiseOrValue = initialPromise ?? config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved()) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? (isServer ? 0 : 3)\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            return canContinue() ? undefined : pause()\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  return {\n    promise: thenable,\n    status: () => thenable.status,\n    cancel,\n    continue: () => {\n      continueFn?.()\n      return thenable\n    },\n    cancelRetry,\n    continueRetry,\n    canStart,\n    start: () => {\n      // Start loop\n      if (canStart()) {\n        run()\n      } else {\n        pause().then(run)\n      }\n      return thenable\n    },\n  }\n}\n", "import { timeoutManager } from './timeoutManager'\nimport { isServer, isValidTimeout } from './utils'\nimport type { ManagedTimerId } from './timeoutManager'\n\nexport abstract class Removable {\n  gcTime!: number\n  #gcTimeout?: ManagedTimerId\n\n  destroy(): void {\n    this.clearGcTimeout()\n  }\n\n  protected scheduleGc(): void {\n    this.clearGcTimeout()\n\n    if (isValidTimeout(this.gcTime)) {\n      this.#gcTimeout = timeoutManager.setTimeout(() => {\n        this.optionalRemove()\n      }, this.gcTime)\n    }\n  }\n\n  protected updateGcTime(newGcTime: number | undefined): void {\n    // Default to 5 minutes (Infinity for server-side) if no gcTime is set\n    this.gcTime = Math.max(\n      this.gcTime || 0,\n      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1000),\n    )\n  }\n\n  protected clearGcTimeout() {\n    if (this.#gcTimeout) {\n      timeoutManager.clearTimeout(this.#gcTimeout)\n      this.#gcTimeout = undefined\n    }\n  }\n\n  protected abstract optionalRemove(): void\n}\n", "import {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  skipToken,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { CancelledError, canFetch, createRetryer } from './retryer'\nimport { Removable } from './removable'\nimport type { QueryCache } from './queryCache'\nimport type { QueryClient } from './queryClient'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n  StaleTime,\n} from './types'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  client: QueryClient\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  client: QueryClient\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions<TData = unknown> {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n  initialPromise?: Promise<TData>\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #client: QueryClient\n  #retryer?: Retryer<TData>\n  observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.#client = config.client\n    this.#cache = this.#client.getQueryCache()\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = getDefaultState(this.options)\n    this.state = config.state ?? this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  get promise(): Promise<TData> | undefined {\n    return this.#retryer?.promise\n  }\n\n  setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (this.state && this.state.data === undefined) {\n      const defaultState = getDefaultState(this.options)\n      if (defaultState.data !== undefined) {\n        this.setData(defaultState.data, {\n          updatedAt: defaultState.dataUpdatedAt,\n          manual: true,\n        })\n        this.#initialState = defaultState\n      }\n    }\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#retryer?.promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive()\n    }\n    // if a query has no observers, it should still be considered disabled if it never attempted a fetch\n    return (\n      this.options.queryFn === skipToken ||\n      this.state.dataUpdateCount + this.state.errorUpdateCount === 0\n    )\n  }\n\n  isStatic(): boolean {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) =>\n          resolveStaleTime(observer.options.staleTime, this) === 'static',\n      )\n    }\n\n    return false\n  }\n\n  isStale(): boolean {\n    // check observers first, their `isStale` has the source of truth\n    // calculated with `isStaleByTime` and it takes `enabled` into account\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale,\n      )\n    }\n\n    return this.state.data === undefined || this.state.isInvalidated\n  }\n\n  isStaleByTime(staleTime: StaleTime = 0): boolean {\n    // no data is always stale\n    if (this.state.data === undefined) {\n      return true\n    }\n    // static is never stale\n    if (staleTime === 'static') {\n      return false\n    }\n    // if the query is invalidated, it is stale\n    if (this.state.isInvalidated) {\n      return true\n    }\n\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  async fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions<TQueryFnData>,\n  ): Promise<TData> {\n    if (\n      this.state.fetchStatus !== 'idle' &&\n      // If the promise in the retyer is already rejected, we have to definitely\n      // re-start the fetch; there is a chance that the query is still in a\n      // pending state when that happens\n      this.#retryer?.status() !== 'rejected'\n    ) {\n      if (this.state.data !== undefined && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetch\n        this.cancel({ silent: true })\n      } else if (this.#retryer) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#retryer.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    // Create fetch function\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions)\n\n      // Create query function context\n      const createQueryFnContext = (): QueryFunctionContext<TQueryKey> => {\n        const queryFnContext: OmitKeyof<\n          QueryFunctionContext<TQueryKey>,\n          'signal'\n        > = {\n          client: this.#client,\n          queryKey: this.queryKey,\n          meta: this.meta,\n        }\n        addSignalProperty(queryFnContext)\n        return queryFnContext as QueryFunctionContext<TQueryKey>\n      }\n\n      const queryFnContext = createQueryFnContext()\n\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this as unknown as Query,\n        )\n      }\n\n      return queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const createFetchContext = (): FetchContext<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey\n    > => {\n      const context: OmitKeyof<\n        FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n        'signal'\n      > = {\n        fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        client: this.#client,\n        state: this.state,\n        fetchFn,\n      }\n\n      addSignalProperty(context)\n      return context as FetchContext<TQueryFnData, TError, TData, TQueryKey>\n    }\n\n    const context = createFetchContext()\n\n    this.options.behavior?.onFetch(context, this as unknown as Query)\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise as\n        | Promise<TData>\n        | undefined,\n      fn: context.fetchFn as () => Promise<TData>,\n      onCancel: (error) => {\n        if (error instanceof CancelledError && error.revert) {\n          this.setState({\n            ...this.#revertState,\n            fetchStatus: 'idle' as const,\n          })\n        }\n        abortController.abort()\n      },\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true,\n    })\n\n    try {\n      const data = await this.#retryer.start()\n      // this is more of a runtime guard\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (data === undefined) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.error(\n            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n          )\n        }\n        throw new Error(`${this.queryHash} data is undefined`)\n      }\n\n      this.setData(data)\n\n      // Notify cache callback\n      this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n      this.#cache.config.onSettled?.(\n        data,\n        this.state.error as any,\n        this as Query<any, any, any, any>,\n      )\n      return data\n    } catch (error) {\n      if (error instanceof CancelledError) {\n        if (error.silent) {\n          // silent cancellation implies a new fetch is going to be started,\n          // so we piggyback onto that promise\n          return this.#retryer.promise\n        } else if (error.revert) {\n          // transform error into reverted state data\n          // if the initial fetch was cancelled, we have no data, so we have\n          // to get reject with a CancelledError\n          if (this.state.data === undefined) {\n            throw error\n          }\n          return this.state.data\n        }\n      }\n      this.#dispatch({\n        type: 'error',\n        error: error as TError,\n      })\n\n      // Notify cache callback\n      this.#cache.config.onError?.(\n        error as any,\n        this as Query<any, any, any, any>,\n      )\n      this.#cache.config.onSettled?.(\n        this.state.data,\n        error as any,\n        this as Query<any, any, any, any>,\n      )\n\n      throw error // rethrow the error for further handling\n    } finally {\n      // Schedule query gc after fetching\n      this.scheduleGc()\n    }\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null,\n          }\n        case 'success':\n          const newState = {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success' as const,\n            ...(!action.manual && {\n              fetchStatus: 'idle' as const,\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n          // If fetching ends successfully, we don't need revertState as a fallback anymore.\n          // For manual updates, capture the state to revert to it in case of a cancellation.\n          this.#revertState = action.manual ? newState : undefined\n\n          return newState\n        case 'error':\n          const error = action.error\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nexport function fetchState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  data: TData | undefined,\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? 'fetching' : 'paused',\n    ...(data === undefined &&\n      ({\n        error: null,\n        status: 'pending',\n      } as const)),\n  } as const\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = data !== undefined\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n", "import { focusManager } from './focusManager'\nimport { notifyManager } from './notifyManager'\nimport { fetchState } from './query'\nimport { Subscribable } from './subscribable'\nimport { pendingThenable } from './thenable'\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { timeoutManager } from './timeoutManager'\nimport type { ManagedTimerId } from './timeoutManager'\nimport type { FetchOptions, Query, QueryState } from './query'\nimport type { QueryClient } from './queryClient'\nimport type { PendingThenable, Thenable } from './thenable'\nimport type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\ninterface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  #client: QueryClient\n  #currentQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> = undefined!\n  #currentQueryInitialState: QueryState<TQueryData, TError> = undefined!\n  #currentResult: QueryObserverResult<TData, TError> = undefined!\n  #currentResultState?: QueryState<TQueryData, TError>\n  #currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  #currentThenable: Thenable<TData>\n  #selectError: TError | null\n  #selectFn?: (data: TQueryData) => TData\n  #selectResult?: TData\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData?: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  #staleTimeoutId?: ManagedTimerId\n  #refetchIntervalId?: ManagedTimerId\n  #currentRefetchInterval?: number | false\n  #trackedProps = new Set<keyof QueryObserverResult>()\n\n  constructor(\n    client: QueryClient,\n    public options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.#client = client\n    this.#selectError = null\n    this.#currentThenable = pendingThenable()\n\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch()\n      } else {\n        this.updateResult()\n      }\n\n      this.#updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#clearStaleTimeout()\n    this.#clearRefetchInterval()\n    this.#currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.#currentQuery\n\n    this.options = this.#client.defaultQueryOptions(options)\n\n    if (\n      this.options.enabled !== undefined &&\n      typeof this.options.enabled !== 'boolean' &&\n      typeof this.options.enabled !== 'function' &&\n      typeof resolveEnabled(this.options.enabled, this.#currentQuery) !==\n        'boolean'\n    ) {\n      throw new Error(\n        'Expected enabled to be a boolean or a callback that returns a boolean',\n      )\n    }\n\n    this.#updateQuery()\n    this.#currentQuery.setOptions(this.options)\n\n    if (\n      prevOptions._defaulted &&\n      !shallowEqualObjects(this.options, prevOptions)\n    ) {\n      this.#client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.#currentQuery,\n        observer: this,\n      })\n    }\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.#currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.#executeFetch()\n    }\n\n    // Update result\n    this.updateResult()\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        resolveStaleTime(this.options.staleTime, this.#currentQuery) !==\n          resolveStaleTime(prevOptions.staleTime, this.#currentQuery))\n    ) {\n      this.#updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.#computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        nextRefetchInterval !== this.#currentRefetchInterval)\n    ) {\n      this.#updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.#client.getQueryCache().build(this.#client, options)\n\n    const result = this.createResult(query, options)\n\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult every time\n      // an observer reads an optimistic value.\n\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.#currentResult = result\n      this.#currentResultOptions = this.options\n      this.#currentResultState = this.#currentQuery.state\n    }\n    return result\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.#currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n    onPropTracked?: (key: keyof QueryObserverResult) => void,\n  ): QueryObserverResult<TData, TError> {\n    return new Proxy(result, {\n      get: (target, key) => {\n        this.trackProp(key as keyof QueryObserverResult)\n        onPropTracked?.(key as keyof QueryObserverResult)\n        if (\n          key === 'promise' &&\n          !this.options.experimental_prefetchInRender &&\n          this.#currentThenable.status === 'pending'\n        ) {\n          this.#currentThenable.reject(\n            new Error(\n              'experimental_prefetchInRender feature flag is not enabled',\n            ),\n          )\n        }\n        return Reflect.get(target, key)\n      },\n    })\n  }\n\n  trackProp(key: keyof QueryObserverResult) {\n    this.#trackedProps.add(key)\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.#currentQuery\n  }\n\n  refetch({ ...options }: RefetchOptions = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.#client.defaultQueryOptions(options)\n\n    const query = this.#client\n      .getQueryCache()\n      .build(this.#client, defaultedOptions)\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.#currentResult\n    })\n  }\n\n  #executeFetch(\n    fetchOptions?: Omit<ObserverFetchOptions, 'initialPromise'>,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.#updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.#currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  #updateStaleTimeout(): void {\n    this.#clearStaleTimeout()\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery,\n    )\n\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return\n    }\n\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime)\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.#staleTimeoutId = timeoutManager.setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  #computeRefetchInterval() {\n    return (\n      (typeof this.options.refetchInterval === 'function'\n        ? this.options.refetchInterval(this.#currentQuery)\n        : this.options.refetchInterval) ?? false\n    )\n  }\n\n  #updateRefetchInterval(nextInterval: number | false): void {\n    this.#clearRefetchInterval()\n\n    this.#currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      resolveEnabled(this.options.enabled, this.#currentQuery) === false ||\n      !isValidTimeout(this.#currentRefetchInterval) ||\n      this.#currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.#refetchIntervalId = timeoutManager.setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.#executeFetch()\n      }\n    }, this.#currentRefetchInterval)\n  }\n\n  #updateTimers(): void {\n    this.#updateStaleTimeout()\n    this.#updateRefetchInterval(this.#computeRefetchInterval())\n  }\n\n  #clearStaleTimeout(): void {\n    if (this.#staleTimeoutId) {\n      timeoutManager.clearTimeout(this.#staleTimeoutId)\n      this.#staleTimeoutId = undefined\n    }\n  }\n\n  #clearRefetchInterval(): void {\n    if (this.#refetchIntervalId) {\n      timeoutManager.clearInterval(this.#refetchIntervalId)\n      this.#refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.#currentQuery\n    const prevOptions = this.options\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.#currentResultState\n    const prevResultOptions = this.#currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.#currentQueryInitialState\n\n    const { state } = query\n    let newState = { ...state }\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options),\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        newState.fetchStatus = 'idle'\n      }\n    }\n\n    let { error, errorUpdatedAt, status } = newState\n\n    // Per default, use query data\n    data = newState.data as unknown as TData\n    let skipSelect = false\n\n    // use placeholderData if needed\n    if (\n      options.placeholderData !== undefined &&\n      data === undefined &&\n      status === 'pending'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n        // we have to skip select when reading this memoization\n        // because prevResult.data is already \"selected\"\n        skipSelect = true\n      } else {\n        // compute placeholderData\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (\n                options.placeholderData as unknown as PlaceholderDataFunction<TQueryData>\n              )(\n                this.#lastQueryWithDefinedData?.state.data,\n                this.#lastQueryWithDefinedData as any,\n              )\n            : options.placeholderData\n      }\n\n      if (placeholderData !== undefined) {\n        status = 'success'\n        data = replaceData(\n          prevResult?.data,\n          placeholderData as unknown,\n          options,\n        ) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    // Select data if needed\n    // this also runs placeholderData through the select function\n    if (options.select && data !== undefined && !skipSelect) {\n      // Memoize select result\n      if (\n        prevResult &&\n        data === prevResultState?.data &&\n        options.select === this.#selectFn\n      ) {\n        data = this.#selectResult\n      } else {\n        try {\n          this.#selectFn = options.select\n          data = options.select(data as any)\n          data = replaceData(prevResult?.data, data, options)\n          this.#selectResult = data\n          this.#selectError = null\n        } catch (selectError) {\n          this.#selectError = selectError as TError\n        }\n      }\n    }\n\n    if (this.#selectError) {\n      error = this.#selectError as any\n      data = this.#selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = newState.fetchStatus === 'fetching'\n    const isPending = status === 'pending'\n    const isError = status === 'error'\n\n    const isLoading = isPending && isFetching\n    const hasData = data !== undefined\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        newState.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === 'paused',\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable,\n      isEnabled: resolveEnabled(options.enabled, query) !== false,\n    }\n\n    const nextResult = result as QueryObserverResult<TData, TError>\n\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = (thenable: PendingThenable<TData>) => {\n        if (nextResult.status === 'error') {\n          thenable.reject(nextResult.error)\n        } else if (nextResult.data !== undefined) {\n          thenable.resolve(nextResult.data)\n        }\n      }\n\n      /**\n       * Create a new thenable and result promise when the results have changed\n       */\n      const recreateThenable = () => {\n        const pending =\n          (this.#currentThenable =\n          nextResult.promise =\n            pendingThenable())\n\n        finalizeThenableIfPossible(pending)\n      }\n\n      const prevThenable = this.#currentThenable\n      switch (prevThenable.status) {\n        case 'pending':\n          // Finalize the previous thenable if it was pending\n          // and we are still observing the same query\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable)\n          }\n          break\n        case 'fulfilled':\n          if (\n            nextResult.status === 'error' ||\n            nextResult.data !== prevThenable.value\n          ) {\n            recreateThenable()\n          }\n          break\n        case 'rejected':\n          if (\n            nextResult.status !== 'error' ||\n            nextResult.error !== prevThenable.reason\n          ) {\n            recreateThenable()\n          }\n          break\n      }\n    }\n\n    return nextResult\n  }\n\n  updateResult(): void {\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.#currentQuery, this.options)\n\n    this.#currentResultState = this.#currentQuery.state\n    this.#currentResultOptions = this.options\n\n    if (this.#currentResultState.data !== undefined) {\n      this.#lastQueryWithDefinedData = this.#currentQuery\n    }\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.#currentResult = nextResult\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n      const notifyOnChangePropsValue =\n        typeof notifyOnChangeProps === 'function'\n          ? notifyOnChangeProps()\n          : notifyOnChangeProps\n\n      if (\n        notifyOnChangePropsValue === 'all' ||\n        (!notifyOnChangePropsValue && !this.#trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps,\n      )\n\n      if (this.options.throwOnError) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey]\n\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    this.#notify({ listeners: shouldNotifyListeners() })\n  }\n\n  #updateQuery(): void {\n    const query = this.#client.getQueryCache().build(this.#client, this.options)\n\n    if (query === this.#currentQuery) {\n      return\n    }\n\n    const prevQuery = this.#currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.#currentQuery = query\n    this.#currentQueryInitialState = query.state\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(): void {\n    this.updateResult()\n\n    if (this.hasListeners()) {\n      this.#updateTimers()\n    }\n  }\n\n  #notify(notifyOptions: { listeners: boolean }): void {\n    notifyManager.batch(() => {\n      // First, trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: 'observerResultsUpdated',\n      })\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.state.data === undefined &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.data !== undefined &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: (typeof options)['refetchOnMount'] &\n    (typeof options)['refetchOnWindowFocus'] &\n    (typeof options)['refetchOnReconnect'],\n) {\n  if (\n    resolveEnabled(options.enabled, query) !== false &&\n    resolveStaleTime(options.staleTime, query) !== 'static'\n  ) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    (query !== prevQuery ||\n      resolveEnabled(prevOptions.enabled, query) === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.isStaleByTime(resolveStaleTime(options.staleTime, query))\n  )\n}\n\n// this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\nfunction shouldAssignObserverCurrentProperties<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  optimisticResult: QueryObserverResult<TData, TError>,\n) {\n  // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true\n  }\n\n  // basically, just keep previous properties if nothing changed\n  return false\n}\n", "import { addToEnd, addToStart, ensureQueryFn } from './utils'\nimport type { QueryBehavior } from './query'\nimport type {\n  InfiniteData,\n  InfiniteQueryPageParamsOptions,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n} from './types'\n\nexport function infiniteQueryBehavior<TQueryFnData, TError, TData, TPageParam>(\n  pages?: number,\n): QueryBehavior<TQueryFnData, TError, InfiniteData<TData, TPageParam>> {\n  return {\n    onFetch: (context, query) => {\n      const options = context.options as InfiniteQueryPageParamsOptions<TData>\n      const direction = context.fetchOptions?.meta?.fetchMore?.direction\n      const oldPages = context.state.data?.pages || []\n      const oldPageParams = context.state.data?.pageParams || []\n      let result: InfiniteData<unknown> = { pages: [], pageParams: [] }\n      let currentPage = 0\n\n      const fetchFn = async () => {\n        let cancelled = false\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true\n              } else {\n                context.signal.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        const queryFn = ensureQueryFn(context.options, context.fetchOptions)\n\n        // Create function to fetch a page\n        const fetchPage = async (\n          data: InfiniteData<unknown>,\n          param: unknown,\n          previous?: boolean,\n        ): Promise<InfiniteData<unknown>> => {\n          if (cancelled) {\n            return Promise.reject()\n          }\n\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data)\n          }\n\n          const createQueryFnContext = () => {\n            const queryFnContext: OmitKeyof<\n              QueryFunctionContext<QueryKey, unknown>,\n              'signal'\n            > = {\n              client: context.client,\n              queryKey: context.queryKey,\n              pageParam: param,\n              direction: previous ? 'backward' : 'forward',\n              meta: context.options.meta,\n            }\n            addSignalProperty(queryFnContext)\n            return queryFnContext as QueryFunctionContext<QueryKey, unknown>\n          }\n\n          const queryFnContext = createQueryFnContext()\n\n          const page = await queryFn(queryFnContext)\n\n          const { maxPages } = context.options\n          const addTo = previous ? addToStart : addToEnd\n\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages),\n          }\n        }\n\n        // fetch next / previous page?\n        if (direction && oldPages.length) {\n          const previous = direction === 'backward'\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams,\n          }\n          const param = pageParamFn(options, oldData)\n\n          result = await fetchPage(oldData, param, previous)\n        } else {\n          const remainingPages = pages ?? oldPages.length\n\n          // Fetch all pages\n          do {\n            const param =\n              currentPage === 0\n                ? (oldPageParams[0] ?? options.initialPageParam)\n                : getNextPageParam(options, result)\n            if (currentPage > 0 && param == null) {\n              break\n            }\n            result = await fetchPage(result, param)\n            currentPage++\n          } while (currentPage < remainingPages)\n        }\n\n        return result\n      }\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn as any,\n            {\n              client: context.client,\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal,\n            },\n            query,\n          )\n        }\n      } else {\n        context.fetchFn = fetchFn\n      }\n    },\n  }\n}\n\nfunction getNextPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  const lastIndex = pages.length - 1\n  return pages.length > 0\n    ? options.getNextPageParam(\n        pages[lastIndex],\n        pages,\n        pageParams[lastIndex],\n        pageParams,\n      )\n    : undefined\n}\n\nfunction getPreviousPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  return pages.length > 0\n    ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams)\n    : undefined\n}\n\n/**\n * Checks if there is a next page.\n */\nexport function hasNextPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data) return false\n  return getNextPageParam(options, data) != null\n}\n\n/**\n * Checks if there is a previous page.\n */\nexport function hasPreviousPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data || !options.getPreviousPageParam) return false\n  return getPreviousPageParam(options, data) != null\n}\n", "import { notifyManager } from './notifyManager'\nimport { Removable } from './removable'\nimport { createRetryer } from './retryer'\nimport type {\n  DefaultError,\n  MutationFunctionContext,\n  MutationMeta,\n  MutationOptions,\n  MutationStatus,\n} from './types'\nimport type { MutationCache } from './mutationCache'\nimport type { MutationObserver } from './mutationObserver'\nimport type { Retryer } from './retryer'\nimport type { QueryClient } from './queryClient'\n\n// TYPES\n\ninterface MutationConfig<TData, TError, TVariables, TOnMutateResult> {\n  client: QueryClient\n  mutationId: number\n  mutationCache: MutationCache\n  options: MutationOptions<TData, TError, TVariables, TOnMutateResult>\n  state?: MutationState<TData, TError, TVariables, TOnMutateResult>\n}\n\nexport interface MutationState<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TOnMutateResult = unknown,\n> {\n  context: TOnMutateResult | undefined\n  data: TData | undefined\n  error: TError | null\n  failureCount: number\n  failureReason: TError | null\n  isPaused: boolean\n  status: MutationStatus\n  variables: TVariables | undefined\n  submittedAt: number\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError | null\n}\n\ninterface PendingAction<TVariables, TOnMutateResult> {\n  type: 'pending'\n  isPaused: boolean\n  variables?: TVariables\n  context?: TOnMutateResult\n}\n\ninterface SuccessAction<TData> {\n  type: 'success'\n  data: TData\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\nexport type Action<TData, TError, TVariables, TOnMutateResult> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | PendingAction<TVariables, TOnMutateResult>\n  | PauseAction\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Mutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TOnMutateResult = unknown,\n> extends Removable {\n  state: MutationState<TData, TError, TVariables, TOnMutateResult>\n  options!: MutationOptions<TData, TError, TVariables, TOnMutateResult>\n  readonly mutationId: number\n\n  #client: QueryClient\n  #observers: Array<\n    MutationObserver<TData, TError, TVariables, TOnMutateResult>\n  >\n  #mutationCache: MutationCache\n  #retryer?: Retryer<TData>\n\n  constructor(\n    config: MutationConfig<TData, TError, TVariables, TOnMutateResult>,\n  ) {\n    super()\n\n    this.#client = config.client\n    this.mutationId = config.mutationId\n    this.#mutationCache = config.mutationCache\n    this.#observers = []\n    this.state = config.state || getDefaultState()\n\n    this.setOptions(config.options)\n    this.scheduleGc()\n  }\n\n  setOptions(\n    options: MutationOptions<TData, TError, TVariables, TOnMutateResult>,\n  ): void {\n    this.options = options\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  get meta(): MutationMeta | undefined {\n    return this.options.meta\n  }\n\n  addObserver(observer: MutationObserver<any, any, any, any>): void {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer)\n\n      // Stop the mutation from being garbage collected\n      this.clearGcTimeout()\n\n      this.#mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer,\n      })\n    }\n  }\n\n  removeObserver(observer: MutationObserver<any, any, any, any>): void {\n    this.#observers = this.#observers.filter((x) => x !== observer)\n\n    this.scheduleGc()\n\n    this.#mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer,\n    })\n  }\n\n  protected optionalRemove() {\n    if (!this.#observers.length) {\n      if (this.state.status === 'pending') {\n        this.scheduleGc()\n      } else {\n        this.#mutationCache.remove(this)\n      }\n    }\n  }\n\n  continue(): Promise<unknown> {\n    return (\n      this.#retryer?.continue() ??\n      // continuing a mutation assumes that variables are set, mutation must have been dehydrated before\n      this.execute(this.state.variables!)\n    )\n  }\n\n  async execute(variables: TVariables): Promise<TData> {\n    const onContinue = () => {\n      this.#dispatch({ type: 'continue' })\n    }\n\n    const mutationFnContext = {\n      client: this.#client,\n      meta: this.options.meta,\n      mutationKey: this.options.mutationKey,\n    } satisfies MutationFunctionContext\n\n    this.#retryer = createRetryer({\n      fn: () => {\n        if (!this.options.mutationFn) {\n          return Promise.reject(new Error('No mutationFn found'))\n        }\n\n        return this.options.mutationFn(variables, mutationFnContext)\n      },\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue,\n      retry: this.options.retry ?? 0,\n      retryDelay: this.options.retryDelay,\n      networkMode: this.options.networkMode,\n      canRun: () => this.#mutationCache.canRun(this),\n    })\n\n    const restored = this.state.status === 'pending'\n    const isPaused = !this.#retryer.canStart()\n\n    try {\n      if (restored) {\n        // Dispatch continue action to unpause restored mutation\n        onContinue()\n      } else {\n        this.#dispatch({ type: 'pending', variables, isPaused })\n        // Notify cache callback\n        await this.#mutationCache.config.onMutate?.(\n          variables,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n          mutationFnContext,\n        )\n        const context = await this.options.onMutate?.(\n          variables,\n          mutationFnContext,\n        )\n        if (context !== this.state.context) {\n          this.#dispatch({\n            type: 'pending',\n            context,\n            variables,\n            isPaused,\n          })\n        }\n      }\n      const data = await this.#retryer.start()\n\n      // Notify cache callback\n      await this.#mutationCache.config.onSuccess?.(\n        data,\n        variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n        mutationFnContext,\n      )\n\n      await this.options.onSuccess?.(\n        data,\n        variables,\n        this.state.context,\n        mutationFnContext,\n      )\n\n      // Notify cache callback\n      await this.#mutationCache.config.onSettled?.(\n        data,\n        null,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n        mutationFnContext,\n      )\n\n      await this.options.onSettled?.(\n        data,\n        null,\n        variables,\n        this.state.context,\n        mutationFnContext,\n      )\n\n      this.#dispatch({ type: 'success', data })\n      return data\n    } catch (error) {\n      try {\n        // Notify cache callback\n        await this.#mutationCache.config.onError?.(\n          error as any,\n          variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n          mutationFnContext,\n        )\n\n        await this.options.onError?.(\n          error as TError,\n          variables,\n          this.state.context,\n          mutationFnContext,\n        )\n\n        // Notify cache callback\n        await this.#mutationCache.config.onSettled?.(\n          undefined,\n          error as any,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n          mutationFnContext,\n        )\n\n        await this.options.onSettled?.(\n          undefined,\n          error as TError,\n          variables,\n          this.state.context,\n          mutationFnContext,\n        )\n        throw error\n      } finally {\n        this.#dispatch({ type: 'error', error: error as TError })\n      }\n    } finally {\n      this.#mutationCache.runNext(this)\n    }\n  }\n\n  #dispatch(action: Action<TData, TError, TVariables, TOnMutateResult>): void {\n    const reducer = (\n      state: MutationState<TData, TError, TVariables, TOnMutateResult>,\n    ): MutationState<TData, TError, TVariables, TOnMutateResult> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            isPaused: true,\n          }\n        case 'continue':\n          return {\n            ...state,\n            isPaused: false,\n          }\n        case 'pending':\n          return {\n            ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: action.isPaused,\n            status: 'pending',\n            variables: action.variables,\n            submittedAt: Date.now(),\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false,\n          }\n        case 'error':\n          return {\n            ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error',\n          }\n      }\n    }\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.#observers.forEach((observer) => {\n        observer.onMutationUpdate(action)\n      })\n      this.#mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action,\n      })\n    })\n  }\n}\n\nexport function getDefaultState<\n  TData,\n  TError,\n  TVariables,\n  TOnMutateResult,\n>(): MutationState<TData, TError, TVariables, TOnMutateResult> {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n    submittedAt: 0,\n  }\n}\n", "import { notifyManager } from './notifyManager'\nimport { Mutation } from './mutation'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\nimport type { MutationObserver } from './mutationObserver'\nimport type {\n  DefaultError,\n  MutationFunctionContext,\n  MutationOptions,\n  NotifyEvent,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { Action, MutationState } from './mutation'\nimport type { MutationFilters } from './utils'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: DefaultError,\n    variables: unknown,\n    onMutateResult: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n    context: MutationFunctionContext,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    onMutateResult: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n    context: MutationFunctionContext,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n    context: MutationFunctionContext,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    variables: unknown,\n    onMutateResult: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n    context: MutationFunctionContext,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded extends NotifyEvent {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved extends NotifyEvent {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated extends NotifyEvent {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\nexport type MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  #mutations: Set<Mutation<any, any, any, any>>\n  #scopes: Map<string, Array<Mutation<any, any, any, any>>>\n  #mutationId: number\n\n  constructor(public config: MutationCacheConfig = {}) {\n    super()\n    this.#mutations = new Set()\n    this.#scopes = new Map()\n    this.#mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TOnMutateResult>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TOnMutateResult>,\n    state?: MutationState<TData, TError, TVariables, TOnMutateResult>,\n  ): Mutation<TData, TError, TVariables, TOnMutateResult> {\n    const mutation = new Mutation({\n      client,\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.#mutations.add(mutation)\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const scopedMutations = this.#scopes.get(scope)\n      if (scopedMutations) {\n        scopedMutations.push(mutation)\n      } else {\n        this.#scopes.set(scope, [mutation])\n      }\n    }\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    if (this.#mutations.delete(mutation)) {\n      const scope = scopeFor(mutation)\n      if (typeof scope === 'string') {\n        const scopedMutations = this.#scopes.get(scope)\n        if (scopedMutations) {\n          if (scopedMutations.length > 1) {\n            const index = scopedMutations.indexOf(mutation)\n            if (index !== -1) {\n              scopedMutations.splice(index, 1)\n            }\n          } else if (scopedMutations[0] === mutation) {\n            this.#scopes.delete(scope)\n          }\n        }\n      }\n    }\n\n    // Currently we notify the removal even if the mutation was already removed.\n    // Consider making this an error or not notifying of the removal depending on the desired semantics.\n    this.notify({ type: 'removed', mutation })\n  }\n\n  canRun(mutation: Mutation<any, any, any, any>): boolean {\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const mutationsWithSameScope = this.#scopes.get(scope)\n      const firstPendingMutation = mutationsWithSameScope?.find(\n        (m) => m.state.status === 'pending',\n      )\n      // we can run if there is no current pending mutation (start use-case)\n      // or if WE are the first pending mutation (continue use-case)\n      return !firstPendingMutation || firstPendingMutation === mutation\n    } else {\n      // For unscoped mutations there are never any pending mutations in front of the\n      // current mutation\n      return true\n    }\n  }\n\n  runNext(mutation: Mutation<any, any, any, any>): Promise<unknown> {\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const foundMutation = this.#scopes\n        .get(scope)\n        ?.find((m) => m !== mutation && m.state.isPaused)\n\n      return foundMutation?.continue() ?? Promise.resolve()\n    } else {\n      return Promise.resolve()\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.#mutations.forEach((mutation) => {\n        this.notify({ type: 'removed', mutation })\n      })\n      this.#mutations.clear()\n      this.#scopes.clear()\n    })\n  }\n\n  getAll(): Array<Mutation> {\n    return Array.from(this.#mutations)\n  }\n\n  find<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = any,\n    TOnMutateResult = unknown,\n  >(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TOnMutateResult> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((mutation) =>\n      matchMutation(defaultedFilters, mutation),\n    ) as Mutation<TData, TError, TVariables, TOnMutateResult> | undefined\n  }\n\n  findAll(filters: MutationFilters = {}): Array<Mutation> {\n    return this.getAll().filter((mutation) => matchMutation(filters, mutation))\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused)\n\n    return notifyManager.batch(() =>\n      Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(noop)),\n      ),\n    )\n  }\n}\n\nfunction scopeFor(mutation: Mutation<any, any, any, any>) {\n  return mutation.options.scope?.id\n}\n", "import { getDefaultState } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport { hashKey, shallowEqualObjects } from './utils'\nimport type { QueryClient } from './queryClient'\nimport type {\n  DefaultError,\n  MutateOptions,\n  MutationFunctionContext,\n  MutationObserverOptions,\n  MutationObserverResult,\n} from './types'\nimport type { Action, Mutation } from './mutation'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TOnMutateResult> = (\n  result: MutationObserverResult<TData, TError, TVariables, TOnMutateResult>,\n) => void\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TOnMutateResult = unknown,\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TOnMutateResult>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TOnMutateResult>\n\n  #client: QueryClient\n  #currentResult: MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TOnMutateResult\n  > = undefined!\n  #currentMutation?: Mutation<TData, TError, TVariables, TOnMutateResult>\n  #mutateOptions?: MutateOptions<TData, TError, TVariables, TOnMutateResult>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<\n      TData,\n      TError,\n      TVariables,\n      TOnMutateResult\n    >,\n  ) {\n    super()\n\n    this.#client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.#updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options: MutationObserverOptions<\n      TData,\n      TError,\n      TVariables,\n      TOnMutateResult\n    >,\n  ) {\n    const prevOptions = this.options as\n      | MutationObserverOptions<TData, TError, TVariables, TOnMutateResult>\n      | undefined\n    this.options = this.#client.defaultMutationOptions(options)\n    if (!shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.#currentMutation,\n        observer: this,\n      })\n    }\n\n    if (\n      prevOptions?.mutationKey &&\n      this.options.mutationKey &&\n      hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)\n    ) {\n      this.reset()\n    } else if (this.#currentMutation?.state.status === 'pending') {\n      this.#currentMutation.setOptions(this.options)\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.#currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(\n    action: Action<TData, TError, TVariables, TOnMutateResult>,\n  ): void {\n    this.#updateResult()\n\n    this.#notify(action)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TOnMutateResult\n  > {\n    return this.#currentResult\n  }\n\n  reset(): void {\n    // reset needs to remove the observer from the mutation because there is no way to \"get it back\"\n    // another mutate call will yield a new mutation!\n    this.#currentMutation?.removeObserver(this)\n    this.#currentMutation = undefined\n    this.#updateResult()\n    this.#notify()\n  }\n\n  mutate(\n    variables: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TOnMutateResult>,\n  ): Promise<TData> {\n    this.#mutateOptions = options\n\n    this.#currentMutation?.removeObserver(this)\n\n    this.#currentMutation = this.#client\n      .getMutationCache()\n      .build(this.#client, this.options)\n\n    this.#currentMutation.addObserver(this)\n\n    return this.#currentMutation.execute(variables)\n  }\n\n  #updateResult(): void {\n    const state =\n      this.#currentMutation?.state ??\n      getDefaultState<TData, TError, TVariables, TOnMutateResult>()\n\n    this.#currentResult = {\n      ...state,\n      isPending: state.status === 'pending',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    } as MutationObserverResult<TData, TError, TVariables, TOnMutateResult>\n  }\n\n  #notify(action?: Action<TData, TError, TVariables, TOnMutateResult>): void {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.#mutateOptions && this.hasListeners()) {\n        const variables = this.#currentResult.variables!\n        const onMutateResult = this.#currentResult.context\n\n        const context = {\n          client: this.#client,\n          meta: this.options.meta,\n          mutationKey: this.options.mutationKey,\n        } satisfies MutationFunctionContext\n\n        if (action?.type === 'success') {\n          this.#mutateOptions.onSuccess?.(\n            action.data,\n            variables,\n            onMutateResult,\n            context,\n          )\n          this.#mutateOptions.onSettled?.(\n            action.data,\n            null,\n            variables,\n            onMutateResult,\n            context,\n          )\n        } else if (action?.type === 'error') {\n          this.#mutateOptions.onError?.(\n            action.error,\n            variables,\n            onMutateResult,\n            context,\n          )\n          this.#mutateOptions.onSettled?.(\n            undefined,\n            action.error,\n            variables,\n            onMutateResult,\n            context,\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      this.listeners.forEach((listener) => {\n        listener(this.#currentResult)\n      })\n    })\n  }\n}\n", "import { hashQueryKeyByOptions, matchQuery } from './utils'\nimport { Query } from './query'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport type { QueryFilters } from './utils'\nimport type { Action, QueryState } from './query'\nimport type {\n  DefaultError,\n  NotifyEvent,\n  QueryKey,\n  QueryOptions,\n  WithRequired,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (\n    error: DefaultError,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n  onSuccess?: (data: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n}\n\ninterface NotifyEventQueryAdded extends NotifyEvent {\n  type: 'added'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryRemoved extends NotifyEvent {\n  type: 'removed'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryUpdated extends NotifyEvent {\n  type: 'updated'\n  query: Query<any, any, any, any>\n  action: Action<any, any>\n}\n\ninterface NotifyEventQueryObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverResultsUpdated extends NotifyEvent {\n  type: 'observerResultsUpdated'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\nexport type QueryCacheNotifyEvent =\n  | NotifyEventQueryAdded\n  | NotifyEventQueryRemoved\n  | NotifyEventQueryUpdated\n  | NotifyEventQueryObserverAdded\n  | NotifyEventQueryObserverRemoved\n  | NotifyEventQueryObserverResultsUpdated\n  | NotifyEventQueryObserverOptionsUpdated\n\ntype QueryCacheListener = (event: QueryCacheNotifyEvent) => void\n\nexport interface QueryStore {\n  has: (queryHash: string) => boolean\n  set: (queryHash: string, query: Query) => void\n  get: (queryHash: string) => Query | undefined\n  delete: (queryHash: string) => void\n  values: () => IterableIterator<Query>\n}\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  #queries: QueryStore\n\n  constructor(public config: QueryCacheConfig = {}) {\n    super()\n    this.#queries = new Map<string, Query>()\n  }\n\n  build<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    client: QueryClient,\n    options: WithRequired<\n      QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n    state?: QueryState<TData, TError>,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> {\n    const queryKey = options.queryKey\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData, TQueryKey>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        client,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any, any, any>): void {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query)\n\n      this.notify({\n        type: 'added',\n        query,\n      })\n    }\n  }\n\n  remove(query: Query<any, any, any, any>): void {\n    const queryInMap = this.#queries.get(query.queryHash)\n\n    if (queryInMap) {\n      query.destroy()\n\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash)\n      }\n\n      this.notify({ type: 'removed', query })\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryHash: string,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> | undefined {\n    return this.#queries.get(queryHash) as\n      | Query<TQueryFnData, TError, TData, TQueryKey>\n      | undefined\n  }\n\n  getAll(): Array<Query> {\n    return [...this.#queries.values()]\n  }\n\n  find<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData>(\n    filters: WithRequired<QueryFilters, 'queryKey'>,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((query) =>\n      matchQuery(defaultedFilters, query),\n    ) as Query<TQueryFnData, TError, TData> | undefined\n  }\n\n  findAll(filters: QueryFilters<any> = {}): Array<Query> {\n    const queries = this.getAll()\n    return Object.keys(filters).length > 0\n      ? queries.filter((query) => matchQuery(filters, query))\n      : queries\n  }\n\n  notify(event: QueryCacheNotifyEvent): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline()\n      })\n    })\n  }\n}\n", "import {\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  noop,\n  partialMatchKey,\n  resolveStaleTime,\n  skipToken,\n} from './utils'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport type {\n  CancelOptions,\n  DefaultError,\n  DefaultOptions,\n  DefaultedQueryObserverOptions,\n  EnsureInfiniteQueryDataOptions,\n  EnsureQueryDataOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InferDataFromTag,\n  InferErrorFromTag,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  NoInfer,\n  OmitKeyof,\n  QueryClientConfig,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n} from './types'\nimport type { QueryState } from './query'\nimport type { MutationFilters, QueryFilters, Updater } from './utils'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: OmitKeyof<QueryOptions<any, any, any>, 'queryKey'>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  #queryCache: QueryCache\n  #mutationCache: MutationCache\n  #defaultOptions: DefaultOptions\n  #queryDefaults: Map<string, QueryDefaults>\n  #mutationDefaults: Map<string, MutationDefaults>\n  #mountCount: number\n  #unsubscribeFocus?: () => void\n  #unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.#queryCache = config.queryCache || new QueryCache()\n    this.#mutationCache = config.mutationCache || new MutationCache()\n    this.#defaultOptions = config.defaultOptions || {}\n    this.#queryDefaults = new Map()\n    this.#mutationDefaults = new Map()\n    this.#mountCount = 0\n  }\n\n  mount(): void {\n    this.#mountCount++\n    if (this.#mountCount !== 1) return\n\n    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {\n      if (focused) {\n        await this.resumePausedMutations()\n        this.#queryCache.onFocus()\n      }\n    })\n    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {\n      if (online) {\n        await this.resumePausedMutations()\n        this.#queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.#mountCount--\n    if (this.#mountCount !== 0) return\n\n    this.#unsubscribeFocus?.()\n    this.#unsubscribeFocus = undefined\n\n    this.#unsubscribeOnline?.()\n    this.#unsubscribeOnline = undefined\n  }\n\n  isFetching<TQueryFilters extends QueryFilters<any> = QueryFilters>(\n    filters?: TQueryFilters,\n  ): number {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: 'fetching' })\n      .length\n  }\n\n  isMutating<\n    TMutationFilters extends MutationFilters<any, any> = MutationFilters,\n  >(filters?: TMutationFilters): number {\n    return this.#mutationCache.findAll({ ...filters, status: 'pending' }).length\n  }\n\n  /**\n   * Imperative (non-reactive) way to retrieve data for a QueryKey.\n   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.\n   *\n   * Hint: Do not use this function inside a component, because it won't receive updates.\n   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.\n   */\n  getQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n  >(queryKey: TTaggedQueryKey): TInferredQueryFnData | undefined {\n    const options = this.defaultQueryOptions({ queryKey })\n\n    return this.#queryCache.get<TInferredQueryFnData>(options.queryHash)?.state\n      .data\n  }\n\n  ensureQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: EnsureQueryDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n    const query = this.#queryCache.build(this, defaultedOptions)\n    const cachedData = query.state.data\n\n    if (cachedData === undefined) {\n      return this.fetchQuery(options)\n    }\n\n    if (\n      options.revalidateIfStale &&\n      query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))\n    ) {\n      void this.prefetchQuery(defaultedOptions)\n    }\n\n    return Promise.resolve(cachedData)\n  }\n\n  getQueriesData<\n    TQueryFnData = unknown,\n    TQueryFilters extends QueryFilters<any> = QueryFilters,\n  >(filters: TQueryFilters): Array<[QueryKey, TQueryFnData | undefined]> {\n    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data as TQueryFnData | undefined\n      return [queryKey, data]\n    })\n  }\n\n  setQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n  >(\n    queryKey: TTaggedQueryKey,\n    updater: Updater<\n      NoInfer<TInferredQueryFnData> | undefined,\n      NoInfer<TInferredQueryFnData> | undefined\n    >,\n    options?: SetDataOptions,\n  ): NoInfer<TInferredQueryFnData> | undefined {\n    const defaultedOptions = this.defaultQueryOptions<\n      any,\n      any,\n      unknown,\n      any,\n      QueryKey\n    >({ queryKey })\n\n    const query = this.#queryCache.get<TInferredQueryFnData>(\n      defaultedOptions.queryHash,\n    )\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (data === undefined) {\n      return undefined\n    }\n\n    return this.#queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<\n    TQueryFnData,\n    TQueryFilters extends QueryFilters<any> = QueryFilters,\n  >(\n    filters: TQueryFilters,\n    updater: Updater<\n      NoInfer<TQueryFnData> | undefined,\n      NoInfer<TQueryFnData> | undefined\n    >,\n    options?: SetDataOptions,\n  ): Array<[QueryKey, TQueryFnData | undefined]> {\n    return notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    queryKey: TTaggedQueryKey,\n  ): QueryState<TInferredQueryFnData, TInferredError> | undefined {\n    const options = this.defaultQueryOptions({ queryKey })\n    return this.#queryCache.get<TInferredQueryFnData, TInferredError>(\n      options.queryHash,\n    )?.state\n  }\n\n  removeQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n  ): void {\n    const queryCache = this.#queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n    options?: ResetOptions,\n  ): Promise<void> {\n    const queryCache = this.#queryCache\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(\n        {\n          type: 'active',\n          ...filters,\n        },\n        options,\n      )\n    })\n  }\n\n  cancelQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n    cancelOptions: CancelOptions = {},\n  ): Promise<void> {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions }\n\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(defaultedCancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: InvalidateQueryFilters<TTaggedQueryKey>,\n    options: InvalidateOptions = {},\n  ): Promise<void> {\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters?.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      return this.refetchQueries(\n        {\n          ...filters,\n          type: filters?.refetchType ?? filters?.type ?? 'active',\n        },\n        options,\n      )\n    })\n  }\n\n  refetchQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: RefetchQueryFilters<TTaggedQueryKey>,\n    options: RefetchOptions = {},\n  ): Promise<void> {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options.cancelRefetch ?? true,\n    }\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled() && !query.isStatic())\n        .map((query) => {\n          let promise = query.fetch(undefined, fetchOptions)\n          if (!fetchOptions.throwOnError) {\n            promise = promise.catch(noop)\n          }\n          return query.state.fetchStatus === 'paused'\n            ? Promise.resolve()\n            : promise\n        }),\n    )\n\n    return Promise.all(promises).then(noop)\n  }\n\n  fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: FetchQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (defaultedOptions.retry === undefined) {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.#queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(\n      resolveStaleTime(defaultedOptions.staleTime, query),\n    )\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchQuery(options).then(noop).catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n    return this.fetchQuery(options as any)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop)\n  }\n\n  ensureInfiniteQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: EnsureInfiniteQueryDataOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n\n    return this.ensureQueryData(options as any)\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    if (onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations()\n    }\n    return Promise.resolve()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.#queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.#mutationCache\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.#defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.#defaultOptions = options\n  }\n\n  setQueryDefaults<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n  >(\n    queryKey: QueryKey,\n    options: Partial<\n      OmitKeyof<\n        QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>,\n        'queryKey'\n      >\n    >,\n  ): void {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options,\n    })\n  }\n\n  getQueryDefaults(\n    queryKey: QueryKey,\n  ): OmitKeyof<QueryObserverOptions<any, any, any, any, any>, 'queryKey'> {\n    const defaults = [...this.#queryDefaults.values()]\n\n    const result: OmitKeyof<\n      QueryObserverOptions<any, any, any, any, any>,\n      'queryKey'\n    > = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        Object.assign(result, queryDefault.defaultOptions)\n      }\n    })\n    return result\n  }\n\n  setMutationDefaults<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = void,\n    TOnMutateResult = unknown,\n  >(\n    mutationKey: MutationKey,\n    options: OmitKeyof<\n      MutationObserverOptions<TData, TError, TVariables, TOnMutateResult>,\n      'mutationKey'\n    >,\n  ): void {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options,\n    })\n  }\n\n  getMutationDefaults(\n    mutationKey: MutationKey,\n  ): OmitKeyof<MutationObserverOptions<any, any, any, any>, 'mutationKey'> {\n    const defaults = [...this.#mutationDefaults.values()]\n\n    const result: OmitKeyof<\n      MutationObserverOptions<any, any, any, any>,\n      'mutationKey'\n    > = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        Object.assign(result, queryDefault.defaultOptions)\n      }\n    })\n\n    return result\n  }\n\n  defaultQueryOptions<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options:\n      | QueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey,\n          TPageParam\n        >\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (defaultedOptions.refetchOnReconnect === undefined) {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (defaultedOptions.throwOnError === undefined) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense\n    }\n\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = 'offlineFirst'\n    }\n\n    if (defaultedOptions.queryFn === skipToken) {\n      defaultedOptions.enabled = false\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...(options?.mutationKey &&\n        this.getMutationDefaults(options.mutationKey)),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.#queryCache.clear()\n    this.#mutationCache.clear()\n  }\n}\n", "/* istanbul ignore file */\n\nimport type { QueryClient } from './queryClient'\nimport type { DehydrateOptions, HydrateOptions } from './hydration'\nimport type { MutationState } from './mutation'\nimport type { FetchDirection, Query, QueryBehavior } from './query'\nimport type { RetryDelayValue, RetryValue } from './retryer'\nimport type { QueryFilters, QueryTypeFilter, SkipToken } from './utils'\nimport type { QueryCache } from './queryCache'\nimport type { MutationCache } from './mutationCache'\n\nexport type NonUndefinedGuard<T> = T extends undefined ? never : T\n\nexport type DistributiveOmit<\n  TObject,\n  TKey extends keyof TObject,\n> = TObject extends any ? Omit<TObject, TKey> : never\n\nexport type OmitKeyof<\n  TObject,\n  TKey extends TStrictly extends 'safely'\n    ?\n        | keyof TObject\n        | (string & Record<never, never>)\n        | (number & Record<never, never>)\n        | (symbol & Record<never, never>)\n    : keyof TObject,\n  TStrictly extends 'strictly' | 'safely' = 'strictly',\n> = Omit<TObject, TKey>\n\nexport type Override<TTargetA, TTargetB> = {\n  [AKey in keyof TTargetA]: AKey extends keyof TTargetB\n    ? TTargetB[AKey]\n    : TTargetA[AKey]\n}\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\n\nexport interface Register {\n  // defaultError: Error\n  // queryMeta: Record<string, unknown>\n  // mutationMeta: Record<string, unknown>\n  // queryKey: ReadonlyArray<unknown>\n  // mutationKey: ReadonlyArray<unknown>\n}\n\nexport type DefaultError = Register extends {\n  defaultError: infer TError\n}\n  ? TError\n  : Error\n\nexport type QueryKey = Register extends {\n  queryKey: infer TQueryKey\n}\n  ? TQueryKey extends ReadonlyArray<unknown>\n    ? TQueryKey\n    : TQueryKey extends Array<unknown>\n      ? TQueryKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport const dataTagSymbol = Symbol('dataTagSymbol')\nexport type dataTagSymbol = typeof dataTagSymbol\nexport const dataTagErrorSymbol = Symbol('dataTagErrorSymbol')\nexport type dataTagErrorSymbol = typeof dataTagErrorSymbol\nexport const unsetMarker = Symbol('unsetMarker')\nexport type UnsetMarker = typeof unsetMarker\nexport type AnyDataTag = {\n  [dataTagSymbol]: any\n  [dataTagErrorSymbol]: any\n}\nexport type DataTag<\n  TType,\n  TValue,\n  TError = UnsetMarker,\n> = TType extends AnyDataTag\n  ? TType\n  : TType & {\n      [dataTagSymbol]: TValue\n      [dataTagErrorSymbol]: TError\n    }\n\nexport type InferDataFromTag<TQueryFnData, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, infer TaggedValue, unknown>\n    ? TaggedValue\n    : TQueryFnData\n\nexport type InferErrorFromTag<TError, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, unknown, infer TaggedError>\n    ? TaggedError extends UnsetMarker\n      ? TError\n      : TaggedError\n    : TError\n\nexport type QueryFunction<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = (context: QueryFunctionContext<TQueryKey, TPageParam>) => T | Promise<T>\n\nexport type StaleTime = number | 'static'\n\nexport type StaleTimeFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | StaleTime\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => StaleTime)\n\nexport type Enabled<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | boolean\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => boolean)\n\nexport type QueryPersister<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? (\n      queryFn: QueryFunction<T, TQueryKey, never>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n  : (\n      queryFn: QueryFunction<T, TQueryKey, TPageParam>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n\nexport type QueryFunctionContext<\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      meta: QueryMeta | undefined\n      pageParam?: unknown\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction?: unknown\n    }\n  : {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      pageParam: TPageParam\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction: FetchDirection\n      meta: QueryMeta | undefined\n    }\n\nexport type InitialDataFunction<T> = () => T | undefined\n\ntype NonFunctionGuard<T> = T extends Function ? never : T\n\nexport type PlaceholderDataFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = (\n  previousData: TQueryData | undefined,\n  previousQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined,\n) => TQueryData | undefined\n\nexport type QueriesPlaceholderDataFunction<TQueryData> = (\n  previousData: undefined,\n  previousQuery: undefined,\n) => TQueryData | undefined\n\nexport type QueryKeyHashFunction<TQueryKey extends QueryKey> = (\n  queryKey: TQueryKey,\n) => string\n\nexport type GetPreviousPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  firstPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  firstPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport type GetNextPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  lastPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  lastPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport interface InfiniteData<TData, TPageParam = unknown> {\n  pages: Array<TData>\n  pageParams: Array<TPageParam>\n}\n\nexport type QueryMeta = Register extends {\n  queryMeta: infer TQueryMeta\n}\n  ? TQueryMeta extends Record<string, unknown>\n    ? TQueryMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type NetworkMode = 'online' | 'always' | 'offlineFirst'\n\nexport type NotifyOnChangeProps =\n  | Array<keyof InfiniteQueryObserverResult>\n  | 'all'\n  | undefined\n  | (() => Array<keyof InfiniteQueryObserverResult> | 'all' | undefined)\n\nexport interface QueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> {\n  /**\n   * If `false`, failed queries will not retry by default.\n   * If `true`, failed queries will retry infinitely., failureCount: num\n   * If set to an integer number, e.g. 3, failed queries will retry until the failed query count meets that number.\n   * If set to a function `(failureCount, error) => boolean` failed queries will retry until the function returns false.\n   */\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  /**\n   * The time in milliseconds that unused/inactive cache data remains in memory.\n   * When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration.\n   * When different garbage collection times are specified, the longest one will be used.\n   * Setting it to `Infinity` will disable garbage collection.\n   */\n  gcTime?: number\n  queryFn?: QueryFunction<TQueryFnData, TQueryKey, TPageParam> | SkipToken\n  persister?: QueryPersister<\n    NoInfer<TQueryFnData>,\n    NoInfer<TQueryKey>,\n    NoInfer<TPageParam>\n  >\n  queryHash?: string\n  queryKey?: TQueryKey\n  queryKeyHashFn?: QueryKeyHashFunction<TQueryKey>\n  initialData?: TData | InitialDataFunction<TData>\n  initialDataUpdatedAt?: number | (() => number | undefined)\n  behavior?: QueryBehavior<TQueryFnData, TError, TData, TQueryKey>\n  /**\n   * Set this to `false` to disable structural sharing between query results.\n   * Set this to a function which accepts the old and new data and returns resolved data of the same type to implement custom structural sharing logic.\n   * Defaults to `true`.\n   */\n  structuralSharing?:\n    | boolean\n    | ((oldData: unknown | undefined, newData: unknown) => unknown)\n  _defaulted?: boolean\n  /**\n   * Additional payload to be stored on each query.\n   * Use this property to pass information that can be used in other places.\n   */\n  meta?: QueryMeta\n  /**\n   * Maximum number of pages to store in the data of an infinite query.\n   */\n  maxPages?: number\n}\n\nexport interface InitialPageParam<TPageParam = unknown> {\n  initialPageParam: TPageParam\n}\n\nexport interface InfiniteQueryPageParamsOptions<\n  TQueryFnData = unknown,\n  TPageParam = unknown,\n> extends InitialPageParam<TPageParam> {\n  /**\n   * This function can be set to automatically get the previous cursor for infinite queries.\n   * The result will also be used to determine the value of `hasPreviousPage`.\n   */\n  getPreviousPageParam?: GetPreviousPageParamFunction<TPageParam, TQueryFnData>\n  /**\n   * This function can be set to automatically get the next cursor for infinite queries.\n   * The result will also be used to determine the value of `hasNextPage`.\n   */\n  getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n}\n\nexport type ThrowOnError<\n  TQueryFnData,\n  TError,\n  TQueryData,\n  TQueryKey extends QueryKey,\n> =\n  | boolean\n  | ((\n      error: TError,\n      query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    ) => boolean)\n\nexport interface QueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  /**\n   * Set this to `false` or a function that returns `false` to disable automatic refetching when the query mounts or changes query keys.\n   * To refetch the query, use the `refetch` method returned from the `useQuery` instance.\n   * Accepts a boolean or function that returns a boolean.\n   * Defaults to `true`.\n   */\n  enabled?: Enabled<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If set to `Infinity`, the data will never be considered stale.\n   * If set to a function, the function will be executed with the query to compute a `staleTime`.\n   * Defaults to `0`.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * If set to a number, the query will continuously refetch at this frequency in milliseconds.\n   * If set to a function, the function will be executed with the latest data and query to compute a frequency\n   * Defaults to `false`.\n   */\n  refetchInterval?:\n    | number\n    | false\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => number | false | undefined)\n  /**\n   * If set to `true`, the query will continue to refetch while their tab/window is in the background.\n   * Defaults to `false`.\n   */\n  refetchIntervalInBackground?: boolean\n  /**\n   * If set to `true`, the query will refetch on window focus if the data is stale.\n   * If set to `false`, the query will not refetch on window focus.\n   * If set to `'always'`, the query will always refetch on window focus.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to `true`.\n   */\n  refetchOnWindowFocus?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on reconnect if the data is stale.\n   * If set to `false`, the query will not refetch on reconnect.\n   * If set to `'always'`, the query will always refetch on reconnect.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to the value of `networkOnline` (`true`)\n   */\n  refetchOnReconnect?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on mount if the data is stale.\n   * If set to `false`, will disable additional instances of a query to trigger background refetch.\n   * If set to `'always'`, the query will always refetch on mount.\n   * If set to a function, the function will be executed with the latest data and query to compute the value\n   * Defaults to `true`.\n   */\n  refetchOnMount?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `false`, the query will not be retried on mount if it contains an error.\n   * Defaults to `true`.\n   */\n  retryOnMount?: boolean\n  /**\n   * If set, the component will only re-render if any of the listed properties change.\n   * When set to `['data', 'error']`, the component will only re-render when the `data` or `error` properties change.\n   * When set to `'all'`, the component will re-render whenever a query is updated.\n   * When set to a function, the function will be executed to compute the list of properties.\n   * By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.\n   */\n  notifyOnChangeProps?: NotifyOnChangeProps\n  /**\n   * Whether errors should be thrown instead of setting the `error` property.\n   * If set to `true` or `suspense` is `true`, all errors will be thrown to the error boundary.\n   * If set to `false` and `suspense` is `false`, errors are returned as state.\n   * If set to a function, it will be passed the error and the query, and it should return a boolean indicating whether to show the error in an error boundary (`true`) or return the error as state (`false`).\n   * Defaults to `false`.\n   */\n  throwOnError?: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * This option can be used to transform or select a part of the data returned by the query function.\n   */\n  select?: (data: TQueryData) => TData\n  /**\n   * If set to `true`, the query will suspend when `status === 'pending'`\n   * and throw errors when `status === 'error'`.\n   * Defaults to `false`.\n   */\n  suspense?: boolean\n  /**\n   * If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `loading` data and no initialData has been provided.\n   */\n  placeholderData?:\n    | NonFunctionGuard<TQueryData>\n    | PlaceholderDataFunction<\n        NonFunctionGuard<TQueryData>,\n        TError,\n        NonFunctionGuard<TQueryData>,\n        TQueryKey\n      >\n\n  _optimisticResults?: 'optimistic' | 'isRestoring'\n\n  /**\n   * Enable prefetching during rendering\n   */\n  experimental_prefetchInRender?: boolean\n}\n\nexport type WithRequired<TTarget, TKey extends keyof TTarget> = TTarget & {\n  [_ in TKey]: {}\n}\n\nexport type DefaultedQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = WithRequired<\n  QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface InfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      InfiniteData<TQueryFnData, TPageParam>,\n      TQueryKey,\n      TPageParam\n    >,\n    InfiniteQueryPageParamsOptions<TQueryFnData, TPageParam> {}\n\nexport type DefaultedInfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = WithRequired<\n  InfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface FetchQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  initialPageParam?: never\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If the data is fresh it will be returned from the cache.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TData, TQueryKey>\n}\n\nexport interface EnsureQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  > {\n  revalidateIfStale?: boolean\n}\n\nexport type EnsureInfiniteQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = FetchInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  revalidateIfStale?: boolean\n}\n\ntype FetchInfiniteQueryPages<TQueryFnData = unknown, TPageParam = unknown> =\n  | { pages?: never }\n  | {\n      pages: number\n      getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n    }\n\nexport type FetchInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = Omit<\n  FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    InfiniteData<TData, TPageParam>,\n    TQueryKey,\n    TPageParam\n  >,\n  'initialPageParam'\n> &\n  InitialPageParam<TPageParam> &\n  FetchInfiniteQueryPages<TQueryFnData, TPageParam>\n\nexport interface ResultOptions {\n  throwOnError?: boolean\n}\n\nexport interface RefetchOptions extends ResultOptions {\n  /**\n   * If set to `true`, a currently running request will be cancelled before a new request is made\n   *\n   * If set to `false`, no refetch will be made if there is already a request running.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport interface InvalidateQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {\n  refetchType?: QueryTypeFilter | 'none'\n}\n\nexport interface RefetchQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {}\n\nexport interface InvalidateOptions extends RefetchOptions {}\nexport interface ResetOptions extends RefetchOptions {}\n\nexport interface FetchNextPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchNextPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchNextPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport interface FetchPreviousPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchPreviousPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchPreviousPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport type QueryStatus = 'pending' | 'error' | 'success'\nexport type FetchStatus = 'fetching' | 'paused' | 'idle'\n\nexport interface QueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> {\n  /**\n   * The last successfully resolved data for the query.\n   */\n  data: TData | undefined\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"success\"`.\n   */\n  dataUpdatedAt: number\n  /**\n   * The error object for the query, if an error was thrown.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"error\"`.\n   */\n  errorUpdatedAt: number\n  /**\n   * The failure count for the query.\n   * - Incremented every time the query fails.\n   * - Reset to `0` when the query succeeds.\n   */\n  failureCount: number\n  /**\n   * The failure reason for the query retry.\n   * - Reset to `null` when the query succeeds.\n   */\n  failureReason: TError | null\n  /**\n   * The sum of all errors.\n   */\n  errorUpdateCount: number\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * Will be `true` if the query has been fetched.\n   */\n  isFetched: boolean\n  /**\n   * Will be `true` if the query has been fetched after the component mounted.\n   * - This property can be used to not show any previously cached data.\n   */\n  isFetchedAfterMount: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - `true` whenever the `queryFn` is executing, which includes initial `pending` as well as background refetch.\n   */\n  isFetching: boolean\n  /**\n   * Is `true` whenever the first fetch for a query is in-flight.\n   * - Is the same as `isFetching && isPending`.\n   */\n  isLoading: boolean\n  /**\n   * Will be `pending` if there's no cached data and no query attempt was finished yet.\n   */\n  isPending: boolean\n  /**\n   * Will be `true` if the query failed while fetching for the first time.\n   */\n  isLoadingError: boolean\n  /**\n   * @deprecated `isInitialLoading` is being deprecated in favor of `isLoading`\n   * and will be removed in the next major version.\n   */\n  isInitialLoading: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - The query wanted to fetch, but has been `paused`.\n   */\n  isPaused: boolean\n  /**\n   * Will be `true` if the data shown is the placeholder data.\n   */\n  isPlaceholderData: boolean\n  /**\n   * Will be `true` if the query failed while refetching.\n   */\n  isRefetchError: boolean\n  /**\n   * Is `true` whenever a background refetch is in-flight, which _does not_ include initial `pending`.\n   * - Is the same as `isFetching && !isPending`.\n   */\n  isRefetching: boolean\n  /**\n   * Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.\n   */\n  isStale: boolean\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query has received a response with no errors and is ready to display its data.\n   */\n  isSuccess: boolean\n  /**\n   * `true` if this observer is enabled, `false` otherwise.\n   */\n  isEnabled: boolean\n  /**\n   * A function to manually refetch the query.\n   */\n  refetch: (\n    options?: RefetchOptions,\n  ) => Promise<QueryObserverResult<TData, TError>>\n  /**\n   * The status of the query.\n   * - Will be:\n   *   - `pending` if there's no cached data and no query attempt was finished yet.\n   *   - `error` if the query attempt resulted in an error.\n   *   - `success` if the query has received a response with no errors and is ready to display its data.\n   */\n  status: QueryStatus\n  /**\n   * The fetch status of the query.\n   * - `fetching`: Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetch.\n   * - `paused`: The query wanted to fetch, but has been `paused`.\n   * - `idle`: The query is not fetching.\n   * - See [Network Mode](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode) for more information.\n   */\n  fetchStatus: FetchStatus\n  /**\n   * A stable promise that will be resolved with the data of the query.\n   * Requires the `experimental_prefetchInRender` feature flag to be enabled.\n   * @example\n   *\n   * ### Enabling the feature flag\n   * ```ts\n   * const client = new QueryClient({\n   *   defaultOptions: {\n   *     queries: {\n   *       experimental_prefetchInRender: true,\n   *     },\n   *   },\n   * })\n   * ```\n   *\n   * ### Usage\n   * ```tsx\n   * import { useQuery } from '@tanstack/react-query'\n   * import React from 'react'\n   * import { fetchTodos, type Todo } from './api'\n   *\n   * function TodoList({ query }: { query: UseQueryResult<Todo[], Error> }) {\n   *   const data = React.use(query.promise)\n   *\n   *   return (\n   *     <ul>\n   *       {data.map(todo => (\n   *         <li key={todo.id}>{todo.title}</li>\n   *       ))}\n   *     </ul>\n   *   )\n   * }\n   *\n   * export function App() {\n   *   const query = useQuery({ queryKey: ['todos'], queryFn: fetchTodos })\n   *\n   *   return (\n   *     <>\n   *       <h1>Todos</h1>\n   *       <React.Suspense fallback={<div>Loading...</div>}>\n   *         <TodoList query={query} />\n   *       </React.Suspense>\n   *     </>\n   *   )\n   * }\n   * ```\n   */\n  promise: Promise<TData>\n}\n\nexport interface QueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface QueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  status: 'success'\n}\n\nexport type DefinedQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | QueryObserverRefetchErrorResult<TData, TError>\n  | QueryObserverSuccessResult<TData, TError>\n\nexport type QueryObserverResult<TData = unknown, TError = DefaultError> =\n  | DefinedQueryObserverResult<TData, TError>\n  | QueryObserverLoadingErrorResult<TData, TError>\n  | QueryObserverLoadingResult<TData, TError>\n  | QueryObserverPendingResult<TData, TError>\n  | QueryObserverPlaceholderResult<TData, TError>\n\nexport interface InfiniteQueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  /**\n   * This function allows you to fetch the next \"page\" of results.\n   */\n  fetchNextPage: (\n    options?: FetchNextPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * This function allows you to fetch the previous \"page\" of results.\n   */\n  fetchPreviousPage: (\n    options?: FetchPreviousPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * Will be `true` if there is a next page to be fetched (known via the `getNextPageParam` option).\n   */\n  hasNextPage: boolean\n  /**\n   * Will be `true` if there is a previous page to be fetched (known via the `getPreviousPageParam` option).\n   */\n  hasPreviousPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the next page.\n   */\n  isFetchNextPageError: boolean\n  /**\n   * Will be `true` while fetching the next page with `fetchNextPage`.\n   */\n  isFetchingNextPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the previous page.\n   */\n  isFetchPreviousPageError: boolean\n  /**\n   * Will be `true` while fetching the previous page with `fetchPreviousPage`.\n   */\n  isFetchingPreviousPage: boolean\n}\n\nexport interface InfiniteQueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface InfiniteQueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  status: 'success'\n}\n\nexport type DefinedInfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | InfiniteQueryObserverRefetchErrorResult<TData, TError>\n  | InfiniteQueryObserverSuccessResult<TData, TError>\n\nexport type InfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | DefinedInfiniteQueryObserverResult<TData, TError>\n  | InfiniteQueryObserverLoadingErrorResult<TData, TError>\n  | InfiniteQueryObserverLoadingResult<TData, TError>\n  | InfiniteQueryObserverPendingResult<TData, TError>\n  | InfiniteQueryObserverPlaceholderResult<TData, TError>\n\nexport type MutationKey = Register extends {\n  mutationKey: infer TMutationKey\n}\n  ? TMutationKey extends Array<unknown>\n    ? TMutationKey\n    : TMutationKey extends Array<unknown>\n      ? TMutationKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport type MutationStatus = 'idle' | 'pending' | 'success' | 'error'\n\nexport type MutationScope = {\n  id: string\n}\n\nexport type MutationMeta = Register extends {\n  mutationMeta: infer TMutationMeta\n}\n  ? TMutationMeta extends Record<string, unknown>\n    ? TMutationMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type MutationFunctionContext = {\n  client: QueryClient\n  meta: MutationMeta | undefined\n  mutationKey?: MutationKey\n}\n\nexport type MutationFunction<TData = unknown, TVariables = unknown> = (\n  variables: TVariables,\n  context: MutationFunctionContext,\n) => Promise<TData>\n\nexport interface MutationOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TOnMutateResult = unknown,\n> {\n  mutationFn?: MutationFunction<TData, TVariables>\n  mutationKey?: MutationKey\n  onMutate?: (\n    variables: TVariables,\n    context: MutationFunctionContext,\n  ) => Promise<TOnMutateResult | undefined> | TOnMutateResult | undefined\n  onSuccess?: (\n    data: TData,\n    variables: TVariables,\n    onMutateResult: TOnMutateResult | undefined,\n    context: MutationFunctionContext,\n  ) => Promise<unknown> | unknown\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    onMutateResult: TOnMutateResult | undefined,\n    context: MutationFunctionContext,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    onMutateResult: TOnMutateResult | undefined,\n    context: MutationFunctionContext,\n  ) => Promise<unknown> | unknown\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  gcTime?: number\n  _defaulted?: boolean\n  meta?: MutationMeta\n  scope?: MutationScope\n}\n\nexport interface MutationObserverOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TOnMutateResult = unknown,\n> extends MutationOptions<TData, TError, TVariables, TOnMutateResult> {\n  throwOnError?: boolean | ((error: TError) => boolean)\n}\n\nexport interface MutateOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TOnMutateResult = unknown,\n> {\n  onSuccess?: (\n    data: TData,\n    variables: TVariables,\n    onMutateResult: TOnMutateResult | undefined,\n    context: MutationFunctionContext,\n  ) => void\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    onMutateResult: TOnMutateResult | undefined,\n    context: MutationFunctionContext,\n  ) => void\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    onMutateResult: TOnMutateResult | undefined,\n    context: MutationFunctionContext,\n  ) => void\n}\n\nexport type MutateFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TOnMutateResult = unknown,\n> = (\n  variables: TVariables,\n  options?: MutateOptions<TData, TError, TVariables, TOnMutateResult>,\n) => Promise<TData>\n\nexport interface MutationObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TOnMutateResult = unknown,\n> extends MutationState<TData, TError, TVariables, TOnMutateResult> {\n  /**\n   * The last successfully resolved data for the mutation.\n   */\n  data: TData | undefined\n  /**\n   * The variables object passed to the `mutationFn`.\n   */\n  variables: TVariables | undefined\n  /**\n   * The error object for the mutation, if an error was encountered.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is in its initial state prior to executing.\n   */\n  isIdle: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is currently executing.\n   */\n  isPending: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt was successful.\n   */\n  isSuccess: boolean\n  /**\n   * The status of the mutation.\n   * - Will be:\n   *   - `idle` initial status prior to the mutation function executing.\n   *   - `pending` if the mutation is currently executing.\n   *   - `error` if the last mutation attempt resulted in an error.\n   *   - `success` if the last mutation attempt was successful.\n   */\n  status: MutationStatus\n  /**\n   * The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.\n   * @param variables - The variables object to pass to the `mutationFn`.\n   * @param options.onSuccess - This function will fire when the mutation is successful and will be passed the mutation's result.\n   * @param options.onError - This function will fire if the mutation encounters an error and will be passed the error.\n   * @param options.onSettled - This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error.\n   * @remarks\n   * - If you make multiple requests, `onSuccess` will fire only after the latest call you've made.\n   * - All the callback functions (`onSuccess`, `onError`, `onSettled`) are void functions, and the returned value will be ignored.\n   */\n  mutate: MutateFunction<TData, TError, TVariables, TOnMutateResult>\n  /**\n   * A function to clean the mutation internal state (i.e., it resets the mutation to its initial state).\n   */\n  reset: () => void\n}\n\nexport interface MutationObserverIdleResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TOnMutateResult = unknown,\n> extends MutationObserverBaseResult<\n    TData,\n    TError,\n    TVariables,\n    TOnMutateResult\n  > {\n  data: undefined\n  variables: undefined\n  error: null\n  isError: false\n  isIdle: true\n  isPending: false\n  isSuccess: false\n  status: 'idle'\n}\n\nexport interface MutationObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TOnMutateResult = unknown,\n> extends MutationObserverBaseResult<\n    TData,\n    TError,\n    TVariables,\n    TOnMutateResult\n  > {\n  data: undefined\n  variables: TVariables\n  error: null\n  isError: false\n  isIdle: false\n  isPending: true\n  isSuccess: false\n  status: 'pending'\n}\n\nexport interface MutationObserverErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TOnMutateResult = unknown,\n> extends MutationObserverBaseResult<\n    TData,\n    TError,\n    TVariables,\n    TOnMutateResult\n  > {\n  data: undefined\n  error: TError\n  variables: TVariables\n  isError: true\n  isIdle: false\n  isPending: false\n  isSuccess: false\n  status: 'error'\n}\n\nexport interface MutationObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TOnMutateResult = unknown,\n> extends MutationObserverBaseResult<\n    TData,\n    TError,\n    TVariables,\n    TOnMutateResult\n  > {\n  data: TData\n  error: null\n  variables: TVariables\n  isError: false\n  isIdle: false\n  isPending: false\n  isSuccess: true\n  status: 'success'\n}\n\nexport type MutationObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TOnMutateResult = unknown,\n> =\n  | MutationObserverIdleResult<TData, TError, TVariables, TOnMutateResult>\n  | MutationObserverLoadingResult<TData, TError, TVariables, TOnMutateResult>\n  | MutationObserverErrorResult<TData, TError, TVariables, TOnMutateResult>\n  | MutationObserverSuccessResult<TData, TError, TVariables, TOnMutateResult>\n\nexport interface QueryClientConfig {\n  queryCache?: QueryCache\n  mutationCache?: MutationCache\n  defaultOptions?: DefaultOptions\n}\n\nexport interface DefaultOptions<TError = DefaultError> {\n  queries?: OmitKeyof<\n    QueryObserverOptions<unknown, TError>,\n    'suspense' | 'queryKey'\n  >\n  mutations?: MutationObserverOptions<unknown, TError, unknown, unknown>\n  hydrate?: HydrateOptions['defaultOptions']\n  dehydrate?: DehydrateOptions\n}\n\nexport interface CancelOptions {\n  revert?: boolean\n  silent?: boolean\n}\n\nexport interface SetDataOptions {\n  updatedAt?: number\n}\n\nexport type NotifyEventType =\n  | 'added'\n  | 'removed'\n  | 'updated'\n  | 'observerAdded'\n  | 'observerRemoved'\n  | 'observerResultsUpdated'\n  | 'observerOptionsUpdated'\n\nexport interface NotifyEvent {\n  type: NotifyEventType\n}\n", "//# sourceMappingURL=types.js.map", "'use client'\nimport * as React from 'react'\n\nimport {\n  QueriesObserver,\n  QueryObserver,\n  noop,\n  notifyManager,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './IsRestoringProvider'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport type {\n  DefaultError,\n  OmitKeyof,\n  QueriesObserverOptions,\n  QueriesPlaceholderDataFunction,\n  QueryClient,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  ThrowOnError,\n} from '@tanstack/query-core'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// `placeholderData` function always gets undefined passed\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = OmitKeyof<\n  UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'placeholderData' | 'subscribed'\n> & {\n  placeholderData?: TQueryFnData | QueriesPlaceholderDataFunction<TQueryFnData>\n}\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\n// Widen the type of the symbol to enable type inference even if skipToken is not immutable.\ntype SkipTokenForUseQueries = symbol\n\ntype GetUseQueryOptionsForUseQueries<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n        : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n          T extends [infer TQueryFnData, infer TError, infer TData]\n          ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseQueryOptionsForUseQueries<TQueryFnData>\n              : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                      | SkipTokenForUseQueries\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseQueryOptionsForUseQueries<\n                    TQueryFnData,\n                    unknown extends TError ? DefaultError : TError,\n                    unknown extends TData ? TQueryFnData : TData,\n                    TQueryKey\n                  >\n                : // Fallback\n                  UseQueryOptionsForUseQueries\n\n// A defined initialData setting should return a DefinedUseQueryResult rather than UseQueryResult\ntype GetDefinedOrUndefinedQueryResult<T, TData, TError = unknown> = T extends {\n  initialData?: infer TInitialData\n}\n  ? unknown extends TInitialData\n    ? UseQueryResult<TData, TError>\n    : TInitialData extends TData\n      ? DefinedUseQueryResult<TData, TError>\n      : TInitialData extends () => infer TInitialDataResult\n        ? unknown extends TInitialDataResult\n          ? UseQueryResult<TData, TError>\n          : TInitialDataResult extends TData\n            ? DefinedUseQueryResult<TData, TError>\n            : UseQueryResult<TData, TError>\n        : UseQueryResult<TData, TError>\n  : UseQueryResult<TData, TError>\n\ntype GetUseQueryResult<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n        : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n          T extends [any, infer TError, infer TData]\n          ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n          : T extends [infer TQueryFnData, infer TError]\n            ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData>\n              : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, any>\n                      | SkipTokenForUseQueries\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? GetDefinedOrUndefinedQueryResult<\n                    T,\n                    unknown extends TData ? TQueryFnData : TData,\n                    unknown extends TError ? DefaultError : TError\n                  >\n                : // Fallback\n                  UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryOptionsForUseQueries>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryOptionsForUseQueries<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? QueriesOptions<\n            [...Tails],\n            [...TResults, GetUseQueryOptionsForUseQueries<Head>],\n            [...TDepth, 1]\n          >\n        : ReadonlyArray<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                UseQueryOptionsForUseQueries<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                UseQueryOptionsForUseQueries<\n                  TQueryFnData,\n                  TError,\n                  TData,\n                  TQueryKey\n                >\n              >\n            : // Fallback\n              Array<UseQueryOptionsForUseQueries>\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryResult<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? QueriesResults<\n            [...Tails],\n            [...TResults, GetUseQueryResult<Head>],\n            [...TDepth, 1]\n          >\n        : { [K in keyof T]: GetUseQueryResult<T[K]> }\n\nexport function useQueries<\n  T extends Array<any>,\n  TCombinedResult = QueriesResults<T>,\n>(\n  {\n    queries,\n    ...options\n  }: {\n    queries:\n      | readonly [...QueriesOptions<T>]\n      | readonly [...{ [K in keyof T]: GetUseQueryOptionsForUseQueries<T[K]> }]\n    combine?: (result: QueriesResults<T>) => TCombinedResult\n    subscribed?: boolean\n  },\n  queryClient?: QueryClient,\n): TCombinedResult {\n  const client = useQueryClient(queryClient)\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((opts) => {\n        const defaultedOptions = client.defaultQueryOptions(\n          opts as QueryObserverOptions,\n        )\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, client, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureSuspenseTimers(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new QueriesObserver<TCombinedResult>(\n        client,\n        defaultedQueries,\n        options as QueriesObserverOptions<TCombinedResult>,\n      ),\n  )\n\n  // note: this must be called before useSyncExternalStore\n  const [optimisticResult, getCombinedResult, trackResult] =\n    observer.getOptimisticResult(\n      defaultedQueries,\n      (options as QueriesObserverOptions<TCombinedResult>).combine,\n    )\n\n  const shouldSubscribe = !isRestoring && options.subscribed !== false\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        shouldSubscribe\n          ? observer.subscribe(notifyManager.batchCalls(onStoreChange))\n          : noop,\n      [observer, shouldSubscribe],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    observer.setQueries(\n      defaultedQueries,\n      options as QueriesObserverOptions<TCombinedResult>,\n    )\n  }, [defaultedQueries, options, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const opts = defaultedQueries[index]\n\n        if (opts) {\n          const queryObserver = new QueryObserver(client, opts)\n          if (shouldSuspend(opts, result)) {\n            return fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises)\n  }\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) => {\n      const query = defaultedQueries[index]\n      return (\n        query &&\n        getHasError({\n          result,\n          errorResetBoundary,\n          throwOnError: query.throwOnError,\n          query: client.getQueryCache().get(query.queryHash),\n          suspense: query.suspense,\n        })\n      )\n    },\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return getCombinedResult(trackResult())\n}\n", "'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\n\nexport const QueryClientContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\n\nexport const useQueryClient = (queryClient?: QueryClient) => {\n  const client = React.useContext(QueryClientContext)\n\n  if (queryClient) {\n    return queryClient\n  }\n\n  if (!client) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return client\n}\n\nexport type QueryClientProviderProps = {\n  client: QueryClient\n  children?: React.ReactNode\n}\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n}: QueryClientProviderProps): React.JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  return (\n    <QueryClientContext.Provider value={client}>\n      {children}\n    </QueryClientContext.Provider>\n  )\n}\n", "'use client'\nimport * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n", "'use client'\nimport * as React from 'react'\n\n// CONTEXT\nexport type QueryErrorResetFunction = () => void\nexport type QueryErrorIsResetFunction = () => boolean\nexport type QueryErrorClearResetFunction = () => void\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: QueryErrorClearResetFunction\n  isReset: QueryErrorIsResetFunction\n  reset: QueryErrorResetFunction\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport type QueryErrorResetBoundaryFunction = (\n  value: QueryErrorResetBoundaryValue,\n) => React.ReactNode\n\nexport interface QueryErrorResetBoundaryProps {\n  children: QueryErrorResetBoundaryFunction | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function' ? children(value) : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n", "'use client'\nimport * as React from 'react'\nimport { shouldThrowError } from '@tanstack/query-core'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  ThrowOnError,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  if (\n    options.suspense ||\n    options.throwOnError ||\n    options.experimental_prefetchInRender\n  ) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query,\n  suspense,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  throwOnError: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined\n  suspense: boolean | undefined\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    query &&\n    ((suspense && result.data === undefined) ||\n      shouldThrowError(throwOnError, [result.error, query]))\n  )\n}\n", "import type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const defaultThrowOnError = <\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  _error: TError,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n) => query.state.data === undefined\n\nexport const ensureSuspenseTimers = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  if (defaultedOptions.suspense) {\n    // Handle staleTime to ensure minimum 1000ms in Suspense mode\n    // This prevents unnecessary refetching when components remount after suspending\n    const MIN_SUSPENSE_TIME_MS = 1000\n\n    const clamp = (value: number | 'static' | undefined) =>\n      value === 'static'\n        ? value\n        : Math.max(value ?? MIN_SUSPENSE_TIME_MS, MIN_SUSPENSE_TIME_MS)\n\n    const originalStaleTime = defaultedOptions.staleTime\n    defaultedOptions.staleTime =\n      typeof originalStaleTime === 'function'\n        ? (...args) => clamp(originalStaleTime(...args))\n        : clamp(originalStaleTime)\n\n    if (typeof defaultedOptions.gcTime === 'number') {\n      defaultedOptions.gcTime = Math.max(\n        defaultedOptions.gcTime,\n        MIN_SUSPENSE_TIME_MS,\n      )\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n) => defaultedOptions?.suspense && result.isPending\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer.fetchOptimistic(defaultedOptions).catch(() => {\n    errorResetBoundary.clearReset()\n  })\n", "'use client'\nimport * as React from 'react'\n\nimport { isServer, noop, notifyManager } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { useIsRestoring } from './IsRestoringProvider'\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type {\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { UseBaseQueryOptions } from './types'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n  queryClient?: QueryClient,\n): QueryObserverResult<TData, TError> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof options !== 'object' || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object',\n      )\n    }\n  }\n\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const client = useQueryClient(queryClient)\n  const defaultedOptions = client.defaultQueryOptions(options)\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_beforeQuery?.(\n    defaultedOptions,\n  )\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!defaultedOptions.queryFn) {\n      console.error(\n        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`,\n      )\n    }\n  }\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  ensureSuspenseTimers(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  // this needs to be invoked before creating the Observer because that can create a cache entry\n  const isNewCacheEntry = !client\n    .getQueryCache()\n    .get(defaultedOptions.queryHash)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        client,\n        defaultedOptions,\n      ),\n  )\n\n  // note: this must be called before useSyncExternalStore\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  const shouldSubscribe = !isRestoring && options.subscribed !== false\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = shouldSubscribe\n          ? observer.subscribe(notifyManager.batchCalls(onStoreChange))\n          : noop\n\n        // Update result to make sure we did not miss any query updates\n        // between creating the observer and subscribing to it.\n        observer.updateResult()\n\n        return unsubscribe\n      },\n      [observer, shouldSubscribe],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(defaultedOptions)\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      throwOnError: defaultedOptions.throwOnError,\n      query: client\n        .getQueryCache()\n        .get<\n          TQueryFnData,\n          TError,\n          TQueryData,\n          TQueryKey\n        >(defaultedOptions.queryHash),\n      suspense: defaultedOptions.suspense,\n    })\n  ) {\n    throw result.error\n  }\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_afterQuery?.(\n    defaultedOptions,\n    result,\n  )\n\n  if (\n    defaultedOptions.experimental_prefetchInRender &&\n    !isServer &&\n    willFetch(result, isRestoring)\n  ) {\n    const promise = isNewCacheEntry\n      ? // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted\n        fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n      : // subscribe to the \"cache promise\" so that we can finalize the currentThenable once data comes in\n        client.getQueryCache().get(defaultedOptions.queryHash)?.promise\n\n    promise?.catch(noop).finally(() => {\n      // `.updateResult()` will trigger `.#currentThenable` to finalize\n      observer.updateResult()\n    })\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n", "'use client'\nimport { QueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type {\n  DefaultError,\n  NoInfer,\n  QueryClient,\n  QueryKey,\n} from '@tanstack/query-core'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport type {\n  DefinedInitialDataOptions,\n  UndefinedInitialDataOptions,\n} from './queryOptions'\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): DefinedUseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery(options: UseQueryOptions, queryClient?: QueryClient) {\n  return useBaseQuery(options, QueryObserver, queryClient)\n}\n", "'use client'\nimport * as React from 'react'\n\nimport { hydrate } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  DehydratedState,\n  HydrateOptions,\n  OmitKeyof,\n  QueryClient,\n} from '@tanstack/query-core'\n\nexport interface HydrationBoundaryProps {\n  state: DehydratedState | null | undefined\n  options?: OmitKeyof<HydrateOptions, 'defaultOptions'> & {\n    defaultOptions?: OmitKeyof<\n      Exclude<HydrateOptions['defaultOptions'], undefined>,\n      'mutations'\n    >\n  }\n  children?: React.ReactNode\n  queryClient?: QueryClient\n}\n\nexport const HydrationBoundary = ({\n  children,\n  options = {},\n  state,\n  queryClient,\n}: HydrationBoundaryProps) => {\n  const client = useQueryClient(queryClient)\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // This useMemo is for performance reasons only, everything inside it must\n  // be safe to run in every render and code here should be read as \"in render\".\n  //\n  // This code needs to happen during the render phase, because after initial\n  // SSR, hydration needs to happen _before_ children render. Also, if hydrating\n  // during a transition, we want to hydrate as much as is safe in render so\n  // we can prerender as much as possible.\n  //\n  // For any queries that already exist in the cache, we want to hold back on\n  // hydrating until _after_ the render phase. The reason for this is that during\n  // transitions, we don't want the existing queries and observers to update to\n  // the new data on the current page, only _after_ the transition is committed.\n  // If the transition is aborted, we will have hydrated any _new_ queries, but\n  // we throw away the fresh data for any existing ones to avoid unexpectedly\n  // updating the UI.\n  const hydrationQueue: DehydratedState['queries'] | undefined =\n    React.useMemo(() => {\n      if (state) {\n        if (typeof state !== 'object') {\n          return\n        }\n\n        const queryCache = client.getQueryCache()\n        // State is supplied from the outside and we might as well fail\n        // gracefully if it has the wrong shape, so while we type `queries`\n        // as required, we still provide a fallback.\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        const queries = state.queries || []\n\n        const newQueries: DehydratedState['queries'] = []\n        const existingQueries: DehydratedState['queries'] = []\n        for (const dehydratedQuery of queries) {\n          const existingQuery = queryCache.get(dehydratedQuery.queryHash)\n\n          if (!existingQuery) {\n            newQueries.push(dehydratedQuery)\n          } else {\n            const hydrationIsNewer =\n              dehydratedQuery.state.dataUpdatedAt >\n                existingQuery.state.dataUpdatedAt ||\n              (dehydratedQuery.promise &&\n                existingQuery.state.status !== 'pending' &&\n                existingQuery.state.fetchStatus !== 'fetching' &&\n                dehydratedQuery.dehydratedAt !== undefined &&\n                dehydratedQuery.dehydratedAt >\n                  existingQuery.state.dataUpdatedAt)\n\n            if (hydrationIsNewer) {\n              existingQueries.push(dehydratedQuery)\n            }\n          }\n        }\n\n        if (newQueries.length > 0) {\n          // It's actually fine to call this with queries/state that already exists\n          // in the cache, or is older. hydrate() is idempotent for queries.\n          hydrate(client, { queries: newQueries }, optionsRef.current)\n        }\n        if (existingQueries.length > 0) {\n          return existingQueries\n        }\n      }\n      return undefined\n    }, [client, state])\n\n  React.useEffect(() => {\n    if (hydrationQueue) {\n      hydrate(client, { queries: hydrationQueue }, optionsRef.current)\n    }\n  }, [client, hydrationQueue])\n\n  return children as React.ReactElement\n}\n", "'use client'\nimport * as React from 'react'\nimport { notifyManager } from '@tanstack/query-core'\n\nimport { useQueryClient } from './QueryClientProvider'\nimport type { QueryClient, QueryFilters } from '@tanstack/query-core'\n\nexport function useIsFetching(\n  filters?: QueryFilters,\n  queryClient?: QueryClient,\n): number {\n  const client = useQueryClient(queryClient)\n  const queryCache = client.getQueryCache()\n\n  return React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        queryCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [queryCache],\n    ),\n    () => client.isFetching(filters),\n    () => client.isFetching(filters),\n  )\n}\n", "'use client'\nimport * as React from 'react'\n\nimport { notifyManager, replaceEqualDeep } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  Mutation,\n  MutationCache,\n  MutationFilters,\n  MutationState,\n  QueryClient,\n} from '@tanstack/query-core'\n\nexport function useIsMutating(\n  filters?: MutationFilters,\n  queryClient?: QueryClient,\n): number {\n  const client = useQueryClient(queryClient)\n  return useMutationState(\n    { filters: { ...filters, status: 'pending' } },\n    client,\n  ).length\n}\n\ntype MutationStateOptions<TResult = MutationState> = {\n  filters?: MutationFilters\n  select?: (mutation: Mutation) => TResult\n}\n\nfunction getResult<TResult = MutationState>(\n  mutationCache: MutationCache,\n  options: MutationStateOptions<TResult>,\n): Array<TResult> {\n  return mutationCache\n    .findAll(options.filters)\n    .map(\n      (mutation): TResult =>\n        (options.select ? options.select(mutation) : mutation.state) as TResult,\n    )\n}\n\nexport function useMutationState<TResult = MutationState>(\n  options: MutationStateOptions<TResult> = {},\n  queryClient?: QueryClient,\n): Array<TResult> {\n  const mutationCache = useQueryClient(queryClient).getMutationCache()\n  const optionsRef = React.useRef(options)\n  const result = React.useRef<Array<TResult>>(null)\n  if (!result.current) {\n    result.current = getResult(mutationCache, options)\n  }\n\n  React.useEffect(() => {\n    optionsRef.current = options\n  })\n\n  return React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        mutationCache.subscribe(() => {\n          const nextResult = replaceEqualDeep(\n            result.current,\n            getResult(mutationCache, optionsRef.current),\n          )\n          if (result.current !== nextResult) {\n            result.current = nextResult\n            notifyManager.schedule(onStoreChange)\n          }\n        }),\n      [mutationCache],\n    ),\n    () => result.current,\n    () => result.current,\n  )!\n}\n", "'use client'\nimport * as React from 'react'\nimport {\n  MutationObserver,\n  noop,\n  notifyManager,\n  shouldThrowError,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport type { DefaultError, QueryClient } from '@tanstack/query-core'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TOnMutateResult = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TOnMutateResult>,\n  queryClient?: QueryClient,\n): UseMutationResult<TData, TError, TVariables, TOnMutateResult> {\n  const client = useQueryClient(queryClient)\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TOnMutateResult>(\n        client,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TOnMutateResult>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.throwOnError, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n", "export { AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR, APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR, APPROVE_CHECKED_DISCRIMINATOR, APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR, APPROVE_DISCRIMINATOR, ASSOCIATED_TOKEN_ERROR__INVALID_OWNER, ASSOCIATED_TOKEN_PROGRAM_ADDRESS, AccountState, AssociatedTokenInstruction, AuthorityType, BURN_CHECKED_DISCRIMINATOR, BURN_DISCRIMINATOR, CLOSE_ACCOUNT_DISCRIMINATOR, CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, CONFIDENTIAL_DEPOSIT_DISCRIMINATOR, CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, CONFIDENTIAL_TRANSFER_DISCRIMINATOR, CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR, CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, CONFIDENTIAL_WITHDRAW_DISCRIMINATOR, CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR, CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR, CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR, CREATE_NATIVE_MINT_DISCRIMINATOR, DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR, DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR, DISABLE_CPI_GUARD_DISCRIMINATOR, DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR, DISABLE_HARVEST_TO_MINT_DISCRIMINATOR, DISABLE_MEMO_TRANSFERS_DISCRIMINATOR, DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR, DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR, EMIT_TOKEN_METADATA_DISCRIMINATOR, EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR, ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR, ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR, ENABLE_CPI_GUARD_DISCRIMINATOR, ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR, ENABLE_HARVEST_TO_MINT_DISCRIMINATOR, ENABLE_MEMO_TRANSFERS_DISCRIMINATOR, ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR, ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR, ExtensionType, FREEZE_ACCOUNT_DISCRIMINATOR, GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR, HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR, HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR, HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR, HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR, INITIALIZE_ACCOUNT2_DISCRIMINATOR, INITIALIZE_ACCOUNT3_DISCRIMINATOR, INITIALIZE_ACCOUNT_DISCRIMINATOR, INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR, INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR, INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR, INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR, INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR, INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR, INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR, INITIALIZE_GROUP_POINTER_DISCRIMINATOR, INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR, INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR, INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR, INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR, INITIALIZE_METADATA_POINTER_DISCRIMINATOR, INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR, INITIALIZE_MINT2_DISCRIMINATOR, INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR, INITIALIZE_MINT_DISCRIMINATOR, INITIALIZE_MULTISIG2_DISCRIMINATOR, INITIALIZE_MULTISIG_DISCRIMINATOR, INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR, INITIALIZE_PAUSABLE_CONFIG_DISCRIMINATOR, INITIALIZE_PAUSABLE_CONFIG_PAUSABLE_DISCRIMINATOR, INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR, INITIALIZE_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR, INITIALIZE_SCALED_UI_AMOUNT_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR, INITIALIZE_TOKEN_GROUP_DISCRIMINATOR, INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR, INITIALIZE_TOKEN_METADATA_DISCRIMINATOR, INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR, INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR, INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR, INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR, MINT_TO_CHECKED_DISCRIMINATOR, MINT_TO_DISCRIMINATOR, PAUSE_DISCRIMINATOR, PAUSE_PAUSABLE_DISCRIMINATOR, REALLOCATE_DISCRIMINATOR, RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR, REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR, RESUME_DISCRIMINATOR, RESUME_PAUSABLE_DISCRIMINATOR, REVOKE_DISCRIMINATOR, SET_AUTHORITY_DISCRIMINATOR, SET_TRANSFER_FEE_DISCRIMINATOR, SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR, SYNC_NATIVE_DISCRIMINATOR, THAW_ACCOUNT_DISCRIMINATOR, TOKEN_2022_ERROR__ACCOUNT_FROZEN, TOKEN_2022_ERROR__ALREADY_IN_USE, TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED, TOKEN_2022_ERROR__FIXED_SUPPLY, TOKEN_2022_ERROR__INSUFFICIENT_FUNDS, TOKEN_2022_ERROR__INVALID_INSTRUCTION, TOKEN_2022_ERROR__INVALID_MINT, TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS, TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS, TOKEN_2022_ERROR__INVALID_STATE, TOKEN_2022_ERROR__MINT_CANNOT_FREEZE, TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH, TOKEN_2022_ERROR__MINT_MISMATCH, TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED, TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE, TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED, TOKEN_2022_ERROR__NOT_RENT_EXEMPT, TOKEN_2022_ERROR__OVERFLOW, TOKEN_2022_ERROR__OWNER_MISMATCH, TOKEN_2022_ERROR__UNINITIALIZED_STATE, TOKEN_2022_PROGRAM_ADDRESS, TOKEN_PROGRAM_ADDRESS, TRANSFER_CHECKED_DISCRIMINATOR, TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR, TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR, TRANSFER_DISCRIMINATOR, Token2022Account, Token2022Instruction, UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR, UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR, UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR, UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR, UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR, UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR, UPDATE_GROUP_POINTER_DISCRIMINATOR, UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR, UPDATE_METADATA_POINTER_DISCRIMINATOR, UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR, UPDATE_MULTIPLIER_SCALED_UI_MINT_DISCRIMINATOR, UPDATE_MULTIPLIER_SCALED_UI_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR, UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR, UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR, UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR, UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR, UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR, UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR, UPDATE_TRANSFER_HOOK_DISCRIMINATOR, UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR, WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR, WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR, WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR, WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR, WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR, WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR, WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR, WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR, WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR, amountToUiAmountForInterestBearingMintWithoutSimulation, amountToUiAmountForMintWithoutSimulation, amountToUiAmountForScaledUiAmountMintWithoutSimulation, assertIsSupportedTokenProgram, buildCreateTokenTransaction, buildMintTokensTransaction, buildTransferTokensTransaction, checkedTokenProgramAddress, decodeMint, decodeMultisig, decodeToken, extension, fetchAllMaybeMint, fetchAllMaybeMultisig, fetchAllMaybeToken, fetchAllMint, fetchAllMultisig, fetchAllToken, fetchMaybeMint, fetchMaybeMultisig, fetchMaybeToken, fetchMint, fetchMultisig, fetchToken, findAssociatedTokenPda, getAccountStateCodec, getAccountStateDecoder, getAccountStateEncoder, getAmountToUiAmountDiscriminatorBytes, getAmountToUiAmountInstruction, getAmountToUiAmountInstructionDataCodec, getAmountToUiAmountInstructionDataDecoder, getAmountToUiAmountInstructionDataEncoder, getApplyConfidentialPendingBalanceConfidentialTransferDiscriminatorBytes, getApplyConfidentialPendingBalanceDiscriminatorBytes, getApplyConfidentialPendingBalanceInstruction, getApplyConfidentialPendingBalanceInstructionDataCodec, getApplyConfidentialPendingBalanceInstructionDataDecoder, getApplyConfidentialPendingBalanceInstructionDataEncoder, getApproveCheckedDiscriminatorBytes, getApproveCheckedInstruction, getApproveCheckedInstructionDataCodec, getApproveCheckedInstructionDataDecoder, getApproveCheckedInstructionDataEncoder, getApproveConfidentialTransferAccountConfidentialTransferDiscriminatorBytes, getApproveConfidentialTransferAccountDiscriminatorBytes, getApproveConfidentialTransferAccountInstruction, getApproveConfidentialTransferAccountInstructionDataCodec, getApproveConfidentialTransferAccountInstructionDataDecoder, getApproveConfidentialTransferAccountInstructionDataEncoder, getApproveDiscriminatorBytes, getApproveInstruction, getApproveInstructionDataCodec, getApproveInstructionDataDecoder, getApproveInstructionDataEncoder, getAssociatedTokenAccountAddress, getAssociatedTokenErrorMessage, getAuthorityTypeCodec, getAuthorityTypeDecoder, getAuthorityTypeEncoder, getBurnCheckedDiscriminatorBytes, getBurnCheckedInstruction, getBurnCheckedInstructionDataCodec, getBurnCheckedInstructionDataDecoder, getBurnCheckedInstructionDataEncoder, getBurnDiscriminatorBytes, getBurnInstruction, getBurnInstructionDataCodec, getBurnInstructionDataDecoder, getBurnInstructionDataEncoder, getCloseAccountDiscriminatorBytes, getCloseAccountInstruction, getCloseAccountInstructionDataCodec, getCloseAccountInstructionDataDecoder, getCloseAccountInstructionDataEncoder, getConfidentialDepositConfidentialTransferDiscriminatorBytes, getConfidentialDepositDiscriminatorBytes, getConfidentialDepositInstruction, getConfidentialDepositInstructionDataCodec, getConfidentialDepositInstructionDataDecoder, getConfidentialDepositInstructionDataEncoder, getConfidentialTransferConfidentialTransferDiscriminatorBytes, getConfidentialTransferDiscriminatorBytes, getConfidentialTransferInstruction, getConfidentialTransferInstructionDataCodec, getConfidentialTransferInstructionDataDecoder, getConfidentialTransferInstructionDataEncoder, getConfidentialTransferWithFeeConfidentialTransferDiscriminatorBytes, getConfidentialTransferWithFeeDiscriminatorBytes, getConfidentialTransferWithFeeInstruction, getConfidentialTransferWithFeeInstructionDataCodec, getConfidentialTransferWithFeeInstructionDataDecoder, getConfidentialTransferWithFeeInstructionDataEncoder, getConfidentialWithdrawConfidentialTransferDiscriminatorBytes, getConfidentialWithdrawDiscriminatorBytes, getConfidentialWithdrawInstruction, getConfidentialWithdrawInstructionDataCodec, getConfidentialWithdrawInstructionDataDecoder, getConfidentialWithdrawInstructionDataEncoder, getConfigureConfidentialTransferAccountConfidentialTransferDiscriminatorBytes, getConfigureConfidentialTransferAccountDiscriminatorBytes, getConfigureConfidentialTransferAccountInstruction, getConfigureConfidentialTransferAccountInstructionDataCodec, getConfigureConfidentialTransferAccountInstructionDataDecoder, getConfigureConfidentialTransferAccountInstructionDataEncoder, getCreateAssociatedTokenDiscriminatorBytes, getCreateAssociatedTokenIdempotentDiscriminatorBytes, getCreateAssociatedTokenIdempotentInstruction, getCreateAssociatedTokenIdempotentInstructionAsync, getCreateAssociatedTokenIdempotentInstructionDataCodec, getCreateAssociatedTokenIdempotentInstructionDataDecoder, getCreateAssociatedTokenIdempotentInstructionDataEncoder, getCreateAssociatedTokenInstruction, getCreateAssociatedTokenInstructionAsync, getCreateAssociatedTokenInstructionDataCodec, getCreateAssociatedTokenInstructionDataDecoder, getCreateAssociatedTokenInstructionDataEncoder, getCreateNativeMintDiscriminatorBytes, getCreateNativeMintInstruction, getCreateNativeMintInstructionDataCodec, getCreateNativeMintInstructionDataDecoder, getCreateNativeMintInstructionDataEncoder, getCreateTokenInstructions, getDecryptableBalanceCodec, getDecryptableBalanceDecoder, getDecryptableBalanceEncoder, getDisableConfidentialCreditsConfidentialTransferDiscriminatorBytes, getDisableConfidentialCreditsDiscriminatorBytes, getDisableConfidentialCreditsInstruction, getDisableConfidentialCreditsInstructionDataCodec, getDisableConfidentialCreditsInstructionDataDecoder, getDisableConfidentialCreditsInstructionDataEncoder, getDisableCpiGuardCpiGuardDiscriminatorBytes, getDisableCpiGuardDiscriminatorBytes, getDisableCpiGuardInstruction, getDisableCpiGuardInstructionDataCodec, getDisableCpiGuardInstructionDataDecoder, getDisableCpiGuardInstructionDataEncoder, getDisableHarvestToMintConfidentialTransferFeeDiscriminatorBytes, getDisableHarvestToMintDiscriminatorBytes, getDisableHarvestToMintInstruction, getDisableHarvestToMintInstructionDataCodec, getDisableHarvestToMintInstructionDataDecoder, getDisableHarvestToMintInstructionDataEncoder, getDisableMemoTransfersDiscriminatorBytes, getDisableMemoTransfersInstruction, getDisableMemoTransfersInstructionDataCodec, getDisableMemoTransfersInstructionDataDecoder, getDisableMemoTransfersInstructionDataEncoder, getDisableMemoTransfersMemoTransfersDiscriminatorBytes, getDisableNonConfidentialCreditsConfidentialTransferDiscriminatorBytes, getDisableNonConfidentialCreditsDiscriminatorBytes, getDisableNonConfidentialCreditsInstruction, getDisableNonConfidentialCreditsInstructionDataCodec, getDisableNonConfidentialCreditsInstructionDataDecoder, getDisableNonConfidentialCreditsInstructionDataEncoder, getEmitTokenMetadataDiscriminatorBytes, getEmitTokenMetadataInstruction, getEmitTokenMetadataInstructionDataCodec, getEmitTokenMetadataInstructionDataDecoder, getEmitTokenMetadataInstructionDataEncoder, getEmptyConfidentialTransferAccountConfidentialTransferDiscriminatorBytes, getEmptyConfidentialTransferAccountDiscriminatorBytes, getEmptyConfidentialTransferAccountInstruction, getEmptyConfidentialTransferAccountInstructionDataCodec, getEmptyConfidentialTransferAccountInstructionDataDecoder, getEmptyConfidentialTransferAccountInstructionDataEncoder, getEnableConfidentialCreditsConfidentialTransferDiscriminatorBytes, getEnableConfidentialCreditsDiscriminatorBytes, getEnableConfidentialCreditsInstruction, getEnableConfidentialCreditsInstructionDataCodec, getEnableConfidentialCreditsInstructionDataDecoder, getEnableConfidentialCreditsInstructionDataEncoder, getEnableCpiGuardCpiGuardDiscriminatorBytes, getEnableCpiGuardDiscriminatorBytes, getEnableCpiGuardInstruction, getEnableCpiGuardInstructionDataCodec, getEnableCpiGuardInstructionDataDecoder, getEnableCpiGuardInstructionDataEncoder, getEnableHarvestToMintConfidentialTransferFeeDiscriminatorBytes, getEnableHarvestToMintDiscriminatorBytes, getEnableHarvestToMintInstruction, getEnableHarvestToMintInstructionDataCodec, getEnableHarvestToMintInstructionDataDecoder, getEnableHarvestToMintInstructionDataEncoder, getEnableMemoTransfersDiscriminatorBytes, getEnableMemoTransfersInstruction, getEnableMemoTransfersInstructionDataCodec, getEnableMemoTransfersInstructionDataDecoder, getEnableMemoTransfersInstructionDataEncoder, getEnableMemoTransfersMemoTransfersDiscriminatorBytes, getEnableNonConfidentialCreditsConfidentialTransferDiscriminatorBytes, getEnableNonConfidentialCreditsDiscriminatorBytes, getEnableNonConfidentialCreditsInstruction, getEnableNonConfidentialCreditsInstructionDataCodec, getEnableNonConfidentialCreditsInstructionDataDecoder, getEnableNonConfidentialCreditsInstructionDataEncoder, getEncryptedBalanceCodec, getEncryptedBalanceDecoder, getEncryptedBalanceEncoder, getExtensionCodec, getExtensionDecoder, getExtensionEncoder, getExtensionTypeCodec, getExtensionTypeDecoder, getExtensionTypeEncoder, getFreezeAccountDiscriminatorBytes, getFreezeAccountInstruction, getFreezeAccountInstructionDataCodec, getFreezeAccountInstructionDataDecoder, getFreezeAccountInstructionDataEncoder, getGetAccountDataSizeDiscriminatorBytes, getGetAccountDataSizeInstruction, getGetAccountDataSizeInstructionDataCodec, getGetAccountDataSizeInstructionDataDecoder, getGetAccountDataSizeInstructionDataEncoder, getHarvestWithheldTokensToMintDiscriminatorBytes, getHarvestWithheldTokensToMintForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes, getHarvestWithheldTokensToMintForConfidentialTransferFeeDiscriminatorBytes, getHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction, getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataCodec, getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder, getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder, getHarvestWithheldTokensToMintInstruction, getHarvestWithheldTokensToMintInstructionDataCodec, getHarvestWithheldTokensToMintInstructionDataDecoder, getHarvestWithheldTokensToMintInstructionDataEncoder, getHarvestWithheldTokensToMintTransferFeeDiscriminatorBytes, getInitializeAccount2DiscriminatorBytes, getInitializeAccount2Instruction, getInitializeAccount2InstructionDataCodec, getInitializeAccount2InstructionDataDecoder, getInitializeAccount2InstructionDataEncoder, getInitializeAccount3DiscriminatorBytes, getInitializeAccount3Instruction, getInitializeAccount3InstructionDataCodec, getInitializeAccount3InstructionDataDecoder, getInitializeAccount3InstructionDataEncoder, getInitializeAccountDiscriminatorBytes, getInitializeAccountInstruction, getInitializeAccountInstructionDataCodec, getInitializeAccountInstructionDataDecoder, getInitializeAccountInstructionDataEncoder, getInitializeConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes, getInitializeConfidentialTransferFeeDiscriminatorBytes, getInitializeConfidentialTransferFeeInstruction, getInitializeConfidentialTransferFeeInstructionDataCodec, getInitializeConfidentialTransferFeeInstructionDataDecoder, getInitializeConfidentialTransferFeeInstructionDataEncoder, getInitializeConfidentialTransferMintConfidentialTransferDiscriminatorBytes, getInitializeConfidentialTransferMintDiscriminatorBytes, getInitializeConfidentialTransferMintInstruction, getInitializeConfidentialTransferMintInstructionDataCodec, getInitializeConfidentialTransferMintInstructionDataDecoder, getInitializeConfidentialTransferMintInstructionDataEncoder, getInitializeDefaultAccountStateDefaultAccountStateDiscriminatorBytes, getInitializeDefaultAccountStateDiscriminatorBytes, getInitializeDefaultAccountStateInstruction, getInitializeDefaultAccountStateInstructionDataCodec, getInitializeDefaultAccountStateInstructionDataDecoder, getInitializeDefaultAccountStateInstructionDataEncoder, getInitializeGroupMemberPointerDiscriminatorBytes, getInitializeGroupMemberPointerGroupMemberPointerDiscriminatorBytes, getInitializeGroupMemberPointerInstruction, getInitializeGroupMemberPointerInstructionDataCodec, getInitializeGroupMemberPointerInstructionDataDecoder, getInitializeGroupMemberPointerInstructionDataEncoder, getInitializeGroupPointerDiscriminatorBytes, getInitializeGroupPointerGroupPointerDiscriminatorBytes, getInitializeGroupPointerInstruction, getInitializeGroupPointerInstructionDataCodec, getInitializeGroupPointerInstructionDataDecoder, getInitializeGroupPointerInstructionDataEncoder, getInitializeImmutableOwnerDiscriminatorBytes, getInitializeImmutableOwnerInstruction, getInitializeImmutableOwnerInstructionDataCodec, getInitializeImmutableOwnerInstructionDataDecoder, getInitializeImmutableOwnerInstructionDataEncoder, getInitializeInterestBearingMintDiscriminatorBytes, getInitializeInterestBearingMintInstruction, getInitializeInterestBearingMintInstructionDataCodec, getInitializeInterestBearingMintInstructionDataDecoder, getInitializeInterestBearingMintInstructionDataEncoder, getInitializeInterestBearingMintInterestBearingMintDiscriminatorBytes, getInitializeMetadataPointerDiscriminatorBytes, getInitializeMetadataPointerInstruction, getInitializeMetadataPointerInstructionDataCodec, getInitializeMetadataPointerInstructionDataDecoder, getInitializeMetadataPointerInstructionDataEncoder, getInitializeMetadataPointerMetadataPointerDiscriminatorBytes, getInitializeMint2DiscriminatorBytes, getInitializeMint2Instruction, getInitializeMint2InstructionDataCodec, getInitializeMint2InstructionDataDecoder, getInitializeMint2InstructionDataEncoder, getInitializeMintCloseAuthorityDiscriminatorBytes, getInitializeMintCloseAuthorityInstruction, getInitializeMintCloseAuthorityInstructionDataCodec, getInitializeMintCloseAuthorityInstructionDataDecoder, getInitializeMintCloseAuthorityInstructionDataEncoder, getInitializeMintDiscriminatorBytes, getInitializeMintInstruction, getInitializeMintInstructionDataCodec, getInitializeMintInstructionDataDecoder, getInitializeMintInstructionDataEncoder, getInitializeMultisig2DiscriminatorBytes, getInitializeMultisig2Instruction, getInitializeMultisig2InstructionDataCodec, getInitializeMultisig2InstructionDataDecoder, getInitializeMultisig2InstructionDataEncoder, getInitializeMultisigDiscriminatorBytes, getInitializeMultisigInstruction, getInitializeMultisigInstructionDataCodec, getInitializeMultisigInstructionDataDecoder, getInitializeMultisigInstructionDataEncoder, getInitializeNonTransferableMintDiscriminatorBytes, getInitializeNonTransferableMintInstruction, getInitializeNonTransferableMintInstructionDataCodec, getInitializeNonTransferableMintInstructionDataDecoder, getInitializeNonTransferableMintInstructionDataEncoder, getInitializePausableConfigDiscriminatorBytes, getInitializePausableConfigInstruction, getInitializePausableConfigInstructionDataCodec, getInitializePausableConfigInstructionDataDecoder, getInitializePausableConfigInstructionDataEncoder, getInitializePausableConfigPausableDiscriminatorBytes, getInitializePermanentDelegateDiscriminatorBytes, getInitializePermanentDelegateInstruction, getInitializePermanentDelegateInstructionDataCodec, getInitializePermanentDelegateInstructionDataDecoder, getInitializePermanentDelegateInstructionDataEncoder, getInitializeScaledUiAmountMintDiscriminatorBytes, getInitializeScaledUiAmountMintInstruction, getInitializeScaledUiAmountMintInstructionDataCodec, getInitializeScaledUiAmountMintInstructionDataDecoder, getInitializeScaledUiAmountMintInstructionDataEncoder, getInitializeScaledUiAmountMintScaledUiAmountMintDiscriminatorBytes, getInitializeTokenGroupDiscriminatorBytes, getInitializeTokenGroupInstruction, getInitializeTokenGroupInstructionDataCodec, getInitializeTokenGroupInstructionDataDecoder, getInitializeTokenGroupInstructionDataEncoder, getInitializeTokenGroupMemberDiscriminatorBytes, getInitializeTokenGroupMemberInstruction, getInitializeTokenGroupMemberInstructionDataCodec, getInitializeTokenGroupMemberInstructionDataDecoder, getInitializeTokenGroupMemberInstructionDataEncoder, getInitializeTokenMetadataDiscriminatorBytes, getInitializeTokenMetadataInstruction, getInitializeTokenMetadataInstructionDataCodec, getInitializeTokenMetadataInstructionDataDecoder, getInitializeTokenMetadataInstructionDataEncoder, getInitializeTransferFeeConfigDiscriminatorBytes, getInitializeTransferFeeConfigInstruction, getInitializeTransferFeeConfigInstructionDataCodec, getInitializeTransferFeeConfigInstructionDataDecoder, getInitializeTransferFeeConfigInstructionDataEncoder, getInitializeTransferFeeConfigTransferFeeDiscriminatorBytes, getInitializeTransferHookDiscriminatorBytes, getInitializeTransferHookInstruction, getInitializeTransferHookInstructionDataCodec, getInitializeTransferHookInstructionDataDecoder, getInitializeTransferHookInstructionDataEncoder, getInitializeTransferHookTransferHookDiscriminatorBytes, getMintCodec, getMintDecoder, getMintEncoder, getMintSize, getMintToCheckedDiscriminatorBytes, getMintToCheckedInstruction, getMintToCheckedInstructionDataCodec, getMintToCheckedInstructionDataDecoder, getMintToCheckedInstructionDataEncoder, getMintToDiscriminatorBytes, getMintToInstruction, getMintToInstructionDataCodec, getMintToInstructionDataDecoder, getMintToInstructionDataEncoder, getMintTokensInstructions, getMultisigCodec, getMultisigDecoder, getMultisigEncoder, getMultisigSize, getPauseDiscriminatorBytes, getPauseInstruction, getPauseInstructionDataCodec, getPauseInstructionDataDecoder, getPauseInstructionDataEncoder, getPausePausableDiscriminatorBytes, getPostInitializeInstructionsForMintExtensions, getPostInitializeInstructionsForTokenExtensions, getPreInitializeInstructionsForMintExtensions, getReallocateDiscriminatorBytes, getReallocateInstruction, getReallocateInstructionDataCodec, getReallocateInstructionDataDecoder, getReallocateInstructionDataEncoder, getRecoverNestedAssociatedTokenDiscriminatorBytes, getRecoverNestedAssociatedTokenInstruction, getRecoverNestedAssociatedTokenInstructionAsync, getRecoverNestedAssociatedTokenInstructionDataCodec, getRecoverNestedAssociatedTokenInstructionDataDecoder, getRecoverNestedAssociatedTokenInstructionDataEncoder, getRemoveTokenMetadataKeyDiscriminatorBytes, getRemoveTokenMetadataKeyInstruction, getRemoveTokenMetadataKeyInstructionDataCodec, getRemoveTokenMetadataKeyInstructionDataDecoder, getRemoveTokenMetadataKeyInstructionDataEncoder, getResumeDiscriminatorBytes, getResumeInstruction, getResumeInstructionDataCodec, getResumeInstructionDataDecoder, getResumeInstructionDataEncoder, getResumePausableDiscriminatorBytes, getRevokeDiscriminatorBytes, getRevokeInstruction, getRevokeInstructionDataCodec, getRevokeInstructionDataDecoder, getRevokeInstructionDataEncoder, getSetAuthorityDiscriminatorBytes, getSetAuthorityInstruction, getSetAuthorityInstructionDataCodec, getSetAuthorityInstructionDataDecoder, getSetAuthorityInstructionDataEncoder, getSetTransferFeeDiscriminatorBytes, getSetTransferFeeInstruction, getSetTransferFeeInstructionDataCodec, getSetTransferFeeInstructionDataDecoder, getSetTransferFeeInstructionDataEncoder, getSetTransferFeeTransferFeeDiscriminatorBytes, getSyncNativeDiscriminatorBytes, getSyncNativeInstruction, getSyncNativeInstructionDataCodec, getSyncNativeInstructionDataDecoder, getSyncNativeInstructionDataEncoder, getThawAccountDiscriminatorBytes, getThawAccountInstruction, getThawAccountInstructionDataCodec, getThawAccountInstructionDataDecoder, getThawAccountInstructionDataEncoder, getToken2022ErrorMessage, getTokenCodec, getTokenDecoder, getTokenEncoder, getTokenMetadataFieldCodec, getTokenMetadataFieldDecoder, getTokenMetadataFieldEncoder, getTokenSize, getTransferCheckedDiscriminatorBytes, getTransferCheckedInstruction, getTransferCheckedInstructionDataCodec, getTransferCheckedInstructionDataDecoder, getTransferCheckedInstructionDataEncoder, getTransferCheckedWithFeeDiscriminatorBytes, getTransferCheckedWithFeeInstruction, getTransferCheckedWithFeeInstructionDataCodec, getTransferCheckedWithFeeInstructionDataDecoder, getTransferCheckedWithFeeInstructionDataEncoder, getTransferCheckedWithFeeTransferFeeDiscriminatorBytes, getTransferDiscriminatorBytes, getTransferFeeCodec, getTransferFeeDecoder, getTransferFeeEncoder, getTransferInstruction, getTransferInstructionDataCodec, getTransferInstructionDataDecoder, getTransferInstructionDataEncoder, getTransferTokensInstructions, getUiAmountToAmountDiscriminatorBytes, getUiAmountToAmountInstruction, getUiAmountToAmountInstructionDataCodec, getUiAmountToAmountInstructionDataDecoder, getUiAmountToAmountInstructionDataEncoder, getUpdateConfidentialTransferMintConfidentialTransferDiscriminatorBytes, getUpdateConfidentialTransferMintDiscriminatorBytes, getUpdateConfidentialTransferMintInstruction, getUpdateConfidentialTransferMintInstructionDataCodec, getUpdateConfidentialTransferMintInstructionDataDecoder, getUpdateConfidentialTransferMintInstructionDataEncoder, getUpdateDefaultAccountStateDefaultAccountStateDiscriminatorBytes, getUpdateDefaultAccountStateDiscriminatorBytes, getUpdateDefaultAccountStateInstruction, getUpdateDefaultAccountStateInstructionDataCodec, getUpdateDefaultAccountStateInstructionDataDecoder, getUpdateDefaultAccountStateInstructionDataEncoder, getUpdateGroupMemberPointerDiscriminatorBytes, getUpdateGroupMemberPointerGroupMemberPointerDiscriminatorBytes, getUpdateGroupMemberPointerInstruction, getUpdateGroupMemberPointerInstructionDataCodec, getUpdateGroupMemberPointerInstructionDataDecoder, getUpdateGroupMemberPointerInstructionDataEncoder, getUpdateGroupPointerDiscriminatorBytes, getUpdateGroupPointerGroupPointerDiscriminatorBytes, getUpdateGroupPointerInstruction, getUpdateGroupPointerInstructionDataCodec, getUpdateGroupPointerInstructionDataDecoder, getUpdateGroupPointerInstructionDataEncoder, getUpdateMetadataPointerDiscriminatorBytes, getUpdateMetadataPointerInstruction, getUpdateMetadataPointerInstructionDataCodec, getUpdateMetadataPointerInstructionDataDecoder, getUpdateMetadataPointerInstructionDataEncoder, getUpdateMetadataPointerMetadataPointerDiscriminatorBytes, getUpdateMultiplierScaledUiMintDiscriminatorBytes, getUpdateMultiplierScaledUiMintInstruction, getUpdateMultiplierScaledUiMintInstructionDataCodec, getUpdateMultiplierScaledUiMintInstructionDataDecoder, getUpdateMultiplierScaledUiMintInstructionDataEncoder, getUpdateMultiplierScaledUiMintScaledUiAmountMintDiscriminatorBytes, getUpdateRateInterestBearingMintDiscriminatorBytes, getUpdateRateInterestBearingMintInstruction, getUpdateRateInterestBearingMintInstructionDataCodec, getUpdateRateInterestBearingMintInstructionDataDecoder, getUpdateRateInterestBearingMintInstructionDataEncoder, getUpdateRateInterestBearingMintInterestBearingMintDiscriminatorBytes, getUpdateTokenGroupMaxSizeDiscriminatorBytes, getUpdateTokenGroupMaxSizeInstruction, getUpdateTokenGroupMaxSizeInstructionDataCodec, getUpdateTokenGroupMaxSizeInstructionDataDecoder, getUpdateTokenGroupMaxSizeInstructionDataEncoder, getUpdateTokenGroupUpdateAuthorityDiscriminatorBytes, getUpdateTokenGroupUpdateAuthorityInstruction, getUpdateTokenGroupUpdateAuthorityInstructionDataCodec, getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder, getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder, getUpdateTokenMetadataFieldDiscriminatorBytes, getUpdateTokenMetadataFieldInstruction, getUpdateTokenMetadataFieldInstructionDataCodec, getUpdateTokenMetadataFieldInstructionDataDecoder, getUpdateTokenMetadataFieldInstructionDataEncoder, getUpdateTokenMetadataUpdateAuthorityDiscriminatorBytes, getUpdateTokenMetadataUpdateAuthorityInstruction, getUpdateTokenMetadataUpdateAuthorityInstructionDataCodec, getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder, getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder, getUpdateTransferHookDiscriminatorBytes, getUpdateTransferHookInstruction, getUpdateTransferHookInstructionDataCodec, getUpdateTransferHookInstructionDataDecoder, getUpdateTransferHookInstructionDataEncoder, getUpdateTransferHookTransferHookDiscriminatorBytes, getWithdrawExcessLamportsDiscriminatorBytes, getWithdrawExcessLamportsInstruction, getWithdrawExcessLamportsInstructionDataCodec, getWithdrawExcessLamportsInstructionDataDecoder, getWithdrawExcessLamportsInstructionDataEncoder, getWithdrawWithheldTokensFromAccountsDiscriminatorBytes, getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes, getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeDiscriminatorBytes, getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction, getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataCodec, getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder, getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder, getWithdrawWithheldTokensFromAccountsInstruction, getWithdrawWithheldTokensFromAccountsInstructionDataCodec, getWithdrawWithheldTokensFromAccountsInstructionDataDecoder, getWithdrawWithheldTokensFromAccountsInstructionDataEncoder, getWithdrawWithheldTokensFromAccountsTransferFeeDiscriminatorBytes, getWithdrawWithheldTokensFromMintDiscriminatorBytes, getWithdrawWithheldTokensFromMintForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes, getWithdrawWithheldTokensFromMintForConfidentialTransferFeeDiscriminatorBytes, getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction, getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataCodec, getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder, getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder, getWithdrawWithheldTokensFromMintInstruction, getWithdrawWithheldTokensFromMintInstructionDataCodec, getWithdrawWithheldTokensFromMintInstructionDataDecoder, getWithdrawWithheldTokensFromMintInstructionDataEncoder, getWithdrawWithheldTokensFromMintTransferFeeDiscriminatorBytes, identifyAssociatedTokenInstruction, identifyToken2022Account, identifyToken2022Instruction, isAssociatedTokenError, isExtension, isToken2022Error, isTokenMetadataField, parseAmountToUiAmountInstruction, parseApplyConfidentialPendingBalanceInstruction, parseApproveCheckedInstruction, parseApproveConfidentialTransferAccountInstruction, parseApproveInstruction, parseBurnCheckedInstruction, parseBurnInstruction, parseCloseAccountInstruction, parseConfidentialDepositInstruction, parseConfidentialTransferInstruction, parseConfidentialTransferWithFeeInstruction, parseConfidentialWithdrawInstruction, parseConfigureConfidentialTransferAccountInstruction, parseCreateAssociatedTokenIdempotentInstruction, parseCreateAssociatedTokenInstruction, parseCreateNativeMintInstruction, parseDisableConfidentialCreditsInstruction, parseDisableCpiGuardInstruction, parseDisableHarvestToMintInstruction, parseDisableMemoTransfersInstruction, parseDisableNonConfidentialCreditsInstruction, parseEmitTokenMetadataInstruction, parseEmptyConfidentialTransferAccountInstruction, parseEnableConfidentialCreditsInstruction, parseEnableCpiGuardInstruction, parseEnableHarvestToMintInstruction, parseEnableMemoTransfersInstruction, parseEnableNonConfidentialCreditsInstruction, parseFreezeAccountInstruction, parseGetAccountDataSizeInstruction, parseHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction, parseHarvestWithheldTokensToMintInstruction, parseInitializeAccount2Instruction, parseInitializeAccount3Instruction, parseInitializeAccountInstruction, parseInitializeConfidentialTransferFeeInstruction, parseInitializeConfidentialTransferMintInstruction, parseInitializeDefaultAccountStateInstruction, parseInitializeGroupMemberPointerInstruction, parseInitializeGroupPointerInstruction, parseInitializeImmutableOwnerInstruction, parseInitializeInterestBearingMintInstruction, parseInitializeMetadataPointerInstruction, parseInitializeMint2Instruction, parseInitializeMintCloseAuthorityInstruction, parseInitializeMintInstruction, parseInitializeMultisig2Instruction, parseInitializeMultisigInstruction, parseInitializeNonTransferableMintInstruction, parseInitializePausableConfigInstruction, parseInitializePermanentDelegateInstruction, parseInitializeScaledUiAmountMintInstruction, parseInitializeTokenGroupInstruction, parseInitializeTokenGroupMemberInstruction, parseInitializeTokenMetadataInstruction, parseInitializeTransferFeeConfigInstruction, parseInitializeTransferHookInstruction, parseMintToCheckedInstruction, parseMintToInstruction, parsePauseInstruction, parseReallocateInstruction, parseRecoverNestedAssociatedTokenInstruction, parseRemoveTokenMetadataKeyInstruction, parseResumeInstruction, parseRevokeInstruction, parseSetAuthorityInstruction, parseSetTransferFeeInstruction, parseSyncNativeInstruction, parseThawAccountInstruction, parseTokenProgramAddressOrMoniker, parseTransferCheckedInstruction, parseTransferCheckedWithFeeInstruction, parseTransferInstruction, parseUiAmountToAmountInstruction, parseUpdateConfidentialTransferMintInstruction, parseUpdateDefaultAccountStateInstruction, parseUpdateGroupMemberPointerInstruction, parseUpdateGroupPointerInstruction, parseUpdateMetadataPointerInstruction, parseUpdateMultiplierScaledUiMintInstruction, parseUpdateRateInterestBearingMintInstruction, parseUpdateTokenGroupMaxSizeInstruction, parseUpdateTokenGroupUpdateAuthorityInstruction, parseUpdateTokenMetadataFieldInstruction, parseUpdateTokenMetadataUpdateAuthorityInstruction, parseUpdateTransferHookInstruction, parseWithdrawExcessLamportsInstruction, parseWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction, parseWithdrawWithheldTokensFromAccountsInstruction, parseWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction, parseWithdrawWithheldTokensFromMintInstruction, tokenAmountToUiAmount, tokenMetadataField, tokenUiAmountToAmount, uiAmountToAmountForInterestBearingMintWithoutSimulation, uiAmountToAmountForMintWithoutSimulation, uiAmountToAmountForScaledUiAmountMintWithoutSimulation } from '../../chunk-ZYQZBNRK.node.mjs';\nimport '../../chunk-VC6NKDS2.node.mjs';\n//# sourceMappingURL=index.node.mjs.map\n//# sourceMappingURL=index.node.mjs.map", "/**\n *\n */\n\ntype LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\n\nconst GILL_LOG_LEVELS: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\ndeclare global {\n  /**\n   * Whether or not to enable debug mode. When enabled, default log level of `info`\n   */\n  var __GILL_DEBUG__: boolean | undefined;\n  /**\n   * Set the a desired level of logs to be output in the application\n   *\n   * - Default: `info`\n   * - Options: `debug` | `info` | `warn` | `error`\n   */\n  var __GILL_DEBUG_LEVEL__: LogLevel | undefined;\n}\n\nconst getMinLogLevel = (): LogLevel =>\n  (process.env.GILL_DEBUG_LEVEL as LogLevel) ||\n  global.__GILL_DEBUG_LEVEL__ ||\n  (typeof window !== \"undefined\" && (window as any).__GILL_DEBUG_LEVEL__) ||\n  \"info\";\n\n/**\n * Check if the `gill` debug logger is enabled or not\n */\nexport const isDebugEnabled = (): boolean =>\n  Boolean(\n    process.env.GILL_DEBUG_LEVEL ||\n      global.__GILL_DEBUG_LEVEL__ ||\n      process.env.GILL_DEBUG === \"true\" ||\n      process.env.GILL_DEBUG === \"1\" ||\n      global.__GILL_DEBUG__ === true ||\n      (typeof window !== \"undefined\" && (window as any).__GILL_DEBUG__ === true),\n  );\n\n/**\n * Log debug messages based on the desired application's logging level.\n *\n * @param message - the message contents to be logged\n * @param level - default: `info` (see: {@link GILL_LOG_LEVELS})\n * @param prefix - default: `[GILL]`\n *\n * To enable gill's debug logger, set any of the following to `true`:\n * - `process.env.GILL_DEBUG`\n * - `global.__GILL_DEBUG__`\n * - `window.__GILL_DEBUG__`\n *\n * To set a desired level of logs to be output in the application, set the value of one of the following:\n * - `process.env.GILL_DEBUG_LEVEL`\n * - `global.__GILL_DEBUG_LEVEL__`\n * - `window.__GILL_DEBUG_LEVEL__`\n */\nexport function debug(message: unknown, level: LogLevel = \"info\", prefix: string = \"[GILL]\") {\n  if (!isDebugEnabled()) return;\n\n  if (GILL_LOG_LEVELS[level] < GILL_LOG_LEVELS[getMinLogLevel()]) return;\n\n  const formattedMessage = typeof message === \"string\" ? message : JSON.stringify(message, null, 2);\n\n  switch (level) {\n    case \"debug\":\n      console.log(prefix, formattedMessage);\n      break;\n    case \"info\":\n      console.info(prefix, formattedMessage);\n      break;\n    case \"warn\":\n      console.warn(prefix, formattedMessage);\n      break;\n    case \"error\":\n      console.error(prefix, formattedMessage);\n      break;\n  }\n}\n", "/** 1 billion lamports per SOL */\nexport const LAMPORTS_PER_SOL = 1_000_000_000;\n\n/**\n * Genesis hash for Solana network clusters\n */\nexport const GENESIS_HASH = {\n  mainnet: \"5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d\",\n  devnet: \"EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG\",\n  testnet: \"4uhcVJyU9pJkvQyS88uRDiswHXSCkY3zQawwpjk2NsNY\",\n};\n", "import {\n  assertIsTransactionSigner,\n  createNoopSigner,\n  isTransactionSigner,\n  type Address,\n  type TransactionSigner,\n} from \"@solana/kit\";\nimport type { SolanaClusterMoniker } from \"../types\";\nimport { GENESIS_HASH } from \"./const\";\n\n/**\n * Determine the Solana moniker from its genesis hash\n *\n * If the hash is NOT known, returns `unknown`\n */\nexport function getMonikerFromGenesisHash(hash: string): SolanaClusterMoniker | \"unknown\" {\n  switch (hash) {\n    case GENESIS_HASH.mainnet:\n      return \"mainnet\";\n    case GENESIS_HASH.devnet:\n      return \"devnet\";\n    case GENESIS_HASH.testnet:\n      return \"testnet\";\n    default:\n      return \"unknown\";\n  }\n}\n\nexport function checkedAddress<TAddress extends string = string>(\n  input: Address<TAddress> | TransactionSigner<TAddress>,\n): Address<TAddress> {\n  return typeof input == \"string\" ? input : input.address;\n}\n\nexport function checkedTransactionSigner<TAddress extends string = string>(\n  input: Address<TAddress> | TransactionSigner<TAddress>,\n): TransactionSigner<TAddress> {\n  if (typeof input === \"string\" || \"address\" in input == false) input = createNoopSigner(input);\n  if (!isTransactionSigner(input)) throw new Error(\"A signer or address is required\");\n  assertIsTransactionSigner(input);\n  return input;\n}\n\n/**\n * Convert a lamport number to the human readable string of a SOL value\n */\nexport function lamportsToSol(lamports: bigint | number): string {\n  // @ts-expect-error This format is valid\n  return new Intl.NumberFormat(\"en-US\", { maximumFractionDigits: 9 }).format(`${lamports}E-9`);\n}\n", "import type { DevnetUrl, MainnetUrl, TestnetUrl } from \"@solana/kit\";\nimport type { LocalnetUrl, ModifiedClusterUrl, SolanaClusterMoniker } from \"../types/rpc\";\n\nexport function localnet(putativeString: string): LocalnetUrl {\n  return putativeString as LocalnetUrl;\n}\n\n/**\n * Get a public Solana RPC endpoint for a cluster based on its moniker\n *\n * Note: These RPC URLs are rate limited and not suitable for production applications.\n */\nexport function getPublicSolanaRpcUrl(\n  cluster: SolanaClusterMoniker | \"mainnet-beta\" | \"localhost\",\n): ModifiedClusterUrl {\n  switch (cluster) {\n    case \"devnet\":\n      return \"https://api.devnet.solana.com\" as DevnetUrl;\n    case \"testnet\":\n      return \"https://api.testnet.solana.com\" as TestnetUrl;\n    case \"mainnet-beta\":\n    case \"mainnet\":\n      return \"https://api.mainnet-beta.solana.com\" as MainnetUrl;\n    case \"localnet\":\n    case \"localhost\":\n      return \"http://127.0.0.1:8899\" as LocalnetUrl;\n    default:\n      throw new Error(\"Invalid cluster moniker\");\n  }\n}\n", "import type { GetExplorerLinkArgs } from \"../types\";\n\n/**\n * Craft a Solana Explorer link on any cluster\n */\nexport function getExplorerLink(props: GetExplorerLinkArgs = {}): string {\n  let url = new URL(\"https://explorer.solana.com\");\n\n  // default to mainnet / mainnet-beta\n  if (!props.cluster || props.cluster == \"mainnet\") props.cluster = \"mainnet-beta\";\n\n  if (\"address\" in props) {\n    url.pathname = `/address/${props.address}`;\n  } else if (\"transaction\" in props) {\n    url.pathname = `/tx/${props.transaction}`;\n  } else if (\"block\" in props) {\n    url.pathname = `/block/${props.block}`;\n  }\n\n  if (props.cluster !== \"mainnet-beta\") {\n    if (props.cluster === \"localnet\" || props.cluster === \"localhost\") {\n      // localnet technically isn't a cluster, so requires special handling\n      url.searchParams.set(\"cluster\", \"custom\");\n      url.searchParams.set(\"customUrl\", \"http://localhost:8899\");\n    } else {\n      url.searchParams.set(\"cluster\", props.cluster);\n    }\n  }\n\n  return url.toString();\n}\n", "import type { Simplify } from \"../types\";\n\nimport { getSetComputeUnitLimitInstruction, getSetComputeUnitPriceInstruction } from \"@solana-program/compute-budget\";\nimport type {\n  Address,\n  TransactionMessageWithBlockhashLifetime,\n  TransactionMessageWithFeePayer,\n  TransactionMessageWithFeePayerSigner,\n  TransactionSigner,\n  TransactionVersion,\n} from \"@solana/kit\";\nimport {\n  appendTransactionMessageInstruction,\n  appendTransactionMessageInstructions,\n  createTransactionMessage,\n  isTransactionSigner,\n  pipe,\n  setTransactionMessageFeePayer,\n  setTransactionMessageFeePayerSigner,\n  setTransactionMessageLifetimeUsingBlockhash,\n} from \"@solana/kit\";\n\nimport type { CreateTransactionInput, FullTransaction } from \"../types/transactions\";\n\n/**\n * Simple interface for creating a Solana transaction\n */\nexport function createTransaction<TVersion extends TransactionVersion, TFeePayer extends TransactionSigner>(\n  props: CreateTransactionInput<TVersion, TFeePayer>,\n): FullTransaction<TVersion, TransactionMessageWithFeePayerSigner>;\nexport function createTransaction<TVersion extends TransactionVersion, TFeePayer extends Address>(\n  props: CreateTransactionInput<TVersion, TFeePayer>,\n): FullTransaction<TVersion, TransactionMessageWithFeePayer>;\nexport function createTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends TransactionSigner,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  props: CreateTransactionInput<TVersion, TFeePayer, TLifetimeConstraint>,\n): Simplify<FullTransaction<TVersion, TransactionMessageWithFeePayerSigner, TransactionMessageWithBlockhashLifetime>>;\nexport function createTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends Address,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  props: CreateTransactionInput<TVersion, TFeePayer, TLifetimeConstraint>,\n): Simplify<FullTransaction<TVersion, TransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;\nexport function createTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends Address | TransactionSigner,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  props: CreateTransactionInput<TVersion, TFeePayer, TLifetimeConstraint>,\n): Simplify<FullTransaction<TVersion, TransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;\nexport function createTransaction<TVersion extends TransactionVersion, TFeePayer extends Address | TransactionSigner>({\n  version,\n  feePayer,\n  instructions,\n  latestBlockhash,\n  computeUnitLimit,\n  computeUnitPrice,\n}: CreateTransactionInput<TVersion, TFeePayer>): FullTransaction<\n  TVersion,\n  TransactionMessageWithFeePayer | TransactionMessageWithFeePayerSigner\n> {\n  return pipe(\n    createTransactionMessage({ version: version ?? (\"legacy\" as TVersion) }),\n    (tx) => {\n      const withLifetime = latestBlockhash ? setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx) : tx;\n      if (typeof feePayer !== \"string\" && \"address\" in feePayer && isTransactionSigner(feePayer)) {\n        return setTransactionMessageFeePayerSigner(feePayer, withLifetime);\n      } else return setTransactionMessageFeePayer(feePayer, withLifetime);\n    },\n    (tx) => {\n      const withComputeLimit =\n        typeof computeUnitLimit !== \"undefined\"\n          ? appendTransactionMessageInstruction(\n              getSetComputeUnitLimitInstruction({ units: Number(computeUnitLimit) }),\n              tx,\n            )\n          : tx;\n\n      const withComputePrice =\n        typeof computeUnitPrice !== \"undefined\"\n          ? appendTransactionMessageInstruction(\n              getSetComputeUnitPriceInstruction({ microLamports: Number(computeUnitPrice) }),\n              withComputeLimit,\n            )\n          : withComputeLimit;\n\n      return appendTransactionMessageInstructions(instructions, withComputePrice);\n    },\n  );\n}\n", "import type {\n  BaseTransactionMessage,\n  CompilableTransactionMessage,\n  FullySignedTransaction,\n  GetEpochInfoApi,\n  GetLatestBlockhashApi,\n  GetSignatureStatusesApi,\n  Rpc,\n  RpcSubscriptions,\n  SendTransactionApi,\n  Signature,\n  SignatureNotificationsApi,\n  SlotNotificationsApi,\n  TransactionMessageWithFeePayer,\n  TransactionWithBlockhashLifetime,\n} from \"@solana/kit\";\nimport {\n  assertIsTransactionMessageWithBlockhashLifetime,\n  Commitment,\n  getBase64EncodedWireTransaction,\n  getSignatureFromTransaction,\n  sendAndConfirmTransactionFactory,\n  setTransactionMessageLifetimeUsingBlockhash,\n  signTransactionMessageWithSigners,\n} from \"@solana/kit\";\nimport { type waitForRecentTransactionConfirmation } from \"@solana/transaction-confirmation\";\nimport { debug } from \"./debug\";\nimport { getExplorerLink } from \"./explorer\";\n\ninterface SendAndConfirmTransactionWithBlockhashLifetimeConfig extends SendTransactionConfigWithoutEncoding {\n  confirmRecentTransaction: (\n    config: Omit<\n      Parameters<typeof waitForRecentTransactionConfirmation>[0],\n      \"getBlockHeightExceedencePromise\" | \"getRecentSignatureConfirmationPromise\"\n    >,\n  ) => Promise<void>;\n  abortSignal?: AbortSignal;\n  commitment: Commitment;\n}\n\ntype SendTransactionConfigWithoutEncoding = Omit<\n  NonNullable<Parameters<SendTransactionApi[\"sendTransaction\"]>[1]>,\n  \"encoding\"\n>;\n\ntype SendableTransaction =\n  | CompilableTransactionMessage\n  | (FullySignedTransaction & TransactionWithBlockhashLifetime)\n  | (BaseTransactionMessage & TransactionMessageWithFeePayer);\n\nexport type SendAndConfirmTransactionWithSignersFunction = (\n  transaction: SendableTransaction,\n  config?: Omit<\n    SendAndConfirmTransactionWithBlockhashLifetimeConfig,\n    \"confirmRecentTransaction\" | \"rpc\" | \"transaction\"\n  >,\n) => Promise<Signature>;\n\ntype SendAndConfirmTransactionWithSignersFactoryConfig<TCluster> = {\n  rpc: Rpc<GetEpochInfoApi & GetSignatureStatusesApi & SendTransactionApi & GetLatestBlockhashApi> & {\n    \"~cluster\"?: TCluster;\n  };\n  rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi & SlotNotificationsApi> & {\n    \"~cluster\"?: TCluster;\n  };\n};\n\nexport function sendAndConfirmTransactionWithSignersFactory({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<\"devnet\">): SendAndConfirmTransactionWithSignersFunction;\nexport function sendAndConfirmTransactionWithSignersFactory({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<\"testnet\">): SendAndConfirmTransactionWithSignersFunction;\nexport function sendAndConfirmTransactionWithSignersFactory({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<\"mainnet\">): SendAndConfirmTransactionWithSignersFunction;\nexport function sendAndConfirmTransactionWithSignersFactory({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<\"localnet\">): SendAndConfirmTransactionWithSignersFunction;\nexport function sendAndConfirmTransactionWithSignersFactory<\n  TCluster extends \"devnet\" | \"mainnet\" | \"testnet\" | \"localnet\" | undefined = undefined,\n>({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<TCluster>): SendAndConfirmTransactionWithSignersFunction {\n  // @ts-ignore - TODO(FIXME)\n  const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });\n  return async function sendAndConfirmTransactionWithSigners(transaction, config = { commitment: \"confirmed\" }) {\n    if (\"messageBytes\" in transaction == false) {\n      if (\"lifetimeConstraint\" in transaction === false) {\n        const { value: latestBlockhash } = await rpc.getLatestBlockhash().send({ abortSignal: config.abortSignal });\n        transaction = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, transaction);\n        assertIsTransactionMessageWithBlockhashLifetime(transaction);\n      }\n      transaction = (await signTransactionMessageWithSigners(transaction)) as Readonly<\n        FullySignedTransaction & TransactionWithBlockhashLifetime\n      >;\n    }\n    debug(`Sending transaction: ${getExplorerLink({ transaction: getSignatureFromTransaction(transaction) })}`);\n    debug(`Transaction as base64: ${getBase64EncodedWireTransaction(transaction)}`, \"debug\");\n    await sendAndConfirmTransaction(transaction, config);\n    return getSignatureFromTransaction(transaction);\n  };\n}\n", "import { COMPUTE_BUDGET_PROGRAM_ADDRESS, ComputeBudgetInstruction } from \"@solana-program/compute-budget\";\nimport type { IInstruction, IInstructionWithData, TransactionMessage } from \"@solana/kit\";\nimport { isInstructionForProgram, isInstructionWithData } from \"@solana/kit\";\n\n/**\n * Check if a given instruction is a `SetComputeUnitLimit` instruction\n */\nexport function isSetComputeLimitInstruction(\n  instruction: IInstruction,\n): instruction is IInstruction<typeof COMPUTE_BUDGET_PROGRAM_ADDRESS> & IInstructionWithData<Uint8Array> {\n  return (\n    isInstructionForProgram(instruction, COMPUTE_BUDGET_PROGRAM_ADDRESS) &&\n    isInstructionWithData(instruction) &&\n    instruction.data[0] === ComputeBudgetInstruction.SetComputeUnitLimit\n  );\n}\n\n/**\n * Check if a given transaction contains a `SetComputeUnitLimit` instruction\n */\nexport function hasSetComputeLimitInstruction(tx: TransactionMessage): boolean {\n  return tx.instructions.filter(isSetComputeLimitInstruction).length == 1;\n}\n\n/**\n * Check if a given instruction is a `SetComputeUnitPrice` instruction\n */\nexport function isSetComputeUnitPriceInstruction(\n  instruction: IInstruction,\n): instruction is IInstruction<typeof COMPUTE_BUDGET_PROGRAM_ADDRESS> & IInstructionWithData<Uint8Array> {\n  return (\n    isInstructionForProgram(instruction, COMPUTE_BUDGET_PROGRAM_ADDRESS) &&\n    isInstructionWithData(instruction) &&\n    instruction.data[0] === ComputeBudgetInstruction.SetComputeUnitPrice\n  );\n}\n\n/**\n * Check if a given transaction contains a `SetComputeUnitPrice` instruction\n */\nexport function hasSetComputeUnitPriceInstruction(tx: TransactionMessage): boolean {\n  return tx.instructions.filter(isSetComputeUnitPriceInstruction).length == 1;\n}\n", "import type { Base64EncodedWireTransaction, CompilableTransactionMessage, Transaction } from \"@solana/kit\";\nimport {\n  compileTransaction,\n  getBase64EncodedWireTransaction,\n  partiallySignTransactionMessageWithSigners,\n  pipe,\n} from \"@solana/kit\";\n\n/**\n * Compile a transaction to a base64 string\n *\n * Note: This will NOT attempt to sign the transaction,\n * so it will be missing `signatures` from any of the attached Signers\n *\n * Use {@link transactionToBase64WithSignatures} sign and base64 encode\n */\nexport function transactionToBase64(tx: CompilableTransactionMessage | Transaction): Base64EncodedWireTransaction {\n  if (\"messageBytes\" in tx) return pipe(tx, getBase64EncodedWireTransaction);\n  else return pipe(tx, compileTransaction, getBase64EncodedWireTransaction);\n}\n\n/**\n * Compile a transaction to a base64 string and sign it with all attached Signers\n *\n * See also {@link partiallySignTransactionMessageWithSigners}\n */\nexport async function transactionToBase64WithSigners(\n  tx: CompilableTransactionMessage | Transaction,\n): Promise<Base64EncodedWireTransaction> {\n  if (\"messageBytes\" in tx) return transactionToBase64(tx);\n  else return transactionToBase64(await partiallySignTransactionMessageWithSigners(tx));\n}\n", "import { COMPUTE_BUDGET_PROGRAM_ADDRESS, getSetComputeUnitLimitInstruction } from \"@solana-program/compute-budget\";\nimport type {\n  CompilableTransactionMessage,\n  GetLatestBlockhashApi,\n  ITransactionMessageWithFeePayer,\n  Rpc,\n  SimulateTransactionApi,\n  TransactionMessage,\n  TransactionMessageWithBlockhashLifetime,\n} from \"@solana/kit\";\nimport {\n  appendTransactionMessageInstruction,\n  assertIsTransactionMessageWithBlockhashLifetime,\n  getComputeUnitEstimateForTransactionMessageFactory,\n  setTransactionMessageLifetimeUsingBlockhash,\n} from \"@solana/kit\";\nimport { isSetComputeLimitInstruction } from \"../programs/compute-budget\";\nimport { transactionToBase64WithSigners } from \"./base64-to-transaction\";\nimport { debug, isDebugEnabled } from \"./debug\";\n\ntype PrepareCompilableTransactionMessage =\n  | CompilableTransactionMessage\n  | (ITransactionMessageWithFeePayer & TransactionMessage);\n\nexport type PrepareTransactionConfig<TMessage extends PrepareCompilableTransactionMessage> = {\n  /**\n   * Transaction to prepare for sending to the blockchain\n   */\n  transaction: TMessage;\n  /**\n   * RPC client capable of simulating transactions and getting the latest blockhash\n   **/\n  rpc: Rpc<GetLatestBlockhashApi & SimulateTransactionApi>;\n  /**\n   * Multiplier applied to the simulated compute unit value obtained from simulation\n   *\n   * Default: `1.1`\n   **/\n  computeUnitLimitMultiplier?: number;\n  /**\n   * Whether or not you wish to force reset the compute unit limit value (if one is already set)\n   * using the simulation response and `computeUnitLimitMultiplier`\n   **/\n  computeUnitLimitReset?: boolean;\n  /**\n   * Whether or not you wish to force reset the latest blockhash (if one is already set)\n   *\n   * Default: `true`\n   **/\n  blockhashReset?: boolean;\n};\n\n/**\n * Prepare a Transaction to be signed and sent to the network. Including:\n * - setting a compute unit limit (if not already set)\n * - fetching the latest blockhash (if not already set)\n * - (optional) simulating and resetting the compute unit limit\n * - (optional) resetting latest blockhash to the most recent\n */\nexport async function prepareTransaction<TMessage extends PrepareCompilableTransactionMessage>(\n  config: PrepareTransactionConfig<TMessage>,\n): Promise<TMessage & TransactionMessageWithBlockhashLifetime> {\n  // set the config defaults\n  if (!config.computeUnitLimitMultiplier) config.computeUnitLimitMultiplier = 1.1;\n  if (config.blockhashReset !== false) config.blockhashReset = true;\n\n  const computeBudgetIndex = {\n    limit: -1,\n    price: -1,\n  };\n\n  config.transaction.instructions.map((ix, index) => {\n    if (ix.programAddress != COMPUTE_BUDGET_PROGRAM_ADDRESS) return;\n\n    if (isSetComputeLimitInstruction(ix)) {\n      computeBudgetIndex.limit = index;\n    }\n    // else if (isSetComputeUnitPriceInstruction(ix)) {\n    //   computeBudgetIndex.price = index;\n    // }\n  });\n\n  // set a compute unit limit instruction\n  if (computeBudgetIndex.limit < 0 || config.computeUnitLimitReset) {\n    const units = await getComputeUnitEstimateForTransactionMessageFactory({ rpc: config.rpc })(config.transaction);\n    debug(`Obtained compute units from simulation: ${units}`, \"debug\");\n    const ix = getSetComputeUnitLimitInstruction({\n      units: units * config.computeUnitLimitMultiplier,\n    });\n\n    if (computeBudgetIndex.limit < 0) {\n      config.transaction = appendTransactionMessageInstruction(ix, config.transaction) as unknown as TMessage;\n    } else if (config.computeUnitLimitReset) {\n      const nextInstructions = [...config.transaction.instructions];\n      nextInstructions.splice(computeBudgetIndex.limit, 1, ix);\n      config.transaction = Object.freeze({\n        ...config.transaction,\n        instructions: nextInstructions,\n      } as TMessage);\n    }\n  }\n\n  // update the latest blockhash\n  if (config.blockhashReset || \"lifetimeConstraint\" in config.transaction == false) {\n    const { value: latestBlockhash } = await config.rpc.getLatestBlockhash().send();\n    if (\"lifetimeConstraint\" in config.transaction == false) {\n      debug(\"Transaction missing latest blockhash, fetching one.\", \"debug\");\n      config.transaction = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, config.transaction) as unknown as TMessage;\n    } else if (config.blockhashReset) {\n      debug(\"Auto resetting the latest blockhash.\", \"debug\");\n      config.transaction = Object.freeze({\n        ...config.transaction,\n        lifetimeConstraint: latestBlockhash,\n      } as TransactionMessageWithBlockhashLifetime & typeof config.transaction);\n    }\n  }\n\n  assertIsTransactionMessageWithBlockhashLifetime(config.transaction);\n\n  // skip the async call if debugging is off\n  if (isDebugEnabled()) {\n    debug(`Transaction as base64: ${await transactionToBase64WithSigners(config.transaction)}`, \"debug\");\n  }\n\n  return config.transaction;\n}\n", "import type { CompilableTransactionMessage, Rpc, SimulateTransactionApi, Transaction } from \"@solana/kit\";\nimport { getBase64EncodedWireTransaction, partiallySignTransactionMessageWithSigners } from \"@solana/kit\";\nimport type { Simplify } from \"./../types/index\";\n\nexport type SimulateTransactionFunction = (\n  transaction: Transaction | CompilableTransactionMessage,\n  config?: Simplify<Omit<Parameters<SimulateTransactionApi[\"simulateTransaction\"]>[1], \"encoding\" | \"sigVerify\">>,\n) => Promise<ReturnType<SimulateTransactionApi[\"simulateTransaction\"]>>;\n\ntype SimulateTransactionFactoryConfig<TCluster> = {\n  rpc: Rpc<SimulateTransactionApi> & {\n    \"~cluster\"?: TCluster;\n  };\n};\n\nexport function simulateTransactionFactory({\n  rpc,\n}: SimulateTransactionFactoryConfig<\"devnet\">): SimulateTransactionFunction;\nexport function simulateTransactionFactory({\n  rpc,\n}: SimulateTransactionFactoryConfig<\"testnet\">): SimulateTransactionFunction;\nexport function simulateTransactionFactory({\n  rpc,\n}: SimulateTransactionFactoryConfig<\"mainnet\">): SimulateTransactionFunction;\nexport function simulateTransactionFactory({\n  rpc,\n}: SimulateTransactionFactoryConfig<\"localnet\">): SimulateTransactionFunction;\nexport function simulateTransactionFactory<\n  TCluster extends \"devnet\" | \"mainnet\" | \"testnet\" | \"localnet\" | void = void,\n>({ rpc }: SimulateTransactionFactoryConfig<TCluster>): SimulateTransactionFunction {\n  return async function simulateTransaction(transaction, config) {\n    if (\"messageBytes\" in transaction == false) {\n      transaction = await partiallySignTransactionMessageWithSigners(transaction);\n    }\n\n    return rpc\n      .simulateTransaction(getBase64EncodedWireTransaction(transaction), {\n        replaceRecentBlockhash: true,\n        // innerInstructions: true,\n        ...config,\n        sigVerify: false,\n        encoding: \"base64\",\n      })\n      .send();\n  };\n}\n", "import type { DevnetUrl, MainnetUrl, TestnetUrl } from \"@solana/kit\";\nimport { createSolanaRpc, createSolanaRpcSubscriptions } from \"@solana/kit\";\n\nimport type { CreateSolanaClientArgs, LocalnetUrl, ModifiedClusterUrl, SolanaClient } from \"../types/rpc\";\nimport { getPublicSolanaRpcUrl } from \"./rpc\";\nimport { sendAndConfirmTransactionWithSignersFactory } from \"./send-and-confirm-transaction-with-signers\";\nimport { simulateTransactionFactory } from \"./simulate-transaction\";\n\n/**\n * Create a Solana `rpc` and `rpcSubscriptions` client\n */\nexport function createSolanaClient(\n  props: Omit<CreateSolanaClientArgs<MainnetUrl | \"mainnet\">, \"urlOrMoniker\"> & {\n    urlOrMoniker: \"mainnet\";\n  },\n): SolanaClient<MainnetUrl>;\nexport function createSolanaClient(\n  props: Omit<CreateSolanaClientArgs<DevnetUrl | \"devnet\">, \"urlOrMoniker\"> & {\n    urlOrMoniker: \"devnet\";\n  },\n): SolanaClient<DevnetUrl>;\nexport function createSolanaClient(\n  props: Omit<CreateSolanaClientArgs<TestnetUrl | \"testnet\">, \"urlOrMoniker\"> & {\n    urlOrMoniker: \"testnet\";\n  },\n): SolanaClient<TestnetUrl>;\nexport function createSolanaClient(\n  props: Omit<CreateSolanaClientArgs<LocalnetUrl | \"localnet\">, \"urlOrMoniker\"> & {\n    urlOrMoniker: \"localnet\";\n  },\n): SolanaClient<LocalnetUrl>;\nexport function createSolanaClient<TClusterUrl extends ModifiedClusterUrl>(\n  props: CreateSolanaClientArgs<TClusterUrl>,\n): SolanaClient<TClusterUrl>;\nexport function createSolanaClient<TCluster extends ModifiedClusterUrl>({\n  urlOrMoniker,\n  rpcConfig,\n  rpcSubscriptionsConfig,\n}: CreateSolanaClientArgs<TCluster>) {\n  if (!urlOrMoniker) throw new Error(\"Cluster url or moniker is required\");\n  if (urlOrMoniker instanceof URL == false) {\n    try {\n      urlOrMoniker = new URL(urlOrMoniker.toString());\n    } catch (err) {\n      try {\n        urlOrMoniker = new URL(getPublicSolanaRpcUrl(urlOrMoniker.toString() as any));\n      } catch (err) {\n        throw new Error(\"Invalid URL or cluster moniker\");\n      }\n    }\n  }\n\n  if (!urlOrMoniker.protocol.match(/^https?/i)) {\n    throw new Error(\"Unsupported protocol. Only HTTP and HTTPS are supported\");\n  }\n\n  if (rpcConfig?.port) {\n    urlOrMoniker.port = rpcConfig.port.toString();\n  }\n\n  const rpc = createSolanaRpc<TCluster>(urlOrMoniker.toString() as TCluster, rpcConfig);\n\n  urlOrMoniker.protocol = urlOrMoniker.protocol.replace('http', 'ws');\n\n  if (rpcSubscriptionsConfig?.port) {\n    urlOrMoniker.port = rpcSubscriptionsConfig.port.toString();\n  } else if (urlOrMoniker.hostname == \"localhost\" || urlOrMoniker.hostname.startsWith(\"127\")) {\n    urlOrMoniker.port = \"8900\";\n  }\n\n  const rpcSubscriptions = createSolanaRpcSubscriptions<TCluster>(\n    urlOrMoniker.toString() as TCluster,\n    rpcSubscriptionsConfig,\n  );\n\n  return {\n    rpc,\n    rpcSubscriptions,\n    sendAndConfirmTransaction: sendAndConfirmTransactionWithSignersFactory({\n      // @ts-ignore - TODO(FIXME:nick)\n      rpc,\n      // @ts-ignore - TODO(FIXME:nick)\n      rpcSubscriptions,\n    }),\n    // @ts-ignore\n    simulateTransaction: simulateTransactionFactory({ rpc }),\n  };\n}\n", "/**\n * Calculate the total rent needed for to create an account, with or without extra data stored in it\n */\nexport function getMinimumBalanceForRentExemption(space: bigint | number = 0) {\n  /**\n   * Default values for Rent calculations\n   *\n   * Values taken from: https://github.com/anza-xyz/solana-sdk/blob/c07f692e41d757057c8700211a9300cdcd6d33b1/rent/src/lib.rs#L93-L97\n   * \n   */\n  const RENT = {\n    /**\n     * Account storage overhead for calculation of base rent. (aka the number of bytes required to store an account with no data.\n     */\n    ACCOUNT_STORAGE_OVERHEAD: 128n,\n    /**\n     * Amount of time (in years) a balance must include rent for the account to\n     * be rent exempt.\n     */\n    DEFAULT_EXEMPTION_THRESHOLD: BigInt(Math.floor(2.0 * 1000)) / 1000n,\n    /**\n     * Default rental rate in lamports/byte-year. This calculation is based on:\n     * - 10^9 lamports per SOL\n     * - $1 per SOL\n     * - $0.01 per megabyte day\n     * - $3.65 per megabyte year\n     */\n    DEFAULT_LAMPORTS_PER_BYTE_YEAR: BigInt(\n      Math.floor(((1_000_000_000 / 100) * 365) / (1024 * 1024)),\n    ),\n  };\n\n  return (\n    ((RENT.ACCOUNT_STORAGE_OVERHEAD + BigInt(space)) *\n      RENT.DEFAULT_LAMPORTS_PER_BYTE_YEAR *\n      RENT.DEFAULT_EXEMPTION_THRESHOLD) /\n    1n\n  );\n}\n", "import { assertKeyExporterIsAvailable, assertKeyGenerationIsAvailable } from \"@solana/assertions\";\nimport type { KeyPairSigner, createKeyPairFromBytes, createKeyPairSignerFromBytes } from \"@solana/kit\";\nimport { createSignerFromKeyPair } from \"@solana/kit\";\n\nexport function assertKeyPairIsExtractable(keyPair: CryptoKeyPair): asserts keyPair is ExtractableCryptoKeyPair {\n  assertKeyExporterIsAvailable();\n\n  if (!keyPair.privateKey) {\n    throw new Error(\"Keypair is missing private key\");\n  }\n\n  if (!keyPair.publicKey) {\n    throw new Error(\"Keypair is missing public key\");\n  }\n\n  if (!keyPair.privateKey.extractable) {\n    throw new Error(\"Private key is not extractable\");\n  }\n}\n\ntype Extractable = { \"~extractable\": true };\n\ntype ExtractableCryptoKeyPair = CryptoKeyPair & Extractable;\ntype ExtractableKeyPairSigner = KeyPairSigner & Extractable;\n\n/**\n * Generates an extractable Ed25519 `CryptoKeyPair` capable of signing messages and transactions\n * */\nexport async function generateExtractableKeyPair(): Promise<ExtractableCryptoKeyPair> {\n  await assertKeyGenerationIsAvailable();\n  return crypto.subtle.generateKey(\n    /* algorithm */ \"Ed25519\", // Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20\n    /* extractable */ true,\n    /* allowed uses */ [\"sign\", \"verify\"],\n  ) as Promise<ExtractableCryptoKeyPair>;\n}\n\n/**\n * Generates an extractable signer capable of signing messages and transactions using a Crypto KeyPair.\n * */\nexport async function generateExtractableKeyPairSigner(): Promise<ExtractableKeyPairSigner> {\n  return createSignerFromKeyPair(await generateExtractableKeyPair()) as Promise<ExtractableKeyPairSigner>;\n}\n\n/**\n * Extracts the raw key material from an extractable Ed25519 CryptoKeyPair.\n *\n * @remarks\n * - Requires a keypair generated with extractable=true. See {@link generateExtractableKeyPair}.\n * - The extracted bytes can be used to reconstruct the `CryptoKeyPair` with {@link createKeyPairFromBytes}.\n *\n * @param keypair An extractable Ed25519 `CryptoKeyPair`\n * @returns Raw key bytes as `Uint8Array`\n */\nexport async function extractBytesFromKeyPair(keypair: ExtractableCryptoKeyPair | CryptoKeyPair): Promise<Uint8Array> {\n  assertKeyPairIsExtractable(keypair);\n\n  const [publicKeyBytes, privateKeyJwk] = await Promise.all([\n    crypto.subtle.exportKey(\"raw\", keypair.publicKey),\n    crypto.subtle.exportKey(\"jwk\", keypair.privateKey),\n  ]);\n\n  if (!privateKeyJwk.d) throw new Error(\"Failed to get private key bytes\");\n\n  return new Uint8Array([...Buffer.from(privateKeyJwk.d, \"base64\"), ...new Uint8Array(publicKeyBytes)]);\n}\n\n/**\n * Extracts the raw key material from an extractable Ed25519 KeyPairSigner.\n *\n * @remarks\n * - Requires a keypair generated with extractable=true. See {@link generateExtractableKeyPairSigner}.\n * - The extracted bytes can be used to reconstruct the `CryptoKeyPair` with {@link createKeyPairSignerFromBytes}.\n *\n * @param keypairSigner An extractable Ed25519 `KeyPairSigner`\n * @returns Raw key bytes as `Uint8Array`\n */\nexport async function extractBytesFromKeyPairSigner(\n  keypairSigner: ExtractableKeyPairSigner | KeyPairSigner,\n): Promise<Uint8Array> {\n  return extractBytesFromKeyPair(keypairSigner.keyPair);\n}\n", "import { createKeyPairFromBytes, createSignerFromKeyPair, getBase58Encoder, type KeyPairSigner } from \"@solana/kit\";\n\n/**\n * Create a `CryptoKeyPair` from as base58 encoded secret key\n */\nexport async function createKeypairFromBase58(punitiveSecretKey: string): Promise<CryptoKeyPair> {\n  return createKeyPairFromBytes(getBase58Encoder().encode(punitiveSecretKey));\n}\n\n/**\n * Create a `KeyPairSigner` from as base58 encoded secret key\n */\nexport async function createKeypairSignerFromBase58(punitiveSecretKey: string): Promise<KeyPairSigner> {\n  return createSignerFromKeyPair(await createKeypairFromBase58(punitiveSecretKey));\n}\n", "import { getBase64Encoder, getTransactionDecoder, type Transaction } from \"@solana/kit\";\nimport type { transactionToBase64, transactionToBase64WithSigners } from \"./base64-to-transaction\";\n\n/**\n * Convert a base64 encoded transaction string into compiled transaction\n *\n * Use {@link transactionToBase64} or {@link transactionToBase64WithSigners} to create the base64 encoded transaction string\n */\nexport function transactionFromBase64(base64EncodedTransaction: string): Transaction {\n  return getTransactionDecoder().decode(getBase64Encoder().encode(base64EncodedTransaction));\n}\n", "import type { Simplify } from \"../types/index\";\n\nimport type { Address, GetSignaturesForAddressApi, Rpc } from \"@solana/kit\";\nimport { isSolanaError, SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN, SolanaError } from \"@solana/kit\";\n\ntype GetOldestSignatureForAddressRpc<TCluster> = Rpc<GetSignaturesForAddressApi> & {\n  \"~cluster\"?: TCluster;\n};\n\ntype GetOldestSignatureForAddressConfig = Simplify<\n  Parameters<GetSignaturesForAddressApi[\"getSignaturesForAddress\"]>[1]\n> & { abortSignal?: AbortSignal };\n\n/**\n * Get the oldest signature for the provided `address`\n */\nexport async function getOldestSignatureForAddress<TCluster>(\n  rpc: GetOldestSignatureForAddressRpc<TCluster>,\n  address: Address,\n  config?: GetOldestSignatureForAddressConfig,\n): Promise<ReturnType<GetSignaturesForAddressApi[\"getSignaturesForAddress\"]>[0]> {\n  const signatures = await rpc.getSignaturesForAddress(address, config).send({ abortSignal: config?.abortSignal });\n\n  if (!signatures.length) {\n    throw new SolanaError(SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN, {\n      errorName: \"OldestSignatureNotFound\",\n    });\n  }\n\n  const oldest = signatures[signatures.length - 1];\n  if (signatures.length < (config?.limit || 1000)) return oldest;\n\n  try {\n    // if signatures are found to the limit, recurse for find the oldest\n    return await getOldestSignatureForAddress(rpc, address, { ...config, before: oldest.signature });\n  } catch (err) {\n    // if signatures found were exactly at the limit, there will be no more to find, so we return the oldest\n    if (isSolanaError(err, SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN)) return oldest;\n    throw err;\n  }\n}\n", "import type { Address, BaseTransactionMessage } from \"@solana/kit\";\nimport { AccountRole, SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR, SolanaError } from \"@solana/kit\";\nimport type { getOldestSignatureForAddress } from \"./get-oldest-signature\";\n\n/**\n * Insert a single of reference key {@link Address} into a transaction message\n *\n * Use {@link getOldestSignatureForAddress} to locate the oldest signature for a reference key's address\n *\n * Note: The `transaction` must have at least one non-memo instruction.\n */\nexport function insertReferenceKeyToTransactionMessage<TTransaction extends BaseTransactionMessage>(\n  reference: Address,\n  transaction: TTransaction,\n): TTransaction {\n  return insertReferenceKeysToTransactionMessage([reference], transaction);\n}\n\n/**\n * Insert multiple reference key {@link Address | Addresses} into a transaction message\n *\n * Use {@link getOldestSignatureForAddress} to locate the oldest signature for a reference key's address\n *\n * Note: The `transaction` must have at least one non-memo instruction.\n */\nexport function insertReferenceKeysToTransactionMessage<TTransaction extends BaseTransactionMessage>(\n  references: Address[],\n  transaction: TTransaction,\n): TTransaction {\n  const nonMemoIndex = transaction.instructions.findIndex(\n    (ix) => ix.programAddress !== \"MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr\",\n  );\n\n  if (transaction.instructions.length == 0 || nonMemoIndex == -1) {\n    throw new SolanaError(SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR, {\n      index: transaction.instructions.length || nonMemoIndex,\n      cause: \"At least one non-memo instruction is required\",\n    });\n  }\n\n  const modifiedIx = {\n    ...transaction.instructions[nonMemoIndex],\n    accounts: [\n      ...(transaction.instructions[nonMemoIndex].accounts || []),\n      // actually insert the reference keys\n      ...references.map((ref) => ({\n        address: ref,\n        role: AccountRole.READONLY,\n      })),\n    ],\n  };\n\n  const instructions = [...transaction.instructions];\n  instructions.splice(nonMemoIndex, 1, modifiedIx);\n\n  return Object.freeze({\n    ...transaction,\n    instructions: Object.freeze(instructions),\n  });\n}\n", "/**\n * Codama dependency map to utilize gill imports\n */\nexport const GILL_EXTERNAL_MODULE_MAP: Record<string, string> = {\n  solanaAccounts: \"gill\",\n  solanaAddresses: \"gill\",\n  solanaCodecsCore: \"gill\",\n  solanaCodecsDataStructures: \"gill\",\n  solanaCodecsNumbers: \"gill\",\n  solanaCodecsStrings: \"gill\",\n  solanaErrors: \"gill\",\n  solanaInstructions: \"gill\",\n  solanaOptions: \"gill\",\n  solanaPrograms: \"gill\",\n  solanaRpcTypes: \"gill\",\n  solanaSigners: \"gill\",\n};\n\n/**\n * Create a Codama CLI configuration to generate a program client from an IDL.\n * Normally saved to `codama.js`.\n *\n * @example\n * ```ts\n * import { createCodamaConfig } from \"gill\";\n *\n * export default createCodamaConfig({\n *  idl: \"program/idl.json\",\n *  clientJs: \"clients/js/src/generated\",\n *  // clientRust: \"clients/rust/src/generated\",\n * });\n * ```\n */\nexport function createCodamaConfig({\n  idl,\n  clientJs,\n  clientRust,\n  dependencyMap = GILL_EXTERNAL_MODULE_MAP,\n}: {\n  idl: string;\n  clientJs: string;\n  clientRust?: string;\n  dependencyMap?: Record<string, string>;\n}) {\n  return {\n    idl,\n    scripts: {\n      js: {\n        args: [clientJs, { dependencyMap }],\n        from: \"@codama/renderers-js\",\n      },\n      rust: clientRust\n        ? {\n            from: \"@codama/renderers-rust\",\n            args: [\n              clientRust,\n              {\n                crateFolder: \"clients/rust\",\n                formatCode: true,\n              },\n            ],\n          }\n        : undefined,\n    },\n  };\n}\n", "import {\n    type FetchAccountConfig,\n    fetchEncodedAccount,\n    fetchJsonParsedAccount,\n    type MaybeAccount,\n    type MaybeEncodedAccount,\n} from '@solana/accounts';\nimport type { Address } from '@solana/addresses';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { JsonParsedSysvarAccount } from '@solana/rpc-parsed-types';\nimport type { Rpc } from '@solana/rpc-spec';\n\nexport const SYSVAR_CLOCK_ADDRESS =\n    'SysvarC1ock11111111111111111111111111111111' as Address<'SysvarC1ock11111111111111111111111111111111'>;\nexport const SYSVAR_EPOCH_REWARDS_ADDRESS =\n    'SysvarEpochRewards1111111111111111111111111' as Address<'SysvarEpochRewards1111111111111111111111111'>;\nexport const SYSVAR_EPOCH_SCHEDULE_ADDRESS =\n    'SysvarEpochSchedu1e111111111111111111111111' as Address<'SysvarEpochSchedu1e111111111111111111111111'>;\nexport const SYSVAR_INSTRUCTIONS_ADDRESS =\n    'Sysvar1nstructions1111111111111111111111111' as Address<'Sysvar1nstructions1111111111111111111111111'>;\nexport const SYSVAR_LAST_RESTART_SLOT_ADDRESS =\n    'SysvarLastRestartS1ot1111111111111111111111' as Address<'SysvarLastRestartS1ot1111111111111111111111'>;\nexport const SYSVAR_RECENT_BLOCKHASHES_ADDRESS =\n    'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\nexport const SYSVAR_RENT_ADDRESS =\n    'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\nexport const SYSVAR_SLOT_HASHES_ADDRESS =\n    'SysvarS1otHashes111111111111111111111111111' as Address<'SysvarS1otHashes111111111111111111111111111'>;\nexport const SYSVAR_SLOT_HISTORY_ADDRESS =\n    'SysvarS1otHistory11111111111111111111111111' as Address<'SysvarS1otHistory11111111111111111111111111'>;\nexport const SYSVAR_STAKE_HISTORY_ADDRESS =\n    'SysvarStakeHistory1111111111111111111111111' as Address<'SysvarStakeHistory1111111111111111111111111'>;\n\ntype SysvarAddress =\n    | typeof SYSVAR_CLOCK_ADDRESS\n    | typeof SYSVAR_EPOCH_REWARDS_ADDRESS\n    | typeof SYSVAR_EPOCH_SCHEDULE_ADDRESS\n    | typeof SYSVAR_INSTRUCTIONS_ADDRESS\n    | typeof SYSVAR_LAST_RESTART_SLOT_ADDRESS\n    | typeof SYSVAR_RECENT_BLOCKHASHES_ADDRESS\n    | typeof SYSVAR_RENT_ADDRESS\n    | typeof SYSVAR_SLOT_HASHES_ADDRESS\n    | typeof SYSVAR_SLOT_HISTORY_ADDRESS\n    | typeof SYSVAR_STAKE_HISTORY_ADDRESS;\n\n/**\n * Fetch an encoded sysvar account.\n *\n * Sysvars are special accounts that contain dynamically-updated data about the network cluster, the\n * blockchain history, and the executing transaction.\n */\nexport async function fetchEncodedSysvarAccount<TAddress extends SysvarAddress>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: TAddress,\n    config?: FetchAccountConfig,\n): Promise<MaybeEncodedAccount<TAddress>> {\n    return await fetchEncodedAccount<TAddress>(rpc, address, config);\n}\n\n/**\n * Fetch a JSON-parsed sysvar account.\n *\n * Sysvars are special accounts that contain dynamically-updated data about the network cluster, the\n * blockchain history, and the executing transaction.\n */\nexport async function fetchJsonParsedSysvarAccount<TAddress extends SysvarAddress>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: TAddress,\n    config?: FetchAccountConfig,\n): Promise<MaybeAccount<JsonParsedSysvarAccount, TAddress> | MaybeEncodedAccount<TAddress>> {\n    return await fetchJsonParsedAccount<JsonParsedSysvarAccount, TAddress>(rpc, address, config);\n}\n", "import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getI64Decoder,\n    getI64Encoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Epoch, Slot, UnixTimestamp } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_CLOCK_ADDRESS } from './sysvar';\n\ntype SysvarClockSize = 40;\n\n/**\n * Contains data on cluster time, including the current slot, epoch, and estimated wall-clock Unix\n * timestamp. It is updated every slot.\n */\nexport type SysvarClock = Readonly<{\n    /** The current epoch */\n    epoch: Epoch;\n    /**\n     * The Unix timestamp of the first slot in this epoch.\n     *\n     * In the first slot of an epoch, this timestamp is identical to the `unixTimestamp`.\n     */\n    epochStartTimestamp: UnixTimestamp;\n    /** The most recent epoch for which the leader schedule has already been generated */\n    leaderScheduleEpoch: Epoch;\n    /** The current slot */\n    slot: Slot;\n    /** The Unix timestamp of this slot */\n    unixTimestamp: UnixTimestamp;\n}>;\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarClock} to a byte array representing\n * the `Clock` sysvar's account data.\n */\nexport function getSysvarClockEncoder(): FixedSizeEncoder<SysvarClock, SysvarClockSize> {\n    return getStructEncoder([\n        ['slot', getU64Encoder()],\n        ['epochStartTimestamp', getI64Encoder()],\n        ['epoch', getU64Encoder()],\n        ['leaderScheduleEpoch', getU64Encoder()],\n        ['unixTimestamp', getI64Encoder()],\n    ]) as FixedSizeEncoder<SysvarClock, SysvarClockSize>;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `Clock` sysvar's\n * account data to a {@link SysvarClock}.\n */\nexport function getSysvarClockDecoder(): FixedSizeDecoder<SysvarClock, SysvarClockSize> {\n    return getStructDecoder([\n        ['slot', getU64Decoder()],\n        ['epochStartTimestamp', getI64Decoder()],\n        ['epoch', getU64Decoder()],\n        ['leaderScheduleEpoch', getU64Decoder()],\n        ['unixTimestamp', getI64Decoder()],\n    ]) as FixedSizeDecoder<SysvarClock, SysvarClockSize>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarClock}\n *\n * @see {@link getSysvarClockDecoder}\n * @see {@link getSysvarClockEncoder}\n */\nexport function getSysvarClockCodec(): FixedSizeCodec<SysvarClock, SysvarClock, SysvarClockSize> {\n    return combineCodec(getSysvarClockEncoder(), getSysvarClockDecoder());\n}\n\n/**\n * Fetches the `Clock` sysvar account using any RPC that supports the {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarClock(rpc: Rpc<GetAccountInfoApi>, config?: FetchAccountConfig): Promise<SysvarClock> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_CLOCK_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarClockDecoder());\n    return decoded.data;\n}\n", "import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getBooleanDecoder,\n    getBooleanEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n    getU128Decoder,\n    getU128Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport {\n    Blockhash,\n    getBlockhashDecoder,\n    getBlockhashEncoder,\n    getDefaultLamportsDecoder,\n    getDefaultLamportsEncoder,\n    Lamports,\n} from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_EPOCH_REWARDS_ADDRESS } from './sysvar';\n\ntype SysvarEpochRewardsSize = 81;\n\n/**\n * Tracks whether the rewards period (including calculation and distribution) is in progress, as\n * well as the details needed to resume distribution when starting from a snapshot during the\n * rewards period.\n *\n * The sysvar is repopulated at the start of the first block of each epoch. Therefore, the sysvar\n * contains data about the current epoch until a new epoch begins.\n */\nexport type SysvarEpochRewards = Readonly<{\n    /** Whether the rewards period (including calculation and distribution) is active */\n    active: boolean;\n    /** The rewards currently distributed for the current epoch, in {@link Lamports} */\n    distributedRewards: Lamports;\n    /** The starting block height of the rewards distribution in the current epoch */\n    distributionStartingBlockHeight: bigint;\n    /**\n     * Number of partitions in the rewards distribution in the current epoch, used to generate an\n     * `EpochRewardsHasher`\n     */\n    numPartitions: bigint;\n    /**\n     * The {@link Blockhash} of the parent block of the first block in the epoch, used to seed an\n     * `EpochRewardsHasher`\n     */\n    parentBlockhash: Blockhash;\n    /**\n     * The total rewards points calculated for the current epoch, where points equals the sum of\n     * (delegated stake * credits observed) for all  delegations\n     */\n    totalPoints: bigint;\n    /** The total rewards for the current epoch, in {@link Lamports} */\n    totalRewards: Lamports;\n}>;\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarEpochRewards} to a byte array\n * representing the `EpochRewards` sysvar's account data.\n */\nexport function getSysvarEpochRewardsEncoder(): FixedSizeEncoder<SysvarEpochRewards, SysvarEpochRewardsSize> {\n    return getStructEncoder([\n        ['distributionStartingBlockHeight', getU64Encoder()],\n        ['numPartitions', getU64Encoder()],\n        ['parentBlockhash', getBlockhashEncoder()],\n        ['totalPoints', getU128Encoder()],\n        ['totalRewards', getDefaultLamportsEncoder()],\n        ['distributedRewards', getDefaultLamportsEncoder()],\n        ['active', getBooleanEncoder()],\n    ]) as FixedSizeEncoder<SysvarEpochRewards, SysvarEpochRewardsSize>;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `EpochRewards`\n * sysvar's account data to a {@link SysvarEpochRewards}.\n */\nexport function getSysvarEpochRewardsDecoder(): FixedSizeDecoder<SysvarEpochRewards, SysvarEpochRewardsSize> {\n    return getStructDecoder([\n        ['distributionStartingBlockHeight', getU64Decoder()],\n        ['numPartitions', getU64Decoder()],\n        ['parentBlockhash', getBlockhashDecoder()],\n        ['totalPoints', getU128Decoder()],\n        ['totalRewards', getDefaultLamportsDecoder()],\n        ['distributedRewards', getDefaultLamportsDecoder()],\n        ['active', getBooleanDecoder()],\n    ]) as FixedSizeDecoder<SysvarEpochRewards, SysvarEpochRewardsSize>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarEpochRewards}\n *\n * @see {@link getSysvarEpochRewardsDecoder}\n * @see {@link getSysvarEpochRewardsEncoder}\n */\nexport function getSysvarEpochRewardsCodec(): FixedSizeCodec<\n    SysvarEpochRewards,\n    SysvarEpochRewards,\n    SysvarEpochRewardsSize\n> {\n    return combineCodec(getSysvarEpochRewardsEncoder(), getSysvarEpochRewardsDecoder());\n}\n\n/**\n * Fetch the `EpochRewards` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarEpochRewards(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarEpochRewards> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_EPOCH_REWARDS_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarEpochRewardsDecoder());\n    return decoded.data;\n}\n", "import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getBooleanDecoder,\n    getBooleanEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Epoch, Slot } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_EPOCH_SCHEDULE_ADDRESS } from './sysvar';\n\ntype SysvarEpochScheduleSize = 33;\n\n/**\n * Includes the number of slots per epoch, timing of leader schedule selection, and information\n * about epoch warm-up time.\n */\nexport type SysvarEpochSchedule = Readonly<{\n    /**\n     * First normal-length epoch after the warmup period,\n     * log2(slotsPerEpoch) - log2(MINIMUM_SLOTS_PER_EPOCH)\n     */\n    firstNormalEpoch: Epoch;\n    /**\n     * The first slot after the warmup period, MINIMUM_SLOTS_PER_EPOCH * (2^(firstNormalEpoch) - 1)\n     */\n    firstNormalSlot: Slot;\n    /**\n     * A number of slots before beginning of an epoch to calculate a leader schedule for that\n     * epoch.\n     */\n    leaderScheduleSlotOffset: bigint;\n    /** The maximum number of slots in each epoch */\n    slotsPerEpoch: bigint;\n    /** Whether epochs start short and grow */\n    warmup: boolean;\n}>;\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarEpochSchedule} to a byte array\n * representing the `EpochSchedule` sysvar's account data.\n */\nexport function getSysvarEpochScheduleEncoder(): FixedSizeEncoder<SysvarEpochSchedule, SysvarEpochScheduleSize> {\n    return getStructEncoder([\n        ['slotsPerEpoch', getU64Encoder()],\n        ['leaderScheduleSlotOffset', getU64Encoder()],\n        ['warmup', getBooleanEncoder()],\n        ['firstNormalEpoch', getU64Encoder()],\n        ['firstNormalSlot', getU64Encoder()],\n    ]) as FixedSizeEncoder<SysvarEpochSchedule, SysvarEpochScheduleSize>;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `EpochSchedule`\n * sysvar's account data to a {@link SysvarEpochSchedule}.\n */\nexport function getSysvarEpochScheduleDecoder(): FixedSizeDecoder<SysvarEpochSchedule, SysvarEpochScheduleSize> {\n    return getStructDecoder([\n        ['slotsPerEpoch', getU64Decoder()],\n        ['leaderScheduleSlotOffset', getU64Decoder()],\n        ['warmup', getBooleanDecoder()],\n        ['firstNormalEpoch', getU64Decoder()],\n        ['firstNormalSlot', getU64Decoder()],\n    ]) as FixedSizeDecoder<SysvarEpochSchedule, SysvarEpochScheduleSize>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarEpochSchedule}\n *\n * @see {@link getSysvarEpochScheduleDecoder}\n * @see {@link getSysvarEpochScheduleEncoder}\n */\nexport function getSysvarEpochScheduleCodec(): FixedSizeCodec<\n    SysvarEpochSchedule,\n    SysvarEpochSchedule,\n    SysvarEpochScheduleSize\n> {\n    return combineCodec(getSysvarEpochScheduleEncoder(), getSysvarEpochScheduleDecoder());\n}\n\n/**\n * Fetches the `EpochSchedule` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarEpochSchedule(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarEpochSchedule> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_EPOCH_SCHEDULE_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarEpochScheduleDecoder());\n    return decoded.data;\n}\n", "import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Slot } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_LAST_RESTART_SLOT_ADDRESS } from './sysvar';\n\ntype SysvarLastRestartSlotSize = 8;\n\n/**\n * Information about the last restart slot (hard fork).\n *\n * The `LastRestartSlot` sysvar provides access to the last restart slot kept in the bank fork for\n * the slot on the fork that executes the current transaction. In case there was no fork it returns\n * `0`.\n */\nexport type SysvarLastRestartSlot = Readonly<{\n    /** The last restart {@link Slot} */\n    lastRestartSlot: Slot;\n}>;\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarLastRestartSlot} to a byte array\n * representing the `LastRestartSlot` sysvar's account data.\n */\nexport function getSysvarLastRestartSlotEncoder(): FixedSizeEncoder<SysvarLastRestartSlot, SysvarLastRestartSlotSize> {\n    return getStructEncoder([['lastRestartSlot', getU64Encoder()]]) as FixedSizeEncoder<\n        SysvarLastRestartSlot,\n        SysvarLastRestartSlotSize\n    >;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `LastRestartSlot`\n * sysvar's account data to a {@link SysvarLastRestartSlot}.\n */\nexport function getSysvarLastRestartSlotDecoder(): FixedSizeDecoder<SysvarLastRestartSlot, SysvarLastRestartSlotSize> {\n    return getStructDecoder([['lastRestartSlot', getU64Decoder()]]) as FixedSizeDecoder<\n        SysvarLastRestartSlot,\n        SysvarLastRestartSlotSize\n    >;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarLastRestartSlot}\n *\n * @see {@link getSysvarLastRestartSlotDecoder}\n * @see {@link getSysvarLastRestartSlotEncoder}\n */\nexport function getSysvarLastRestartSlotCodec(): FixedSizeCodec<\n    SysvarLastRestartSlot,\n    SysvarLastRestartSlot,\n    SysvarLastRestartSlotSize\n> {\n    return combineCodec(getSysvarLastRestartSlotEncoder(), getSysvarLastRestartSlotDecoder());\n}\n\n/**\n * Fetches the `LastRestartSlot` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarLastRestartSlot(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarLastRestartSlot> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_LAST_RESTART_SLOT_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarLastRestartSlotDecoder());\n    return decoded.data;\n}\n", "import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    getArrayDecoder,\n    getArrayEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport {\n    type Blockhash,\n    getBlockhashDecoder,\n    getBlockhashEncoder,\n    getDefaultLamportsDecoder,\n    getDefaultLamportsEncoder,\n    type Lamports,\n} from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_RECENT_BLOCKHASHES_ADDRESS } from './sysvar';\n\ntype FeeCalculator = Readonly<{\n    /**\n     * The current cost of a signature.\n     *\n     * This amount may increase/decrease over time based on cluster processing load\n     */\n    lamportsPerSignature: Lamports;\n}>;\ntype Entry = Readonly<{\n    blockhash: Blockhash;\n    feeCalculator: FeeCalculator;\n}>;\n\n/**\n * Information about recent blocks and their fee calculators.\n *\n * @deprecated Transaction fees should be determined with the\n * {@link GetFeeForMessageApi.getFeeForMessage} RPC method. For additional context see the\n * [Comprehensive Compute Fees proposal](https://docs.anza.xyz/proposals/comprehensive-compute-fees/).\n */\nexport type SysvarRecentBlockhashes = Entry[];\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarRecentBlockhashes} to a byte array\n * representing the `RecentBlockhashes` sysvar's account data.\n *\n * @deprecated Transaction fees should be determined with the\n * {@link GetFeeForMessageApi.getFeeForMessage} RPC method. For additional context see the\n * [Comprehensive Compute Fees proposal](https://docs.anza.xyz/proposals/comprehensive-compute-fees/).\n */\nexport function getSysvarRecentBlockhashesEncoder(): VariableSizeEncoder<SysvarRecentBlockhashes> {\n    return getArrayEncoder(\n        getStructEncoder([\n            ['blockhash', getBlockhashEncoder()],\n            ['feeCalculator', getStructEncoder([['lamportsPerSignature', getDefaultLamportsEncoder()]])],\n        ]),\n    );\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `RecentBlockhashes`\n * sysvar's account data to a {@link SysvarRecentBlockhashes}.\n *\n * @deprecated Transaction fees should be determined with the\n * {@link GetFeeForMessageApi.getFeeForMessage} RPC method. For additional context see the\n * [Comprehensive Compute Fees proposal](https://docs.anza.xyz/proposals/comprehensive-compute-fees/).\n */\nexport function getSysvarRecentBlockhashesDecoder(): VariableSizeDecoder<SysvarRecentBlockhashes> {\n    return getArrayDecoder(\n        getStructDecoder([\n            ['blockhash', getBlockhashDecoder()],\n            ['feeCalculator', getStructDecoder([['lamportsPerSignature', getDefaultLamportsDecoder()]])],\n        ]),\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarRecentBlockhashes}\n *\n * @deprecated Transaction fees should be determined with the\n * {@link GetFeeForMessageApi.getFeeForMessage} RPC method. For additional context see the\n * [Comprehensive Compute Fees proposal](https://docs.anza.xyz/proposals/comprehensive-compute-fees/).\n *\n * @see {@link getSysvarRecentBlockhashesDecoder}\n * @see {@link getSysvarRecentBlockhashesEncoder}\n */\nexport function getSysvarRecentBlockhashesCodec(): VariableSizeCodec<SysvarRecentBlockhashes> {\n    return combineCodec(getSysvarRecentBlockhashesEncoder(), getSysvarRecentBlockhashesDecoder());\n}\n\n/**\n * Fetches the `RecentBlockhashes` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n *\n * @deprecated Transaction fees should be determined with the\n * {@link GetFeeForMessageApi.getFeeForMessage} RPC method. For additional context see the\n * [Comprehensive Compute Fees proposal](https://docs.anza.xyz/proposals/comprehensive-compute-fees/).\n */\nexport async function fetchSysvarRecentBlockhashes(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarRecentBlockhashes> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_RECENT_BLOCKHASHES_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarRecentBlockhashesDecoder());\n    return decoded.data;\n}\n", "import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getF64Decoder,\n    getF64Encoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU8Decoder,\n    getU8Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport {\n    F64UnsafeSeeDocumentation,\n    getDefaultLamportsDecoder,\n    getDefaultLamportsEncoder,\n    type Lamports,\n} from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_RENT_ADDRESS } from './sysvar';\n\ntype SysvarRentSize = 17;\n\n/**\n * Configuration for network rent.\n */\nexport type SysvarRent = Readonly<{\n    /**\n     * The percentage of collected rent that is burned.\n     *\n     * Valid values are in the range [0, 100]. The remaining percentage is distributed to\n     * validators.\n     */\n    burnPercent: number;\n    /** Amount of time (in years) a balance must include rent for the account to be rent exempt */\n    exemptionThreshold: F64UnsafeSeeDocumentation;\n    /** Rental rate in {@link Lamports}/byte-year. */\n    lamportsPerByteYear: Lamports;\n}>;\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarRent} to a byte array representing\n * the `Rent` sysvar's account data.\n */\nexport function getSysvarRentEncoder(): FixedSizeEncoder<SysvarRent, SysvarRentSize> {\n    return getStructEncoder([\n        ['lamportsPerByteYear', getDefaultLamportsEncoder()],\n        ['exemptionThreshold', getF64Encoder()],\n        ['burnPercent', getU8Encoder()],\n    ]) as FixedSizeEncoder<SysvarRent, SysvarRentSize>;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `Rent` sysvar's\n * account data to a {@link SysvarRent}.\n */\nexport function getSysvarRentDecoder(): FixedSizeDecoder<SysvarRent, SysvarRentSize> {\n    return getStructDecoder([\n        ['lamportsPerByteYear', getDefaultLamportsDecoder()],\n        ['exemptionThreshold', getF64Decoder()],\n        ['burnPercent', getU8Decoder()],\n    ]) as FixedSizeDecoder<SysvarRent, SysvarRentSize>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarRent}\n *\n * @see {@link getSysvarRentDecoder}\n * @see {@link getSysvarRentEncoder}\n */\nexport function getSysvarRentCodec(): FixedSizeCodec<SysvarRent, SysvarRent, SysvarRentSize> {\n    return combineCodec(getSysvarRentEncoder(), getSysvarRentDecoder());\n}\n\n/**\n * Fetches the `Rent` sysvar account using any RPC that supports the {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarRent(rpc: Rpc<GetAccountInfoApi>, config?: FetchAccountConfig): Promise<SysvarRent> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_RENT_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarRentDecoder());\n    return decoded.data;\n}\n", "import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    getArrayDecoder,\n    getArrayEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport { type Blockhash, getBlockhashDecoder, getBlockhashEncoder, type Slot } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_SLOT_HASHES_ADDRESS } from './sysvar';\n\ntype Entry = Readonly<{\n    hash: Blockhash;\n    slot: Slot;\n}>;\n\n/** The most recent hashes of a slot's parent banks. */\nexport type SysvarSlotHashes = Entry[];\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarSlotHashes} to a byte array\n * representing the `SlotHashes` sysvar's account data.\n */\nexport function getSysvarSlotHashesEncoder(): VariableSizeEncoder<SysvarSlotHashes> {\n    return getArrayEncoder(\n        getStructEncoder([\n            ['slot', getU64Encoder()],\n            ['hash', getBlockhashEncoder()],\n        ]),\n    );\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `SlotHashes` sysvar's\n * account data to a {@link SysvarSlotHashes}.\n */\nexport function getSysvarSlotHashesDecoder(): VariableSizeDecoder<SysvarSlotHashes> {\n    return getArrayDecoder(\n        getStructDecoder([\n            ['slot', getU64Decoder()],\n            ['hash', getBlockhashDecoder()],\n        ]),\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarSlotHashes}\n *\n * @see {@link getSysvarSlotHashesDecoder}\n * @see {@link getSysvarSlotHashesEncoder}\n */\nexport function getSysvarSlotHashesCodec(): VariableSizeCodec<SysvarSlotHashes> {\n    return combineCodec(getSysvarSlotHashesEncoder(), getSysvarSlotHashesDecoder());\n}\n\n/**\n * Fetches the `SlotHashes` sysvar account using any RPC that supports the {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarSlotHashes(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarSlotHashes> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_SLOT_HASHES_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarSlotHashesDecoder());\n    return decoded.data;\n}\n", "import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getArrayCodec,\n    getU64Codec,\n    getU64Decoder,\n    getU64Encoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs';\nimport {\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SolanaError,\n} from '@solana/errors';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Slot } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_SLOT_HISTORY_ADDRESS } from './sysvar';\n\nconst BITVEC_DISCRIMINATOR = 1;\n// Max number of bits in the bitvector.\n// The Solana SDK defines a constant `MAX_ENTRIES` representing the maximum\n// number of bits that can be represented by the bitvector in the `SlotHistory`\n// sysvar. This value is 1024 * 1024 = 1_048_576.\n// See https://github.com/anza-xyz/agave/blob/e0203f22dc83cb792fa97f91dbe6e924cbd08af1/sdk/program/src/slot_history.rs#L43\nconst BITVEC_NUM_BITS = 1024 * 1024;\n// The length of the bitvector in blocks.\n// At 64 bits per block, this is 1024 * 1024 / 64 = 16_384.\nconst BITVEC_LENGTH = BITVEC_NUM_BITS / 64;\n\nconst SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE =\n    1 + // Discriminator\n    8 + // bitvector length (u64)\n    BITVEC_LENGTH * 8 +\n    8 + // Number of bits (u64)\n    8; // Next slot (u64)\n\nlet memoizedU64Encoder: FixedSizeEncoder<bigint, 8> | undefined;\nlet memoizedU64Decoder: FixedSizeDecoder<bigint, 8> | undefined;\nlet memoizedU64ArrayEncoder: FixedSizeEncoder<bigint[]> | undefined;\nlet memoizedU64ArrayDecoder: FixedSizeDecoder<bigint[]> | undefined;\n\nfunction getMemoizedU64Encoder(): FixedSizeEncoder<bigint, 8> {\n    if (!memoizedU64Encoder) memoizedU64Encoder = getU64Encoder();\n    return memoizedU64Encoder;\n}\nfunction getMemoizedU64Decoder(): FixedSizeDecoder<bigint, 8> {\n    if (!memoizedU64Decoder) memoizedU64Decoder = getU64Decoder();\n    return memoizedU64Decoder;\n}\nfunction getMemoizedU64ArrayEncoder(): FixedSizeEncoder<bigint[], typeof BITVEC_LENGTH> {\n    if (!memoizedU64ArrayEncoder) memoizedU64ArrayEncoder = getArrayCodec(getU64Codec(), { size: BITVEC_LENGTH });\n    return memoizedU64ArrayEncoder;\n}\nfunction getMemoizedU64ArrayDecoder(): FixedSizeDecoder<bigint[], typeof BITVEC_LENGTH> {\n    if (!memoizedU64ArrayDecoder) memoizedU64ArrayDecoder = getArrayCodec(getU64Codec(), { size: BITVEC_LENGTH });\n    return memoizedU64ArrayDecoder;\n}\n\ntype SysvarSlotHistorySize = typeof SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE;\n\n/** A bitvector of slots present over the last epoch. */\nexport type SysvarSlotHistory = {\n    /**\n     * A vector of 64-bit numbers which, when their bits are strung together, represent a record of\n     * non-skipped slots.\n     *\n     * The bit in position (slot % MAX_ENTRIES) is 0 if the slot was skipped and 1 otherwise, valid\n     * only when the candidate slot is less than `nextSlot` and greater than or equal to\n     * `MAX_ENTRIES - nextSlot`.\n     */\n    bits: bigint[];\n    /** The number of the slot one newer than tracked by the bitvector */\n    nextSlot: Slot;\n};\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarSlotHistory} to a byte array\n * representing the `SlotHistory` sysvar's account data.\n */\nexport function getSysvarSlotHistoryEncoder(): FixedSizeEncoder<SysvarSlotHistory, SysvarSlotHistorySize> {\n    return createEncoder({\n        fixedSize: SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE,\n        write: (value: SysvarSlotHistory, bytes, offset) => {\n            // First byte is the bitvector discriminator.\n            bytes.set([BITVEC_DISCRIMINATOR], offset);\n            offset += 1;\n            // Next 8 bytes are the bitvector length.\n            getMemoizedU64Encoder().write(BigInt(BITVEC_LENGTH), bytes, offset);\n            offset += 8;\n            // Next `BITVEC_LENGTH` bytes are the bitvector.\n            // Any missing bits are assumed to be 0.\n            getMemoizedU64ArrayEncoder().write(value.bits, bytes, offset);\n            offset += BITVEC_LENGTH * 8;\n            // Next 8 bytes are the number of bits.\n            getMemoizedU64Encoder().write(BigInt(BITVEC_NUM_BITS), bytes, offset);\n            offset += 8;\n            // Next 8 bytes are the next slot.\n            getMemoizedU64Encoder().write(value.nextSlot, bytes, offset);\n            offset += 8;\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `SlotHistory` sysvar's\n * account data to a {@link SysvarSlotHistory}.\n */\nexport function getSysvarSlotHistoryDecoder(): FixedSizeDecoder<SysvarSlotHistory, SysvarSlotHistorySize> {\n    return createDecoder({\n        fixedSize: SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            // Byte length should be exact.\n            if (bytes.length != SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n                    actual: bytes.length,\n                    expected: SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE,\n                });\n            }\n            // First byte is the bitvector discriminator.\n            const discriminator = bytes[offset];\n            offset += 1;\n            if (discriminator !== BITVEC_DISCRIMINATOR) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                    actual: discriminator,\n                    expected: BITVEC_DISCRIMINATOR,\n                });\n            }\n            // Next 8 bytes are the bitvector length.\n            const bitVecLength = getMemoizedU64Decoder().read(bytes, offset)[0];\n            offset += 8;\n            if (bitVecLength !== BigInt(BITVEC_LENGTH)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n                    actual: bitVecLength,\n                    codecDescription: 'SysvarSlotHistoryCodec',\n                    expected: BITVEC_LENGTH,\n                });\n            }\n            // Next `BITVEC_LENGTH` bytes are the bitvector.\n            const bits = getMemoizedU64ArrayDecoder().read(bytes, offset)[0];\n            offset += BITVEC_LENGTH * 8;\n            // Next 8 bytes are the number of bits.\n            const numBits = getMemoizedU64Decoder().read(bytes, offset)[0];\n            offset += 8;\n            if (numBits !== BigInt(BITVEC_NUM_BITS)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n                    actual: numBits,\n                    codecDescription: 'SysvarSlotHistoryCodec',\n                    expected: BITVEC_NUM_BITS,\n                });\n            }\n            // Next 8 bytes are the next slot.\n            const nextSlot = getMemoizedU64Decoder().read(bytes, offset)[0];\n            offset += 8;\n            return [\n                {\n                    bits,\n                    nextSlot,\n                },\n                offset,\n            ];\n        },\n    });\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarSlotHistory}\n *\n * @see {@link getSysvarSlotHistoryDecoder}\n * @see {@link getSysvarSlotHistoryEncoder}\n */\nexport function getSysvarSlotHistoryCodec(): FixedSizeCodec<\n    SysvarSlotHistory,\n    SysvarSlotHistory,\n    SysvarSlotHistorySize\n> {\n    return combineCodec(getSysvarSlotHistoryEncoder(), getSysvarSlotHistoryDecoder());\n}\n\n/**\n * Fetches the `SlotHistory` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarSlotHistory(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarSlotHistory> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_SLOT_HISTORY_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarSlotHistoryDecoder());\n    return decoded.data;\n}\n", "import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    getArrayDecoder,\n    getArrayEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport { Epoch, getDefaultLamportsDecoder, getDefaultLamportsEncoder, type Lamports } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_STAKE_HISTORY_ADDRESS } from './sysvar';\n\ntype Entry = Readonly<{\n    /** The epoch to which this stake history entry pertains */\n    epoch: Epoch;\n    stakeHistory: Readonly<{\n        /**\n         * Sum of portion of stakes requested to be warmed up, but not fully activated yet, in\n         * {@link Lamports}\n         */\n        activating: Lamports;\n        /**\n         * Sum of portion of stakes requested to be cooled down, but not fully deactivated yet, in\n         * {@link Lamports}\n         */\n        deactivating: Lamports;\n        /** Effective stake at this epoch, in {@link Lamports} */\n        effective: Lamports;\n    }>;\n}>;\n\n/** History of stake activations and de-activations. */\nexport type SysvarStakeHistory = Entry[];\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarStakeHistory} to a byte array\n * representing the `StakeHistory` sysvar's account data.\n */\nexport function getSysvarStakeHistoryEncoder(): VariableSizeEncoder<SysvarStakeHistory> {\n    return getArrayEncoder(\n        getStructEncoder([\n            ['epoch', getU64Encoder()],\n            [\n                'stakeHistory',\n                getStructEncoder([\n                    ['effective', getDefaultLamportsEncoder()],\n                    ['activating', getDefaultLamportsEncoder()],\n                    ['deactivating', getDefaultLamportsEncoder()],\n                ]),\n            ],\n        ]),\n        { size: getU64Encoder() },\n    );\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `StakeHistory`\n * sysvar's account data to a {@link SysvarStakeHistory}.\n */\nexport function getSysvarStakeHistoryDecoder(): VariableSizeDecoder<SysvarStakeHistory> {\n    return getArrayDecoder(\n        getStructDecoder([\n            ['epoch', getU64Decoder()],\n            [\n                'stakeHistory',\n                getStructDecoder([\n                    ['effective', getDefaultLamportsDecoder()],\n                    ['activating', getDefaultLamportsDecoder()],\n                    ['deactivating', getDefaultLamportsDecoder()],\n                ]),\n            ],\n        ]),\n        { size: getU64Decoder() },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarStakeHistory}\n *\n * @see {@link getSysvarStakeHistoryDecoder}\n * @see {@link getSysvarStakeHistoryEncoder}\n */\nexport function getSysvarStakeHistoryCodec(): VariableSizeCodec<SysvarStakeHistory> {\n    return combineCodec(getSysvarStakeHistoryEncoder(), getSysvarStakeHistoryDecoder());\n}\n\n/**\n * Fetches the `StakeHistory` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarStakeHistory(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarStakeHistory> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_STAKE_HISTORY_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarStakeHistoryDecoder());\n    return decoded.data;\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport enum AccountState {\n  Uninitialized,\n  Initialized,\n  Frozen,\n}\n\nexport type AccountStateArgs = AccountState;\n\nexport function getAccountStateEncoder(): Encoder<AccountStateArgs> {\n  return getEnumEncoder(AccountState);\n}\n\nexport function getAccountStateDecoder(): Decoder<AccountState> {\n  return getEnumDecoder(AccountState);\n}\n\nexport function getAccountStateCodec(): Codec<AccountStateArgs, AccountState> {\n  return combineCodec(getAccountStateEncoder(), getAccountStateDecoder());\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport enum AuthorityType {\n  MintTokens,\n  FreezeAccount,\n  AccountOwner,\n  CloseAccount,\n  TransferFeeConfig,\n  WithheldWithdraw,\n  CloseMint,\n  InterestRate,\n  PermanentDelegate,\n  ConfidentialTransferMint,\n  TransferHookProgramId,\n  ConfidentialTransferFeeConfig,\n  MetadataPointer,\n  GroupPointer,\n  GroupMemberPointer,\n  ScaledUiAmount,\n  Pause,\n}\n\nexport type AuthorityTypeArgs = AuthorityType;\n\nexport function getAuthorityTypeEncoder(): Encoder<AuthorityTypeArgs> {\n  return getEnumEncoder(AuthorityType);\n}\n\nexport function getAuthorityTypeDecoder(): Decoder<AuthorityType> {\n  return getEnumDecoder(AuthorityType);\n}\n\nexport function getAuthorityTypeCodec(): Codec<\n  AuthorityTypeArgs,\n  AuthorityType\n> {\n  return combineCodec(getAuthorityTypeEncoder(), getAuthorityTypeDecoder());\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\n\n/** Authenticated encryption containing an account balance. */\nexport type DecryptableBalance = ReadonlyUint8Array;\n\nexport type DecryptableBalanceArgs = DecryptableBalance;\n\nexport function getDecryptableBalanceEncoder(): Encoder<DecryptableBalanceArgs> {\n  return fixEncoderSize(getBytesEncoder(), 36);\n}\n\nexport function getDecryptableBalanceDecoder(): Decoder<DecryptableBalance> {\n  return fixDecoderSize(getBytesDecoder(), 36);\n}\n\nexport function getDecryptableBalanceCodec(): Codec<\n  DecryptableBalanceArgs,\n  DecryptableBalance\n> {\n  return combineCodec(\n    getDecryptableBalanceEncoder(),\n    getDecryptableBalanceDecoder()\n  );\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\n\n/** ElGamal ciphertext containing an account balance. */\nexport type EncryptedBalance = ReadonlyUint8Array;\n\nexport type EncryptedBalanceArgs = EncryptedBalance;\n\nexport function getEncryptedBalanceEncoder(): Encoder<EncryptedBalanceArgs> {\n  return fixEncoderSize(getBytesEncoder(), 64);\n}\n\nexport function getEncryptedBalanceDecoder(): Decoder<EncryptedBalance> {\n  return fixDecoderSize(getBytesDecoder(), 64);\n}\n\nexport function getEncryptedBalanceCodec(): Codec<\n  EncryptedBalanceArgs,\n  EncryptedBalance\n> {\n  return combineCodec(\n    getEncryptedBalanceEncoder(),\n    getEncryptedBalanceDecoder()\n  );\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getDiscriminatedUnionDecoder,\n  getDiscriminatedUnionEncoder,\n  getF64Decoder,\n  getF64Encoder,\n  getI16Decoder,\n  getI16Encoder,\n  getMapDecoder,\n  getMapEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getUnitDecoder,\n  getUnitEncoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type GetDiscriminatedUnionVariant,\n  type GetDiscriminatedUnionVariantContent,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/kit';\nimport {\n  getAccountStateDecoder,\n  getAccountStateEncoder,\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  getEncryptedBalanceDecoder,\n  getEncryptedBalanceEncoder,\n  getTransferFeeDecoder,\n  getTransferFeeEncoder,\n  type AccountState,\n  type AccountStateArgs,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n  type EncryptedBalance,\n  type EncryptedBalanceArgs,\n  type TransferFee,\n  type TransferFeeArgs,\n} from '.';\n\nexport type Extension =\n  | { __kind: 'Uninitialized' }\n  | {\n      __kind: 'TransferFeeConfig';\n      /** Optional authority to set the fee. */\n      transferFeeConfigAuthority: Address;\n      /** Withdraw from mint instructions must be signed by this key. */\n      withdrawWithheldAuthority: Address;\n      /** Withheld transfer fee tokens that have been moved to the mint for withdrawal. */\n      withheldAmount: bigint;\n      /** Older transfer fee, used if the current epoch < newerTransferFee.epoch. */\n      olderTransferFee: TransferFee;\n      /** Newer transfer fee, used if the current epoch >= newerTransferFee.epoch. */\n      newerTransferFee: TransferFee;\n    }\n  | {\n      __kind: 'TransferFeeAmount';\n      /** Withheld transfer fee tokens that can be claimed by the fee authority. */\n      withheldAmount: bigint;\n    }\n  | { __kind: 'MintCloseAuthority'; closeAuthority: Address }\n  | {\n      __kind: 'ConfidentialTransferMint';\n      /**\n       * Authority to modify the `ConfidentialTransferMint` configuration and to\n       * approve new accounts (if `auto_approve_new_accounts` is true).\n       *\n       * The legacy Token Multisig account is not supported as the authority.\n       */\n      authority: Option<Address>;\n      /**\n       * Indicate if newly configured accounts must be approved by the\n       * `authority` before they may be used by the user.\n       *\n       * * If `true`, no approval is required and new accounts may be used immediately.\n       * * If `false`, the authority must approve newly configured accounts (see\n       *   `ConfidentialTransferInstruction::ConfigureAccount`).\n       */\n      autoApproveNewAccounts: boolean;\n      /** Authority to decode any transfer amount in a confidential transfer. */\n      auditorElgamalPubkey: Option<Address>;\n    }\n  | {\n      __kind: 'ConfidentialTransferAccount';\n      /**\n       * `true` if this account has been approved for use. All confidential\n       * transfer operations for the account will fail until approval is granted.\n       */\n      approved: boolean;\n      /** The public key associated with ElGamal encryption. */\n      elgamalPubkey: Address;\n      /** The low 16 bits of the pending balance (encrypted by `elgamal_pubkey`). */\n      pendingBalanceLow: EncryptedBalance;\n      /** The high 48 bits of the pending balance (encrypted by `elgamal_pubkey`). */\n      pendingBalanceHigh: EncryptedBalance;\n      /** The available balance (encrypted by `encrypiton_pubkey`). */\n      availableBalance: EncryptedBalance;\n      /** The decryptable available balance. */\n      decryptableAvailableBalance: DecryptableBalance;\n      /** If `false`, the extended account rejects any incoming confidential transfers. */\n      allowConfidentialCredits: boolean;\n      /** If `false`, the base account rejects any incoming transfers. */\n      allowNonConfidentialCredits: boolean;\n      /** The total number of `Deposit` and `Transfer` instructions that have credited `pending_balance`. */\n      pendingBalanceCreditCounter: bigint;\n      /**\n       * The maximum number of `Deposit` and `Transfer` instructions that can\n       * credit `pending_balance` before the `ApplyPendingBalance`\n       * instruction is executed.\n       */\n      maximumPendingBalanceCreditCounter: bigint;\n      /**\n       * The `expected_pending_balance_credit_counter` value that was included in\n       * the last `ApplyPendingBalance` instruction.\n       */\n      expectedPendingBalanceCreditCounter: bigint;\n      /**\n       * The actual `pending_balance_credit_counter` when the last\n       * `ApplyPendingBalance` instruction was executed.\n       */\n      actualPendingBalanceCreditCounter: bigint;\n    }\n  | { __kind: 'DefaultAccountState'; state: AccountState }\n  | { __kind: 'ImmutableOwner' }\n  | {\n      __kind: 'MemoTransfer';\n      /** Require transfers into this account to be accompanied by a memo. */\n      requireIncomingTransferMemos: boolean;\n    }\n  | { __kind: 'NonTransferable' }\n  | {\n      __kind: 'InterestBearingConfig';\n      rateAuthority: Address;\n      initializationTimestamp: bigint;\n      preUpdateAverageRate: number;\n      lastUpdateTimestamp: bigint;\n      currentRate: number;\n    }\n  | {\n      __kind: 'CpiGuard';\n      /** Lock certain token operations from taking place within CPI for this account. */\n      lockCpi: boolean;\n    }\n  | { __kind: 'PermanentDelegate'; delegate: Address }\n  | { __kind: 'NonTransferableAccount' }\n  | {\n      __kind: 'TransferHook';\n      /** The transfer hook update authority. */\n      authority: Address;\n      /** The transfer hook program account. */\n      programId: Address;\n    }\n  | {\n      __kind: 'TransferHookAccount';\n      /**\n       * Whether or not this account is currently transferring tokens\n       * True during the transfer hook cpi, otherwise false.\n       */\n      transferring: boolean;\n    }\n  | {\n      __kind: 'ConfidentialTransferFee';\n      /** Optional authority to set the withdraw withheld authority ElGamal key. */\n      authority: Option<Address>;\n      /**\n       * Withheld fees from accounts must be encrypted with this ElGamal key.\n       *\n       * Note that whoever holds the ElGamal private key for this ElGamal public\n       * key has the ability to decode any withheld fee amount that are\n       * associated with accounts. When combined with the fee parameters, the\n       * withheld fee amounts can reveal information about transfer amounts.\n       */\n      elgamalPubkey: Address;\n      /** If `false`, the harvest of withheld tokens to mint is rejected. */\n      harvestToMintEnabled: boolean;\n      /**\n       * Withheld confidential transfer fee tokens that have been moved to the\n       * mint for withdrawal.\n       */\n      withheldAmount: EncryptedBalance;\n    }\n  | {\n      __kind: 'ConfidentialTransferFeeAmount';\n      /** Amount withheld during confidential transfers, to be harvest to the mint. */\n      withheldAmount: EncryptedBalance;\n    }\n  | {\n      __kind: 'MetadataPointer';\n      /** Optional authority that can set the metadata address. */\n      authority: Option<Address>;\n      /** Optional Account Address that holds the metadata. */\n      metadataAddress: Option<Address>;\n    }\n  | {\n      __kind: 'TokenMetadata';\n      /** The authority that can sign to update the metadata. */\n      updateAuthority: Option<Address>;\n      /** The associated mint, used to counter spoofing to be sure that metadata belongs to a particular mint. */\n      mint: Address;\n      /** The longer name of the token. */\n      name: string;\n      /** The shortened symbol for the token. */\n      symbol: string;\n      /** The URI pointing to richer metadata. */\n      uri: string;\n      /** Any additional metadata about the token as key-value pairs. */\n      additionalMetadata: Map<string, string>;\n    }\n  | {\n      __kind: 'GroupPointer';\n      /** Optional authority that can set the group address. */\n      authority: Option<Address>;\n      /** Optional account address that holds the group. */\n      groupAddress: Option<Address>;\n    }\n  | {\n      __kind: 'TokenGroup';\n      /** The authority that can sign to update the group. */\n      updateAuthority: Option<Address>;\n      /** The associated mint, used to counter spoofing to be sure that group belongs to a particular mint. */\n      mint: Address;\n      /** The current number of group members. */\n      size: bigint;\n      /** The maximum number of group members. */\n      maxSize: bigint;\n    }\n  | {\n      __kind: 'GroupMemberPointer';\n      /** Optional authority that can set the member address. */\n      authority: Option<Address>;\n      /** Optional account address that holds the member. */\n      memberAddress: Option<Address>;\n    }\n  | {\n      __kind: 'TokenGroupMember';\n      /** The associated mint, used to counter spoofing to be sure that member belongs to a particular mint. */\n      mint: Address;\n      /** The pubkey of the `TokenGroup`. */\n      group: Address;\n      /** The member number. */\n      memberNumber: bigint;\n    }\n  | { __kind: 'ConfidentialMintBurn' }\n  | {\n      __kind: 'ScaledUiAmountConfig';\n      authority: Address;\n      multiplier: number;\n      newMultiplierEffectiveTimestamp: bigint;\n      newMultiplier: number;\n    }\n  | { __kind: 'PausableConfig'; authority: Option<Address>; paused: boolean }\n  | { __kind: 'PausableAccount' };\n\nexport type ExtensionArgs =\n  | { __kind: 'Uninitialized' }\n  | {\n      __kind: 'TransferFeeConfig';\n      /** Optional authority to set the fee. */\n      transferFeeConfigAuthority: Address;\n      /** Withdraw from mint instructions must be signed by this key. */\n      withdrawWithheldAuthority: Address;\n      /** Withheld transfer fee tokens that have been moved to the mint for withdrawal. */\n      withheldAmount: number | bigint;\n      /** Older transfer fee, used if the current epoch < newerTransferFee.epoch. */\n      olderTransferFee: TransferFeeArgs;\n      /** Newer transfer fee, used if the current epoch >= newerTransferFee.epoch. */\n      newerTransferFee: TransferFeeArgs;\n    }\n  | {\n      __kind: 'TransferFeeAmount';\n      /** Withheld transfer fee tokens that can be claimed by the fee authority. */\n      withheldAmount: number | bigint;\n    }\n  | { __kind: 'MintCloseAuthority'; closeAuthority: Address }\n  | {\n      __kind: 'ConfidentialTransferMint';\n      /**\n       * Authority to modify the `ConfidentialTransferMint` configuration and to\n       * approve new accounts (if `auto_approve_new_accounts` is true).\n       *\n       * The legacy Token Multisig account is not supported as the authority.\n       */\n      authority: OptionOrNullable<Address>;\n      /**\n       * Indicate if newly configured accounts must be approved by the\n       * `authority` before they may be used by the user.\n       *\n       * * If `true`, no approval is required and new accounts may be used immediately.\n       * * If `false`, the authority must approve newly configured accounts (see\n       *   `ConfidentialTransferInstruction::ConfigureAccount`).\n       */\n      autoApproveNewAccounts: boolean;\n      /** Authority to decode any transfer amount in a confidential transfer. */\n      auditorElgamalPubkey: OptionOrNullable<Address>;\n    }\n  | {\n      __kind: 'ConfidentialTransferAccount';\n      /**\n       * `true` if this account has been approved for use. All confidential\n       * transfer operations for the account will fail until approval is granted.\n       */\n      approved: boolean;\n      /** The public key associated with ElGamal encryption. */\n      elgamalPubkey: Address;\n      /** The low 16 bits of the pending balance (encrypted by `elgamal_pubkey`). */\n      pendingBalanceLow: EncryptedBalanceArgs;\n      /** The high 48 bits of the pending balance (encrypted by `elgamal_pubkey`). */\n      pendingBalanceHigh: EncryptedBalanceArgs;\n      /** The available balance (encrypted by `encrypiton_pubkey`). */\n      availableBalance: EncryptedBalanceArgs;\n      /** The decryptable available balance. */\n      decryptableAvailableBalance: DecryptableBalanceArgs;\n      /** If `false`, the extended account rejects any incoming confidential transfers. */\n      allowConfidentialCredits: boolean;\n      /** If `false`, the base account rejects any incoming transfers. */\n      allowNonConfidentialCredits: boolean;\n      /** The total number of `Deposit` and `Transfer` instructions that have credited `pending_balance`. */\n      pendingBalanceCreditCounter: number | bigint;\n      /**\n       * The maximum number of `Deposit` and `Transfer` instructions that can\n       * credit `pending_balance` before the `ApplyPendingBalance`\n       * instruction is executed.\n       */\n      maximumPendingBalanceCreditCounter: number | bigint;\n      /**\n       * The `expected_pending_balance_credit_counter` value that was included in\n       * the last `ApplyPendingBalance` instruction.\n       */\n      expectedPendingBalanceCreditCounter: number | bigint;\n      /**\n       * The actual `pending_balance_credit_counter` when the last\n       * `ApplyPendingBalance` instruction was executed.\n       */\n      actualPendingBalanceCreditCounter: number | bigint;\n    }\n  | { __kind: 'DefaultAccountState'; state: AccountStateArgs }\n  | { __kind: 'ImmutableOwner' }\n  | {\n      __kind: 'MemoTransfer';\n      /** Require transfers into this account to be accompanied by a memo. */\n      requireIncomingTransferMemos: boolean;\n    }\n  | { __kind: 'NonTransferable' }\n  | {\n      __kind: 'InterestBearingConfig';\n      rateAuthority: Address;\n      initializationTimestamp: number | bigint;\n      preUpdateAverageRate: number;\n      lastUpdateTimestamp: number | bigint;\n      currentRate: number;\n    }\n  | {\n      __kind: 'CpiGuard';\n      /** Lock certain token operations from taking place within CPI for this account. */\n      lockCpi: boolean;\n    }\n  | { __kind: 'PermanentDelegate'; delegate: Address }\n  | { __kind: 'NonTransferableAccount' }\n  | {\n      __kind: 'TransferHook';\n      /** The transfer hook update authority. */\n      authority: Address;\n      /** The transfer hook program account. */\n      programId: Address;\n    }\n  | {\n      __kind: 'TransferHookAccount';\n      /**\n       * Whether or not this account is currently transferring tokens\n       * True during the transfer hook cpi, otherwise false.\n       */\n      transferring: boolean;\n    }\n  | {\n      __kind: 'ConfidentialTransferFee';\n      /** Optional authority to set the withdraw withheld authority ElGamal key. */\n      authority: OptionOrNullable<Address>;\n      /**\n       * Withheld fees from accounts must be encrypted with this ElGamal key.\n       *\n       * Note that whoever holds the ElGamal private key for this ElGamal public\n       * key has the ability to decode any withheld fee amount that are\n       * associated with accounts. When combined with the fee parameters, the\n       * withheld fee amounts can reveal information about transfer amounts.\n       */\n      elgamalPubkey: Address;\n      /** If `false`, the harvest of withheld tokens to mint is rejected. */\n      harvestToMintEnabled: boolean;\n      /**\n       * Withheld confidential transfer fee tokens that have been moved to the\n       * mint for withdrawal.\n       */\n      withheldAmount: EncryptedBalanceArgs;\n    }\n  | {\n      __kind: 'ConfidentialTransferFeeAmount';\n      /** Amount withheld during confidential transfers, to be harvest to the mint. */\n      withheldAmount: EncryptedBalanceArgs;\n    }\n  | {\n      __kind: 'MetadataPointer';\n      /** Optional authority that can set the metadata address. */\n      authority: OptionOrNullable<Address>;\n      /** Optional Account Address that holds the metadata. */\n      metadataAddress: OptionOrNullable<Address>;\n    }\n  | {\n      __kind: 'TokenMetadata';\n      /** The authority that can sign to update the metadata. */\n      updateAuthority: OptionOrNullable<Address>;\n      /** The associated mint, used to counter spoofing to be sure that metadata belongs to a particular mint. */\n      mint: Address;\n      /** The longer name of the token. */\n      name: string;\n      /** The shortened symbol for the token. */\n      symbol: string;\n      /** The URI pointing to richer metadata. */\n      uri: string;\n      /** Any additional metadata about the token as key-value pairs. */\n      additionalMetadata: Map<string, string>;\n    }\n  | {\n      __kind: 'GroupPointer';\n      /** Optional authority that can set the group address. */\n      authority: OptionOrNullable<Address>;\n      /** Optional account address that holds the group. */\n      groupAddress: OptionOrNullable<Address>;\n    }\n  | {\n      __kind: 'TokenGroup';\n      /** The authority that can sign to update the group. */\n      updateAuthority: OptionOrNullable<Address>;\n      /** The associated mint, used to counter spoofing to be sure that group belongs to a particular mint. */\n      mint: Address;\n      /** The current number of group members. */\n      size: number | bigint;\n      /** The maximum number of group members. */\n      maxSize: number | bigint;\n    }\n  | {\n      __kind: 'GroupMemberPointer';\n      /** Optional authority that can set the member address. */\n      authority: OptionOrNullable<Address>;\n      /** Optional account address that holds the member. */\n      memberAddress: OptionOrNullable<Address>;\n    }\n  | {\n      __kind: 'TokenGroupMember';\n      /** The associated mint, used to counter spoofing to be sure that member belongs to a particular mint. */\n      mint: Address;\n      /** The pubkey of the `TokenGroup`. */\n      group: Address;\n      /** The member number. */\n      memberNumber: number | bigint;\n    }\n  | { __kind: 'ConfidentialMintBurn' }\n  | {\n      __kind: 'ScaledUiAmountConfig';\n      authority: Address;\n      multiplier: number;\n      newMultiplierEffectiveTimestamp: number | bigint;\n      newMultiplier: number;\n    }\n  | {\n      __kind: 'PausableConfig';\n      authority: OptionOrNullable<Address>;\n      paused: boolean;\n    }\n  | { __kind: 'PausableAccount' };\n\nexport function getExtensionEncoder(): Encoder<ExtensionArgs> {\n  return getDiscriminatedUnionEncoder(\n    [\n      ['Uninitialized', getUnitEncoder()],\n      [\n        'TransferFeeConfig',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['transferFeeConfigAuthority', getAddressEncoder()],\n            ['withdrawWithheldAuthority', getAddressEncoder()],\n            ['withheldAmount', getU64Encoder()],\n            ['olderTransferFee', getTransferFeeEncoder()],\n            ['newerTransferFee', getTransferFeeEncoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'TransferFeeAmount',\n        addEncoderSizePrefix(\n          getStructEncoder([['withheldAmount', getU64Encoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'MintCloseAuthority',\n        addEncoderSizePrefix(\n          getStructEncoder([['closeAuthority', getAddressEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferMint',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['autoApproveNewAccounts', getBooleanEncoder()],\n            [\n              'auditorElgamalPubkey',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferAccount',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['approved', getBooleanEncoder()],\n            ['elgamalPubkey', getAddressEncoder()],\n            ['pendingBalanceLow', getEncryptedBalanceEncoder()],\n            ['pendingBalanceHigh', getEncryptedBalanceEncoder()],\n            ['availableBalance', getEncryptedBalanceEncoder()],\n            ['decryptableAvailableBalance', getDecryptableBalanceEncoder()],\n            ['allowConfidentialCredits', getBooleanEncoder()],\n            ['allowNonConfidentialCredits', getBooleanEncoder()],\n            ['pendingBalanceCreditCounter', getU64Encoder()],\n            ['maximumPendingBalanceCreditCounter', getU64Encoder()],\n            ['expectedPendingBalanceCreditCounter', getU64Encoder()],\n            ['actualPendingBalanceCreditCounter', getU64Encoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'DefaultAccountState',\n        addEncoderSizePrefix(\n          getStructEncoder([['state', getAccountStateEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'ImmutableOwner',\n        addEncoderSizePrefix(getStructEncoder([]), getU16Encoder()),\n      ],\n      [\n        'MemoTransfer',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['requireIncomingTransferMemos', getBooleanEncoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'NonTransferable',\n        addEncoderSizePrefix(getStructEncoder([]), getU16Encoder()),\n      ],\n      [\n        'InterestBearingConfig',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['rateAuthority', getAddressEncoder()],\n            ['initializationTimestamp', getU64Encoder()],\n            ['preUpdateAverageRate', getI16Encoder()],\n            ['lastUpdateTimestamp', getU64Encoder()],\n            ['currentRate', getI16Encoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'CpiGuard',\n        addEncoderSizePrefix(\n          getStructEncoder([['lockCpi', getBooleanEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'PermanentDelegate',\n        addEncoderSizePrefix(\n          getStructEncoder([['delegate', getAddressEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'NonTransferableAccount',\n        addEncoderSizePrefix(getStructEncoder([]), getU16Encoder()),\n      ],\n      [\n        'TransferHook',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['authority', getAddressEncoder()],\n            ['programId', getAddressEncoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'TransferHookAccount',\n        addEncoderSizePrefix(\n          getStructEncoder([['transferring', getBooleanEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferFee',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['elgamalPubkey', getAddressEncoder()],\n            ['harvestToMintEnabled', getBooleanEncoder()],\n            ['withheldAmount', getEncryptedBalanceEncoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferFeeAmount',\n        addEncoderSizePrefix(\n          getStructEncoder([['withheldAmount', getEncryptedBalanceEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'MetadataPointer',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'metadataAddress',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'TokenMetadata',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'updateAuthority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['mint', getAddressEncoder()],\n            ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n            ['symbol', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n            ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n            [\n              'additionalMetadata',\n              getMapEncoder(\n                addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),\n                addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())\n              ),\n            ],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'GroupPointer',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'groupAddress',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'TokenGroup',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'updateAuthority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['mint', getAddressEncoder()],\n            ['size', getU64Encoder()],\n            ['maxSize', getU64Encoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'GroupMemberPointer',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'memberAddress',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'TokenGroupMember',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['mint', getAddressEncoder()],\n            ['group', getAddressEncoder()],\n            ['memberNumber', getU64Encoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      ['ConfidentialMintBurn', getUnitEncoder()],\n      [\n        'ScaledUiAmountConfig',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['authority', getAddressEncoder()],\n            ['multiplier', getF64Encoder()],\n            ['newMultiplierEffectiveTimestamp', getU64Encoder()],\n            ['newMultiplier', getF64Encoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'PausableConfig',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['paused', getBooleanEncoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      ['PausableAccount', getUnitEncoder()],\n    ],\n    { size: getU16Encoder() }\n  );\n}\n\nexport function getExtensionDecoder(): Decoder<Extension> {\n  return getDiscriminatedUnionDecoder(\n    [\n      ['Uninitialized', getUnitDecoder()],\n      [\n        'TransferFeeConfig',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['transferFeeConfigAuthority', getAddressDecoder()],\n            ['withdrawWithheldAuthority', getAddressDecoder()],\n            ['withheldAmount', getU64Decoder()],\n            ['olderTransferFee', getTransferFeeDecoder()],\n            ['newerTransferFee', getTransferFeeDecoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'TransferFeeAmount',\n        addDecoderSizePrefix(\n          getStructDecoder([['withheldAmount', getU64Decoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'MintCloseAuthority',\n        addDecoderSizePrefix(\n          getStructDecoder([['closeAuthority', getAddressDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferMint',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['autoApproveNewAccounts', getBooleanDecoder()],\n            [\n              'auditorElgamalPubkey',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferAccount',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['approved', getBooleanDecoder()],\n            ['elgamalPubkey', getAddressDecoder()],\n            ['pendingBalanceLow', getEncryptedBalanceDecoder()],\n            ['pendingBalanceHigh', getEncryptedBalanceDecoder()],\n            ['availableBalance', getEncryptedBalanceDecoder()],\n            ['decryptableAvailableBalance', getDecryptableBalanceDecoder()],\n            ['allowConfidentialCredits', getBooleanDecoder()],\n            ['allowNonConfidentialCredits', getBooleanDecoder()],\n            ['pendingBalanceCreditCounter', getU64Decoder()],\n            ['maximumPendingBalanceCreditCounter', getU64Decoder()],\n            ['expectedPendingBalanceCreditCounter', getU64Decoder()],\n            ['actualPendingBalanceCreditCounter', getU64Decoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'DefaultAccountState',\n        addDecoderSizePrefix(\n          getStructDecoder([['state', getAccountStateDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'ImmutableOwner',\n        addDecoderSizePrefix(getStructDecoder([]), getU16Decoder()),\n      ],\n      [\n        'MemoTransfer',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['requireIncomingTransferMemos', getBooleanDecoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'NonTransferable',\n        addDecoderSizePrefix(getStructDecoder([]), getU16Decoder()),\n      ],\n      [\n        'InterestBearingConfig',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['rateAuthority', getAddressDecoder()],\n            ['initializationTimestamp', getU64Decoder()],\n            ['preUpdateAverageRate', getI16Decoder()],\n            ['lastUpdateTimestamp', getU64Decoder()],\n            ['currentRate', getI16Decoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'CpiGuard',\n        addDecoderSizePrefix(\n          getStructDecoder([['lockCpi', getBooleanDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'PermanentDelegate',\n        addDecoderSizePrefix(\n          getStructDecoder([['delegate', getAddressDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'NonTransferableAccount',\n        addDecoderSizePrefix(getStructDecoder([]), getU16Decoder()),\n      ],\n      [\n        'TransferHook',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['authority', getAddressDecoder()],\n            ['programId', getAddressDecoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'TransferHookAccount',\n        addDecoderSizePrefix(\n          getStructDecoder([['transferring', getBooleanDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferFee',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['elgamalPubkey', getAddressDecoder()],\n            ['harvestToMintEnabled', getBooleanDecoder()],\n            ['withheldAmount', getEncryptedBalanceDecoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferFeeAmount',\n        addDecoderSizePrefix(\n          getStructDecoder([['withheldAmount', getEncryptedBalanceDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'MetadataPointer',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'metadataAddress',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'TokenMetadata',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'updateAuthority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['mint', getAddressDecoder()],\n            ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n            ['symbol', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n            ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n            [\n              'additionalMetadata',\n              getMapDecoder(\n                addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()),\n                addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())\n              ),\n            ],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'GroupPointer',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'groupAddress',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'TokenGroup',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'updateAuthority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['mint', getAddressDecoder()],\n            ['size', getU64Decoder()],\n            ['maxSize', getU64Decoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'GroupMemberPointer',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'memberAddress',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'TokenGroupMember',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['mint', getAddressDecoder()],\n            ['group', getAddressDecoder()],\n            ['memberNumber', getU64Decoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      ['ConfidentialMintBurn', getUnitDecoder()],\n      [\n        'ScaledUiAmountConfig',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['authority', getAddressDecoder()],\n            ['multiplier', getF64Decoder()],\n            ['newMultiplierEffectiveTimestamp', getU64Decoder()],\n            ['newMultiplier', getF64Decoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'PausableConfig',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['paused', getBooleanDecoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      ['PausableAccount', getUnitDecoder()],\n    ],\n    { size: getU16Decoder() }\n  );\n}\n\nexport function getExtensionCodec(): Codec<ExtensionArgs, Extension> {\n  return combineCodec(getExtensionEncoder(), getExtensionDecoder());\n}\n\n// Data Enum Helpers.\nexport function extension(\n  kind: 'Uninitialized'\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'Uninitialized'>;\nexport function extension(\n  kind: 'TransferFeeConfig',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TransferFeeConfig'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TransferFeeConfig'>;\nexport function extension(\n  kind: 'TransferFeeAmount',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TransferFeeAmount'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TransferFeeAmount'>;\nexport function extension(\n  kind: 'MintCloseAuthority',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'MintCloseAuthority'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'MintCloseAuthority'>;\nexport function extension(\n  kind: 'ConfidentialTransferMint',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ConfidentialTransferMint'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ConfidentialTransferMint'\n>;\nexport function extension(\n  kind: 'ConfidentialTransferAccount',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ConfidentialTransferAccount'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ConfidentialTransferAccount'\n>;\nexport function extension(\n  kind: 'DefaultAccountState',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'DefaultAccountState'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'DefaultAccountState'>;\nexport function extension(\n  kind: 'ImmutableOwner',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ImmutableOwner'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'ImmutableOwner'>;\nexport function extension(\n  kind: 'MemoTransfer',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'MemoTransfer'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'MemoTransfer'>;\nexport function extension(\n  kind: 'NonTransferable',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'NonTransferable'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'NonTransferable'>;\nexport function extension(\n  kind: 'InterestBearingConfig',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'InterestBearingConfig'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'InterestBearingConfig'\n>;\nexport function extension(\n  kind: 'CpiGuard',\n  data: GetDiscriminatedUnionVariantContent<ExtensionArgs, '__kind', 'CpiGuard'>\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'CpiGuard'>;\nexport function extension(\n  kind: 'PermanentDelegate',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'PermanentDelegate'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'PermanentDelegate'>;\nexport function extension(\n  kind: 'NonTransferableAccount',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'NonTransferableAccount'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'NonTransferableAccount'\n>;\nexport function extension(\n  kind: 'TransferHook',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TransferHook'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TransferHook'>;\nexport function extension(\n  kind: 'TransferHookAccount',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TransferHookAccount'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TransferHookAccount'>;\nexport function extension(\n  kind: 'ConfidentialTransferFee',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ConfidentialTransferFee'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ConfidentialTransferFee'\n>;\nexport function extension(\n  kind: 'ConfidentialTransferFeeAmount',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ConfidentialTransferFeeAmount'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ConfidentialTransferFeeAmount'\n>;\nexport function extension(\n  kind: 'MetadataPointer',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'MetadataPointer'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'MetadataPointer'>;\nexport function extension(\n  kind: 'TokenMetadata',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TokenMetadata'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TokenMetadata'>;\nexport function extension(\n  kind: 'GroupPointer',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'GroupPointer'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'GroupPointer'>;\nexport function extension(\n  kind: 'TokenGroup',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TokenGroup'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TokenGroup'>;\nexport function extension(\n  kind: 'GroupMemberPointer',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'GroupMemberPointer'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'GroupMemberPointer'>;\nexport function extension(\n  kind: 'TokenGroupMember',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TokenGroupMember'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TokenGroupMember'>;\nexport function extension(\n  kind: 'ConfidentialMintBurn'\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ConfidentialMintBurn'\n>;\nexport function extension(\n  kind: 'ScaledUiAmountConfig',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ScaledUiAmountConfig'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ScaledUiAmountConfig'\n>;\nexport function extension(\n  kind: 'PausableConfig',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'PausableConfig'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'PausableConfig'>;\nexport function extension(\n  kind: 'PausableAccount'\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'PausableAccount'>;\nexport function extension<K extends ExtensionArgs['__kind'], Data>(\n  kind: K,\n  data?: Data\n) {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isExtension<K extends Extension['__kind']>(\n  kind: K,\n  value: Extension\n): value is Extension & { __kind: K } {\n  return value.__kind === kind;\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\n/**\n * Extensions that can be applied to mints or accounts.  Mint extensions must\n * only be applied to mint accounts, and account extensions must only be\n * applied to token holding accounts.\n */\n\nexport enum ExtensionType {\n  Uninitialized,\n  TransferFeeConfig,\n  TransferFeeAmount,\n  MintCloseAuthority,\n  ConfidentialTransferMint,\n  ConfidentialTransferAccount,\n  DefaultAccountState,\n  ImmutableOwner,\n  MemoTransfer,\n  NonTransferable,\n  InterestBearingConfig,\n  CpiGuard,\n  PermanentDelegate,\n  NonTransferableAccount,\n  TransferHook,\n  TransferHookAccount,\n  ConfidentialTransferFee,\n  ConfidentialTransferFeeAmount,\n  ScaledUiAmountConfig,\n  PausableConfig,\n  PausableAccount,\n  MetadataPointer,\n  TokenMetadata,\n  GroupPointer,\n  TokenGroup,\n  GroupMemberPointer,\n  TokenGroupMember,\n}\n\nexport type ExtensionTypeArgs = ExtensionType;\n\nexport function getExtensionTypeEncoder(): Encoder<ExtensionTypeArgs> {\n  return getEnumEncoder(ExtensionType, { size: getU16Encoder() });\n}\n\nexport function getExtensionTypeDecoder(): Decoder<ExtensionType> {\n  return getEnumDecoder(ExtensionType, { size: getU16Decoder() });\n}\n\nexport function getExtensionTypeCodec(): Codec<\n  ExtensionTypeArgs,\n  ExtensionType\n> {\n  return combineCodec(getExtensionTypeEncoder(), getExtensionTypeDecoder());\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getDiscriminatedUnionDecoder,\n  getDiscriminatedUnionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getTupleDecoder,\n  getTupleEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUnitDecoder,\n  getUnitEncoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type GetDiscriminatedUnionVariant,\n  type GetDiscriminatedUnionVariantContent,\n} from '@solana/kit';\n\n/** Fields in the metadata account, used for updating. */\nexport type TokenMetadataField =\n  | { __kind: 'Name' }\n  | { __kind: 'Symbol' }\n  | { __kind: 'Uri' }\n  | { __kind: 'Key'; fields: readonly [string] };\n\nexport type TokenMetadataFieldArgs = TokenMetadataField;\n\nexport function getTokenMetadataFieldEncoder(): Encoder<TokenMetadataFieldArgs> {\n  return getDiscriminatedUnionEncoder([\n    ['Name', getUnitEncoder()],\n    ['Symbol', getUnitEncoder()],\n    ['Uri', getUnitEncoder()],\n    [\n      'Key',\n      getStructEncoder([\n        [\n          'fields',\n          getTupleEncoder([\n            addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),\n          ]),\n        ],\n      ]),\n    ],\n  ]);\n}\n\nexport function getTokenMetadataFieldDecoder(): Decoder<TokenMetadataField> {\n  return getDiscriminatedUnionDecoder([\n    ['Name', getUnitDecoder()],\n    ['Symbol', getUnitDecoder()],\n    ['Uri', getUnitDecoder()],\n    [\n      'Key',\n      getStructDecoder([\n        [\n          'fields',\n          getTupleDecoder([\n            addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()),\n          ]),\n        ],\n      ]),\n    ],\n  ]);\n}\n\nexport function getTokenMetadataFieldCodec(): Codec<\n  TokenMetadataFieldArgs,\n  TokenMetadataField\n> {\n  return combineCodec(\n    getTokenMetadataFieldEncoder(),\n    getTokenMetadataFieldDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function tokenMetadataField(\n  kind: 'Name'\n): GetDiscriminatedUnionVariant<TokenMetadataFieldArgs, '__kind', 'Name'>;\nexport function tokenMetadataField(\n  kind: 'Symbol'\n): GetDiscriminatedUnionVariant<TokenMetadataFieldArgs, '__kind', 'Symbol'>;\nexport function tokenMetadataField(\n  kind: 'Uri'\n): GetDiscriminatedUnionVariant<TokenMetadataFieldArgs, '__kind', 'Uri'>;\nexport function tokenMetadataField(\n  kind: 'Key',\n  data: GetDiscriminatedUnionVariantContent<\n    TokenMetadataFieldArgs,\n    '__kind',\n    'Key'\n  >['fields']\n): GetDiscriminatedUnionVariant<TokenMetadataFieldArgs, '__kind', 'Key'>;\nexport function tokenMetadataField<\n  K extends TokenMetadataFieldArgs['__kind'],\n  Data,\n>(kind: K, data?: Data) {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isTokenMetadataField<K extends TokenMetadataField['__kind']>(\n  kind: K,\n  value: TokenMetadataField\n): value is TokenMetadataField & { __kind: K } {\n  return value.__kind === kind;\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport type TransferFee = {\n  /** First epoch where the transfer fee takes effect. */\n  epoch: bigint;\n  /** Maximum fee assessed on transfers, expressed as an amount of tokens. */\n  maximumFee: bigint;\n  /**\n   * Amount of transfer collected as fees, expressed as basis points of the\n   * transfer amount, ie. increments of 0.01%.\n   */\n  transferFeeBasisPoints: number;\n};\n\nexport type TransferFeeArgs = {\n  /** First epoch where the transfer fee takes effect. */\n  epoch: number | bigint;\n  /** Maximum fee assessed on transfers, expressed as an amount of tokens. */\n  maximumFee: number | bigint;\n  /**\n   * Amount of transfer collected as fees, expressed as basis points of the\n   * transfer amount, ie. increments of 0.01%.\n   */\n  transferFeeBasisPoints: number;\n};\n\nexport function getTransferFeeEncoder(): Encoder<TransferFeeArgs> {\n  return getStructEncoder([\n    ['epoch', getU64Encoder()],\n    ['maximumFee', getU64Encoder()],\n    ['transferFeeBasisPoints', getU16Encoder()],\n  ]);\n}\n\nexport function getTransferFeeDecoder(): Decoder<TransferFee> {\n  return getStructDecoder([\n    ['epoch', getU64Decoder()],\n    ['maximumFee', getU64Decoder()],\n    ['transferFeeBasisPoints', getU16Decoder()],\n  ]);\n}\n\nexport function getTransferFeeCodec(): Codec<TransferFeeArgs, TransferFee> {\n  return combineCodec(getTransferFeeEncoder(), getTransferFeeDecoder());\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getArrayDecoder,\n  getArrayEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getConstantDecoder,\n  getConstantEncoder,\n  getHiddenPrefixDecoder,\n  getHiddenPrefixEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  padLeftEncoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/kit';\nimport {\n  getExtensionDecoder,\n  getExtensionEncoder,\n  type Extension,\n  type ExtensionArgs,\n} from '../types';\n\nexport type Mint = {\n  /**\n   * Optional authority used to mint new tokens. The mint authority may only\n   * be provided during mint creation. If no mint authority is present\n   * then the mint has a fixed supply and no further tokens may be minted.\n   */\n  mintAuthority: Option<Address>;\n  /** Total supply of tokens. */\n  supply: bigint;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Optional authority to freeze token accounts. */\n  freezeAuthority: Option<Address>;\n  /** The extensions activated on the mint account. */\n  extensions: Option<Array<Extension>>;\n};\n\nexport type MintArgs = {\n  /**\n   * Optional authority used to mint new tokens. The mint authority may only\n   * be provided during mint creation. If no mint authority is present\n   * then the mint has a fixed supply and no further tokens may be minted.\n   */\n  mintAuthority: OptionOrNullable<Address>;\n  /** Total supply of tokens. */\n  supply: number | bigint;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Optional authority to freeze token accounts. */\n  freezeAuthority: OptionOrNullable<Address>;\n  /** The extensions activated on the mint account. */\n  extensions: OptionOrNullable<Array<ExtensionArgs>>;\n};\n\nexport function getMintEncoder(): Encoder<MintArgs> {\n  return getStructEncoder([\n    [\n      'mintAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['supply', getU64Encoder()],\n    ['decimals', getU8Encoder()],\n    ['isInitialized', getBooleanEncoder()],\n    [\n      'freezeAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'extensions',\n      getOptionEncoder(\n        getHiddenPrefixEncoder(\n          getArrayEncoder(getExtensionEncoder(), { size: 'remainder' }),\n          [getConstantEncoder(padLeftEncoder(getU8Encoder(), 83).encode(1))]\n        ),\n        { prefix: null }\n      ),\n    ],\n  ]);\n}\n\nexport function getMintDecoder(): Decoder<Mint> {\n  return getStructDecoder([\n    [\n      'mintAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['supply', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n    ['isInitialized', getBooleanDecoder()],\n    [\n      'freezeAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'extensions',\n      getOptionDecoder(\n        getHiddenPrefixDecoder(\n          getArrayDecoder(getExtensionDecoder(), { size: 'remainder' }),\n          [getConstantDecoder(padLeftEncoder(getU8Encoder(), 83).encode(1))]\n        ),\n        { prefix: null }\n      ),\n    ],\n  ]);\n}\n\nexport function getMintCodec(): Codec<MintArgs, Mint> {\n  return combineCodec(getMintEncoder(), getMintDecoder());\n}\n\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Mint, TAddress>;\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Mint, TAddress>;\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Mint, TAddress> | MaybeAccount<Mint, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getMintDecoder()\n  );\n}\n\nexport async function fetchMint<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Mint, TAddress>> {\n  const maybeAccount = await fetchMaybeMint(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeMint<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Mint, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeMint(maybeAccount);\n}\n\nexport async function fetchAllMint(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Mint>[]> {\n  const maybeAccounts = await fetchAllMaybeMint(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeMint(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Mint>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeMint(maybeAccount));\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getArrayDecoder,\n  getArrayEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n} from '@solana/kit';\n\nexport type Multisig = {\n  /** Number of signers required. */\n  m: number;\n  /** Number of valid signers. */\n  n: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Signer public keys. */\n  signers: Array<Address>;\n};\n\nexport type MultisigArgs = Multisig;\n\nexport function getMultisigEncoder(): Encoder<MultisigArgs> {\n  return getStructEncoder([\n    ['m', getU8Encoder()],\n    ['n', getU8Encoder()],\n    ['isInitialized', getBooleanEncoder()],\n    ['signers', getArrayEncoder(getAddressEncoder(), { size: 11 })],\n  ]);\n}\n\nexport function getMultisigDecoder(): Decoder<Multisig> {\n  return getStructDecoder([\n    ['m', getU8Decoder()],\n    ['n', getU8Decoder()],\n    ['isInitialized', getBooleanDecoder()],\n    ['signers', getArrayDecoder(getAddressDecoder(), { size: 11 })],\n  ]);\n}\n\nexport function getMultisigCodec(): Codec<MultisigArgs, Multisig> {\n  return combineCodec(getMultisigEncoder(), getMultisigDecoder());\n}\n\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Multisig, TAddress>;\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Multisig, TAddress>;\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Multisig, TAddress> | MaybeAccount<Multisig, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getMultisigDecoder()\n  );\n}\n\nexport async function fetchMultisig<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Multisig, TAddress>> {\n  const maybeAccount = await fetchMaybeMultisig(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeMultisig<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Multisig, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeMultisig(maybeAccount);\n}\n\nexport async function fetchAllMultisig(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Multisig>[]> {\n  const maybeAccounts = await fetchAllMaybeMultisig(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeMultisig(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Multisig>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeMultisig(maybeAccount));\n}\n\nexport function getMultisigSize(): number {\n  return 355;\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getArrayDecoder,\n  getArrayEncoder,\n  getConstantDecoder,\n  getConstantEncoder,\n  getHiddenPrefixDecoder,\n  getHiddenPrefixEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Encoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/kit';\nimport {\n  getAccountStateDecoder,\n  getAccountStateEncoder,\n  getExtensionDecoder,\n  getExtensionEncoder,\n  type AccountState,\n  type AccountStateArgs,\n  type Extension,\n  type ExtensionArgs,\n} from '../types';\n\nexport type Token = {\n  /** The mint associated with this account. */\n  mint: Address;\n  /** The owner of this account. */\n  owner: Address;\n  /** The amount of tokens this account holds. */\n  amount: bigint;\n  /**\n   * If `delegate` is `Some` then `delegated_amount` represents\n   * the amount authorized by the delegate.\n   */\n  delegate: Option<Address>;\n  /** The account's state. */\n  state: AccountState;\n  /**\n   * If is_native.is_some, this is a native token, and the value logs the\n   * rent-exempt reserve. An Account is required to be rent-exempt, so\n   * the value is used by the Processor to ensure that wrapped SOL\n   * accounts do not drop below this threshold.\n   */\n  isNative: Option<bigint>;\n  /** The amount delegated. */\n  delegatedAmount: bigint;\n  /** Optional authority to close the account. */\n  closeAuthority: Option<Address>;\n  /** The extensions activated on the token account. */\n  extensions: Option<Array<Extension>>;\n};\n\nexport type TokenArgs = {\n  /** The mint associated with this account. */\n  mint: Address;\n  /** The owner of this account. */\n  owner: Address;\n  /** The amount of tokens this account holds. */\n  amount: number | bigint;\n  /**\n   * If `delegate` is `Some` then `delegated_amount` represents\n   * the amount authorized by the delegate.\n   */\n  delegate: OptionOrNullable<Address>;\n  /** The account's state. */\n  state: AccountStateArgs;\n  /**\n   * If is_native.is_some, this is a native token, and the value logs the\n   * rent-exempt reserve. An Account is required to be rent-exempt, so\n   * the value is used by the Processor to ensure that wrapped SOL\n   * accounts do not drop below this threshold.\n   */\n  isNative: OptionOrNullable<number | bigint>;\n  /** The amount delegated. */\n  delegatedAmount: number | bigint;\n  /** Optional authority to close the account. */\n  closeAuthority: OptionOrNullable<Address>;\n  /** The extensions activated on the token account. */\n  extensions: OptionOrNullable<Array<ExtensionArgs>>;\n};\n\nexport function getTokenEncoder(): Encoder<TokenArgs> {\n  return getStructEncoder([\n    ['mint', getAddressEncoder()],\n    ['owner', getAddressEncoder()],\n    ['amount', getU64Encoder()],\n    [\n      'delegate',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['state', getAccountStateEncoder()],\n    [\n      'isNative',\n      getOptionEncoder(getU64Encoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['delegatedAmount', getU64Encoder()],\n    [\n      'closeAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'extensions',\n      getOptionEncoder(\n        getHiddenPrefixEncoder(\n          getArrayEncoder(getExtensionEncoder(), { size: 'remainder' }),\n          [getConstantEncoder(getU8Encoder().encode(2))]\n        ),\n        { prefix: null }\n      ),\n    ],\n  ]);\n}\n\nexport function getTokenDecoder(): Decoder<Token> {\n  return getStructDecoder([\n    ['mint', getAddressDecoder()],\n    ['owner', getAddressDecoder()],\n    ['amount', getU64Decoder()],\n    [\n      'delegate',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['state', getAccountStateDecoder()],\n    [\n      'isNative',\n      getOptionDecoder(getU64Decoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['delegatedAmount', getU64Decoder()],\n    [\n      'closeAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'extensions',\n      getOptionDecoder(\n        getHiddenPrefixDecoder(\n          getArrayDecoder(getExtensionDecoder(), { size: 'remainder' }),\n          [getConstantDecoder(getU8Encoder().encode(2))]\n        ),\n        { prefix: null }\n      ),\n    ],\n  ]);\n}\n\nexport function getTokenCodec(): Codec<TokenArgs, Token> {\n  return combineCodec(getTokenEncoder(), getTokenDecoder());\n}\n\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Token, TAddress>;\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Token, TAddress>;\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Token, TAddress> | MaybeAccount<Token, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getTokenDecoder()\n  );\n}\n\nexport async function fetchToken<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Token, TAddress>> {\n  const maybeAccount = await fetchMaybeToken(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeToken<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Token, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeToken(maybeAccount);\n}\n\nexport async function fetchAllToken(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Token>[]> {\n  const maybeAccounts = await fetchAllMaybeToken(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeToken(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Token>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeToken(maybeAccount));\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU8Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedCreateAssociatedTokenIdempotentInstruction,\n  type ParsedCreateAssociatedTokenInstruction,\n  type ParsedRecoverNestedAssociatedTokenInstruction,\n} from '../instructions';\n\nexport const ASSOCIATED_TOKEN_PROGRAM_ADDRESS =\n  'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;\n\nexport enum AssociatedTokenInstruction {\n  CreateAssociatedToken,\n  CreateAssociatedTokenIdempotent,\n  RecoverNestedAssociatedToken,\n}\n\nexport function identifyAssociatedTokenInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): AssociatedTokenInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return AssociatedTokenInstruction.CreateAssociatedToken;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return AssociatedTokenInstruction.CreateAssociatedTokenIdempotent;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return AssociatedTokenInstruction.RecoverNestedAssociatedToken;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a associatedToken instruction.'\n  );\n}\n\nexport type ParsedAssociatedTokenInstruction<\n  TProgram extends string = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',\n> =\n  | ({\n      instructionType: AssociatedTokenInstruction.CreateAssociatedToken;\n    } & ParsedCreateAssociatedTokenInstruction<TProgram>)\n  | ({\n      instructionType: AssociatedTokenInstruction.CreateAssociatedTokenIdempotent;\n    } & ParsedCreateAssociatedTokenIdempotentInstruction<TProgram>)\n  | ({\n      instructionType: AssociatedTokenInstruction.RecoverNestedAssociatedToken;\n    } & ParsedRecoverNestedAssociatedTokenInstruction<TProgram>);\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU8Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedAmountToUiAmountInstruction,\n  type ParsedApplyConfidentialPendingBalanceInstruction,\n  type ParsedApproveCheckedInstruction,\n  type ParsedApproveConfidentialTransferAccountInstruction,\n  type ParsedApproveInstruction,\n  type ParsedBurnCheckedInstruction,\n  type ParsedBurnInstruction,\n  type ParsedCloseAccountInstruction,\n  type ParsedConfidentialDepositInstruction,\n  type ParsedConfidentialTransferInstruction,\n  type ParsedConfidentialTransferWithFeeInstruction,\n  type ParsedConfidentialWithdrawInstruction,\n  type ParsedConfigureConfidentialTransferAccountInstruction,\n  type ParsedCreateNativeMintInstruction,\n  type ParsedDisableConfidentialCreditsInstruction,\n  type ParsedDisableCpiGuardInstruction,\n  type ParsedDisableHarvestToMintInstruction,\n  type ParsedDisableMemoTransfersInstruction,\n  type ParsedDisableNonConfidentialCreditsInstruction,\n  type ParsedEmitTokenMetadataInstruction,\n  type ParsedEmptyConfidentialTransferAccountInstruction,\n  type ParsedEnableConfidentialCreditsInstruction,\n  type ParsedEnableCpiGuardInstruction,\n  type ParsedEnableHarvestToMintInstruction,\n  type ParsedEnableMemoTransfersInstruction,\n  type ParsedEnableNonConfidentialCreditsInstruction,\n  type ParsedFreezeAccountInstruction,\n  type ParsedGetAccountDataSizeInstruction,\n  type ParsedHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction,\n  type ParsedHarvestWithheldTokensToMintInstruction,\n  type ParsedInitializeAccount2Instruction,\n  type ParsedInitializeAccount3Instruction,\n  type ParsedInitializeAccountInstruction,\n  type ParsedInitializeConfidentialTransferFeeInstruction,\n  type ParsedInitializeConfidentialTransferMintInstruction,\n  type ParsedInitializeDefaultAccountStateInstruction,\n  type ParsedInitializeGroupMemberPointerInstruction,\n  type ParsedInitializeGroupPointerInstruction,\n  type ParsedInitializeImmutableOwnerInstruction,\n  type ParsedInitializeInterestBearingMintInstruction,\n  type ParsedInitializeMetadataPointerInstruction,\n  type ParsedInitializeMint2Instruction,\n  type ParsedInitializeMintCloseAuthorityInstruction,\n  type ParsedInitializeMintInstruction,\n  type ParsedInitializeMultisig2Instruction,\n  type ParsedInitializeMultisigInstruction,\n  type ParsedInitializeNonTransferableMintInstruction,\n  type ParsedInitializePausableConfigInstruction,\n  type ParsedInitializePermanentDelegateInstruction,\n  type ParsedInitializeScaledUiAmountMintInstruction,\n  type ParsedInitializeTokenGroupInstruction,\n  type ParsedInitializeTokenGroupMemberInstruction,\n  type ParsedInitializeTokenMetadataInstruction,\n  type ParsedInitializeTransferFeeConfigInstruction,\n  type ParsedInitializeTransferHookInstruction,\n  type ParsedMintToCheckedInstruction,\n  type ParsedMintToInstruction,\n  type ParsedPauseInstruction,\n  type ParsedReallocateInstruction,\n  type ParsedRemoveTokenMetadataKeyInstruction,\n  type ParsedResumeInstruction,\n  type ParsedRevokeInstruction,\n  type ParsedSetAuthorityInstruction,\n  type ParsedSetTransferFeeInstruction,\n  type ParsedSyncNativeInstruction,\n  type ParsedThawAccountInstruction,\n  type ParsedTransferCheckedInstruction,\n  type ParsedTransferCheckedWithFeeInstruction,\n  type ParsedTransferInstruction,\n  type ParsedUiAmountToAmountInstruction,\n  type ParsedUpdateConfidentialTransferMintInstruction,\n  type ParsedUpdateDefaultAccountStateInstruction,\n  type ParsedUpdateGroupMemberPointerInstruction,\n  type ParsedUpdateGroupPointerInstruction,\n  type ParsedUpdateMetadataPointerInstruction,\n  type ParsedUpdateMultiplierScaledUiMintInstruction,\n  type ParsedUpdateRateInterestBearingMintInstruction,\n  type ParsedUpdateTokenGroupMaxSizeInstruction,\n  type ParsedUpdateTokenGroupUpdateAuthorityInstruction,\n  type ParsedUpdateTokenMetadataFieldInstruction,\n  type ParsedUpdateTokenMetadataUpdateAuthorityInstruction,\n  type ParsedUpdateTransferHookInstruction,\n  type ParsedWithdrawExcessLamportsInstruction,\n  type ParsedWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction,\n  type ParsedWithdrawWithheldTokensFromAccountsInstruction,\n  type ParsedWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction,\n  type ParsedWithdrawWithheldTokensFromMintInstruction,\n} from '../instructions';\n\nexport const TOKEN_2022_PROGRAM_ADDRESS =\n  'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n\nexport enum Token2022Account {\n  Mint,\n  Token,\n  Multisig,\n}\n\nexport function identifyToken2022Account(\n  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): Token2022Account {\n  const data = 'data' in account ? account.data : account;\n  if (data.length === 82) {\n    return Token2022Account.Mint;\n  }\n  if (data.length === 165) {\n    return Token2022Account.Token;\n  }\n  if (data.length === 355) {\n    return Token2022Account.Multisig;\n  }\n  throw new Error(\n    'The provided account could not be identified as a token-2022 account.'\n  );\n}\n\nexport enum Token2022Instruction {\n  InitializeMint,\n  InitializeAccount,\n  InitializeMultisig,\n  Transfer,\n  Approve,\n  Revoke,\n  SetAuthority,\n  MintTo,\n  Burn,\n  CloseAccount,\n  FreezeAccount,\n  ThawAccount,\n  TransferChecked,\n  ApproveChecked,\n  MintToChecked,\n  BurnChecked,\n  InitializeAccount2,\n  SyncNative,\n  InitializeAccount3,\n  InitializeMultisig2,\n  InitializeMint2,\n  GetAccountDataSize,\n  InitializeImmutableOwner,\n  AmountToUiAmount,\n  UiAmountToAmount,\n  InitializeMintCloseAuthority,\n  InitializeTransferFeeConfig,\n  TransferCheckedWithFee,\n  WithdrawWithheldTokensFromMint,\n  WithdrawWithheldTokensFromAccounts,\n  HarvestWithheldTokensToMint,\n  SetTransferFee,\n  InitializeConfidentialTransferMint,\n  UpdateConfidentialTransferMint,\n  ConfigureConfidentialTransferAccount,\n  ApproveConfidentialTransferAccount,\n  EmptyConfidentialTransferAccount,\n  ConfidentialDeposit,\n  ConfidentialWithdraw,\n  ConfidentialTransfer,\n  ApplyConfidentialPendingBalance,\n  EnableConfidentialCredits,\n  DisableConfidentialCredits,\n  EnableNonConfidentialCredits,\n  DisableNonConfidentialCredits,\n  ConfidentialTransferWithFee,\n  InitializeDefaultAccountState,\n  UpdateDefaultAccountState,\n  Reallocate,\n  EnableMemoTransfers,\n  DisableMemoTransfers,\n  CreateNativeMint,\n  InitializeNonTransferableMint,\n  InitializeInterestBearingMint,\n  UpdateRateInterestBearingMint,\n  EnableCpiGuard,\n  DisableCpiGuard,\n  InitializePermanentDelegate,\n  InitializeTransferHook,\n  UpdateTransferHook,\n  InitializeConfidentialTransferFee,\n  WithdrawWithheldTokensFromMintForConfidentialTransferFee,\n  WithdrawWithheldTokensFromAccountsForConfidentialTransferFee,\n  HarvestWithheldTokensToMintForConfidentialTransferFee,\n  EnableHarvestToMint,\n  DisableHarvestToMint,\n  WithdrawExcessLamports,\n  InitializeMetadataPointer,\n  UpdateMetadataPointer,\n  InitializeGroupPointer,\n  UpdateGroupPointer,\n  InitializeGroupMemberPointer,\n  UpdateGroupMemberPointer,\n  InitializeScaledUiAmountMint,\n  UpdateMultiplierScaledUiMint,\n  InitializePausableConfig,\n  Pause,\n  Resume,\n  InitializeTokenMetadata,\n  UpdateTokenMetadataField,\n  RemoveTokenMetadataKey,\n  UpdateTokenMetadataUpdateAuthority,\n  EmitTokenMetadata,\n  InitializeTokenGroup,\n  UpdateTokenGroupMaxSize,\n  UpdateTokenGroupUpdateAuthority,\n  InitializeTokenGroupMember,\n}\n\nexport function identifyToken2022Instruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): Token2022Instruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return Token2022Instruction.InitializeMint;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return Token2022Instruction.InitializeAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return Token2022Instruction.InitializeMultisig;\n  }\n  if (containsBytes(data, getU8Encoder().encode(3), 0)) {\n    return Token2022Instruction.Transfer;\n  }\n  if (containsBytes(data, getU8Encoder().encode(4), 0)) {\n    return Token2022Instruction.Approve;\n  }\n  if (containsBytes(data, getU8Encoder().encode(5), 0)) {\n    return Token2022Instruction.Revoke;\n  }\n  if (containsBytes(data, getU8Encoder().encode(6), 0)) {\n    return Token2022Instruction.SetAuthority;\n  }\n  if (containsBytes(data, getU8Encoder().encode(7), 0)) {\n    return Token2022Instruction.MintTo;\n  }\n  if (containsBytes(data, getU8Encoder().encode(8), 0)) {\n    return Token2022Instruction.Burn;\n  }\n  if (containsBytes(data, getU8Encoder().encode(9), 0)) {\n    return Token2022Instruction.CloseAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(10), 0)) {\n    return Token2022Instruction.FreezeAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(11), 0)) {\n    return Token2022Instruction.ThawAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(12), 0)) {\n    return Token2022Instruction.TransferChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(13), 0)) {\n    return Token2022Instruction.ApproveChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(14), 0)) {\n    return Token2022Instruction.MintToChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(15), 0)) {\n    return Token2022Instruction.BurnChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(16), 0)) {\n    return Token2022Instruction.InitializeAccount2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(17), 0)) {\n    return Token2022Instruction.SyncNative;\n  }\n  if (containsBytes(data, getU8Encoder().encode(18), 0)) {\n    return Token2022Instruction.InitializeAccount3;\n  }\n  if (containsBytes(data, getU8Encoder().encode(19), 0)) {\n    return Token2022Instruction.InitializeMultisig2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(20), 0)) {\n    return Token2022Instruction.InitializeMint2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(21), 0)) {\n    return Token2022Instruction.GetAccountDataSize;\n  }\n  if (containsBytes(data, getU8Encoder().encode(22), 0)) {\n    return Token2022Instruction.InitializeImmutableOwner;\n  }\n  if (containsBytes(data, getU8Encoder().encode(23), 0)) {\n    return Token2022Instruction.AmountToUiAmount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(24), 0)) {\n    return Token2022Instruction.UiAmountToAmount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(25), 0)) {\n    return Token2022Instruction.InitializeMintCloseAuthority;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeTransferFeeConfig;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.TransferCheckedWithFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(2), 1)\n  ) {\n    return Token2022Instruction.WithdrawWithheldTokensFromMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(3), 1)\n  ) {\n    return Token2022Instruction.WithdrawWithheldTokensFromAccounts;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(4), 1)\n  ) {\n    return Token2022Instruction.HarvestWithheldTokensToMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(5), 1)\n  ) {\n    return Token2022Instruction.SetTransferFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeConfidentialTransferMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateConfidentialTransferMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(2), 1)\n  ) {\n    return Token2022Instruction.ConfigureConfidentialTransferAccount;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(3), 1)\n  ) {\n    return Token2022Instruction.ApproveConfidentialTransferAccount;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(4), 1)\n  ) {\n    return Token2022Instruction.EmptyConfidentialTransferAccount;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(5), 1)\n  ) {\n    return Token2022Instruction.ConfidentialDeposit;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(6), 1)\n  ) {\n    return Token2022Instruction.ConfidentialWithdraw;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(7), 1)\n  ) {\n    return Token2022Instruction.ConfidentialTransfer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(8), 1)\n  ) {\n    return Token2022Instruction.ApplyConfidentialPendingBalance;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(9), 1)\n  ) {\n    return Token2022Instruction.EnableConfidentialCredits;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(10), 1)\n  ) {\n    return Token2022Instruction.DisableConfidentialCredits;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(11), 1)\n  ) {\n    return Token2022Instruction.EnableNonConfidentialCredits;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(12), 1)\n  ) {\n    return Token2022Instruction.DisableNonConfidentialCredits;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(13), 1)\n  ) {\n    return Token2022Instruction.ConfidentialTransferWithFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(28), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeDefaultAccountState;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(28), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateDefaultAccountState;\n  }\n  if (containsBytes(data, getU8Encoder().encode(29), 0)) {\n    return Token2022Instruction.Reallocate;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(30), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.EnableMemoTransfers;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(30), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.DisableMemoTransfers;\n  }\n  if (containsBytes(data, getU8Encoder().encode(31), 0)) {\n    return Token2022Instruction.CreateNativeMint;\n  }\n  if (containsBytes(data, getU8Encoder().encode(32), 0)) {\n    return Token2022Instruction.InitializeNonTransferableMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(33), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeInterestBearingMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(33), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateRateInterestBearingMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(34), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.EnableCpiGuard;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(34), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.DisableCpiGuard;\n  }\n  if (containsBytes(data, getU8Encoder().encode(35), 0)) {\n    return Token2022Instruction.InitializePermanentDelegate;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(36), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeTransferHook;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(36), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateTransferHook;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeConfidentialTransferFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.WithdrawWithheldTokensFromMintForConfidentialTransferFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(2), 1)\n  ) {\n    return Token2022Instruction.WithdrawWithheldTokensFromAccountsForConfidentialTransferFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(3), 1)\n  ) {\n    return Token2022Instruction.HarvestWithheldTokensToMintForConfidentialTransferFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(4), 1)\n  ) {\n    return Token2022Instruction.EnableHarvestToMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(5), 1)\n  ) {\n    return Token2022Instruction.DisableHarvestToMint;\n  }\n  if (containsBytes(data, getU8Encoder().encode(38), 0)) {\n    return Token2022Instruction.WithdrawExcessLamports;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(39), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeMetadataPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(39), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateMetadataPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(40), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeGroupPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(40), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateGroupPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(41), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeGroupMemberPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(41), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateGroupMemberPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(43), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeScaledUiAmountMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(43), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateMultiplierScaledUiMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(44), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializePausableConfig;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(44), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.Pause;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(44), 0) &&\n    containsBytes(data, getU8Encoder().encode(2), 1)\n  ) {\n    return Token2022Instruction.Resume;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([210, 225, 30, 162, 88, 184, 77, 141]),\n      0\n    )\n  ) {\n    return Token2022Instruction.InitializeTokenMetadata;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([221, 233, 49, 45, 181, 202, 220, 200]),\n      0\n    )\n  ) {\n    return Token2022Instruction.UpdateTokenMetadataField;\n  }\n  if (\n    containsBytes(data, new Uint8Array([234, 18, 32, 56, 89, 141, 37, 181]), 0)\n  ) {\n    return Token2022Instruction.RemoveTokenMetadataKey;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([215, 228, 166, 228, 84, 100, 86, 123]),\n      0\n    )\n  ) {\n    return Token2022Instruction.UpdateTokenMetadataUpdateAuthority;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([250, 166, 180, 250, 13, 12, 184, 70]),\n      0\n    )\n  ) {\n    return Token2022Instruction.EmitTokenMetadata;\n  }\n  if (\n    containsBytes(data, new Uint8Array([121, 113, 108, 39, 54, 51, 0, 4]), 0)\n  ) {\n    return Token2022Instruction.InitializeTokenGroup;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([108, 37, 171, 143, 248, 30, 18, 110]),\n      0\n    )\n  ) {\n    return Token2022Instruction.UpdateTokenGroupMaxSize;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([161, 105, 88, 1, 237, 221, 216, 203]),\n      0\n    )\n  ) {\n    return Token2022Instruction.UpdateTokenGroupUpdateAuthority;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([152, 32, 222, 176, 223, 237, 116, 134]),\n      0\n    )\n  ) {\n    return Token2022Instruction.InitializeTokenGroupMember;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a token-2022 instruction.'\n  );\n}\n\nexport type ParsedToken2022Instruction<\n  TProgram extends string = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',\n> =\n  | ({\n      instructionType: Token2022Instruction.InitializeMint;\n    } & ParsedInitializeMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeAccount;\n    } & ParsedInitializeAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeMultisig;\n    } & ParsedInitializeMultisigInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Transfer;\n    } & ParsedTransferInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Approve;\n    } & ParsedApproveInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Revoke;\n    } & ParsedRevokeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.SetAuthority;\n    } & ParsedSetAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.MintTo;\n    } & ParsedMintToInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Burn;\n    } & ParsedBurnInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.CloseAccount;\n    } & ParsedCloseAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.FreezeAccount;\n    } & ParsedFreezeAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ThawAccount;\n    } & ParsedThawAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.TransferChecked;\n    } & ParsedTransferCheckedInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ApproveChecked;\n    } & ParsedApproveCheckedInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.MintToChecked;\n    } & ParsedMintToCheckedInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.BurnChecked;\n    } & ParsedBurnCheckedInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeAccount2;\n    } & ParsedInitializeAccount2Instruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.SyncNative;\n    } & ParsedSyncNativeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeAccount3;\n    } & ParsedInitializeAccount3Instruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeMultisig2;\n    } & ParsedInitializeMultisig2Instruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeMint2;\n    } & ParsedInitializeMint2Instruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.GetAccountDataSize;\n    } & ParsedGetAccountDataSizeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeImmutableOwner;\n    } & ParsedInitializeImmutableOwnerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.AmountToUiAmount;\n    } & ParsedAmountToUiAmountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UiAmountToAmount;\n    } & ParsedUiAmountToAmountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeMintCloseAuthority;\n    } & ParsedInitializeMintCloseAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeTransferFeeConfig;\n    } & ParsedInitializeTransferFeeConfigInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.TransferCheckedWithFee;\n    } & ParsedTransferCheckedWithFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.WithdrawWithheldTokensFromMint;\n    } & ParsedWithdrawWithheldTokensFromMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.WithdrawWithheldTokensFromAccounts;\n    } & ParsedWithdrawWithheldTokensFromAccountsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.HarvestWithheldTokensToMint;\n    } & ParsedHarvestWithheldTokensToMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.SetTransferFee;\n    } & ParsedSetTransferFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeConfidentialTransferMint;\n    } & ParsedInitializeConfidentialTransferMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateConfidentialTransferMint;\n    } & ParsedUpdateConfidentialTransferMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ConfigureConfidentialTransferAccount;\n    } & ParsedConfigureConfidentialTransferAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ApproveConfidentialTransferAccount;\n    } & ParsedApproveConfidentialTransferAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EmptyConfidentialTransferAccount;\n    } & ParsedEmptyConfidentialTransferAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ConfidentialDeposit;\n    } & ParsedConfidentialDepositInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ConfidentialWithdraw;\n    } & ParsedConfidentialWithdrawInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ConfidentialTransfer;\n    } & ParsedConfidentialTransferInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ApplyConfidentialPendingBalance;\n    } & ParsedApplyConfidentialPendingBalanceInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EnableConfidentialCredits;\n    } & ParsedEnableConfidentialCreditsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.DisableConfidentialCredits;\n    } & ParsedDisableConfidentialCreditsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EnableNonConfidentialCredits;\n    } & ParsedEnableNonConfidentialCreditsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.DisableNonConfidentialCredits;\n    } & ParsedDisableNonConfidentialCreditsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ConfidentialTransferWithFee;\n    } & ParsedConfidentialTransferWithFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeDefaultAccountState;\n    } & ParsedInitializeDefaultAccountStateInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateDefaultAccountState;\n    } & ParsedUpdateDefaultAccountStateInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Reallocate;\n    } & ParsedReallocateInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EnableMemoTransfers;\n    } & ParsedEnableMemoTransfersInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.DisableMemoTransfers;\n    } & ParsedDisableMemoTransfersInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.CreateNativeMint;\n    } & ParsedCreateNativeMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeNonTransferableMint;\n    } & ParsedInitializeNonTransferableMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeInterestBearingMint;\n    } & ParsedInitializeInterestBearingMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateRateInterestBearingMint;\n    } & ParsedUpdateRateInterestBearingMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EnableCpiGuard;\n    } & ParsedEnableCpiGuardInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.DisableCpiGuard;\n    } & ParsedDisableCpiGuardInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializePermanentDelegate;\n    } & ParsedInitializePermanentDelegateInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeTransferHook;\n    } & ParsedInitializeTransferHookInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateTransferHook;\n    } & ParsedUpdateTransferHookInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeConfidentialTransferFee;\n    } & ParsedInitializeConfidentialTransferFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.WithdrawWithheldTokensFromMintForConfidentialTransferFee;\n    } & ParsedWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.WithdrawWithheldTokensFromAccountsForConfidentialTransferFee;\n    } & ParsedWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.HarvestWithheldTokensToMintForConfidentialTransferFee;\n    } & ParsedHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EnableHarvestToMint;\n    } & ParsedEnableHarvestToMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.DisableHarvestToMint;\n    } & ParsedDisableHarvestToMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.WithdrawExcessLamports;\n    } & ParsedWithdrawExcessLamportsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeMetadataPointer;\n    } & ParsedInitializeMetadataPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateMetadataPointer;\n    } & ParsedUpdateMetadataPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeGroupPointer;\n    } & ParsedInitializeGroupPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateGroupPointer;\n    } & ParsedUpdateGroupPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeGroupMemberPointer;\n    } & ParsedInitializeGroupMemberPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateGroupMemberPointer;\n    } & ParsedUpdateGroupMemberPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeScaledUiAmountMint;\n    } & ParsedInitializeScaledUiAmountMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateMultiplierScaledUiMint;\n    } & ParsedUpdateMultiplierScaledUiMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializePausableConfig;\n    } & ParsedInitializePausableConfigInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Pause;\n    } & ParsedPauseInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Resume;\n    } & ParsedResumeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeTokenMetadata;\n    } & ParsedInitializeTokenMetadataInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateTokenMetadataField;\n    } & ParsedUpdateTokenMetadataFieldInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.RemoveTokenMetadataKey;\n    } & ParsedRemoveTokenMetadataKeyInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateTokenMetadataUpdateAuthority;\n    } & ParsedUpdateTokenMetadataUpdateAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EmitTokenMetadata;\n    } & ParsedEmitTokenMetadataInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeTokenGroup;\n    } & ParsedInitializeTokenGroupInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateTokenGroupMaxSize;\n    } & ParsedUpdateTokenGroupMaxSizeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateTokenGroupUpdateAuthority;\n    } & ParsedUpdateTokenGroupUpdateAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeTokenGroupMember;\n    } & ParsedInitializeTokenGroupMemberInstruction<TProgram>);\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/kit';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\n\n/** InvalidOwner: Associated token account owner does not match address derivation */\nexport const ASSOCIATED_TOKEN_ERROR__INVALID_OWNER = 0x0; // 0\n\nexport type AssociatedTokenError = typeof ASSOCIATED_TOKEN_ERROR__INVALID_OWNER;\n\nlet associatedTokenErrorMessages:\n  | Record<AssociatedTokenError, string>\n  | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  associatedTokenErrorMessages = {\n    [ASSOCIATED_TOKEN_ERROR__INVALID_OWNER]: `Associated token account owner does not match address derivation`,\n  };\n}\n\nexport function getAssociatedTokenErrorMessage(\n  code: AssociatedTokenError\n): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (\n      associatedTokenErrorMessages as Record<AssociatedTokenError, string>\n    )[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isAssociatedTokenError<\n  TProgramErrorCode extends AssociatedTokenError,\n>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n    code\n  );\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\n\n/** NotRentExempt: Lamport balance below rent-exempt threshold */\nexport const TOKEN_2022_ERROR__NOT_RENT_EXEMPT = 0x0; // 0\n/** InsufficientFunds: Insufficient funds */\nexport const TOKEN_2022_ERROR__INSUFFICIENT_FUNDS = 0x1; // 1\n/** InvalidMint: Invalid Mint */\nexport const TOKEN_2022_ERROR__INVALID_MINT = 0x2; // 2\n/** MintMismatch: Account not associated with this Mint */\nexport const TOKEN_2022_ERROR__MINT_MISMATCH = 0x3; // 3\n/** OwnerMismatch: Owner does not match */\nexport const TOKEN_2022_ERROR__OWNER_MISMATCH = 0x4; // 4\n/** FixedSupply: Fixed supply */\nexport const TOKEN_2022_ERROR__FIXED_SUPPLY = 0x5; // 5\n/** AlreadyInUse: Already in use */\nexport const TOKEN_2022_ERROR__ALREADY_IN_USE = 0x6; // 6\n/** InvalidNumberOfProvidedSigners: Invalid number of provided signers */\nexport const TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS = 0x7; // 7\n/** InvalidNumberOfRequiredSigners: Invalid number of required signers */\nexport const TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS = 0x8; // 8\n/** UninitializedState: State is unititialized */\nexport const TOKEN_2022_ERROR__UNINITIALIZED_STATE = 0x9; // 9\n/** NativeNotSupported: Instruction does not support native tokens */\nexport const TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED = 0xa; // 10\n/** NonNativeHasBalance: Non-native account can only be closed if its balance is zero */\nexport const TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE = 0xb; // 11\n/** InvalidInstruction: Invalid instruction */\nexport const TOKEN_2022_ERROR__INVALID_INSTRUCTION = 0xc; // 12\n/** InvalidState: State is invalid for requested operation */\nexport const TOKEN_2022_ERROR__INVALID_STATE = 0xd; // 13\n/** Overflow: Operation overflowed */\nexport const TOKEN_2022_ERROR__OVERFLOW = 0xe; // 14\n/** AuthorityTypeNotSupported: Account does not support specified authority type */\nexport const TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED = 0xf; // 15\n/** MintCannotFreeze: This token mint cannot freeze accounts */\nexport const TOKEN_2022_ERROR__MINT_CANNOT_FREEZE = 0x10; // 16\n/** AccountFrozen: Account is frozen */\nexport const TOKEN_2022_ERROR__ACCOUNT_FROZEN = 0x11; // 17\n/** MintDecimalsMismatch: The provided decimals value different from the Mint decimals */\nexport const TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH = 0x12; // 18\n/** NonNativeNotSupported: Instruction does not support non-native tokens */\nexport const TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED = 0x13; // 19\n\nexport type Token2022Error =\n  | typeof TOKEN_2022_ERROR__ACCOUNT_FROZEN\n  | typeof TOKEN_2022_ERROR__ALREADY_IN_USE\n  | typeof TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED\n  | typeof TOKEN_2022_ERROR__FIXED_SUPPLY\n  | typeof TOKEN_2022_ERROR__INSUFFICIENT_FUNDS\n  | typeof TOKEN_2022_ERROR__INVALID_INSTRUCTION\n  | typeof TOKEN_2022_ERROR__INVALID_MINT\n  | typeof TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS\n  | typeof TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS\n  | typeof TOKEN_2022_ERROR__INVALID_STATE\n  | typeof TOKEN_2022_ERROR__MINT_CANNOT_FREEZE\n  | typeof TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH\n  | typeof TOKEN_2022_ERROR__MINT_MISMATCH\n  | typeof TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED\n  | typeof TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE\n  | typeof TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED\n  | typeof TOKEN_2022_ERROR__NOT_RENT_EXEMPT\n  | typeof TOKEN_2022_ERROR__OVERFLOW\n  | typeof TOKEN_2022_ERROR__OWNER_MISMATCH\n  | typeof TOKEN_2022_ERROR__UNINITIALIZED_STATE;\n\nlet token2022ErrorMessages: Record<Token2022Error, string> | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  token2022ErrorMessages = {\n    [TOKEN_2022_ERROR__ACCOUNT_FROZEN]: `Account is frozen`,\n    [TOKEN_2022_ERROR__ALREADY_IN_USE]: `Already in use`,\n    [TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED]: `Account does not support specified authority type`,\n    [TOKEN_2022_ERROR__FIXED_SUPPLY]: `Fixed supply`,\n    [TOKEN_2022_ERROR__INSUFFICIENT_FUNDS]: `Insufficient funds`,\n    [TOKEN_2022_ERROR__INVALID_INSTRUCTION]: `Invalid instruction`,\n    [TOKEN_2022_ERROR__INVALID_MINT]: `Invalid Mint`,\n    [TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS]: `Invalid number of provided signers`,\n    [TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS]: `Invalid number of required signers`,\n    [TOKEN_2022_ERROR__INVALID_STATE]: `State is invalid for requested operation`,\n    [TOKEN_2022_ERROR__MINT_CANNOT_FREEZE]: `This token mint cannot freeze accounts`,\n    [TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH]: `The provided decimals value different from the Mint decimals`,\n    [TOKEN_2022_ERROR__MINT_MISMATCH]: `Account not associated with this Mint`,\n    [TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED]: `Instruction does not support native tokens`,\n    [TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE]: `Non-native account can only be closed if its balance is zero`,\n    [TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED]: `Instruction does not support non-native tokens`,\n    [TOKEN_2022_ERROR__NOT_RENT_EXEMPT]: `Lamport balance below rent-exempt threshold`,\n    [TOKEN_2022_ERROR__OVERFLOW]: `Operation overflowed`,\n    [TOKEN_2022_ERROR__OWNER_MISMATCH]: `Owner does not match`,\n    [TOKEN_2022_ERROR__UNINITIALIZED_STATE]: `State is unititialized`,\n  };\n}\n\nexport function getToken2022ErrorMessage(code: Token2022Error): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (token2022ErrorMessages as Record<Token2022Error, string>)[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isToken2022Error<TProgramErrorCode extends Token2022Error>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    TOKEN_2022_PROGRAM_ADDRESS,\n    code\n  );\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  isProgramDerivedAddress,\n  isTransactionSigner as kitIsTransactionSigner,\n  type Address,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type ProgramDerivedAddress,\n  type TransactionSigner,\n  upgradeRoleToSigner,\n} from '@solana/kit';\n\n/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value == null) {\n    throw new Error('Expected a value but received null or undefined.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): Address<T> {\n  if (!value) {\n    throw new Error('Expected a Address.');\n  }\n  if (typeof value === 'object' && 'address' in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0];\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error('Expected a ProgramDerivedAddress.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error('Expected a TransactionSigner.');\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<\n  T extends string = string,\n  U extends\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null =\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null,\n> = {\n  isWritable: boolean;\n  value: U;\n};\n\n/**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type IInstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n * Get account metas and signers from resolved accounts.\n * @internal\n */\nexport function getAccountMetaFactory(\n  programAddress: Address,\n  optionalAccountStrategy: 'omitted' | 'programId'\n) {\n  return (\n    account: ResolvedAccount\n  ): IAccountMeta | IAccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === 'omitted') return;\n      return Object.freeze({\n        address: programAddress,\n        role: AccountRole.READONLY,\n      });\n    }\n\n    const writableRole = account.isWritable\n      ? AccountRole.WRITABLE\n      : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value)\n        ? upgradeRoleToSigner(writableRole)\n        : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(\n  value:\n    | Address<TAddress>\n    | ProgramDerivedAddress<TAddress>\n    | TransactionSigner<TAddress>\n): value is TransactionSigner<TAddress> {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'address' in value &&\n    kitIsTransactionSigner(value)\n  );\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR = 23;\n\nexport function getAmountToUiAmountDiscriminatorBytes() {\n  return getU8Encoder().encode(AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR);\n}\n\nexport type AmountToUiAmountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AmountToUiAmountInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to reformat. */\n  amount: bigint;\n};\n\nexport type AmountToUiAmountInstructionDataArgs = {\n  /** The amount of tokens to reformat. */\n  amount: number | bigint;\n};\n\nexport function getAmountToUiAmountInstructionDataEncoder(): Encoder<AmountToUiAmountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getAmountToUiAmountInstructionDataDecoder(): Decoder<AmountToUiAmountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getAmountToUiAmountInstructionDataCodec(): Codec<\n  AmountToUiAmountInstructionDataArgs,\n  AmountToUiAmountInstructionData\n> {\n  return combineCodec(\n    getAmountToUiAmountInstructionDataEncoder(),\n    getAmountToUiAmountInstructionDataDecoder()\n  );\n}\n\nexport type AmountToUiAmountInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n  amount: AmountToUiAmountInstructionDataArgs['amount'];\n};\n\nexport function getAmountToUiAmountInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: AmountToUiAmountInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): AmountToUiAmountInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getAmountToUiAmountInstructionDataEncoder().encode(\n      args as AmountToUiAmountInstructionDataArgs\n    ),\n  } as AmountToUiAmountInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedAmountToUiAmountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: AmountToUiAmountInstructionData;\n};\n\nexport function parseAmountToUiAmountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAmountToUiAmountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getAmountToUiAmountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR = 27;\n\nexport function getApplyConfidentialPendingBalanceDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR\n  );\n}\n\nexport const APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 8;\n\nexport function getApplyConfidentialPendingBalanceConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ApplyConfidentialPendingBalanceInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApplyConfidentialPendingBalanceInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /**\n   * The expected number of pending balance credits since the last successful\n   * `ApplyPendingBalance` instruction\n   */\n  expectedPendingBalanceCreditCounter: bigint;\n  /**\n   * The new decryptable balance if the pending balance is applied\n   * successfully\n   */\n  newDecryptableAvailableBalance: DecryptableBalance;\n};\n\nexport type ApplyConfidentialPendingBalanceInstructionDataArgs = {\n  /**\n   * The expected number of pending balance credits since the last successful\n   * `ApplyPendingBalance` instruction\n   */\n  expectedPendingBalanceCreditCounter: number | bigint;\n  /**\n   * The new decryptable balance if the pending balance is applied\n   * successfully\n   */\n  newDecryptableAvailableBalance: DecryptableBalanceArgs;\n};\n\nexport function getApplyConfidentialPendingBalanceInstructionDataEncoder(): Encoder<ApplyConfidentialPendingBalanceInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['expectedPendingBalanceCreditCounter', getU64Encoder()],\n      ['newDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getApplyConfidentialPendingBalanceInstructionDataDecoder(): Decoder<ApplyConfidentialPendingBalanceInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['expectedPendingBalanceCreditCounter', getU64Decoder()],\n    ['newDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n  ]);\n}\n\nexport function getApplyConfidentialPendingBalanceInstructionDataCodec(): Codec<\n  ApplyConfidentialPendingBalanceInstructionDataArgs,\n  ApplyConfidentialPendingBalanceInstructionData\n> {\n  return combineCodec(\n    getApplyConfidentialPendingBalanceInstructionDataEncoder(),\n    getApplyConfidentialPendingBalanceInstructionDataDecoder()\n  );\n}\n\nexport type ApplyConfidentialPendingBalanceInput<\n  TAccountToken extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  expectedPendingBalanceCreditCounter: ApplyConfidentialPendingBalanceInstructionDataArgs['expectedPendingBalanceCreditCounter'];\n  newDecryptableAvailableBalance: ApplyConfidentialPendingBalanceInstructionDataArgs['newDecryptableAvailableBalance'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getApplyConfidentialPendingBalanceInstruction<\n  TAccountToken extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ApplyConfidentialPendingBalanceInput<TAccountToken, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): ApplyConfidentialPendingBalanceInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getApplyConfidentialPendingBalanceInstructionDataEncoder().encode(\n      args as ApplyConfidentialPendingBalanceInstructionDataArgs\n    ),\n  } as ApplyConfidentialPendingBalanceInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedApplyConfidentialPendingBalanceInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[1];\n  };\n  data: ApplyConfidentialPendingBalanceInstructionData;\n};\n\nexport function parseApplyConfidentialPendingBalanceInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedApplyConfidentialPendingBalanceInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getApplyConfidentialPendingBalanceInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const APPROVE_DISCRIMINATOR = 4;\n\nexport function getApproveDiscriminatorBytes() {\n  return getU8Encoder().encode(APPROVE_DISCRIMINATOR);\n}\n\nexport type ApproveInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountDelegate extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountDelegate extends string\n        ? ReadonlyAccount<TAccountDelegate>\n        : TAccountDelegate,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApproveInstructionData = {\n  discriminator: number;\n  /** The amount of tokens the delegate is approved for. */\n  amount: bigint;\n};\n\nexport type ApproveInstructionDataArgs = {\n  /** The amount of tokens the delegate is approved for. */\n  amount: number | bigint;\n};\n\nexport function getApproveInstructionDataEncoder(): Encoder<ApproveInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: APPROVE_DISCRIMINATOR })\n  );\n}\n\nexport function getApproveInstructionDataDecoder(): Decoder<ApproveInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getApproveInstructionDataCodec(): Codec<\n  ApproveInstructionDataArgs,\n  ApproveInstructionData\n> {\n  return combineCodec(\n    getApproveInstructionDataEncoder(),\n    getApproveInstructionDataDecoder()\n  );\n}\n\nexport type ApproveInput<\n  TAccountSource extends string = string,\n  TAccountDelegate extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The delegate. */\n  delegate: Address<TAccountDelegate>;\n  /** The source account owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  amount: ApproveInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getApproveInstruction<\n  TAccountSource extends string,\n  TAccountDelegate extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ApproveInput<TAccountSource, TAccountDelegate, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): ApproveInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountDelegate,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    delegate: { value: input.delegate ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.delegate),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getApproveInstructionDataEncoder().encode(\n      args as ApproveInstructionDataArgs\n    ),\n  } as ApproveInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountDelegate,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedApproveInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The delegate. */\n    delegate: TAccountMetas[1];\n    /** The source account owner or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: ApproveInstructionData;\n};\n\nexport function parseApproveInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedApproveInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      delegate: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getApproveInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const APPROVE_CHECKED_DISCRIMINATOR = 13;\n\nexport function getApproveCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(APPROVE_CHECKED_DISCRIMINATOR);\n}\n\nexport type ApproveCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountDelegate extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDelegate extends string\n        ? ReadonlyAccount<TAccountDelegate>\n        : TAccountDelegate,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApproveCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens the delegate is approved for. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type ApproveCheckedInstructionDataArgs = {\n  /** The amount of tokens the delegate is approved for. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getApproveCheckedInstructionDataEncoder(): Encoder<ApproveCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: APPROVE_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getApproveCheckedInstructionDataDecoder(): Decoder<ApproveCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getApproveCheckedInstructionDataCodec(): Codec<\n  ApproveCheckedInstructionDataArgs,\n  ApproveCheckedInstructionData\n> {\n  return combineCodec(\n    getApproveCheckedInstructionDataEncoder(),\n    getApproveCheckedInstructionDataDecoder()\n  );\n}\n\nexport type ApproveCheckedInput<\n  TAccountSource extends string = string,\n  TAccountMint extends string = string,\n  TAccountDelegate extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The delegate. */\n  delegate: Address<TAccountDelegate>;\n  /** The source account owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  amount: ApproveCheckedInstructionDataArgs['amount'];\n  decimals: ApproveCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getApproveCheckedInstruction<\n  TAccountSource extends string,\n  TAccountMint extends string,\n  TAccountDelegate extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ApproveCheckedInput<\n    TAccountSource,\n    TAccountMint,\n    TAccountDelegate,\n    TAccountOwner\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ApproveCheckedInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountMint,\n  TAccountDelegate,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    delegate: { value: input.delegate ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.delegate),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getApproveCheckedInstructionDataEncoder().encode(\n      args as ApproveCheckedInstructionDataArgs\n    ),\n  } as ApproveCheckedInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountMint,\n    TAccountDelegate,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedApproveCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The delegate. */\n    delegate: TAccountMetas[2];\n    /** The source account owner or its multisignature account. */\n    owner: TAccountMetas[3];\n  };\n  data: ApproveCheckedInstructionData;\n};\n\nexport function parseApproveCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedApproveCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      delegate: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getApproveCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = 27;\n\nexport function getApproveConfidentialTransferAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR\n  );\n}\n\nexport const APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 3;\n\nexport function getApproveConfidentialTransferAccountConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ApproveConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlySignerAccount<TAccountAuthority> &\n            IAccountSignerMeta<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApproveConfidentialTransferAccountInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n};\n\nexport type ApproveConfidentialTransferAccountInstructionDataArgs = {};\n\nexport function getApproveConfidentialTransferAccountInstructionDataEncoder(): Encoder<ApproveConfidentialTransferAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getApproveConfidentialTransferAccountInstructionDataDecoder(): Decoder<ApproveConfidentialTransferAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getApproveConfidentialTransferAccountInstructionDataCodec(): Codec<\n  ApproveConfidentialTransferAccountInstructionDataArgs,\n  ApproveConfidentialTransferAccountInstructionData\n> {\n  return combineCodec(\n    getApproveConfidentialTransferAccountInstructionDataEncoder(),\n    getApproveConfidentialTransferAccountInstructionDataDecoder()\n  );\n}\n\nexport type ApproveConfidentialTransferAccountInput<\n  TAccountToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account to approve. */\n  token: Address<TAccountToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /** Confidential transfer mint authority. */\n  authority: TransactionSigner<TAccountAuthority>;\n};\n\nexport function getApproveConfidentialTransferAccountInstruction<\n  TAccountToken extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ApproveConfidentialTransferAccountInput<\n    TAccountToken,\n    TAccountMint,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ApproveConfidentialTransferAccountInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountMint,\n  TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n    ],\n    programAddress,\n    data: getApproveConfidentialTransferAccountInstructionDataEncoder().encode(\n      {}\n    ),\n  } as ApproveConfidentialTransferAccountInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountMint,\n    TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedApproveConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account to approve. */\n    token: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /** Confidential transfer mint authority. */\n    authority: TAccountMetas[2];\n  };\n  data: ApproveConfidentialTransferAccountInstructionData;\n};\n\nexport function parseApproveConfidentialTransferAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedApproveConfidentialTransferAccountInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getApproveConfidentialTransferAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const BURN_DISCRIMINATOR = 8;\n\nexport function getBurnDiscriminatorBytes() {\n  return getU8Encoder().encode(BURN_DISCRIMINATOR);\n}\n\nexport type BurnInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type BurnInstructionData = {\n  /** The amount of tokens to burn. */\n  discriminator: number;\n  amount: bigint;\n};\n\nexport type BurnInstructionDataArgs = { amount: number | bigint };\n\nexport function getBurnInstructionDataEncoder(): Encoder<BurnInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: BURN_DISCRIMINATOR })\n  );\n}\n\nexport function getBurnInstructionDataDecoder(): Decoder<BurnInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getBurnInstructionDataCodec(): Codec<\n  BurnInstructionDataArgs,\n  BurnInstructionData\n> {\n  return combineCodec(\n    getBurnInstructionDataEncoder(),\n    getBurnInstructionDataDecoder()\n  );\n}\n\nexport type BurnInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The account to burn from. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: BurnInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getBurnInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: BurnInput<TAccountAccount, TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): BurnInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getBurnInstructionDataEncoder().encode(\n      args as BurnInstructionDataArgs\n    ),\n  } as BurnInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedBurnInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to burn from. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: BurnInstructionData;\n};\n\nexport function parseBurnInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedBurnInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getBurnInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const BURN_CHECKED_DISCRIMINATOR = 15;\n\nexport function getBurnCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(BURN_CHECKED_DISCRIMINATOR);\n}\n\nexport type BurnCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type BurnCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to burn. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type BurnCheckedInstructionDataArgs = {\n  /** The amount of tokens to burn. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getBurnCheckedInstructionDataEncoder(): Encoder<BurnCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: BURN_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getBurnCheckedInstructionDataDecoder(): Decoder<BurnCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getBurnCheckedInstructionDataCodec(): Codec<\n  BurnCheckedInstructionDataArgs,\n  BurnCheckedInstructionData\n> {\n  return combineCodec(\n    getBurnCheckedInstructionDataEncoder(),\n    getBurnCheckedInstructionDataDecoder()\n  );\n}\n\nexport type BurnCheckedInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The account to burn from. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: BurnCheckedInstructionDataArgs['amount'];\n  decimals: BurnCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getBurnCheckedInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: BurnCheckedInput<TAccountAccount, TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): BurnCheckedInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getBurnCheckedInstructionDataEncoder().encode(\n      args as BurnCheckedInstructionDataArgs\n    ),\n  } as BurnCheckedInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedBurnCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to burn from. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: BurnCheckedInstructionData;\n};\n\nexport function parseBurnCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedBurnCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getBurnCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CLOSE_ACCOUNT_DISCRIMINATOR = 9;\n\nexport function getCloseAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(CLOSE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type CloseAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountDestination extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CloseAccountInstructionData = { discriminator: number };\n\nexport type CloseAccountInstructionDataArgs = {};\n\nexport function getCloseAccountInstructionDataEncoder(): Encoder<CloseAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: CLOSE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getCloseAccountInstructionDataDecoder(): Decoder<CloseAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCloseAccountInstructionDataCodec(): Codec<\n  CloseAccountInstructionDataArgs,\n  CloseAccountInstructionData\n> {\n  return combineCodec(\n    getCloseAccountInstructionDataEncoder(),\n    getCloseAccountInstructionDataDecoder()\n  );\n}\n\nexport type CloseAccountInput<\n  TAccountAccount extends string = string,\n  TAccountDestination extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to close. */\n  account: Address<TAccountAccount>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The account's owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getCloseAccountInstruction<\n  TAccountAccount extends string,\n  TAccountDestination extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: CloseAccountInput<TAccountAccount, TAccountDestination, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): CloseAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountDestination,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getCloseAccountInstructionDataEncoder().encode({}),\n  } as CloseAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountDestination,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCloseAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to close. */\n    account: TAccountMetas[0];\n    /** The destination account. */\n    destination: TAccountMetas[1];\n    /** The account's owner or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: CloseAccountInstructionData;\n};\n\nexport function parseCloseAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCloseAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      destination: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getCloseAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CONFIDENTIAL_DEPOSIT_DISCRIMINATOR = 27;\n\nexport function getConfidentialDepositDiscriminatorBytes() {\n  return getU8Encoder().encode(CONFIDENTIAL_DEPOSIT_DISCRIMINATOR);\n}\n\nexport const CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 5;\n\nexport function getConfidentialDepositConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ConfidentialDepositInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ConfidentialDepositInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /** The amount of tokens to deposit. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type ConfidentialDepositInstructionDataArgs = {\n  /** The amount of tokens to deposit. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getConfidentialDepositInstructionDataEncoder(): Encoder<ConfidentialDepositInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIDENTIAL_DEPOSIT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getConfidentialDepositInstructionDataDecoder(): Decoder<ConfidentialDepositInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getConfidentialDepositInstructionDataCodec(): Codec<\n  ConfidentialDepositInstructionDataArgs,\n  ConfidentialDepositInstructionData\n> {\n  return combineCodec(\n    getConfidentialDepositInstructionDataEncoder(),\n    getConfidentialDepositInstructionDataDecoder()\n  );\n}\n\nexport type ConfidentialDepositInput<\n  TAccountToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: ConfidentialDepositInstructionDataArgs['amount'];\n  decimals: ConfidentialDepositInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getConfidentialDepositInstruction<\n  TAccountToken extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ConfidentialDepositInput<\n    TAccountToken,\n    TAccountMint,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ConfidentialDepositInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getConfidentialDepositInstructionDataEncoder().encode(\n      args as ConfidentialDepositInstructionDataArgs\n    ),\n  } as ConfidentialDepositInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedConfidentialDepositInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: ConfidentialDepositInstructionData;\n};\n\nexport function parseConfidentialDepositInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedConfidentialDepositInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getConfidentialDepositInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 27;\n\nexport function getConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(CONFIDENTIAL_TRANSFER_DISCRIMINATOR);\n}\n\nexport const CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 7;\n\nexport function getConfidentialTransferConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ConfidentialTransferInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSourceToken extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountDestinationToken extends string | IAccountMeta<string> = string,\n  TAccountInstructionsSysvar extends string | IAccountMeta<string> = string,\n  TAccountEqualityRecord extends string | IAccountMeta<string> = string,\n  TAccountCiphertextValidityRecord extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountRangeRecord extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSourceToken extends string\n        ? WritableAccount<TAccountSourceToken>\n        : TAccountSourceToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestinationToken extends string\n        ? WritableAccount<TAccountDestinationToken>\n        : TAccountDestinationToken,\n      TAccountInstructionsSysvar extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvar>\n        : TAccountInstructionsSysvar,\n      TAccountEqualityRecord extends string\n        ? ReadonlyAccount<TAccountEqualityRecord>\n        : TAccountEqualityRecord,\n      TAccountCiphertextValidityRecord extends string\n        ? ReadonlyAccount<TAccountCiphertextValidityRecord>\n        : TAccountCiphertextValidityRecord,\n      TAccountRangeRecord extends string\n        ? ReadonlyAccount<TAccountRangeRecord>\n        : TAccountRangeRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ConfidentialTransferInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /** The new source decryptable balance if the transfer succeeds. */\n  newSourceDecryptableAvailableBalance: DecryptableBalance;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `Transfer` instruction in the transaction. If the offset is\n   * `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext3HandlesValidity`\n   * instruction to the `Transfer` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  ciphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU128Data`\n   * instruction to the `Transfer` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport type ConfidentialTransferInstructionDataArgs = {\n  /** The new source decryptable balance if the transfer succeeds. */\n  newSourceDecryptableAvailableBalance: DecryptableBalanceArgs;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `Transfer` instruction in the transaction. If the offset is\n   * `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext3HandlesValidity`\n   * instruction to the `Transfer` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  ciphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU128Data`\n   * instruction to the `Transfer` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport function getConfidentialTransferInstructionDataEncoder(): Encoder<ConfidentialTransferInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['newSourceDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n      ['equalityProofInstructionOffset', getI8Encoder()],\n      ['ciphertextValidityProofInstructionOffset', getI8Encoder()],\n      ['rangeProofInstructionOffset', getI8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getConfidentialTransferInstructionDataDecoder(): Decoder<ConfidentialTransferInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['newSourceDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n    ['equalityProofInstructionOffset', getI8Decoder()],\n    ['ciphertextValidityProofInstructionOffset', getI8Decoder()],\n    ['rangeProofInstructionOffset', getI8Decoder()],\n  ]);\n}\n\nexport function getConfidentialTransferInstructionDataCodec(): Codec<\n  ConfidentialTransferInstructionDataArgs,\n  ConfidentialTransferInstructionData\n> {\n  return combineCodec(\n    getConfidentialTransferInstructionDataEncoder(),\n    getConfidentialTransferInstructionDataDecoder()\n  );\n}\n\nexport type ConfidentialTransferInput<\n  TAccountSourceToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountDestinationToken extends string = string,\n  TAccountInstructionsSysvar extends string = string,\n  TAccountEqualityRecord extends string = string,\n  TAccountCiphertextValidityRecord extends string = string,\n  TAccountRangeRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source SPL Token account. */\n  sourceToken: Address<TAccountSourceToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /** The destination SPL Token account. */\n  destinationToken: Address<TAccountDestinationToken>;\n  /**\n   * (Optional) Instructions sysvar if at least one of the\n   * `zk_elgamal_proof` instructions are included in the same\n   * transaction.\n   */\n  instructionsSysvar?: Address<TAccountInstructionsSysvar>;\n  /** (Optional) Equality proof record account or context state account. */\n  equalityRecord?: Address<TAccountEqualityRecord>;\n  /** (Optional) Ciphertext validity proof record account or context state account. */\n  ciphertextValidityRecord?: Address<TAccountCiphertextValidityRecord>;\n  /** (Optional) Range proof record account or context state account. */\n  rangeRecord?: Address<TAccountRangeRecord>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  newSourceDecryptableAvailableBalance: ConfidentialTransferInstructionDataArgs['newSourceDecryptableAvailableBalance'];\n  equalityProofInstructionOffset: ConfidentialTransferInstructionDataArgs['equalityProofInstructionOffset'];\n  ciphertextValidityProofInstructionOffset: ConfidentialTransferInstructionDataArgs['ciphertextValidityProofInstructionOffset'];\n  rangeProofInstructionOffset: ConfidentialTransferInstructionDataArgs['rangeProofInstructionOffset'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getConfidentialTransferInstruction<\n  TAccountSourceToken extends string,\n  TAccountMint extends string,\n  TAccountDestinationToken extends string,\n  TAccountInstructionsSysvar extends string,\n  TAccountEqualityRecord extends string,\n  TAccountCiphertextValidityRecord extends string,\n  TAccountRangeRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ConfidentialTransferInput<\n    TAccountSourceToken,\n    TAccountMint,\n    TAccountDestinationToken,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountCiphertextValidityRecord,\n    TAccountRangeRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ConfidentialTransferInstruction<\n  TProgramAddress,\n  TAccountSourceToken,\n  TAccountMint,\n  TAccountDestinationToken,\n  TAccountInstructionsSysvar,\n  TAccountEqualityRecord,\n  TAccountCiphertextValidityRecord,\n  TAccountRangeRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    sourceToken: { value: input.sourceToken ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destinationToken: {\n      value: input.destinationToken ?? null,\n      isWritable: true,\n    },\n    instructionsSysvar: {\n      value: input.instructionsSysvar ?? null,\n      isWritable: false,\n    },\n    equalityRecord: { value: input.equalityRecord ?? null, isWritable: false },\n    ciphertextValidityRecord: {\n      value: input.ciphertextValidityRecord ?? null,\n      isWritable: false,\n    },\n    rangeRecord: { value: input.rangeRecord ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.sourceToken),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destinationToken),\n      getAccountMeta(accounts.instructionsSysvar),\n      getAccountMeta(accounts.equalityRecord),\n      getAccountMeta(accounts.ciphertextValidityRecord),\n      getAccountMeta(accounts.rangeRecord),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getConfidentialTransferInstructionDataEncoder().encode(\n      args as ConfidentialTransferInstructionDataArgs\n    ),\n  } as ConfidentialTransferInstruction<\n    TProgramAddress,\n    TAccountSourceToken,\n    TAccountMint,\n    TAccountDestinationToken,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountCiphertextValidityRecord,\n    TAccountRangeRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedConfidentialTransferInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source SPL Token account. */\n    sourceToken: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /** The destination SPL Token account. */\n    destinationToken: TAccountMetas[2];\n    /**\n     * (Optional) Instructions sysvar if at least one of the\n     * `zk_elgamal_proof` instructions are included in the same\n     * transaction.\n     */\n\n    instructionsSysvar?: TAccountMetas[3] | undefined;\n    /** (Optional) Equality proof record account or context state account. */\n    equalityRecord?: TAccountMetas[4] | undefined;\n    /** (Optional) Ciphertext validity proof record account or context state account. */\n    ciphertextValidityRecord?: TAccountMetas[5] | undefined;\n    /** (Optional) Range proof record account or context state account. */\n    rangeRecord?: TAccountMetas[6] | undefined;\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[7];\n  };\n  data: ConfidentialTransferInstructionData;\n};\n\nexport function parseConfidentialTransferInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedConfidentialTransferInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 8) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      sourceToken: getNextAccount(),\n      mint: getNextAccount(),\n      destinationToken: getNextAccount(),\n      instructionsSysvar: getNextOptionalAccount(),\n      equalityRecord: getNextOptionalAccount(),\n      ciphertextValidityRecord: getNextOptionalAccount(),\n      rangeRecord: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getConfidentialTransferInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR = 27;\n\nexport function getConfidentialTransferWithFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR);\n}\n\nexport const CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 13;\n\nexport function getConfidentialTransferWithFeeConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ConfidentialTransferWithFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSourceToken extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountDestinationToken extends string | IAccountMeta<string> = string,\n  TAccountInstructionsSysvar extends string | IAccountMeta<string> = string,\n  TAccountEqualityRecord extends string | IAccountMeta<string> = string,\n  TAccountTransferAmountCiphertextValidityRecord extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountFeeSigmaRecord extends string | IAccountMeta<string> = string,\n  TAccountFeeCiphertextValidityRecord extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountRangeRecord extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSourceToken extends string\n        ? WritableAccount<TAccountSourceToken>\n        : TAccountSourceToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestinationToken extends string\n        ? WritableAccount<TAccountDestinationToken>\n        : TAccountDestinationToken,\n      TAccountInstructionsSysvar extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvar>\n        : TAccountInstructionsSysvar,\n      TAccountEqualityRecord extends string\n        ? ReadonlyAccount<TAccountEqualityRecord>\n        : TAccountEqualityRecord,\n      TAccountTransferAmountCiphertextValidityRecord extends string\n        ? ReadonlyAccount<TAccountTransferAmountCiphertextValidityRecord>\n        : TAccountTransferAmountCiphertextValidityRecord,\n      TAccountFeeSigmaRecord extends string\n        ? ReadonlyAccount<TAccountFeeSigmaRecord>\n        : TAccountFeeSigmaRecord,\n      TAccountFeeCiphertextValidityRecord extends string\n        ? ReadonlyAccount<TAccountFeeCiphertextValidityRecord>\n        : TAccountFeeCiphertextValidityRecord,\n      TAccountRangeRecord extends string\n        ? ReadonlyAccount<TAccountRangeRecord>\n        : TAccountRangeRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ConfidentialTransferWithFeeInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /** The new source decryptable balance if the transfer succeeds. */\n  newSourceDecryptableAvailableBalance: DecryptableBalance;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `TransferWithFee` instruction in the transaction. If the offset\n   * is `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext3HandlesValidity`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  transferAmountCiphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::VerifyPercentageWithFee`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  feeSigmaProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext2HandlesValidity`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  feeCiphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU256Data`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport type ConfidentialTransferWithFeeInstructionDataArgs = {\n  /** The new source decryptable balance if the transfer succeeds. */\n  newSourceDecryptableAvailableBalance: DecryptableBalanceArgs;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `TransferWithFee` instruction in the transaction. If the offset\n   * is `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext3HandlesValidity`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  transferAmountCiphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::VerifyPercentageWithFee`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  feeSigmaProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext2HandlesValidity`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  feeCiphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU256Data`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport function getConfidentialTransferWithFeeInstructionDataEncoder(): Encoder<ConfidentialTransferWithFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['newSourceDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n      ['equalityProofInstructionOffset', getI8Encoder()],\n      [\n        'transferAmountCiphertextValidityProofInstructionOffset',\n        getI8Encoder(),\n      ],\n      ['feeSigmaProofInstructionOffset', getI8Encoder()],\n      ['feeCiphertextValidityProofInstructionOffset', getI8Encoder()],\n      ['rangeProofInstructionOffset', getI8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getConfidentialTransferWithFeeInstructionDataDecoder(): Decoder<ConfidentialTransferWithFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['newSourceDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n    ['equalityProofInstructionOffset', getI8Decoder()],\n    ['transferAmountCiphertextValidityProofInstructionOffset', getI8Decoder()],\n    ['feeSigmaProofInstructionOffset', getI8Decoder()],\n    ['feeCiphertextValidityProofInstructionOffset', getI8Decoder()],\n    ['rangeProofInstructionOffset', getI8Decoder()],\n  ]);\n}\n\nexport function getConfidentialTransferWithFeeInstructionDataCodec(): Codec<\n  ConfidentialTransferWithFeeInstructionDataArgs,\n  ConfidentialTransferWithFeeInstructionData\n> {\n  return combineCodec(\n    getConfidentialTransferWithFeeInstructionDataEncoder(),\n    getConfidentialTransferWithFeeInstructionDataDecoder()\n  );\n}\n\nexport type ConfidentialTransferWithFeeInput<\n  TAccountSourceToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountDestinationToken extends string = string,\n  TAccountInstructionsSysvar extends string = string,\n  TAccountEqualityRecord extends string = string,\n  TAccountTransferAmountCiphertextValidityRecord extends string = string,\n  TAccountFeeSigmaRecord extends string = string,\n  TAccountFeeCiphertextValidityRecord extends string = string,\n  TAccountRangeRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source SPL Token account. */\n  sourceToken: Address<TAccountSourceToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /** The destination SPL Token account. */\n  destinationToken: Address<TAccountDestinationToken>;\n  /**\n   * (Optional) Instructions sysvar if at least one of the\n   * `zk_elgamal_proof` instructions are included in the same\n   * transaction.\n   */\n  instructionsSysvar?: Address<TAccountInstructionsSysvar>;\n  /** (Optional) Equality proof record account or context state account. */\n  equalityRecord?: Address<TAccountEqualityRecord>;\n  /**\n   * (Optional) Transfer amount ciphertext validity proof record\n   * account or context state account.\n   */\n  transferAmountCiphertextValidityRecord?: Address<TAccountTransferAmountCiphertextValidityRecord>;\n  /** (Optional) Fee sigma proof record account or context state account. */\n  feeSigmaRecord?: Address<TAccountFeeSigmaRecord>;\n  /** (Optional) Fee ciphertext validity proof record account or context state account. */\n  feeCiphertextValidityRecord?: Address<TAccountFeeCiphertextValidityRecord>;\n  /** (Optional) Range proof record account or context state account. */\n  rangeRecord?: Address<TAccountRangeRecord>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  newSourceDecryptableAvailableBalance: ConfidentialTransferWithFeeInstructionDataArgs['newSourceDecryptableAvailableBalance'];\n  equalityProofInstructionOffset: ConfidentialTransferWithFeeInstructionDataArgs['equalityProofInstructionOffset'];\n  transferAmountCiphertextValidityProofInstructionOffset: ConfidentialTransferWithFeeInstructionDataArgs['transferAmountCiphertextValidityProofInstructionOffset'];\n  feeSigmaProofInstructionOffset: ConfidentialTransferWithFeeInstructionDataArgs['feeSigmaProofInstructionOffset'];\n  feeCiphertextValidityProofInstructionOffset: ConfidentialTransferWithFeeInstructionDataArgs['feeCiphertextValidityProofInstructionOffset'];\n  rangeProofInstructionOffset: ConfidentialTransferWithFeeInstructionDataArgs['rangeProofInstructionOffset'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getConfidentialTransferWithFeeInstruction<\n  TAccountSourceToken extends string,\n  TAccountMint extends string,\n  TAccountDestinationToken extends string,\n  TAccountInstructionsSysvar extends string,\n  TAccountEqualityRecord extends string,\n  TAccountTransferAmountCiphertextValidityRecord extends string,\n  TAccountFeeSigmaRecord extends string,\n  TAccountFeeCiphertextValidityRecord extends string,\n  TAccountRangeRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ConfidentialTransferWithFeeInput<\n    TAccountSourceToken,\n    TAccountMint,\n    TAccountDestinationToken,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountTransferAmountCiphertextValidityRecord,\n    TAccountFeeSigmaRecord,\n    TAccountFeeCiphertextValidityRecord,\n    TAccountRangeRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ConfidentialTransferWithFeeInstruction<\n  TProgramAddress,\n  TAccountSourceToken,\n  TAccountMint,\n  TAccountDestinationToken,\n  TAccountInstructionsSysvar,\n  TAccountEqualityRecord,\n  TAccountTransferAmountCiphertextValidityRecord,\n  TAccountFeeSigmaRecord,\n  TAccountFeeCiphertextValidityRecord,\n  TAccountRangeRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    sourceToken: { value: input.sourceToken ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destinationToken: {\n      value: input.destinationToken ?? null,\n      isWritable: true,\n    },\n    instructionsSysvar: {\n      value: input.instructionsSysvar ?? null,\n      isWritable: false,\n    },\n    equalityRecord: { value: input.equalityRecord ?? null, isWritable: false },\n    transferAmountCiphertextValidityRecord: {\n      value: input.transferAmountCiphertextValidityRecord ?? null,\n      isWritable: false,\n    },\n    feeSigmaRecord: { value: input.feeSigmaRecord ?? null, isWritable: false },\n    feeCiphertextValidityRecord: {\n      value: input.feeCiphertextValidityRecord ?? null,\n      isWritable: false,\n    },\n    rangeRecord: { value: input.rangeRecord ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.sourceToken),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destinationToken),\n      getAccountMeta(accounts.instructionsSysvar),\n      getAccountMeta(accounts.equalityRecord),\n      getAccountMeta(accounts.transferAmountCiphertextValidityRecord),\n      getAccountMeta(accounts.feeSigmaRecord),\n      getAccountMeta(accounts.feeCiphertextValidityRecord),\n      getAccountMeta(accounts.rangeRecord),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getConfidentialTransferWithFeeInstructionDataEncoder().encode(\n      args as ConfidentialTransferWithFeeInstructionDataArgs\n    ),\n  } as ConfidentialTransferWithFeeInstruction<\n    TProgramAddress,\n    TAccountSourceToken,\n    TAccountMint,\n    TAccountDestinationToken,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountTransferAmountCiphertextValidityRecord,\n    TAccountFeeSigmaRecord,\n    TAccountFeeCiphertextValidityRecord,\n    TAccountRangeRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedConfidentialTransferWithFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source SPL Token account. */\n    sourceToken: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /** The destination SPL Token account. */\n    destinationToken: TAccountMetas[2];\n    /**\n     * (Optional) Instructions sysvar if at least one of the\n     * `zk_elgamal_proof` instructions are included in the same\n     * transaction.\n     */\n\n    instructionsSysvar?: TAccountMetas[3] | undefined;\n    /** (Optional) Equality proof record account or context state account. */\n    equalityRecord?: TAccountMetas[4] | undefined;\n    /**\n     * (Optional) Transfer amount ciphertext validity proof record\n     * account or context state account.\n     */\n\n    transferAmountCiphertextValidityRecord?: TAccountMetas[5] | undefined;\n    /** (Optional) Fee sigma proof record account or context state account. */\n    feeSigmaRecord?: TAccountMetas[6] | undefined;\n    /** (Optional) Fee ciphertext validity proof record account or context state account. */\n    feeCiphertextValidityRecord?: TAccountMetas[7] | undefined;\n    /** (Optional) Range proof record account or context state account. */\n    rangeRecord?: TAccountMetas[8] | undefined;\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[9];\n  };\n  data: ConfidentialTransferWithFeeInstructionData;\n};\n\nexport function parseConfidentialTransferWithFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedConfidentialTransferWithFeeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 10) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      sourceToken: getNextAccount(),\n      mint: getNextAccount(),\n      destinationToken: getNextAccount(),\n      instructionsSysvar: getNextOptionalAccount(),\n      equalityRecord: getNextOptionalAccount(),\n      transferAmountCiphertextValidityRecord: getNextOptionalAccount(),\n      feeSigmaRecord: getNextOptionalAccount(),\n      feeCiphertextValidityRecord: getNextOptionalAccount(),\n      rangeRecord: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getConfidentialTransferWithFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const CONFIDENTIAL_WITHDRAW_DISCRIMINATOR = 27;\n\nexport function getConfidentialWithdrawDiscriminatorBytes() {\n  return getU8Encoder().encode(CONFIDENTIAL_WITHDRAW_DISCRIMINATOR);\n}\n\nexport const CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 6;\n\nexport function getConfidentialWithdrawConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ConfidentialWithdrawInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountInstructionsSysvar extends string | IAccountMeta<string> = string,\n  TAccountEqualityRecord extends string | IAccountMeta<string> = string,\n  TAccountRangeRecord extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountInstructionsSysvar extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvar>\n        : TAccountInstructionsSysvar,\n      TAccountEqualityRecord extends string\n        ? ReadonlyAccount<TAccountEqualityRecord>\n        : TAccountEqualityRecord,\n      TAccountRangeRecord extends string\n        ? ReadonlyAccount<TAccountRangeRecord>\n        : TAccountRangeRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ConfidentialWithdrawInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /** The amount of tokens to withdraw. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The new decryptable balance if the withdrawal succeeds. */\n  newDecryptableAvailableBalance: DecryptableBalance;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `Withdraw` instruction in the transaction. If the offset is\n   * `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU64`\n   * instruction to the `Withdraw` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport type ConfidentialWithdrawInstructionDataArgs = {\n  /** The amount of tokens to withdraw. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The new decryptable balance if the withdrawal succeeds. */\n  newDecryptableAvailableBalance: DecryptableBalanceArgs;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `Withdraw` instruction in the transaction. If the offset is\n   * `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU64`\n   * instruction to the `Withdraw` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport function getConfidentialWithdrawInstructionDataEncoder(): Encoder<ConfidentialWithdrawInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n      ['newDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n      ['equalityProofInstructionOffset', getI8Encoder()],\n      ['rangeProofInstructionOffset', getI8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIDENTIAL_WITHDRAW_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getConfidentialWithdrawInstructionDataDecoder(): Decoder<ConfidentialWithdrawInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n    ['newDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n    ['equalityProofInstructionOffset', getI8Decoder()],\n    ['rangeProofInstructionOffset', getI8Decoder()],\n  ]);\n}\n\nexport function getConfidentialWithdrawInstructionDataCodec(): Codec<\n  ConfidentialWithdrawInstructionDataArgs,\n  ConfidentialWithdrawInstructionData\n> {\n  return combineCodec(\n    getConfidentialWithdrawInstructionDataEncoder(),\n    getConfidentialWithdrawInstructionDataDecoder()\n  );\n}\n\nexport type ConfidentialWithdrawInput<\n  TAccountToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountInstructionsSysvar extends string = string,\n  TAccountEqualityRecord extends string = string,\n  TAccountRangeRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /**\n   * Instructions sysvar if at least one of the\n   * `zk_elgamal_proof` instructions are included in the same\n   * transaction.\n   */\n  instructionsSysvar?: Address<TAccountInstructionsSysvar>;\n  /** (Optional) Equality proof record account or context state account. */\n  equalityRecord?: Address<TAccountEqualityRecord>;\n  /** (Optional) Range proof record account or context state account. */\n  rangeRecord?: Address<TAccountRangeRecord>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: ConfidentialWithdrawInstructionDataArgs['amount'];\n  decimals: ConfidentialWithdrawInstructionDataArgs['decimals'];\n  newDecryptableAvailableBalance: ConfidentialWithdrawInstructionDataArgs['newDecryptableAvailableBalance'];\n  equalityProofInstructionOffset: ConfidentialWithdrawInstructionDataArgs['equalityProofInstructionOffset'];\n  rangeProofInstructionOffset: ConfidentialWithdrawInstructionDataArgs['rangeProofInstructionOffset'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getConfidentialWithdrawInstruction<\n  TAccountToken extends string,\n  TAccountMint extends string,\n  TAccountInstructionsSysvar extends string,\n  TAccountEqualityRecord extends string,\n  TAccountRangeRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ConfidentialWithdrawInput<\n    TAccountToken,\n    TAccountMint,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountRangeRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ConfidentialWithdrawInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountMint,\n  TAccountInstructionsSysvar,\n  TAccountEqualityRecord,\n  TAccountRangeRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    instructionsSysvar: {\n      value: input.instructionsSysvar ?? null,\n      isWritable: false,\n    },\n    equalityRecord: { value: input.equalityRecord ?? null, isWritable: false },\n    rangeRecord: { value: input.rangeRecord ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.instructionsSysvar),\n      getAccountMeta(accounts.equalityRecord),\n      getAccountMeta(accounts.rangeRecord),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getConfidentialWithdrawInstructionDataEncoder().encode(\n      args as ConfidentialWithdrawInstructionDataArgs\n    ),\n  } as ConfidentialWithdrawInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountMint,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountRangeRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedConfidentialWithdrawInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /**\n     * Instructions sysvar if at least one of the\n     * `zk_elgamal_proof` instructions are included in the same\n     * transaction.\n     */\n\n    instructionsSysvar?: TAccountMetas[2] | undefined;\n    /** (Optional) Equality proof record account or context state account. */\n    equalityRecord?: TAccountMetas[3] | undefined;\n    /** (Optional) Range proof record account or context state account. */\n    rangeRecord?: TAccountMetas[4] | undefined;\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[5];\n  };\n  data: ConfidentialWithdrawInstructionData;\n};\n\nexport function parseConfidentialWithdrawInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedConfidentialWithdrawInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      mint: getNextAccount(),\n      instructionsSysvar: getNextOptionalAccount(),\n      equalityRecord: getNextOptionalAccount(),\n      rangeRecord: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getConfidentialWithdrawInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = 27;\n\nexport function getConfigureConfidentialTransferAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR\n  );\n}\n\nexport const CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 2;\n\nexport function getConfigureConfidentialTransferAccountConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ConfigureConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountInstructionsSysvarOrContextState extends\n    | string\n    | IAccountMeta<string> = 'Sysvar1nstructions1111111111111111111111111',\n  TAccountRecord extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountInstructionsSysvarOrContextState extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvarOrContextState>\n        : TAccountInstructionsSysvarOrContextState,\n      TAccountRecord extends string\n        ? ReadonlyAccount<TAccountRecord>\n        : TAccountRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ConfigureConfidentialTransferAccountInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /** The decryptable balance (always 0) once the configure account succeeds. */\n  decryptableZeroBalance: DecryptableBalance;\n  /**\n   * The maximum number of despots and transfers that an account can receiver\n   * before the `ApplyPendingBalance` is executed\n   */\n  maximumPendingBalanceCreditCounter: bigint;\n  /**\n   * Relative location of the `ProofInstruction::ZeroCiphertextProof`\n   * instruction to the `ConfigureAccount` instruction in the\n   * transaction. If the offset is `0`, then use a context state account\n   * for the proof.\n   */\n  proofInstructionOffset: number;\n};\n\nexport type ConfigureConfidentialTransferAccountInstructionDataArgs = {\n  /** The decryptable balance (always 0) once the configure account succeeds. */\n  decryptableZeroBalance: DecryptableBalanceArgs;\n  /**\n   * The maximum number of despots and transfers that an account can receiver\n   * before the `ApplyPendingBalance` is executed\n   */\n  maximumPendingBalanceCreditCounter: number | bigint;\n  /**\n   * Relative location of the `ProofInstruction::ZeroCiphertextProof`\n   * instruction to the `ConfigureAccount` instruction in the\n   * transaction. If the offset is `0`, then use a context state account\n   * for the proof.\n   */\n  proofInstructionOffset: number;\n};\n\nexport function getConfigureConfidentialTransferAccountInstructionDataEncoder(): Encoder<ConfigureConfidentialTransferAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['decryptableZeroBalance', getDecryptableBalanceEncoder()],\n      ['maximumPendingBalanceCreditCounter', getU64Encoder()],\n      ['proofInstructionOffset', getI8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getConfigureConfidentialTransferAccountInstructionDataDecoder(): Decoder<ConfigureConfidentialTransferAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['decryptableZeroBalance', getDecryptableBalanceDecoder()],\n    ['maximumPendingBalanceCreditCounter', getU64Decoder()],\n    ['proofInstructionOffset', getI8Decoder()],\n  ]);\n}\n\nexport function getConfigureConfidentialTransferAccountInstructionDataCodec(): Codec<\n  ConfigureConfidentialTransferAccountInstructionDataArgs,\n  ConfigureConfidentialTransferAccountInstructionData\n> {\n  return combineCodec(\n    getConfigureConfidentialTransferAccountInstructionDataEncoder(),\n    getConfigureConfidentialTransferAccountInstructionDataDecoder()\n  );\n}\n\nexport type ConfigureConfidentialTransferAccountInput<\n  TAccountToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountInstructionsSysvarOrContextState extends string = string,\n  TAccountRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /**\n   * Instructions sysvar if `VerifyPubkeyValidity` is included in\n   * the same transaction or context state account if\n   * `VerifyPubkeyValidity` is pre-verified into a context state\n   * account.\n   */\n  instructionsSysvarOrContextState?: Address<TAccountInstructionsSysvarOrContextState>;\n  /** (Optional) Record account if the accompanying proof is to be read from a record account. */\n  record?: Address<TAccountRecord>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  decryptableZeroBalance: ConfigureConfidentialTransferAccountInstructionDataArgs['decryptableZeroBalance'];\n  maximumPendingBalanceCreditCounter: ConfigureConfidentialTransferAccountInstructionDataArgs['maximumPendingBalanceCreditCounter'];\n  proofInstructionOffset: ConfigureConfidentialTransferAccountInstructionDataArgs['proofInstructionOffset'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getConfigureConfidentialTransferAccountInstruction<\n  TAccountToken extends string,\n  TAccountMint extends string,\n  TAccountInstructionsSysvarOrContextState extends string,\n  TAccountRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ConfigureConfidentialTransferAccountInput<\n    TAccountToken,\n    TAccountMint,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ConfigureConfidentialTransferAccountInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountMint,\n  TAccountInstructionsSysvarOrContextState,\n  TAccountRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    instructionsSysvarOrContextState: {\n      value: input.instructionsSysvarOrContextState ?? null,\n      isWritable: false,\n    },\n    record: { value: input.record ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.instructionsSysvarOrContextState.value) {\n    accounts.instructionsSysvarOrContextState.value =\n      'Sysvar1nstructions1111111111111111111111111' as Address<'Sysvar1nstructions1111111111111111111111111'>;\n  }\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.instructionsSysvarOrContextState),\n      getAccountMeta(accounts.record),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getConfigureConfidentialTransferAccountInstructionDataEncoder().encode(\n      args as ConfigureConfidentialTransferAccountInstructionDataArgs\n    ),\n  } as ConfigureConfidentialTransferAccountInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountMint,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedConfigureConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /**\n     * Instructions sysvar if `VerifyPubkeyValidity` is included in\n     * the same transaction or context state account if\n     * `VerifyPubkeyValidity` is pre-verified into a context state\n     * account.\n     */\n\n    instructionsSysvarOrContextState: TAccountMetas[2];\n    /** (Optional) Record account if the accompanying proof is to be read from a record account. */\n    record?: TAccountMetas[3] | undefined;\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[4];\n  };\n  data: ConfigureConfidentialTransferAccountInstructionData;\n};\n\nexport function parseConfigureConfidentialTransferAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedConfigureConfidentialTransferAccountInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      mint: getNextAccount(),\n      instructionsSysvarOrContextState: getNextAccount(),\n      record: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getConfigureConfidentialTransferAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  getAddressEncoder,\n  getProgramDerivedAddress,\n  type Address,\n  type ProgramDerivedAddress,\n} from '@solana/kit';\n\nexport type AssociatedTokenSeeds = {\n  /** The wallet address of the associated token account. */\n  owner: Address;\n  /** The address of the token program to use. */\n  tokenProgram: Address;\n  /** The mint address of the associated token account. */\n  mint: Address;\n};\n\nexport async function findAssociatedTokenPda(\n  seeds: AssociatedTokenSeeds,\n  config: { programAddress?: Address | undefined } = {}\n): Promise<ProgramDerivedAddress> {\n  const {\n    programAddress = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>,\n  } = config;\n  return await getProgramDerivedAddress({\n    programAddress,\n    seeds: [\n      getAddressEncoder().encode(seeds.owner),\n      getAddressEncoder().encode(seeds.tokenProgram),\n      getAddressEncoder().encode(seeds.mint),\n    ],\n  });\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR = 0;\n\nexport function getCreateAssociatedTokenDiscriminatorBytes() {\n  return getU8Encoder().encode(CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR);\n}\n\nexport type CreateAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountAta extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountAta extends string ? WritableAccount<TAccountAta> : TAccountAta,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAssociatedTokenInstructionData = { discriminator: number };\n\nexport type CreateAssociatedTokenInstructionDataArgs = {};\n\nexport function getCreateAssociatedTokenInstructionDataEncoder(): Encoder<CreateAssociatedTokenInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCreateAssociatedTokenInstructionDataDecoder(): Decoder<CreateAssociatedTokenInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCreateAssociatedTokenInstructionDataCodec(): Codec<\n  CreateAssociatedTokenInstructionDataArgs,\n  CreateAssociatedTokenInstructionData\n> {\n  return combineCodec(\n    getCreateAssociatedTokenInstructionDataEncoder(),\n    getCreateAssociatedTokenInstructionDataDecoder()\n  );\n}\n\nexport type CreateAssociatedTokenAsyncInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata?: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getCreateAssociatedTokenInstructionAsync<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenAsyncInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n  if (!accounts.ata.value) {\n    accounts.ata.value = await findAssociatedTokenPda({\n      owner: expectAddress(accounts.owner.value),\n      tokenProgram: expectAddress(accounts.tokenProgram.value),\n      mint: expectAddress(accounts.mint.value),\n    });\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getCreateAssociatedTokenInstructionDataEncoder().encode({}),\n  } as CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type CreateAssociatedTokenInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getCreateAssociatedTokenInstruction<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateAssociatedTokenInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountAta,\n  TAccountOwner,\n  TAccountMint,\n  TAccountSystemProgram,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getCreateAssociatedTokenInstructionDataEncoder().encode({}),\n  } as CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCreateAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Funding account (must be a system account). */\n    payer: TAccountMetas[0];\n    /** Associated token account address to be created. */\n    ata: TAccountMetas[1];\n    /** Wallet address for the new associated token account. */\n    owner: TAccountMetas[2];\n    /** The token mint for the new associated token account. */\n    mint: TAccountMetas[3];\n    /** System program. */\n    systemProgram: TAccountMetas[4];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[5];\n  };\n  data: CreateAssociatedTokenInstructionData;\n};\n\nexport function parseCreateAssociatedTokenInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCreateAssociatedTokenInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      ata: getNextAccount(),\n      owner: getNextAccount(),\n      mint: getNextAccount(),\n      systemProgram: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getCreateAssociatedTokenInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR = 1;\n\nexport function getCreateAssociatedTokenIdempotentDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR\n  );\n}\n\nexport type CreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountAta extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountAta extends string ? WritableAccount<TAccountAta> : TAccountAta,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAssociatedTokenIdempotentInstructionData = {\n  discriminator: number;\n};\n\nexport type CreateAssociatedTokenIdempotentInstructionDataArgs = {};\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataEncoder(): Encoder<CreateAssociatedTokenIdempotentInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataDecoder(): Decoder<CreateAssociatedTokenIdempotentInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataCodec(): Codec<\n  CreateAssociatedTokenIdempotentInstructionDataArgs,\n  CreateAssociatedTokenIdempotentInstructionData\n> {\n  return combineCodec(\n    getCreateAssociatedTokenIdempotentInstructionDataEncoder(),\n    getCreateAssociatedTokenIdempotentInstructionDataDecoder()\n  );\n}\n\nexport type CreateAssociatedTokenIdempotentAsyncInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata?: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getCreateAssociatedTokenIdempotentInstructionAsync<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenIdempotentAsyncInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n  if (!accounts.ata.value) {\n    accounts.ata.value = await findAssociatedTokenPda({\n      owner: expectAddress(accounts.owner.value),\n      tokenProgram: expectAddress(accounts.tokenProgram.value),\n      mint: expectAddress(accounts.mint.value),\n    });\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({}),\n  } as CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type CreateAssociatedTokenIdempotentInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getCreateAssociatedTokenIdempotentInstruction<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenIdempotentInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateAssociatedTokenIdempotentInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountAta,\n  TAccountOwner,\n  TAccountMint,\n  TAccountSystemProgram,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({}),\n  } as CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Funding account (must be a system account). */\n    payer: TAccountMetas[0];\n    /** Associated token account address to be created. */\n    ata: TAccountMetas[1];\n    /** Wallet address for the new associated token account. */\n    owner: TAccountMetas[2];\n    /** The token mint for the new associated token account. */\n    mint: TAccountMetas[3];\n    /** System program. */\n    systemProgram: TAccountMetas[4];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[5];\n  };\n  data: CreateAssociatedTokenIdempotentInstructionData;\n};\n\nexport function parseCreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCreateAssociatedTokenIdempotentInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      ata: getNextAccount(),\n      owner: getNextAccount(),\n      mint: getNextAccount(),\n      systemProgram: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getCreateAssociatedTokenIdempotentInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CREATE_NATIVE_MINT_DISCRIMINATOR = 31;\n\nexport function getCreateNativeMintDiscriminatorBytes() {\n  return getU8Encoder().encode(CREATE_NATIVE_MINT_DISCRIMINATOR);\n}\n\nexport type CreateNativeMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountNativeMint extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountNativeMint extends string\n        ? WritableAccount<TAccountNativeMint>\n        : TAccountNativeMint,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateNativeMintInstructionData = { discriminator: number };\n\nexport type CreateNativeMintInstructionDataArgs = {};\n\nexport function getCreateNativeMintInstructionDataEncoder(): Encoder<CreateNativeMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: CREATE_NATIVE_MINT_DISCRIMINATOR })\n  );\n}\n\nexport function getCreateNativeMintInstructionDataDecoder(): Decoder<CreateNativeMintInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCreateNativeMintInstructionDataCodec(): Codec<\n  CreateNativeMintInstructionDataArgs,\n  CreateNativeMintInstructionData\n> {\n  return combineCodec(\n    getCreateNativeMintInstructionDataEncoder(),\n    getCreateNativeMintInstructionDataDecoder()\n  );\n}\n\nexport type CreateNativeMintInput<\n  TAccountPayer extends string = string,\n  TAccountNativeMint extends string = string,\n  TAccountSystemProgram extends string = string,\n> = {\n  /** Funding account (must be a system account) */\n  payer: TransactionSigner<TAccountPayer>;\n  /** The native mint address */\n  nativeMint: Address<TAccountNativeMint>;\n  /** System program for mint account funding */\n  systemProgram?: Address<TAccountSystemProgram>;\n};\n\nexport function getCreateNativeMintInstruction<\n  TAccountPayer extends string,\n  TAccountNativeMint extends string,\n  TAccountSystemProgram extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: CreateNativeMintInput<\n    TAccountPayer,\n    TAccountNativeMint,\n    TAccountSystemProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateNativeMintInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountNativeMint,\n  TAccountSystemProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    nativeMint: { value: input.nativeMint ?? null, isWritable: true },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.nativeMint),\n      getAccountMeta(accounts.systemProgram),\n    ],\n    programAddress,\n    data: getCreateNativeMintInstructionDataEncoder().encode({}),\n  } as CreateNativeMintInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountNativeMint,\n    TAccountSystemProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCreateNativeMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Funding account (must be a system account) */\n    payer: TAccountMetas[0];\n    /** The native mint address */\n    nativeMint: TAccountMetas[1];\n    /** System program for mint account funding */\n    systemProgram: TAccountMetas[2];\n  };\n  data: CreateNativeMintInstructionData;\n};\n\nexport function parseCreateNativeMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCreateNativeMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      nativeMint: getNextAccount(),\n      systemProgram: getNextAccount(),\n    },\n    data: getCreateNativeMintInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;\n\nexport function getDisableConfidentialCreditsDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR);\n}\n\nexport const DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 10;\n\nexport function getDisableConfidentialCreditsConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type DisableConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DisableConfidentialCreditsInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n};\n\nexport type DisableConfidentialCreditsInstructionDataArgs = {};\n\nexport function getDisableConfidentialCreditsInstructionDataEncoder(): Encoder<DisableConfidentialCreditsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDisableConfidentialCreditsInstructionDataDecoder(): Decoder<DisableConfidentialCreditsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getDisableConfidentialCreditsInstructionDataCodec(): Codec<\n  DisableConfidentialCreditsInstructionDataArgs,\n  DisableConfidentialCreditsInstructionData\n> {\n  return combineCodec(\n    getDisableConfidentialCreditsInstructionDataEncoder(),\n    getDisableConfidentialCreditsInstructionDataDecoder()\n  );\n}\n\nexport type DisableConfidentialCreditsInput<\n  TAccountToken extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getDisableConfidentialCreditsInstruction<\n  TAccountToken extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: DisableConfidentialCreditsInput<TAccountToken, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): DisableConfidentialCreditsInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getDisableConfidentialCreditsInstructionDataEncoder().encode({}),\n  } as DisableConfidentialCreditsInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedDisableConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[1];\n  };\n  data: DisableConfidentialCreditsInstructionData;\n};\n\nexport function parseDisableConfidentialCreditsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedDisableConfidentialCreditsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getDisableConfidentialCreditsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DISABLE_CPI_GUARD_DISCRIMINATOR = 34;\n\nexport function getDisableCpiGuardDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_CPI_GUARD_DISCRIMINATOR);\n}\n\nexport const DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR = 1;\n\nexport function getDisableCpiGuardCpiGuardDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR);\n}\n\nexport type DisableCpiGuardInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DisableCpiGuardInstructionData = {\n  discriminator: number;\n  cpiGuardDiscriminator: number;\n};\n\nexport type DisableCpiGuardInstructionDataArgs = {};\n\nexport function getDisableCpiGuardInstructionDataEncoder(): Encoder<DisableCpiGuardInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['cpiGuardDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_CPI_GUARD_DISCRIMINATOR,\n      cpiGuardDiscriminator: DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDisableCpiGuardInstructionDataDecoder(): Decoder<DisableCpiGuardInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['cpiGuardDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getDisableCpiGuardInstructionDataCodec(): Codec<\n  DisableCpiGuardInstructionDataArgs,\n  DisableCpiGuardInstructionData\n> {\n  return combineCodec(\n    getDisableCpiGuardInstructionDataEncoder(),\n    getDisableCpiGuardInstructionDataDecoder()\n  );\n}\n\nexport type DisableCpiGuardInput<\n  TAccountToken extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The token account to update. */\n  token: Address<TAccountToken>;\n  /** The account's owner/delegate or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getDisableCpiGuardInstruction<\n  TAccountToken extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: DisableCpiGuardInput<TAccountToken, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): DisableCpiGuardInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getDisableCpiGuardInstructionDataEncoder().encode({}),\n  } as DisableCpiGuardInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedDisableCpiGuardInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token account to update. */\n    token: TAccountMetas[0];\n    /** The account's owner/delegate or its multisignature account. */\n    owner: TAccountMetas[1];\n  };\n  data: DisableCpiGuardInstructionData;\n};\n\nexport function parseDisableCpiGuardInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedDisableCpiGuardInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getDisableCpiGuardInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DISABLE_HARVEST_TO_MINT_DISCRIMINATOR = 37;\n\nexport function getDisableHarvestToMintDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_HARVEST_TO_MINT_DISCRIMINATOR);\n}\n\nexport const DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 5;\n\nexport function getDisableHarvestToMintConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type DisableHarvestToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DisableHarvestToMintInstructionData = {\n  discriminator: number;\n  confidentialTransferFeeDiscriminator: number;\n};\n\nexport type DisableHarvestToMintInstructionDataArgs = {};\n\nexport function getDisableHarvestToMintInstructionDataEncoder(): Encoder<DisableHarvestToMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_HARVEST_TO_MINT_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDisableHarvestToMintInstructionDataDecoder(): Decoder<DisableHarvestToMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getDisableHarvestToMintInstructionDataCodec(): Codec<\n  DisableHarvestToMintInstructionDataArgs,\n  DisableHarvestToMintInstructionData\n> {\n  return combineCodec(\n    getDisableHarvestToMintInstructionDataEncoder(),\n    getDisableHarvestToMintInstructionDataDecoder()\n  );\n}\n\nexport type DisableHarvestToMintInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The confidential transfer fee authority */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getDisableHarvestToMintInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: DisableHarvestToMintInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): DisableHarvestToMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getDisableHarvestToMintInstructionDataEncoder().encode({}),\n  } as DisableHarvestToMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedDisableHarvestToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. */\n    mint: TAccountMetas[0];\n    /** The confidential transfer fee authority */\n    authority: TAccountMetas[1];\n  };\n  data: DisableHarvestToMintInstructionData;\n};\n\nexport function parseDisableHarvestToMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedDisableHarvestToMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getDisableHarvestToMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DISABLE_MEMO_TRANSFERS_DISCRIMINATOR = 30;\n\nexport function getDisableMemoTransfersDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_MEMO_TRANSFERS_DISCRIMINATOR);\n}\n\nexport const DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR = 1;\n\nexport function getDisableMemoTransfersMemoTransfersDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR\n  );\n}\n\nexport type DisableMemoTransfersInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DisableMemoTransfersInstructionData = {\n  discriminator: number;\n  memoTransfersDiscriminator: number;\n};\n\nexport type DisableMemoTransfersInstructionDataArgs = {};\n\nexport function getDisableMemoTransfersInstructionDataEncoder(): Encoder<DisableMemoTransfersInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['memoTransfersDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_MEMO_TRANSFERS_DISCRIMINATOR,\n      memoTransfersDiscriminator:\n        DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDisableMemoTransfersInstructionDataDecoder(): Decoder<DisableMemoTransfersInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['memoTransfersDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getDisableMemoTransfersInstructionDataCodec(): Codec<\n  DisableMemoTransfersInstructionDataArgs,\n  DisableMemoTransfersInstructionData\n> {\n  return combineCodec(\n    getDisableMemoTransfersInstructionDataEncoder(),\n    getDisableMemoTransfersInstructionDataDecoder()\n  );\n}\n\nexport type DisableMemoTransfersInput<\n  TAccountToken extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The token account to update. */\n  token: Address<TAccountToken>;\n  /** The account's owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getDisableMemoTransfersInstruction<\n  TAccountToken extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: DisableMemoTransfersInput<TAccountToken, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): DisableMemoTransfersInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getDisableMemoTransfersInstructionDataEncoder().encode({}),\n  } as DisableMemoTransfersInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedDisableMemoTransfersInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token account to update. */\n    token: TAccountMetas[0];\n    /** The account's owner or its multisignature account. */\n    owner: TAccountMetas[1];\n  };\n  data: DisableMemoTransfersInstructionData;\n};\n\nexport function parseDisableMemoTransfersInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedDisableMemoTransfersInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getDisableMemoTransfersInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;\n\nexport function getDisableNonConfidentialCreditsDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR);\n}\n\nexport const DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 12;\n\nexport function getDisableNonConfidentialCreditsConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type DisableNonConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DisableNonConfidentialCreditsInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n};\n\nexport type DisableNonConfidentialCreditsInstructionDataArgs = {};\n\nexport function getDisableNonConfidentialCreditsInstructionDataEncoder(): Encoder<DisableNonConfidentialCreditsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDisableNonConfidentialCreditsInstructionDataDecoder(): Decoder<DisableNonConfidentialCreditsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getDisableNonConfidentialCreditsInstructionDataCodec(): Codec<\n  DisableNonConfidentialCreditsInstructionDataArgs,\n  DisableNonConfidentialCreditsInstructionData\n> {\n  return combineCodec(\n    getDisableNonConfidentialCreditsInstructionDataEncoder(),\n    getDisableNonConfidentialCreditsInstructionDataDecoder()\n  );\n}\n\nexport type DisableNonConfidentialCreditsInput<\n  TAccountToken extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getDisableNonConfidentialCreditsInstruction<\n  TAccountToken extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: DisableNonConfidentialCreditsInput<TAccountToken, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): DisableNonConfidentialCreditsInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getDisableNonConfidentialCreditsInstructionDataEncoder().encode({}),\n  } as DisableNonConfidentialCreditsInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedDisableNonConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[1];\n  };\n  data: DisableNonConfidentialCreditsInstructionData;\n};\n\nexport function parseDisableNonConfidentialCreditsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedDisableNonConfidentialCreditsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getDisableNonConfidentialCreditsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  none,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const EMIT_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([\n  250, 166, 180, 250, 13, 12, 184, 70,\n]);\n\nexport function getEmitTokenMetadataDiscriminatorBytes() {\n  return getBytesEncoder().encode(EMIT_TOKEN_METADATA_DISCRIMINATOR);\n}\n\nexport type EmitTokenMetadataInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMetadata extends string\n        ? ReadonlyAccount<TAccountMetadata>\n        : TAccountMetadata,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EmitTokenMetadataInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** Start of range of data to emit */\n  start: Option<bigint>;\n  /** End of range of data to emit */\n  end: Option<bigint>;\n};\n\nexport type EmitTokenMetadataInstructionDataArgs = {\n  /** Start of range of data to emit */\n  start?: OptionOrNullable<number | bigint>;\n  /** End of range of data to emit */\n  end?: OptionOrNullable<number | bigint>;\n};\n\nexport function getEmitTokenMetadataInstructionDataEncoder(): Encoder<EmitTokenMetadataInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      ['start', getOptionEncoder(getU64Encoder())],\n      ['end', getOptionEncoder(getU64Encoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: EMIT_TOKEN_METADATA_DISCRIMINATOR,\n      start: value.start ?? none(),\n      end: value.end ?? none(),\n    })\n  );\n}\n\nexport function getEmitTokenMetadataInstructionDataDecoder(): Decoder<EmitTokenMetadataInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    ['start', getOptionDecoder(getU64Decoder())],\n    ['end', getOptionDecoder(getU64Decoder())],\n  ]);\n}\n\nexport function getEmitTokenMetadataInstructionDataCodec(): Codec<\n  EmitTokenMetadataInstructionDataArgs,\n  EmitTokenMetadataInstructionData\n> {\n  return combineCodec(\n    getEmitTokenMetadataInstructionDataEncoder(),\n    getEmitTokenMetadataInstructionDataDecoder()\n  );\n}\n\nexport type EmitTokenMetadataInput<TAccountMetadata extends string = string> = {\n  metadata: Address<TAccountMetadata>;\n  start?: EmitTokenMetadataInstructionDataArgs['start'];\n  end?: EmitTokenMetadataInstructionDataArgs['end'];\n};\n\nexport function getEmitTokenMetadataInstruction<\n  TAccountMetadata extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EmitTokenMetadataInput<TAccountMetadata>,\n  config?: { programAddress?: TProgramAddress }\n): EmitTokenMetadataInstruction<TProgramAddress, TAccountMetadata> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.metadata)],\n    programAddress,\n    data: getEmitTokenMetadataInstructionDataEncoder().encode(\n      args as EmitTokenMetadataInstructionDataArgs\n    ),\n  } as EmitTokenMetadataInstruction<TProgramAddress, TAccountMetadata>;\n\n  return instruction;\n}\n\nexport type ParsedEmitTokenMetadataInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    metadata: TAccountMetas[0];\n  };\n  data: EmitTokenMetadataInstructionData;\n};\n\nexport function parseEmitTokenMetadataInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedEmitTokenMetadataInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      metadata: getNextAccount(),\n    },\n    data: getEmitTokenMetadataInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = 27;\n\nexport function getEmptyConfidentialTransferAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR\n  );\n}\n\nexport const EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 4;\n\nexport function getEmptyConfidentialTransferAccountConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type EmptyConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountInstructionsSysvarOrContextState extends\n    | string\n    | IAccountMeta<string> = 'Sysvar1nstructions1111111111111111111111111',\n  TAccountRecord extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountInstructionsSysvarOrContextState extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvarOrContextState>\n        : TAccountInstructionsSysvarOrContextState,\n      TAccountRecord extends string\n        ? ReadonlyAccount<TAccountRecord>\n        : TAccountRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EmptyConfidentialTransferAccountInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /**\n   * Relative location of the `ProofInstruction::VerifyCloseAccount`\n   * instruction to the `EmptyAccount` instruction in the transaction. If\n   * the offset is `0`, then use a context state account for the proof.\n   */\n  proofInstructionOffset: number;\n};\n\nexport type EmptyConfidentialTransferAccountInstructionDataArgs = {\n  /**\n   * Relative location of the `ProofInstruction::VerifyCloseAccount`\n   * instruction to the `EmptyAccount` instruction in the transaction. If\n   * the offset is `0`, then use a context state account for the proof.\n   */\n  proofInstructionOffset: number;\n};\n\nexport function getEmptyConfidentialTransferAccountInstructionDataEncoder(): Encoder<EmptyConfidentialTransferAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['proofInstructionOffset', getI8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEmptyConfidentialTransferAccountInstructionDataDecoder(): Decoder<EmptyConfidentialTransferAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['proofInstructionOffset', getI8Decoder()],\n  ]);\n}\n\nexport function getEmptyConfidentialTransferAccountInstructionDataCodec(): Codec<\n  EmptyConfidentialTransferAccountInstructionDataArgs,\n  EmptyConfidentialTransferAccountInstructionData\n> {\n  return combineCodec(\n    getEmptyConfidentialTransferAccountInstructionDataEncoder(),\n    getEmptyConfidentialTransferAccountInstructionDataDecoder()\n  );\n}\n\nexport type EmptyConfidentialTransferAccountInput<\n  TAccountToken extends string = string,\n  TAccountInstructionsSysvarOrContextState extends string = string,\n  TAccountRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /**\n   * Instructions sysvar if `VerifyZeroCiphertext` is included in\n   * the same transaction or context state account if\n   * `VerifyZeroCiphertext` is pre-verified into a context state\n   * account.\n   */\n  instructionsSysvarOrContextState?: Address<TAccountInstructionsSysvarOrContextState>;\n  /** (Optional) Record account if the accompanying proof is to be read from a record account. */\n  record?: Address<TAccountRecord>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  proofInstructionOffset: EmptyConfidentialTransferAccountInstructionDataArgs['proofInstructionOffset'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEmptyConfidentialTransferAccountInstruction<\n  TAccountToken extends string,\n  TAccountInstructionsSysvarOrContextState extends string,\n  TAccountRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EmptyConfidentialTransferAccountInput<\n    TAccountToken,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): EmptyConfidentialTransferAccountInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountInstructionsSysvarOrContextState,\n  TAccountRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    instructionsSysvarOrContextState: {\n      value: input.instructionsSysvarOrContextState ?? null,\n      isWritable: false,\n    },\n    record: { value: input.record ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.instructionsSysvarOrContextState.value) {\n    accounts.instructionsSysvarOrContextState.value =\n      'Sysvar1nstructions1111111111111111111111111' as Address<'Sysvar1nstructions1111111111111111111111111'>;\n  }\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.instructionsSysvarOrContextState),\n      getAccountMeta(accounts.record),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getEmptyConfidentialTransferAccountInstructionDataEncoder().encode(\n      args as EmptyConfidentialTransferAccountInstructionDataArgs\n    ),\n  } as EmptyConfidentialTransferAccountInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedEmptyConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /**\n     * Instructions sysvar if `VerifyZeroCiphertext` is included in\n     * the same transaction or context state account if\n     * `VerifyZeroCiphertext` is pre-verified into a context state\n     * account.\n     */\n\n    instructionsSysvarOrContextState: TAccountMetas[1];\n    /** (Optional) Record account if the accompanying proof is to be read from a record account. */\n    record?: TAccountMetas[2] | undefined;\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[3];\n  };\n  data: EmptyConfidentialTransferAccountInstructionData;\n};\n\nexport function parseEmptyConfidentialTransferAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedEmptyConfidentialTransferAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      instructionsSysvarOrContextState: getNextAccount(),\n      record: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getEmptyConfidentialTransferAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;\n\nexport function getEnableConfidentialCreditsDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR);\n}\n\nexport const ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 9;\n\nexport function getEnableConfidentialCreditsConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type EnableConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EnableConfidentialCreditsInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n};\n\nexport type EnableConfidentialCreditsInstructionDataArgs = {};\n\nexport function getEnableConfidentialCreditsInstructionDataEncoder(): Encoder<EnableConfidentialCreditsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEnableConfidentialCreditsInstructionDataDecoder(): Decoder<EnableConfidentialCreditsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getEnableConfidentialCreditsInstructionDataCodec(): Codec<\n  EnableConfidentialCreditsInstructionDataArgs,\n  EnableConfidentialCreditsInstructionData\n> {\n  return combineCodec(\n    getEnableConfidentialCreditsInstructionDataEncoder(),\n    getEnableConfidentialCreditsInstructionDataDecoder()\n  );\n}\n\nexport type EnableConfidentialCreditsInput<\n  TAccountToken extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEnableConfidentialCreditsInstruction<\n  TAccountToken extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EnableConfidentialCreditsInput<TAccountToken, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): EnableConfidentialCreditsInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getEnableConfidentialCreditsInstructionDataEncoder().encode({}),\n  } as EnableConfidentialCreditsInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedEnableConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[1];\n  };\n  data: EnableConfidentialCreditsInstructionData;\n};\n\nexport function parseEnableConfidentialCreditsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedEnableConfidentialCreditsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getEnableConfidentialCreditsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ENABLE_CPI_GUARD_DISCRIMINATOR = 34;\n\nexport function getEnableCpiGuardDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_CPI_GUARD_DISCRIMINATOR);\n}\n\nexport const ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR = 0;\n\nexport function getEnableCpiGuardCpiGuardDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR);\n}\n\nexport type EnableCpiGuardInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EnableCpiGuardInstructionData = {\n  discriminator: number;\n  cpiGuardDiscriminator: number;\n};\n\nexport type EnableCpiGuardInstructionDataArgs = {};\n\nexport function getEnableCpiGuardInstructionDataEncoder(): Encoder<EnableCpiGuardInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['cpiGuardDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_CPI_GUARD_DISCRIMINATOR,\n      cpiGuardDiscriminator: ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEnableCpiGuardInstructionDataDecoder(): Decoder<EnableCpiGuardInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['cpiGuardDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getEnableCpiGuardInstructionDataCodec(): Codec<\n  EnableCpiGuardInstructionDataArgs,\n  EnableCpiGuardInstructionData\n> {\n  return combineCodec(\n    getEnableCpiGuardInstructionDataEncoder(),\n    getEnableCpiGuardInstructionDataDecoder()\n  );\n}\n\nexport type EnableCpiGuardInput<\n  TAccountToken extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The token account to update. */\n  token: Address<TAccountToken>;\n  /** The account's owner/delegate or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEnableCpiGuardInstruction<\n  TAccountToken extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EnableCpiGuardInput<TAccountToken, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): EnableCpiGuardInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getEnableCpiGuardInstructionDataEncoder().encode({}),\n  } as EnableCpiGuardInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedEnableCpiGuardInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token account to update. */\n    token: TAccountMetas[0];\n    /** The account's owner/delegate or its multisignature account. */\n    owner: TAccountMetas[1];\n  };\n  data: EnableCpiGuardInstructionData;\n};\n\nexport function parseEnableCpiGuardInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedEnableCpiGuardInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getEnableCpiGuardInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ENABLE_HARVEST_TO_MINT_DISCRIMINATOR = 37;\n\nexport function getEnableHarvestToMintDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_HARVEST_TO_MINT_DISCRIMINATOR);\n}\n\nexport const ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 4;\n\nexport function getEnableHarvestToMintConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type EnableHarvestToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EnableHarvestToMintInstructionData = {\n  discriminator: number;\n  confidentialTransferFeeDiscriminator: number;\n};\n\nexport type EnableHarvestToMintInstructionDataArgs = {};\n\nexport function getEnableHarvestToMintInstructionDataEncoder(): Encoder<EnableHarvestToMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_HARVEST_TO_MINT_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEnableHarvestToMintInstructionDataDecoder(): Decoder<EnableHarvestToMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getEnableHarvestToMintInstructionDataCodec(): Codec<\n  EnableHarvestToMintInstructionDataArgs,\n  EnableHarvestToMintInstructionData\n> {\n  return combineCodec(\n    getEnableHarvestToMintInstructionDataEncoder(),\n    getEnableHarvestToMintInstructionDataDecoder()\n  );\n}\n\nexport type EnableHarvestToMintInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The confidential transfer fee authority */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEnableHarvestToMintInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EnableHarvestToMintInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): EnableHarvestToMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getEnableHarvestToMintInstructionDataEncoder().encode({}),\n  } as EnableHarvestToMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedEnableHarvestToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. */\n    mint: TAccountMetas[0];\n    /** The confidential transfer fee authority */\n    authority: TAccountMetas[1];\n  };\n  data: EnableHarvestToMintInstructionData;\n};\n\nexport function parseEnableHarvestToMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedEnableHarvestToMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getEnableHarvestToMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ENABLE_MEMO_TRANSFERS_DISCRIMINATOR = 30;\n\nexport function getEnableMemoTransfersDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_MEMO_TRANSFERS_DISCRIMINATOR);\n}\n\nexport const ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR = 0;\n\nexport function getEnableMemoTransfersMemoTransfersDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR\n  );\n}\n\nexport type EnableMemoTransfersInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EnableMemoTransfersInstructionData = {\n  discriminator: number;\n  memoTransfersDiscriminator: number;\n};\n\nexport type EnableMemoTransfersInstructionDataArgs = {};\n\nexport function getEnableMemoTransfersInstructionDataEncoder(): Encoder<EnableMemoTransfersInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['memoTransfersDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_MEMO_TRANSFERS_DISCRIMINATOR,\n      memoTransfersDiscriminator:\n        ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEnableMemoTransfersInstructionDataDecoder(): Decoder<EnableMemoTransfersInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['memoTransfersDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getEnableMemoTransfersInstructionDataCodec(): Codec<\n  EnableMemoTransfersInstructionDataArgs,\n  EnableMemoTransfersInstructionData\n> {\n  return combineCodec(\n    getEnableMemoTransfersInstructionDataEncoder(),\n    getEnableMemoTransfersInstructionDataDecoder()\n  );\n}\n\nexport type EnableMemoTransfersInput<\n  TAccountToken extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The token account to update. */\n  token: Address<TAccountToken>;\n  /** The account's owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEnableMemoTransfersInstruction<\n  TAccountToken extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EnableMemoTransfersInput<TAccountToken, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): EnableMemoTransfersInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getEnableMemoTransfersInstructionDataEncoder().encode({}),\n  } as EnableMemoTransfersInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedEnableMemoTransfersInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token account to update. */\n    token: TAccountMetas[0];\n    /** The account's owner or its multisignature account. */\n    owner: TAccountMetas[1];\n  };\n  data: EnableMemoTransfersInstructionData;\n};\n\nexport function parseEnableMemoTransfersInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedEnableMemoTransfersInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getEnableMemoTransfersInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;\n\nexport function getEnableNonConfidentialCreditsDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR);\n}\n\nexport const ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 11;\n\nexport function getEnableNonConfidentialCreditsConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type EnableNonConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EnableNonConfidentialCreditsInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n};\n\nexport type EnableNonConfidentialCreditsInstructionDataArgs = {};\n\nexport function getEnableNonConfidentialCreditsInstructionDataEncoder(): Encoder<EnableNonConfidentialCreditsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEnableNonConfidentialCreditsInstructionDataDecoder(): Decoder<EnableNonConfidentialCreditsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getEnableNonConfidentialCreditsInstructionDataCodec(): Codec<\n  EnableNonConfidentialCreditsInstructionDataArgs,\n  EnableNonConfidentialCreditsInstructionData\n> {\n  return combineCodec(\n    getEnableNonConfidentialCreditsInstructionDataEncoder(),\n    getEnableNonConfidentialCreditsInstructionDataDecoder()\n  );\n}\n\nexport type EnableNonConfidentialCreditsInput<\n  TAccountToken extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEnableNonConfidentialCreditsInstruction<\n  TAccountToken extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EnableNonConfidentialCreditsInput<TAccountToken, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): EnableNonConfidentialCreditsInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getEnableNonConfidentialCreditsInstructionDataEncoder().encode({}),\n  } as EnableNonConfidentialCreditsInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedEnableNonConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[1];\n  };\n  data: EnableNonConfidentialCreditsInstructionData;\n};\n\nexport function parseEnableNonConfidentialCreditsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedEnableNonConfidentialCreditsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getEnableNonConfidentialCreditsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const FREEZE_ACCOUNT_DISCRIMINATOR = 10;\n\nexport function getFreezeAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(FREEZE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type FreezeAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type FreezeAccountInstructionData = { discriminator: number };\n\nexport type FreezeAccountInstructionDataArgs = {};\n\nexport function getFreezeAccountInstructionDataEncoder(): Encoder<FreezeAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: FREEZE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getFreezeAccountInstructionDataDecoder(): Decoder<FreezeAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getFreezeAccountInstructionDataCodec(): Codec<\n  FreezeAccountInstructionDataArgs,\n  FreezeAccountInstructionData\n> {\n  return combineCodec(\n    getFreezeAccountInstructionDataEncoder(),\n    getFreezeAccountInstructionDataDecoder()\n  );\n}\n\nexport type FreezeAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to freeze. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The mint freeze authority or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getFreezeAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: FreezeAccountInput<TAccountAccount, TAccountMint, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): FreezeAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getFreezeAccountInstructionDataEncoder().encode({}),\n  } as FreezeAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedFreezeAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to freeze. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The mint freeze authority or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: FreezeAccountInstructionData;\n};\n\nexport function parseFreezeAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedFreezeAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getFreezeAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR = 21;\n\nexport function getGetAccountDataSizeDiscriminatorBytes() {\n  return getU8Encoder().encode(GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR);\n}\n\nexport type GetAccountDataSizeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type GetAccountDataSizeInstructionData = { discriminator: number };\n\nexport type GetAccountDataSizeInstructionDataArgs = {};\n\nexport function getGetAccountDataSizeInstructionDataEncoder(): Encoder<GetAccountDataSizeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getGetAccountDataSizeInstructionDataDecoder(): Decoder<GetAccountDataSizeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getGetAccountDataSizeInstructionDataCodec(): Codec<\n  GetAccountDataSizeInstructionDataArgs,\n  GetAccountDataSizeInstructionData\n> {\n  return combineCodec(\n    getGetAccountDataSizeInstructionDataEncoder(),\n    getGetAccountDataSizeInstructionDataDecoder()\n  );\n}\n\nexport type GetAccountDataSizeInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n};\n\nexport function getGetAccountDataSizeInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: GetAccountDataSizeInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): GetAccountDataSizeInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getGetAccountDataSizeInstructionDataEncoder().encode({}),\n  } as GetAccountDataSizeInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedGetAccountDataSizeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: GetAccountDataSizeInstructionData;\n};\n\nexport function parseGetAccountDataSizeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedGetAccountDataSizeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getGetAccountDataSizeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR = 26;\n\nexport function getHarvestWithheldTokensToMintDiscriminatorBytes() {\n  return getU8Encoder().encode(HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR);\n}\n\nexport const HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR = 4;\n\nexport function getHarvestWithheldTokensToMintTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type HarvestWithheldTokensToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type HarvestWithheldTokensToMintInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n};\n\nexport type HarvestWithheldTokensToMintInstructionDataArgs = {};\n\nexport function getHarvestWithheldTokensToMintInstructionDataEncoder(): Encoder<HarvestWithheldTokensToMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR,\n      transferFeeDiscriminator:\n        HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getHarvestWithheldTokensToMintInstructionDataDecoder(): Decoder<HarvestWithheldTokensToMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getHarvestWithheldTokensToMintInstructionDataCodec(): Codec<\n  HarvestWithheldTokensToMintInstructionDataArgs,\n  HarvestWithheldTokensToMintInstructionData\n> {\n  return combineCodec(\n    getHarvestWithheldTokensToMintInstructionDataEncoder(),\n    getHarvestWithheldTokensToMintInstructionDataDecoder()\n  );\n}\n\nexport type HarvestWithheldTokensToMintInput<\n  TAccountMint extends string = string,\n> = {\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  sources: Array<Address>;\n};\n\nexport function getHarvestWithheldTokensToMintInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: HarvestWithheldTokensToMintInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): HarvestWithheldTokensToMintInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = args.sources.map((address) => ({\n    address,\n    role: AccountRole.WRITABLE,\n  }));\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint), ...remainingAccounts],\n    programAddress,\n    data: getHarvestWithheldTokensToMintInstructionDataEncoder().encode({}),\n  } as HarvestWithheldTokensToMintInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedHarvestWithheldTokensToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. */\n    mint: TAccountMetas[0];\n  };\n  data: HarvestWithheldTokensToMintInstructionData;\n};\n\nexport function parseHarvestWithheldTokensToMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedHarvestWithheldTokensToMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getHarvestWithheldTokensToMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport const HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 3;\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type HarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionData =\n  { discriminator: number; confidentialTransferFeeDiscriminator: number };\n\nexport type HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataArgs =\n  {};\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder(): Encoder<HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator:\n        HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder(): Decoder<HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataCodec(): Codec<\n  HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataArgs,\n  HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionData\n> {\n  return combineCodec(\n    getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder(),\n    getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder()\n  );\n}\n\nexport type HarvestWithheldTokensToMintForConfidentialTransferFeeInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  sources?: Array<Address>;\n};\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: HarvestWithheldTokensToMintForConfidentialTransferFeeInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): HarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TProgramAddress,\n  TAccountMint\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.sources ?? []).map(\n    (address) => ({ address, role: AccountRole.WRITABLE })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint), ...remainingAccounts],\n    programAddress,\n    data: getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder().encode(\n      {}\n    ),\n  } as HarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n    TProgramAddress,\n    TAccountMint\n  >;\n\n  return instruction;\n}\n\nexport type ParsedHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n  };\n  data: HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionData;\n};\n\nexport function parseHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT_DISCRIMINATOR = 1;\n\nexport function getInitializeAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type InitializeAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccountInstructionData = { discriminator: number };\n\nexport type InitializeAccountInstructionDataArgs = {};\n\nexport function getInitializeAccountInstructionDataEncoder(): Encoder<InitializeAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccountInstructionDataDecoder(): Decoder<InitializeAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getInitializeAccountInstructionDataCodec(): Codec<\n  InitializeAccountInstructionDataArgs,\n  InitializeAccountInstructionData\n> {\n  return combineCodec(\n    getInitializeAccountInstructionDataEncoder(),\n    getInitializeAccountInstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  /** The new account's owner/multisignature. */\n  owner: Address<TAccountOwner>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n};\n\nexport function getInitializeAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccountInput<\n    TAccountAccount,\n    TAccountMint,\n    TAccountOwner,\n    TAccountRent\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  TAccountOwner,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.rent),\n    ],\n    programAddress,\n    data: getInitializeAccountInstructionDataEncoder().encode({}),\n  } as InitializeAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    TAccountOwner,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n    /** The new account's owner/multisignature. */\n    owner: TAccountMetas[2];\n    /** Rent sysvar. */\n    rent: TAccountMetas[3];\n  };\n  data: InitializeAccountInstructionData;\n};\n\nexport function parseInitializeAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT2_DISCRIMINATOR = 16;\n\nexport function getInitializeAccount2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT2_DISCRIMINATOR);\n}\n\nexport type InitializeAccount2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccount2InstructionData = {\n  discriminator: number;\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport type InitializeAccount2InstructionDataArgs = {\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport function getInitializeAccount2InstructionDataEncoder(): Encoder<InitializeAccount2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['owner', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT2_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccount2InstructionDataDecoder(): Decoder<InitializeAccount2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['owner', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializeAccount2InstructionDataCodec(): Codec<\n  InitializeAccount2InstructionDataArgs,\n  InitializeAccount2InstructionData\n> {\n  return combineCodec(\n    getInitializeAccount2InstructionDataEncoder(),\n    getInitializeAccount2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccount2Input<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  owner: InitializeAccount2InstructionDataArgs['owner'];\n};\n\nexport function getInitializeAccount2Instruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccount2Input<TAccountAccount, TAccountMint, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccount2Instruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.rent),\n    ],\n    programAddress,\n    data: getInitializeAccount2InstructionDataEncoder().encode(\n      args as InitializeAccount2InstructionDataArgs\n    ),\n  } as InitializeAccount2Instruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeAccount2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n    /** Rent sysvar. */\n    rent: TAccountMetas[2];\n  };\n  data: InitializeAccount2InstructionData;\n};\n\nexport function parseInitializeAccount2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeAccount2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeAccount2InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT3_DISCRIMINATOR = 18;\n\nexport function getInitializeAccount3DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT3_DISCRIMINATOR);\n}\n\nexport type InitializeAccount3Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccount3InstructionData = {\n  discriminator: number;\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport type InitializeAccount3InstructionDataArgs = {\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport function getInitializeAccount3InstructionDataEncoder(): Encoder<InitializeAccount3InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['owner', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT3_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccount3InstructionDataDecoder(): Decoder<InitializeAccount3InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['owner', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializeAccount3InstructionDataCodec(): Codec<\n  InitializeAccount3InstructionDataArgs,\n  InitializeAccount3InstructionData\n> {\n  return combineCodec(\n    getInitializeAccount3InstructionDataEncoder(),\n    getInitializeAccount3InstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccount3Input<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  owner: InitializeAccount3InstructionDataArgs['owner'];\n};\n\nexport function getInitializeAccount3Instruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccount3Input<TAccountAccount, TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccount3Instruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.account), getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeAccount3InstructionDataEncoder().encode(\n      args as InitializeAccount3InstructionDataArgs\n    ),\n  } as InitializeAccount3Instruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeAccount3Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n  };\n  data: InitializeAccount3InstructionData;\n};\n\nexport function parseInitializeAccount3Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeAccount3Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n    },\n    data: getInitializeAccount3InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;\n\nexport function getInitializeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport const INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 0;\n\nexport function getInitializeConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type InitializeConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeConfidentialTransferFeeInstructionData = {\n  discriminator: number;\n  confidentialTransferFeeDiscriminator: number;\n  /** Optional authority to set the withdraw withheld authority ElGamal key */\n  authority: Option<Address>;\n  /** Withheld fees from accounts must be encrypted with this ElGamal key */\n  withdrawWithheldAuthorityElGamalPubkey: Option<Address>;\n};\n\nexport type InitializeConfidentialTransferFeeInstructionDataArgs = {\n  /** Optional authority to set the withdraw withheld authority ElGamal key */\n  authority: OptionOrNullable<Address>;\n  /** Withheld fees from accounts must be encrypted with this ElGamal key */\n  withdrawWithheldAuthorityElGamalPubkey: OptionOrNullable<Address>;\n};\n\nexport function getInitializeConfidentialTransferFeeInstructionDataEncoder(): Encoder<InitializeConfidentialTransferFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      [\n        'withdrawWithheldAuthorityElGamalPubkey',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeConfidentialTransferFeeInstructionDataDecoder(): Decoder<InitializeConfidentialTransferFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'withdrawWithheldAuthorityElGamalPubkey',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeConfidentialTransferFeeInstructionDataCodec(): Codec<\n  InitializeConfidentialTransferFeeInstructionDataArgs,\n  InitializeConfidentialTransferFeeInstructionData\n> {\n  return combineCodec(\n    getInitializeConfidentialTransferFeeInstructionDataEncoder(),\n    getInitializeConfidentialTransferFeeInstructionDataDecoder()\n  );\n}\n\nexport type InitializeConfidentialTransferFeeInput<\n  TAccountMint extends string = string,\n> = {\n  /** The SPL Token mint. */\n  mint: Address<TAccountMint>;\n  authority: InitializeConfidentialTransferFeeInstructionDataArgs['authority'];\n  withdrawWithheldAuthorityElGamalPubkey: InitializeConfidentialTransferFeeInstructionDataArgs['withdrawWithheldAuthorityElGamalPubkey'];\n};\n\nexport function getInitializeConfidentialTransferFeeInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeConfidentialTransferFeeInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeConfidentialTransferFeeInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeConfidentialTransferFeeInstructionDataEncoder().encode(\n      args as InitializeConfidentialTransferFeeInstructionDataArgs\n    ),\n  } as InitializeConfidentialTransferFeeInstruction<\n    TProgramAddress,\n    TAccountMint\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token mint. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeConfidentialTransferFeeInstructionData;\n};\n\nexport function parseInitializeConfidentialTransferFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeConfidentialTransferFeeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeConfidentialTransferFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR = 27;\n\nexport function getInitializeConfidentialTransferMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR\n  );\n}\n\nexport const INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 0;\n\nexport function getInitializeConfidentialTransferMintConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type InitializeConfidentialTransferMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeConfidentialTransferMintInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /**\n   * Authority to modify the `ConfidentialTransferMint` configuration and to\n   * approve new accounts.\n   */\n  authority: Option<Address>;\n  /**\n   * Determines if newly configured accounts must be approved by the\n   * `authority` before they may be used by the user.\n   */\n  autoApproveNewAccounts: boolean;\n  /** New authority to decode any transfer amount in a confidential transfer. */\n  auditorElgamalPubkey: Option<Address>;\n};\n\nexport type InitializeConfidentialTransferMintInstructionDataArgs = {\n  /**\n   * Authority to modify the `ConfidentialTransferMint` configuration and to\n   * approve new accounts.\n   */\n  authority: OptionOrNullable<Address>;\n  /**\n   * Determines if newly configured accounts must be approved by the\n   * `authority` before they may be used by the user.\n   */\n  autoApproveNewAccounts: boolean;\n  /** New authority to decode any transfer amount in a confidential transfer. */\n  auditorElgamalPubkey: OptionOrNullable<Address>;\n};\n\nexport function getInitializeConfidentialTransferMintInstructionDataEncoder(): Encoder<InitializeConfidentialTransferMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      ['autoApproveNewAccounts', getBooleanEncoder()],\n      [\n        'auditorElgamalPubkey',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeConfidentialTransferMintInstructionDataDecoder(): Decoder<InitializeConfidentialTransferMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['autoApproveNewAccounts', getBooleanDecoder()],\n    [\n      'auditorElgamalPubkey',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeConfidentialTransferMintInstructionDataCodec(): Codec<\n  InitializeConfidentialTransferMintInstructionDataArgs,\n  InitializeConfidentialTransferMintInstructionData\n> {\n  return combineCodec(\n    getInitializeConfidentialTransferMintInstructionDataEncoder(),\n    getInitializeConfidentialTransferMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeConfidentialTransferMintInput<\n  TAccountMint extends string = string,\n> = {\n  /** The SPL Token mint. */\n  mint: Address<TAccountMint>;\n  authority: InitializeConfidentialTransferMintInstructionDataArgs['authority'];\n  autoApproveNewAccounts: InitializeConfidentialTransferMintInstructionDataArgs['autoApproveNewAccounts'];\n  auditorElgamalPubkey: InitializeConfidentialTransferMintInstructionDataArgs['auditorElgamalPubkey'];\n};\n\nexport function getInitializeConfidentialTransferMintInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeConfidentialTransferMintInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeConfidentialTransferMintInstruction<\n  TProgramAddress,\n  TAccountMint\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeConfidentialTransferMintInstructionDataEncoder().encode(\n      args as InitializeConfidentialTransferMintInstructionDataArgs\n    ),\n  } as InitializeConfidentialTransferMintInstruction<\n    TProgramAddress,\n    TAccountMint\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeConfidentialTransferMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token mint. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeConfidentialTransferMintInstructionData;\n};\n\nexport function parseInitializeConfidentialTransferMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeConfidentialTransferMintInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeConfidentialTransferMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getAccountStateDecoder,\n  getAccountStateEncoder,\n  type AccountState,\n  type AccountStateArgs,\n} from '../types';\n\nexport const INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 28;\n\nexport function getInitializeDefaultAccountStateDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 0;\n\nexport function getInitializeDefaultAccountStateDefaultAccountStateDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR\n  );\n}\n\nexport type InitializeDefaultAccountStateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeDefaultAccountStateInstructionData = {\n  discriminator: number;\n  defaultAccountStateDiscriminator: number;\n  /** The state each new token account should start with. */\n  state: AccountState;\n};\n\nexport type InitializeDefaultAccountStateInstructionDataArgs = {\n  /** The state each new token account should start with. */\n  state: AccountStateArgs;\n};\n\nexport function getInitializeDefaultAccountStateInstructionDataEncoder(): Encoder<InitializeDefaultAccountStateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['defaultAccountStateDiscriminator', getU8Encoder()],\n      ['state', getAccountStateEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR,\n      defaultAccountStateDiscriminator:\n        INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeDefaultAccountStateInstructionDataDecoder(): Decoder<InitializeDefaultAccountStateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['defaultAccountStateDiscriminator', getU8Decoder()],\n    ['state', getAccountStateDecoder()],\n  ]);\n}\n\nexport function getInitializeDefaultAccountStateInstructionDataCodec(): Codec<\n  InitializeDefaultAccountStateInstructionDataArgs,\n  InitializeDefaultAccountStateInstructionData\n> {\n  return combineCodec(\n    getInitializeDefaultAccountStateInstructionDataEncoder(),\n    getInitializeDefaultAccountStateInstructionDataDecoder()\n  );\n}\n\nexport type InitializeDefaultAccountStateInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  state: InitializeDefaultAccountStateInstructionDataArgs['state'];\n};\n\nexport function getInitializeDefaultAccountStateInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeDefaultAccountStateInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeDefaultAccountStateInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeDefaultAccountStateInstructionDataEncoder().encode(\n      args as InitializeDefaultAccountStateInstructionDataArgs\n    ),\n  } as InitializeDefaultAccountStateInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeDefaultAccountStateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeDefaultAccountStateInstructionData;\n};\n\nexport function parseInitializeDefaultAccountStateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeDefaultAccountStateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeDefaultAccountStateInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR = 41;\n\nexport function getInitializeGroupMemberPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR = 0;\n\nexport function getInitializeGroupMemberPointerGroupMemberPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type InitializeGroupMemberPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeGroupMemberPointerInstructionData = {\n  discriminator: number;\n  groupMemberPointerDiscriminator: number;\n  /** The public key for the account that can update the group member address. */\n  authority: Option<Address>;\n  /** The account address that holds the member. */\n  memberAddress: Option<Address>;\n};\n\nexport type InitializeGroupMemberPointerInstructionDataArgs = {\n  /** The public key for the account that can update the group member address. */\n  authority: OptionOrNullable<Address>;\n  /** The account address that holds the member. */\n  memberAddress: OptionOrNullable<Address>;\n};\n\nexport function getInitializeGroupMemberPointerInstructionDataEncoder(): Encoder<InitializeGroupMemberPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['groupMemberPointerDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      [\n        'memberAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR,\n      groupMemberPointerDiscriminator:\n        INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeGroupMemberPointerInstructionDataDecoder(): Decoder<InitializeGroupMemberPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['groupMemberPointerDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'memberAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeGroupMemberPointerInstructionDataCodec(): Codec<\n  InitializeGroupMemberPointerInstructionDataArgs,\n  InitializeGroupMemberPointerInstructionData\n> {\n  return combineCodec(\n    getInitializeGroupMemberPointerInstructionDataEncoder(),\n    getInitializeGroupMemberPointerInstructionDataDecoder()\n  );\n}\n\nexport type InitializeGroupMemberPointerInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  authority: InitializeGroupMemberPointerInstructionDataArgs['authority'];\n  memberAddress: InitializeGroupMemberPointerInstructionDataArgs['memberAddress'];\n};\n\nexport function getInitializeGroupMemberPointerInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeGroupMemberPointerInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeGroupMemberPointerInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeGroupMemberPointerInstructionDataEncoder().encode(\n      args as InitializeGroupMemberPointerInstructionDataArgs\n    ),\n  } as InitializeGroupMemberPointerInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeGroupMemberPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeGroupMemberPointerInstructionData;\n};\n\nexport function parseInitializeGroupMemberPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeGroupMemberPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeGroupMemberPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_GROUP_POINTER_DISCRIMINATOR = 40;\n\nexport function getInitializeGroupPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_GROUP_POINTER_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR = 0;\n\nexport function getInitializeGroupPointerGroupPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type InitializeGroupPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeGroupPointerInstructionData = {\n  discriminator: number;\n  groupPointerDiscriminator: number;\n  /** The public key for the account that can update the group address. */\n  authority: Option<Address>;\n  /** The account address that holds the group. */\n  groupAddress: Option<Address>;\n};\n\nexport type InitializeGroupPointerInstructionDataArgs = {\n  /** The public key for the account that can update the group address. */\n  authority: OptionOrNullable<Address>;\n  /** The account address that holds the group. */\n  groupAddress: OptionOrNullable<Address>;\n};\n\nexport function getInitializeGroupPointerInstructionDataEncoder(): Encoder<InitializeGroupPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['groupPointerDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      [\n        'groupAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_GROUP_POINTER_DISCRIMINATOR,\n      groupPointerDiscriminator:\n        INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeGroupPointerInstructionDataDecoder(): Decoder<InitializeGroupPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['groupPointerDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'groupAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeGroupPointerInstructionDataCodec(): Codec<\n  InitializeGroupPointerInstructionDataArgs,\n  InitializeGroupPointerInstructionData\n> {\n  return combineCodec(\n    getInitializeGroupPointerInstructionDataEncoder(),\n    getInitializeGroupPointerInstructionDataDecoder()\n  );\n}\n\nexport type InitializeGroupPointerInput<TAccountMint extends string = string> =\n  {\n    /** The mint to initialize. */\n    mint: Address<TAccountMint>;\n    authority: InitializeGroupPointerInstructionDataArgs['authority'];\n    groupAddress: InitializeGroupPointerInstructionDataArgs['groupAddress'];\n  };\n\nexport function getInitializeGroupPointerInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeGroupPointerInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeGroupPointerInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeGroupPointerInstructionDataEncoder().encode(\n      args as InitializeGroupPointerInstructionDataArgs\n    ),\n  } as InitializeGroupPointerInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeGroupPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeGroupPointerInstructionData;\n};\n\nexport function parseInitializeGroupPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeGroupPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeGroupPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR = 22;\n\nexport function getInitializeImmutableOwnerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR);\n}\n\nexport type InitializeImmutableOwnerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeImmutableOwnerInstructionData = { discriminator: number };\n\nexport type InitializeImmutableOwnerInstructionDataArgs = {};\n\nexport function getInitializeImmutableOwnerInstructionDataEncoder(): Encoder<InitializeImmutableOwnerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeImmutableOwnerInstructionDataDecoder(): Decoder<InitializeImmutableOwnerInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getInitializeImmutableOwnerInstructionDataCodec(): Codec<\n  InitializeImmutableOwnerInstructionDataArgs,\n  InitializeImmutableOwnerInstructionData\n> {\n  return combineCodec(\n    getInitializeImmutableOwnerInstructionDataEncoder(),\n    getInitializeImmutableOwnerInstructionDataDecoder()\n  );\n}\n\nexport type InitializeImmutableOwnerInput<\n  TAccountAccount extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n};\n\nexport function getInitializeImmutableOwnerInstruction<\n  TAccountAccount extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeImmutableOwnerInput<TAccountAccount>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeImmutableOwnerInstruction<TProgramAddress, TAccountAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.account)],\n    programAddress,\n    data: getInitializeImmutableOwnerInstructionDataEncoder().encode({}),\n  } as InitializeImmutableOwnerInstruction<TProgramAddress, TAccountAccount>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeImmutableOwnerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n  };\n  data: InitializeImmutableOwnerInstructionData;\n};\n\nexport function parseInitializeImmutableOwnerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeImmutableOwnerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n    },\n    data: getInitializeImmutableOwnerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getI16Decoder,\n  getI16Encoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR = 33;\n\nexport function getInitializeInterestBearingMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR = 0;\n\nexport function getInitializeInterestBearingMintInterestBearingMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR\n  );\n}\n\nexport type InitializeInterestBearingMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeInterestBearingMintInstructionData = {\n  discriminator: number;\n  interestBearingMintDiscriminator: number;\n  /** The public key for the account that can update the rate */\n  rateAuthority: Option<Address>;\n  /** The initial interest rate */\n  rate: number;\n};\n\nexport type InitializeInterestBearingMintInstructionDataArgs = {\n  /** The public key for the account that can update the rate */\n  rateAuthority: OptionOrNullable<Address>;\n  /** The initial interest rate */\n  rate: number;\n};\n\nexport function getInitializeInterestBearingMintInstructionDataEncoder(): Encoder<InitializeInterestBearingMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['interestBearingMintDiscriminator', getU8Encoder()],\n      [\n        'rateAuthority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      ['rate', getI16Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR,\n      interestBearingMintDiscriminator:\n        INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeInterestBearingMintInstructionDataDecoder(): Decoder<InitializeInterestBearingMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['interestBearingMintDiscriminator', getU8Decoder()],\n    [\n      'rateAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['rate', getI16Decoder()],\n  ]);\n}\n\nexport function getInitializeInterestBearingMintInstructionDataCodec(): Codec<\n  InitializeInterestBearingMintInstructionDataArgs,\n  InitializeInterestBearingMintInstructionData\n> {\n  return combineCodec(\n    getInitializeInterestBearingMintInstructionDataEncoder(),\n    getInitializeInterestBearingMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeInterestBearingMintInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  rateAuthority: InitializeInterestBearingMintInstructionDataArgs['rateAuthority'];\n  rate: InitializeInterestBearingMintInstructionDataArgs['rate'];\n};\n\nexport function getInitializeInterestBearingMintInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeInterestBearingMintInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeInterestBearingMintInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeInterestBearingMintInstructionDataEncoder().encode(\n      args as InitializeInterestBearingMintInstructionDataArgs\n    ),\n  } as InitializeInterestBearingMintInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeInterestBearingMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeInterestBearingMintInstructionData;\n};\n\nexport function parseInitializeInterestBearingMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeInterestBearingMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeInterestBearingMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_METADATA_POINTER_DISCRIMINATOR = 39;\n\nexport function getInitializeMetadataPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_METADATA_POINTER_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR = 0;\n\nexport function getInitializeMetadataPointerMetadataPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type InitializeMetadataPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMetadataPointerInstructionData = {\n  discriminator: number;\n  metadataPointerDiscriminator: number;\n  /** The public key for the account that can update the metadata address. */\n  authority: Option<Address>;\n  /** The account address that holds the metadata. */\n  metadataAddress: Option<Address>;\n};\n\nexport type InitializeMetadataPointerInstructionDataArgs = {\n  /** The public key for the account that can update the metadata address. */\n  authority: OptionOrNullable<Address>;\n  /** The account address that holds the metadata. */\n  metadataAddress: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMetadataPointerInstructionDataEncoder(): Encoder<InitializeMetadataPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['metadataPointerDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      [\n        'metadataAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_METADATA_POINTER_DISCRIMINATOR,\n      metadataPointerDiscriminator:\n        INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeMetadataPointerInstructionDataDecoder(): Decoder<InitializeMetadataPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['metadataPointerDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'metadataAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeMetadataPointerInstructionDataCodec(): Codec<\n  InitializeMetadataPointerInstructionDataArgs,\n  InitializeMetadataPointerInstructionData\n> {\n  return combineCodec(\n    getInitializeMetadataPointerInstructionDataEncoder(),\n    getInitializeMetadataPointerInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMetadataPointerInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  authority: InitializeMetadataPointerInstructionDataArgs['authority'];\n  metadataAddress: InitializeMetadataPointerInstructionDataArgs['metadataAddress'];\n};\n\nexport function getInitializeMetadataPointerInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMetadataPointerInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMetadataPointerInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeMetadataPointerInstructionDataEncoder().encode(\n      args as InitializeMetadataPointerInstructionDataArgs\n    ),\n  } as InitializeMetadataPointerInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeMetadataPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeMetadataPointerInstructionData;\n};\n\nexport function parseInitializeMetadataPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeMetadataPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeMetadataPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  none,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MINT_DISCRIMINATOR = 0;\n\nexport function getInitializeMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT_DISCRIMINATOR);\n}\n\nexport type InitializeMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMintInstructionData = {\n  discriminator: number;\n  /** Number of decimals in token account amounts. */\n  decimals: number;\n  /** Minting authority. */\n  mintAuthority: Address;\n  /** Optional authority that can freeze token accounts. */\n  freezeAuthority: Option<Address>;\n};\n\nexport type InitializeMintInstructionDataArgs = {\n  /** Number of decimals in token account amounts. */\n  decimals: number;\n  /** Minting authority. */\n  mintAuthority: Address;\n  /** Optional authority that can freeze token accounts. */\n  freezeAuthority?: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMintInstructionDataEncoder(): Encoder<InitializeMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['decimals', getU8Encoder()],\n      ['mintAuthority', getAddressEncoder()],\n      ['freezeAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT_DISCRIMINATOR,\n      freezeAuthority: value.freezeAuthority ?? none(),\n    })\n  );\n}\n\nexport function getInitializeMintInstructionDataDecoder(): Decoder<InitializeMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['decimals', getU8Decoder()],\n    ['mintAuthority', getAddressDecoder()],\n    ['freezeAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getInitializeMintInstructionDataCodec(): Codec<\n  InitializeMintInstructionDataArgs,\n  InitializeMintInstructionData\n> {\n  return combineCodec(\n    getInitializeMintInstructionDataEncoder(),\n    getInitializeMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMintInput<\n  TAccountMint extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** Token mint account. */\n  mint: Address<TAccountMint>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  decimals: InitializeMintInstructionDataArgs['decimals'];\n  mintAuthority: InitializeMintInstructionDataArgs['mintAuthority'];\n  freezeAuthority?: InitializeMintInstructionDataArgs['freezeAuthority'];\n};\n\nexport function getInitializeMintInstruction<\n  TAccountMint extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMintInput<TAccountMint, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMintInstruction<TProgramAddress, TAccountMint, TAccountRent> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint), getAccountMeta(accounts.rent)],\n    programAddress,\n    data: getInitializeMintInstructionDataEncoder().encode(\n      args as InitializeMintInstructionDataArgs\n    ),\n  } as InitializeMintInstruction<TProgramAddress, TAccountMint, TAccountRent>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Token mint account. */\n    mint: TAccountMetas[0];\n    /** Rent sysvar. */\n    rent: TAccountMetas[1];\n  };\n  data: InitializeMintInstructionData;\n};\n\nexport function parseInitializeMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeMintInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  none,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MINT2_DISCRIMINATOR = 20;\n\nexport function getInitializeMint2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT2_DISCRIMINATOR);\n}\n\nexport type InitializeMint2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMint2InstructionData = {\n  discriminator: number;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The authority/multisignature to mint tokens. */\n  mintAuthority: Address;\n  /** The optional freeze authority/multisignature of the mint. */\n  freezeAuthority: Option<Address>;\n};\n\nexport type InitializeMint2InstructionDataArgs = {\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The authority/multisignature to mint tokens. */\n  mintAuthority: Address;\n  /** The optional freeze authority/multisignature of the mint. */\n  freezeAuthority?: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMint2InstructionDataEncoder(): Encoder<InitializeMint2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['decimals', getU8Encoder()],\n      ['mintAuthority', getAddressEncoder()],\n      ['freezeAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT2_DISCRIMINATOR,\n      freezeAuthority: value.freezeAuthority ?? none(),\n    })\n  );\n}\n\nexport function getInitializeMint2InstructionDataDecoder(): Decoder<InitializeMint2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['decimals', getU8Decoder()],\n    ['mintAuthority', getAddressDecoder()],\n    ['freezeAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getInitializeMint2InstructionDataCodec(): Codec<\n  InitializeMint2InstructionDataArgs,\n  InitializeMint2InstructionData\n> {\n  return combineCodec(\n    getInitializeMint2InstructionDataEncoder(),\n    getInitializeMint2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeMint2Input<TAccountMint extends string = string> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  decimals: InitializeMint2InstructionDataArgs['decimals'];\n  mintAuthority: InitializeMint2InstructionDataArgs['mintAuthority'];\n  freezeAuthority?: InitializeMint2InstructionDataArgs['freezeAuthority'];\n};\n\nexport function getInitializeMint2Instruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMint2Input<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMint2Instruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeMint2InstructionDataEncoder().encode(\n      args as InitializeMint2InstructionDataArgs\n    ),\n  } as InitializeMint2Instruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeMint2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeMint2InstructionData;\n};\n\nexport function parseInitializeMint2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeMint2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeMint2InstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR = 25;\n\nexport function getInitializeMintCloseAuthorityDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR);\n}\n\nexport type InitializeMintCloseAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMintCloseAuthorityInstructionData = {\n  discriminator: number;\n  /** Authority that must sign the `CloseAccount` instruction on a mint. */\n  closeAuthority: Option<Address>;\n};\n\nexport type InitializeMintCloseAuthorityInstructionDataArgs = {\n  /** Authority that must sign the `CloseAccount` instruction on a mint. */\n  closeAuthority: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMintCloseAuthorityInstructionDataEncoder(): Encoder<InitializeMintCloseAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['closeAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeMintCloseAuthorityInstructionDataDecoder(): Decoder<InitializeMintCloseAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['closeAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getInitializeMintCloseAuthorityInstructionDataCodec(): Codec<\n  InitializeMintCloseAuthorityInstructionDataArgs,\n  InitializeMintCloseAuthorityInstructionData\n> {\n  return combineCodec(\n    getInitializeMintCloseAuthorityInstructionDataEncoder(),\n    getInitializeMintCloseAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMintCloseAuthorityInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  closeAuthority: InitializeMintCloseAuthorityInstructionDataArgs['closeAuthority'];\n};\n\nexport function getInitializeMintCloseAuthorityInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMintCloseAuthorityInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMintCloseAuthorityInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeMintCloseAuthorityInstructionDataEncoder().encode(\n      args as InitializeMintCloseAuthorityInstructionDataArgs\n    ),\n  } as InitializeMintCloseAuthorityInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeMintCloseAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeMintCloseAuthorityInstructionData;\n};\n\nexport function parseInitializeMintCloseAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeMintCloseAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeMintCloseAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MULTISIG_DISCRIMINATOR = 2;\n\nexport function getInitializeMultisigDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MULTISIG_DISCRIMINATOR);\n}\n\nexport type InitializeMultisigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMultisig extends string | IAccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMultisig extends string\n        ? WritableAccount<TAccountMultisig>\n        : TAccountMultisig,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMultisigInstructionData = {\n  discriminator: number;\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport type InitializeMultisigInstructionDataArgs = {\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport function getInitializeMultisigInstructionDataEncoder(): Encoder<InitializeMultisigInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['m', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_MULTISIG_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeMultisigInstructionDataDecoder(): Decoder<InitializeMultisigInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['m', getU8Decoder()],\n  ]);\n}\n\nexport function getInitializeMultisigInstructionDataCodec(): Codec<\n  InitializeMultisigInstructionDataArgs,\n  InitializeMultisigInstructionData\n> {\n  return combineCodec(\n    getInitializeMultisigInstructionDataEncoder(),\n    getInitializeMultisigInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMultisigInput<\n  TAccountMultisig extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The multisignature account to initialize. */\n  multisig: Address<TAccountMultisig>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  m: InitializeMultisigInstructionDataArgs['m'];\n  signers: Array<Address>;\n};\n\nexport function getInitializeMultisigInstruction<\n  TAccountMultisig extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMultisigInput<TAccountMultisig, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMultisigInstruction<\n  TProgramAddress,\n  TAccountMultisig,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    multisig: { value: input.multisig ?? null, isWritable: true },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = args.signers.map((address) => ({\n    address,\n    role: AccountRole.READONLY,\n  }));\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.multisig),\n      getAccountMeta(accounts.rent),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getInitializeMultisigInstructionDataEncoder().encode(\n      args as InitializeMultisigInstructionDataArgs\n    ),\n  } as InitializeMultisigInstruction<\n    TProgramAddress,\n    TAccountMultisig,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeMultisigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The multisignature account to initialize. */\n    multisig: TAccountMetas[0];\n    /** Rent sysvar. */\n    rent: TAccountMetas[1];\n  };\n  data: InitializeMultisigInstructionData;\n};\n\nexport function parseInitializeMultisigInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeMultisigInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      multisig: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeMultisigInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MULTISIG2_DISCRIMINATOR = 19;\n\nexport function getInitializeMultisig2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MULTISIG2_DISCRIMINATOR);\n}\n\nexport type InitializeMultisig2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMultisig extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMultisig extends string\n        ? WritableAccount<TAccountMultisig>\n        : TAccountMultisig,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMultisig2InstructionData = {\n  discriminator: number;\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport type InitializeMultisig2InstructionDataArgs = {\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport function getInitializeMultisig2InstructionDataEncoder(): Encoder<InitializeMultisig2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['m', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_MULTISIG2_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeMultisig2InstructionDataDecoder(): Decoder<InitializeMultisig2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['m', getU8Decoder()],\n  ]);\n}\n\nexport function getInitializeMultisig2InstructionDataCodec(): Codec<\n  InitializeMultisig2InstructionDataArgs,\n  InitializeMultisig2InstructionData\n> {\n  return combineCodec(\n    getInitializeMultisig2InstructionDataEncoder(),\n    getInitializeMultisig2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeMultisig2Input<TAccountMultisig extends string = string> =\n  {\n    /** The multisignature account to initialize. */\n    multisig: Address<TAccountMultisig>;\n    m: InitializeMultisig2InstructionDataArgs['m'];\n    signers: Array<Address>;\n  };\n\nexport function getInitializeMultisig2Instruction<\n  TAccountMultisig extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMultisig2Input<TAccountMultisig>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMultisig2Instruction<TProgramAddress, TAccountMultisig> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    multisig: { value: input.multisig ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = args.signers.map((address) => ({\n    address,\n    role: AccountRole.READONLY,\n  }));\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.multisig), ...remainingAccounts],\n    programAddress,\n    data: getInitializeMultisig2InstructionDataEncoder().encode(\n      args as InitializeMultisig2InstructionDataArgs\n    ),\n  } as InitializeMultisig2Instruction<TProgramAddress, TAccountMultisig>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeMultisig2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The multisignature account to initialize. */\n    multisig: TAccountMetas[0];\n  };\n  data: InitializeMultisig2InstructionData;\n};\n\nexport function parseInitializeMultisig2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeMultisig2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      multisig: getNextAccount(),\n    },\n    data: getInitializeMultisig2InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR = 32;\n\nexport function getInitializeNonTransferableMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR);\n}\n\nexport type InitializeNonTransferableMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeNonTransferableMintInstructionData = {\n  discriminator: number;\n};\n\nexport type InitializeNonTransferableMintInstructionDataArgs = {};\n\nexport function getInitializeNonTransferableMintInstructionDataEncoder(): Encoder<InitializeNonTransferableMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeNonTransferableMintInstructionDataDecoder(): Decoder<InitializeNonTransferableMintInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getInitializeNonTransferableMintInstructionDataCodec(): Codec<\n  InitializeNonTransferableMintInstructionDataArgs,\n  InitializeNonTransferableMintInstructionData\n> {\n  return combineCodec(\n    getInitializeNonTransferableMintInstructionDataEncoder(),\n    getInitializeNonTransferableMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeNonTransferableMintInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint account to initialize. */\n  mint: Address<TAccountMint>;\n};\n\nexport function getInitializeNonTransferableMintInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeNonTransferableMintInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeNonTransferableMintInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeNonTransferableMintInstructionDataEncoder().encode({}),\n  } as InitializeNonTransferableMintInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeNonTransferableMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint account to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeNonTransferableMintInstructionData;\n};\n\nexport function parseInitializeNonTransferableMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeNonTransferableMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeNonTransferableMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_PAUSABLE_CONFIG_DISCRIMINATOR = 44;\n\nexport function getInitializePausableConfigDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_PAUSABLE_CONFIG_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_PAUSABLE_CONFIG_PAUSABLE_DISCRIMINATOR = 0;\n\nexport function getInitializePausableConfigPausableDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_PAUSABLE_CONFIG_PAUSABLE_DISCRIMINATOR\n  );\n}\n\nexport type InitializePausableConfigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializePausableConfigInstructionData = {\n  discriminator: number;\n  pausableDiscriminator: number;\n  /** The authority that can pause and resume the mint. */\n  authority: Option<Address>;\n};\n\nexport type InitializePausableConfigInstructionDataArgs = {\n  /** The authority that can pause and resume the mint. */\n  authority: OptionOrNullable<Address>;\n};\n\nexport function getInitializePausableConfigInstructionDataEncoder(): Encoder<InitializePausableConfigInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['pausableDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_PAUSABLE_CONFIG_DISCRIMINATOR,\n      pausableDiscriminator: INITIALIZE_PAUSABLE_CONFIG_PAUSABLE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializePausableConfigInstructionDataDecoder(): Decoder<InitializePausableConfigInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['pausableDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializePausableConfigInstructionDataCodec(): Codec<\n  InitializePausableConfigInstructionDataArgs,\n  InitializePausableConfigInstructionData\n> {\n  return combineCodec(\n    getInitializePausableConfigInstructionDataEncoder(),\n    getInitializePausableConfigInstructionDataDecoder()\n  );\n}\n\nexport type InitializePausableConfigInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  authority: InitializePausableConfigInstructionDataArgs['authority'];\n};\n\nexport function getInitializePausableConfigInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializePausableConfigInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializePausableConfigInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializePausableConfigInstructionDataEncoder().encode(\n      args as InitializePausableConfigInstructionDataArgs\n    ),\n  } as InitializePausableConfigInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializePausableConfigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializePausableConfigInstructionData;\n};\n\nexport function parseInitializePausableConfigInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializePausableConfigInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializePausableConfigInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR = 35;\n\nexport function getInitializePermanentDelegateDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR);\n}\n\nexport type InitializePermanentDelegateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializePermanentDelegateInstructionData = {\n  discriminator: number;\n  /** Authority that may sign for `Transfer`s and `Burn`s on any account */\n  delegate: Address;\n};\n\nexport type InitializePermanentDelegateInstructionDataArgs = {\n  /** Authority that may sign for `Transfer`s and `Burn`s on any account */\n  delegate: Address;\n};\n\nexport function getInitializePermanentDelegateInstructionDataEncoder(): Encoder<InitializePermanentDelegateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['delegate', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializePermanentDelegateInstructionDataDecoder(): Decoder<InitializePermanentDelegateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['delegate', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializePermanentDelegateInstructionDataCodec(): Codec<\n  InitializePermanentDelegateInstructionDataArgs,\n  InitializePermanentDelegateInstructionData\n> {\n  return combineCodec(\n    getInitializePermanentDelegateInstructionDataEncoder(),\n    getInitializePermanentDelegateInstructionDataDecoder()\n  );\n}\n\nexport type InitializePermanentDelegateInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  delegate: InitializePermanentDelegateInstructionDataArgs['delegate'];\n};\n\nexport function getInitializePermanentDelegateInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializePermanentDelegateInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializePermanentDelegateInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializePermanentDelegateInstructionDataEncoder().encode(\n      args as InitializePermanentDelegateInstructionDataArgs\n    ),\n  } as InitializePermanentDelegateInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializePermanentDelegateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializePermanentDelegateInstructionData;\n};\n\nexport function parseInitializePermanentDelegateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializePermanentDelegateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializePermanentDelegateInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getF64Decoder,\n  getF64Encoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR = 43;\n\nexport function getInitializeScaledUiAmountMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_SCALED_UI_AMOUNT_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR = 0;\n\nexport function getInitializeScaledUiAmountMintScaledUiAmountMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_SCALED_UI_AMOUNT_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR\n  );\n}\n\nexport type InitializeScaledUiAmountMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeScaledUiAmountMintInstructionData = {\n  discriminator: number;\n  scaledUiAmountMintDiscriminator: number;\n  /** The authority that can update the multiplier */\n  authority: Option<Address>;\n  /** The initial multiplier for the scaled UI extension */\n  multiplier: number;\n};\n\nexport type InitializeScaledUiAmountMintInstructionDataArgs = {\n  /** The authority that can update the multiplier */\n  authority: OptionOrNullable<Address>;\n  /** The initial multiplier for the scaled UI extension */\n  multiplier: number;\n};\n\nexport function getInitializeScaledUiAmountMintInstructionDataEncoder(): Encoder<InitializeScaledUiAmountMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['scaledUiAmountMintDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      ['multiplier', getF64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR,\n      scaledUiAmountMintDiscriminator:\n        INITIALIZE_SCALED_UI_AMOUNT_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeScaledUiAmountMintInstructionDataDecoder(): Decoder<InitializeScaledUiAmountMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['scaledUiAmountMintDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['multiplier', getF64Decoder()],\n  ]);\n}\n\nexport function getInitializeScaledUiAmountMintInstructionDataCodec(): Codec<\n  InitializeScaledUiAmountMintInstructionDataArgs,\n  InitializeScaledUiAmountMintInstructionData\n> {\n  return combineCodec(\n    getInitializeScaledUiAmountMintInstructionDataEncoder(),\n    getInitializeScaledUiAmountMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeScaledUiAmountMintInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  authority: InitializeScaledUiAmountMintInstructionDataArgs['authority'];\n  multiplier: InitializeScaledUiAmountMintInstructionDataArgs['multiplier'];\n};\n\nexport function getInitializeScaledUiAmountMintInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeScaledUiAmountMintInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeScaledUiAmountMintInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeScaledUiAmountMintInstructionDataEncoder().encode(\n      args as InitializeScaledUiAmountMintInstructionDataArgs\n    ),\n  } as InitializeScaledUiAmountMintInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeScaledUiAmountMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeScaledUiAmountMintInstructionData;\n};\n\nexport function parseInitializeScaledUiAmountMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeScaledUiAmountMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeScaledUiAmountMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TOKEN_GROUP_DISCRIMINATOR = new Uint8Array([\n  121, 113, 108, 39, 54, 51, 0, 4,\n]);\n\nexport function getInitializeTokenGroupDiscriminatorBytes() {\n  return getBytesEncoder().encode(INITIALIZE_TOKEN_GROUP_DISCRIMINATOR);\n}\n\nexport type InitializeTokenGroupInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountGroup extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountMintAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountGroup extends string\n        ? WritableAccount<TAccountGroup>\n        : TAccountGroup,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountMintAuthority extends string\n        ? ReadonlySignerAccount<TAccountMintAuthority> &\n            IAccountSignerMeta<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTokenGroupInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** Update authority for the group */\n  updateAuthority: Option<Address>;\n  /** The maximum number of group members */\n  maxSize: bigint;\n};\n\nexport type InitializeTokenGroupInstructionDataArgs = {\n  /** Update authority for the group */\n  updateAuthority: OptionOrNullable<Address>;\n  /** The maximum number of group members */\n  maxSize: number | bigint;\n};\n\nexport function getInitializeTokenGroupInstructionDataEncoder(): Encoder<InitializeTokenGroupInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      [\n        'updateAuthority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      ['maxSize', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TOKEN_GROUP_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTokenGroupInstructionDataDecoder(): Decoder<InitializeTokenGroupInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    [\n      'updateAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['maxSize', getU64Decoder()],\n  ]);\n}\n\nexport function getInitializeTokenGroupInstructionDataCodec(): Codec<\n  InitializeTokenGroupInstructionDataArgs,\n  InitializeTokenGroupInstructionData\n> {\n  return combineCodec(\n    getInitializeTokenGroupInstructionDataEncoder(),\n    getInitializeTokenGroupInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTokenGroupInput<\n  TAccountGroup extends string = string,\n  TAccountMint extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  group: Address<TAccountGroup>;\n  mint: Address<TAccountMint>;\n  mintAuthority: TransactionSigner<TAccountMintAuthority>;\n  updateAuthority: InitializeTokenGroupInstructionDataArgs['updateAuthority'];\n  maxSize: InitializeTokenGroupInstructionDataArgs['maxSize'];\n};\n\nexport function getInitializeTokenGroupInstruction<\n  TAccountGroup extends string,\n  TAccountMint extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeTokenGroupInput<\n    TAccountGroup,\n    TAccountMint,\n    TAccountMintAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTokenGroupInstruction<\n  TProgramAddress,\n  TAccountGroup,\n  TAccountMint,\n  TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    group: { value: input.group ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.group),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.mintAuthority),\n    ],\n    programAddress,\n    data: getInitializeTokenGroupInstructionDataEncoder().encode(\n      args as InitializeTokenGroupInstructionDataArgs\n    ),\n  } as InitializeTokenGroupInstruction<\n    TProgramAddress,\n    TAccountGroup,\n    TAccountMint,\n    TAccountMintAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeTokenGroupInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    group: TAccountMetas[0];\n    mint: TAccountMetas[1];\n    mintAuthority: TAccountMetas[2];\n  };\n  data: InitializeTokenGroupInstructionData;\n};\n\nexport function parseInitializeTokenGroupInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeTokenGroupInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      group: getNextAccount(),\n      mint: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getInitializeTokenGroupInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR = new Uint8Array([\n  152, 32, 222, 176, 223, 237, 116, 134,\n]);\n\nexport function getInitializeTokenGroupMemberDiscriminatorBytes() {\n  return getBytesEncoder().encode(INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR);\n}\n\nexport type InitializeTokenGroupMemberInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMember extends string | IAccountMeta<string> = string,\n  TAccountMemberMint extends string | IAccountMeta<string> = string,\n  TAccountMemberMintAuthority extends string | IAccountMeta<string> = string,\n  TAccountGroup extends string | IAccountMeta<string> = string,\n  TAccountGroupUpdateAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMember extends string\n        ? WritableAccount<TAccountMember>\n        : TAccountMember,\n      TAccountMemberMint extends string\n        ? ReadonlyAccount<TAccountMemberMint>\n        : TAccountMemberMint,\n      TAccountMemberMintAuthority extends string\n        ? ReadonlySignerAccount<TAccountMemberMintAuthority> &\n            IAccountSignerMeta<TAccountMemberMintAuthority>\n        : TAccountMemberMintAuthority,\n      TAccountGroup extends string\n        ? WritableAccount<TAccountGroup>\n        : TAccountGroup,\n      TAccountGroupUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountGroupUpdateAuthority> &\n            IAccountSignerMeta<TAccountGroupUpdateAuthority>\n        : TAccountGroupUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTokenGroupMemberInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type InitializeTokenGroupMemberInstructionDataArgs = {};\n\nexport function getInitializeTokenGroupMemberInstructionDataEncoder(): Encoder<InitializeTokenGroupMemberInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getBytesEncoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTokenGroupMemberInstructionDataDecoder(): Decoder<InitializeTokenGroupMemberInstructionData> {\n  return getStructDecoder([['discriminator', getBytesDecoder()]]);\n}\n\nexport function getInitializeTokenGroupMemberInstructionDataCodec(): Codec<\n  InitializeTokenGroupMemberInstructionDataArgs,\n  InitializeTokenGroupMemberInstructionData\n> {\n  return combineCodec(\n    getInitializeTokenGroupMemberInstructionDataEncoder(),\n    getInitializeTokenGroupMemberInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTokenGroupMemberInput<\n  TAccountMember extends string = string,\n  TAccountMemberMint extends string = string,\n  TAccountMemberMintAuthority extends string = string,\n  TAccountGroup extends string = string,\n  TAccountGroupUpdateAuthority extends string = string,\n> = {\n  member: Address<TAccountMember>;\n  memberMint: Address<TAccountMemberMint>;\n  memberMintAuthority: TransactionSigner<TAccountMemberMintAuthority>;\n  group: Address<TAccountGroup>;\n  groupUpdateAuthority: TransactionSigner<TAccountGroupUpdateAuthority>;\n};\n\nexport function getInitializeTokenGroupMemberInstruction<\n  TAccountMember extends string,\n  TAccountMemberMint extends string,\n  TAccountMemberMintAuthority extends string,\n  TAccountGroup extends string,\n  TAccountGroupUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeTokenGroupMemberInput<\n    TAccountMember,\n    TAccountMemberMint,\n    TAccountMemberMintAuthority,\n    TAccountGroup,\n    TAccountGroupUpdateAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTokenGroupMemberInstruction<\n  TProgramAddress,\n  TAccountMember,\n  TAccountMemberMint,\n  TAccountMemberMintAuthority,\n  TAccountGroup,\n  TAccountGroupUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    member: { value: input.member ?? null, isWritable: true },\n    memberMint: { value: input.memberMint ?? null, isWritable: false },\n    memberMintAuthority: {\n      value: input.memberMintAuthority ?? null,\n      isWritable: false,\n    },\n    group: { value: input.group ?? null, isWritable: true },\n    groupUpdateAuthority: {\n      value: input.groupUpdateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.member),\n      getAccountMeta(accounts.memberMint),\n      getAccountMeta(accounts.memberMintAuthority),\n      getAccountMeta(accounts.group),\n      getAccountMeta(accounts.groupUpdateAuthority),\n    ],\n    programAddress,\n    data: getInitializeTokenGroupMemberInstructionDataEncoder().encode({}),\n  } as InitializeTokenGroupMemberInstruction<\n    TProgramAddress,\n    TAccountMember,\n    TAccountMemberMint,\n    TAccountMemberMintAuthority,\n    TAccountGroup,\n    TAccountGroupUpdateAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeTokenGroupMemberInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    member: TAccountMetas[0];\n    memberMint: TAccountMetas[1];\n    memberMintAuthority: TAccountMetas[2];\n    group: TAccountMetas[3];\n    groupUpdateAuthority: TAccountMetas[4];\n  };\n  data: InitializeTokenGroupMemberInstructionData;\n};\n\nexport function parseInitializeTokenGroupMemberInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeTokenGroupMemberInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      member: getNextAccount(),\n      memberMint: getNextAccount(),\n      memberMintAuthority: getNextAccount(),\n      group: getNextAccount(),\n      groupUpdateAuthority: getNextAccount(),\n    },\n    data: getInitializeTokenGroupMemberInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([\n  210, 225, 30, 162, 88, 184, 77, 141,\n]);\n\nexport function getInitializeTokenMetadataDiscriminatorBytes() {\n  return getBytesEncoder().encode(INITIALIZE_TOKEN_METADATA_DISCRIMINATOR);\n}\n\nexport type InitializeTokenMetadataInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | IAccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountMintAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMetadata extends string\n        ? WritableAccount<TAccountMetadata>\n        : TAccountMetadata,\n      TAccountUpdateAuthority extends string\n        ? ReadonlyAccount<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountMintAuthority extends string\n        ? ReadonlySignerAccount<TAccountMintAuthority> &\n            IAccountSignerMeta<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTokenMetadataInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** Longer name of the token. */\n  name: string;\n  /** Shortened symbol of the token. */\n  symbol: string;\n  /** URI pointing to more metadata (image, video, etc.). */\n  uri: string;\n};\n\nexport type InitializeTokenMetadataInstructionDataArgs = {\n  /** Longer name of the token. */\n  name: string;\n  /** Shortened symbol of the token. */\n  symbol: string;\n  /** URI pointing to more metadata (image, video, etc.). */\n  uri: string;\n};\n\nexport function getInitializeTokenMetadataInstructionDataEncoder(): Encoder<InitializeTokenMetadataInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n      ['symbol', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n      ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TOKEN_METADATA_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTokenMetadataInstructionDataDecoder(): Decoder<InitializeTokenMetadataInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['symbol', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n  ]);\n}\n\nexport function getInitializeTokenMetadataInstructionDataCodec(): Codec<\n  InitializeTokenMetadataInstructionDataArgs,\n  InitializeTokenMetadataInstructionData\n> {\n  return combineCodec(\n    getInitializeTokenMetadataInstructionDataEncoder(),\n    getInitializeTokenMetadataInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTokenMetadataInput<\n  TAccountMetadata extends string = string,\n  TAccountUpdateAuthority extends string = string,\n  TAccountMint extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  metadata: Address<TAccountMetadata>;\n  updateAuthority: Address<TAccountUpdateAuthority>;\n  mint: Address<TAccountMint>;\n  mintAuthority: TransactionSigner<TAccountMintAuthority>;\n  name: InitializeTokenMetadataInstructionDataArgs['name'];\n  symbol: InitializeTokenMetadataInstructionDataArgs['symbol'];\n  uri: InitializeTokenMetadataInstructionDataArgs['uri'];\n};\n\nexport function getInitializeTokenMetadataInstruction<\n  TAccountMetadata extends string,\n  TAccountUpdateAuthority extends string,\n  TAccountMint extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeTokenMetadataInput<\n    TAccountMetadata,\n    TAccountUpdateAuthority,\n    TAccountMint,\n    TAccountMintAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTokenMetadataInstruction<\n  TProgramAddress,\n  TAccountMetadata,\n  TAccountUpdateAuthority,\n  TAccountMint,\n  TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n    mint: { value: input.mint ?? null, isWritable: false },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.updateAuthority),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.mintAuthority),\n    ],\n    programAddress,\n    data: getInitializeTokenMetadataInstructionDataEncoder().encode(\n      args as InitializeTokenMetadataInstructionDataArgs\n    ),\n  } as InitializeTokenMetadataInstruction<\n    TProgramAddress,\n    TAccountMetadata,\n    TAccountUpdateAuthority,\n    TAccountMint,\n    TAccountMintAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeTokenMetadataInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    metadata: TAccountMetas[0];\n    updateAuthority: TAccountMetas[1];\n    mint: TAccountMetas[2];\n    mintAuthority: TAccountMetas[3];\n  };\n  data: InitializeTokenMetadataInstructionData;\n};\n\nexport function parseInitializeTokenMetadataInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeTokenMetadataInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      metadata: getNextAccount(),\n      updateAuthority: getNextAccount(),\n      mint: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getInitializeTokenMetadataInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR = 26;\n\nexport function getInitializeTransferFeeConfigDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR = 0;\n\nexport function getInitializeTransferFeeConfigTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type InitializeTransferFeeConfigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTransferFeeConfigInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n  /** Pubkey that may update the fees. */\n  transferFeeConfigAuthority: Option<Address>;\n  /** Withdraw instructions must be signed by this key. */\n  withdrawWithheldAuthority: Option<Address>;\n  /** Amount of transfer collected as fees, expressed as basis points of the transfer amount. */\n  transferFeeBasisPoints: number;\n  /** Maximum fee assessed on transfers. */\n  maximumFee: bigint;\n};\n\nexport type InitializeTransferFeeConfigInstructionDataArgs = {\n  /** Pubkey that may update the fees. */\n  transferFeeConfigAuthority: OptionOrNullable<Address>;\n  /** Withdraw instructions must be signed by this key. */\n  withdrawWithheldAuthority: OptionOrNullable<Address>;\n  /** Amount of transfer collected as fees, expressed as basis points of the transfer amount. */\n  transferFeeBasisPoints: number;\n  /** Maximum fee assessed on transfers. */\n  maximumFee: number | bigint;\n};\n\nexport function getInitializeTransferFeeConfigInstructionDataEncoder(): Encoder<InitializeTransferFeeConfigInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n      ['transferFeeConfigAuthority', getOptionEncoder(getAddressEncoder())],\n      ['withdrawWithheldAuthority', getOptionEncoder(getAddressEncoder())],\n      ['transferFeeBasisPoints', getU16Encoder()],\n      ['maximumFee', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR,\n      transferFeeDiscriminator:\n        INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTransferFeeConfigInstructionDataDecoder(): Decoder<InitializeTransferFeeConfigInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n    ['transferFeeConfigAuthority', getOptionDecoder(getAddressDecoder())],\n    ['withdrawWithheldAuthority', getOptionDecoder(getAddressDecoder())],\n    ['transferFeeBasisPoints', getU16Decoder()],\n    ['maximumFee', getU64Decoder()],\n  ]);\n}\n\nexport function getInitializeTransferFeeConfigInstructionDataCodec(): Codec<\n  InitializeTransferFeeConfigInstructionDataArgs,\n  InitializeTransferFeeConfigInstructionData\n> {\n  return combineCodec(\n    getInitializeTransferFeeConfigInstructionDataEncoder(),\n    getInitializeTransferFeeConfigInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTransferFeeConfigInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  transferFeeConfigAuthority: InitializeTransferFeeConfigInstructionDataArgs['transferFeeConfigAuthority'];\n  withdrawWithheldAuthority: InitializeTransferFeeConfigInstructionDataArgs['withdrawWithheldAuthority'];\n  transferFeeBasisPoints: InitializeTransferFeeConfigInstructionDataArgs['transferFeeBasisPoints'];\n  maximumFee: InitializeTransferFeeConfigInstructionDataArgs['maximumFee'];\n};\n\nexport function getInitializeTransferFeeConfigInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeTransferFeeConfigInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTransferFeeConfigInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeTransferFeeConfigInstructionDataEncoder().encode(\n      args as InitializeTransferFeeConfigInstructionDataArgs\n    ),\n  } as InitializeTransferFeeConfigInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeTransferFeeConfigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeTransferFeeConfigInstructionData;\n};\n\nexport function parseInitializeTransferFeeConfigInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeTransferFeeConfigInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeTransferFeeConfigInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR = 36;\n\nexport function getInitializeTransferHookDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR = 0;\n\nexport function getInitializeTransferHookTransferHookDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR\n  );\n}\n\nexport type InitializeTransferHookInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTransferHookInstructionData = {\n  discriminator: number;\n  transferHookDiscriminator: number;\n  /** The public key for the account that can update the program id */\n  authority: Option<Address>;\n  /** The program id that performs logic during transfers */\n  programId: Option<Address>;\n};\n\nexport type InitializeTransferHookInstructionDataArgs = {\n  /** The public key for the account that can update the program id */\n  authority: OptionOrNullable<Address>;\n  /** The program id that performs logic during transfers */\n  programId: OptionOrNullable<Address>;\n};\n\nexport function getInitializeTransferHookInstructionDataEncoder(): Encoder<InitializeTransferHookInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferHookDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      [\n        'programId',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR,\n      transferHookDiscriminator:\n        INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTransferHookInstructionDataDecoder(): Decoder<InitializeTransferHookInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferHookDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'programId',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeTransferHookInstructionDataCodec(): Codec<\n  InitializeTransferHookInstructionDataArgs,\n  InitializeTransferHookInstructionData\n> {\n  return combineCodec(\n    getInitializeTransferHookInstructionDataEncoder(),\n    getInitializeTransferHookInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTransferHookInput<TAccountMint extends string = string> =\n  {\n    /** The mint to initialize. */\n    mint: Address<TAccountMint>;\n    authority: InitializeTransferHookInstructionDataArgs['authority'];\n    programId: InitializeTransferHookInstructionDataArgs['programId'];\n  };\n\nexport function getInitializeTransferHookInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeTransferHookInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTransferHookInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeTransferHookInstructionDataEncoder().encode(\n      args as InitializeTransferHookInstructionDataArgs\n    ),\n  } as InitializeTransferHookInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeTransferHookInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeTransferHookInstructionData;\n};\n\nexport function parseInitializeTransferHookInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeTransferHookInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeTransferHookInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const MINT_TO_DISCRIMINATOR = 7;\n\nexport function getMintToDiscriminatorBytes() {\n  return getU8Encoder().encode(MINT_TO_DISCRIMINATOR);\n}\n\nexport type MintToInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountMintAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMintAuthority extends string\n        ? ReadonlyAccount<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type MintToInstructionData = {\n  discriminator: number;\n  /** The amount of new tokens to mint. */\n  amount: bigint;\n};\n\nexport type MintToInstructionDataArgs = {\n  /** The amount of new tokens to mint. */\n  amount: number | bigint;\n};\n\nexport function getMintToInstructionDataEncoder(): Encoder<MintToInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: MINT_TO_DISCRIMINATOR })\n  );\n}\n\nexport function getMintToInstructionDataDecoder(): Decoder<MintToInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getMintToInstructionDataCodec(): Codec<\n  MintToInstructionDataArgs,\n  MintToInstructionData\n> {\n  return combineCodec(\n    getMintToInstructionDataEncoder(),\n    getMintToInstructionDataDecoder()\n  );\n}\n\nexport type MintToInput<\n  TAccountMint extends string = string,\n  TAccountToken extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  /** The mint account. */\n  mint: Address<TAccountMint>;\n  /** The account to mint tokens to. */\n  token: Address<TAccountToken>;\n  /** The mint's minting authority or its multisignature account. */\n  mintAuthority:\n    | Address<TAccountMintAuthority>\n    | TransactionSigner<TAccountMintAuthority>;\n  amount: MintToInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getMintToInstruction<\n  TAccountMint extends string,\n  TAccountToken extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: MintToInput<TAccountMint, TAccountToken, TAccountMintAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): MintToInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountToken,\n  (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n    ? ReadonlySignerAccount<TAccountMintAuthority> &\n        IAccountSignerMeta<TAccountMintAuthority>\n    : TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    token: { value: input.token ?? null, isWritable: true },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mintAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getMintToInstructionDataEncoder().encode(\n      args as MintToInstructionDataArgs\n    ),\n  } as MintToInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountToken,\n    (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n      ? ReadonlySignerAccount<TAccountMintAuthority> &\n          IAccountSignerMeta<TAccountMintAuthority>\n      : TAccountMintAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedMintToInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint account. */\n    mint: TAccountMetas[0];\n    /** The account to mint tokens to. */\n    token: TAccountMetas[1];\n    /** The mint's minting authority or its multisignature account. */\n    mintAuthority: TAccountMetas[2];\n  };\n  data: MintToInstructionData;\n};\n\nexport function parseMintToInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedMintToInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      token: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getMintToInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const MINT_TO_CHECKED_DISCRIMINATOR = 14;\n\nexport function getMintToCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(MINT_TO_CHECKED_DISCRIMINATOR);\n}\n\nexport type MintToCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountMintAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMintAuthority extends string\n        ? ReadonlyAccount<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type MintToCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of new tokens to mint. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type MintToCheckedInstructionDataArgs = {\n  /** The amount of new tokens to mint. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getMintToCheckedInstructionDataEncoder(): Encoder<MintToCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: MINT_TO_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getMintToCheckedInstructionDataDecoder(): Decoder<MintToCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getMintToCheckedInstructionDataCodec(): Codec<\n  MintToCheckedInstructionDataArgs,\n  MintToCheckedInstructionData\n> {\n  return combineCodec(\n    getMintToCheckedInstructionDataEncoder(),\n    getMintToCheckedInstructionDataDecoder()\n  );\n}\n\nexport type MintToCheckedInput<\n  TAccountMint extends string = string,\n  TAccountToken extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The account to mint tokens to. */\n  token: Address<TAccountToken>;\n  /** The mint's minting authority or its multisignature account. */\n  mintAuthority:\n    | Address<TAccountMintAuthority>\n    | TransactionSigner<TAccountMintAuthority>;\n  amount: MintToCheckedInstructionDataArgs['amount'];\n  decimals: MintToCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getMintToCheckedInstruction<\n  TAccountMint extends string,\n  TAccountToken extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: MintToCheckedInput<TAccountMint, TAccountToken, TAccountMintAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): MintToCheckedInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountToken,\n  (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n    ? ReadonlySignerAccount<TAccountMintAuthority> &\n        IAccountSignerMeta<TAccountMintAuthority>\n    : TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    token: { value: input.token ?? null, isWritable: true },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mintAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getMintToCheckedInstructionDataEncoder().encode(\n      args as MintToCheckedInstructionDataArgs\n    ),\n  } as MintToCheckedInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountToken,\n    (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n      ? ReadonlySignerAccount<TAccountMintAuthority> &\n          IAccountSignerMeta<TAccountMintAuthority>\n      : TAccountMintAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedMintToCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The account to mint tokens to. */\n    token: TAccountMetas[1];\n    /** The mint's minting authority or its multisignature account. */\n    mintAuthority: TAccountMetas[2];\n  };\n  data: MintToCheckedInstructionData;\n};\n\nexport function parseMintToCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedMintToCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      token: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getMintToCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const PAUSE_DISCRIMINATOR = 44;\n\nexport function getPauseDiscriminatorBytes() {\n  return getU8Encoder().encode(PAUSE_DISCRIMINATOR);\n}\n\nexport const PAUSE_PAUSABLE_DISCRIMINATOR = 1;\n\nexport function getPausePausableDiscriminatorBytes() {\n  return getU8Encoder().encode(PAUSE_PAUSABLE_DISCRIMINATOR);\n}\n\nexport type PauseInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type PauseInstructionData = {\n  discriminator: number;\n  pausableDiscriminator: number;\n};\n\nexport type PauseInstructionDataArgs = {};\n\nexport function getPauseInstructionDataEncoder(): Encoder<PauseInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['pausableDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: PAUSE_DISCRIMINATOR,\n      pausableDiscriminator: PAUSE_PAUSABLE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getPauseInstructionDataDecoder(): Decoder<PauseInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['pausableDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getPauseInstructionDataCodec(): Codec<\n  PauseInstructionDataArgs,\n  PauseInstructionData\n> {\n  return combineCodec(\n    getPauseInstructionDataEncoder(),\n    getPauseInstructionDataDecoder()\n  );\n}\n\nexport type PauseInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The pausable authority that can pause the mint. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n};\n\nexport function getPauseInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: PauseInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): PauseInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n    ],\n    programAddress,\n    data: getPauseInstructionDataEncoder().encode({}),\n  } as PauseInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedPauseInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The pausable authority that can pause the mint. */\n    authority: TAccountMetas[1];\n  };\n  data: PauseInstructionData;\n};\n\nexport function parsePauseInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedPauseInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getPauseInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getArrayDecoder,\n  getArrayEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getExtensionTypeDecoder,\n  getExtensionTypeEncoder,\n  type ExtensionType,\n  type ExtensionTypeArgs,\n} from '../types';\n\nexport const REALLOCATE_DISCRIMINATOR = 29;\n\nexport function getReallocateDiscriminatorBytes() {\n  return getU8Encoder().encode(REALLOCATE_DISCRIMINATOR);\n}\n\nexport type ReallocateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | IAccountMeta<string> = string,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ReallocateInstructionData = {\n  discriminator: number;\n  /** New extension types to include in the reallocated account. */\n  newExtensionTypes: Array<ExtensionType>;\n};\n\nexport type ReallocateInstructionDataArgs = {\n  /** New extension types to include in the reallocated account. */\n  newExtensionTypes: Array<ExtensionTypeArgs>;\n};\n\nexport function getReallocateInstructionDataEncoder(): Encoder<ReallocateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      [\n        'newExtensionTypes',\n        getArrayEncoder(getExtensionTypeEncoder(), { size: 'remainder' }),\n      ],\n    ]),\n    (value) => ({ ...value, discriminator: REALLOCATE_DISCRIMINATOR })\n  );\n}\n\nexport function getReallocateInstructionDataDecoder(): Decoder<ReallocateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    [\n      'newExtensionTypes',\n      getArrayDecoder(getExtensionTypeDecoder(), { size: 'remainder' }),\n    ],\n  ]);\n}\n\nexport function getReallocateInstructionDataCodec(): Codec<\n  ReallocateInstructionDataArgs,\n  ReallocateInstructionData\n> {\n  return combineCodec(\n    getReallocateInstructionDataEncoder(),\n    getReallocateInstructionDataDecoder()\n  );\n}\n\nexport type ReallocateInput<\n  TAccountToken extends string = string,\n  TAccountPayer extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The token account to reallocate. */\n  token: Address<TAccountToken>;\n  /** The payer account to fund reallocation. */\n  payer: TransactionSigner<TAccountPayer>;\n  /** System program for reallocation funding. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** The account's owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  newExtensionTypes: ReallocateInstructionDataArgs['newExtensionTypes'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getReallocateInstruction<\n  TAccountToken extends string,\n  TAccountPayer extends string,\n  TAccountSystemProgram extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ReallocateInput<\n    TAccountToken,\n    TAccountPayer,\n    TAccountSystemProgram,\n    TAccountOwner\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ReallocateInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountPayer,\n  TAccountSystemProgram,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    payer: { value: input.payer ?? null, isWritable: true },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getReallocateInstructionDataEncoder().encode(\n      args as ReallocateInstructionDataArgs\n    ),\n  } as ReallocateInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountPayer,\n    TAccountSystemProgram,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedReallocateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token account to reallocate. */\n    token: TAccountMetas[0];\n    /** The payer account to fund reallocation. */\n    payer: TAccountMetas[1];\n    /** System program for reallocation funding. */\n    systemProgram: TAccountMetas[2];\n    /** The account's owner or its multisignature account. */\n    owner: TAccountMetas[3];\n  };\n  data: ReallocateInstructionData;\n};\n\nexport function parseReallocateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedReallocateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      payer: getNextAccount(),\n      systemProgram: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getReallocateInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR = 2;\n\nexport function getRecoverNestedAssociatedTokenDiscriminatorBytes() {\n  return getU8Encoder().encode(RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR);\n}\n\nexport type RecoverNestedAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountNestedAssociatedAccountAddress extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountNestedTokenMintAddress extends string | IAccountMeta<string> = string,\n  TAccountDestinationAssociatedAccountAddress extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountOwnerAssociatedAccountAddress extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountOwnerTokenMintAddress extends string | IAccountMeta<string> = string,\n  TAccountWalletAddress extends string | IAccountMeta<string> = string,\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountNestedAssociatedAccountAddress extends string\n        ? WritableAccount<TAccountNestedAssociatedAccountAddress>\n        : TAccountNestedAssociatedAccountAddress,\n      TAccountNestedTokenMintAddress extends string\n        ? ReadonlyAccount<TAccountNestedTokenMintAddress>\n        : TAccountNestedTokenMintAddress,\n      TAccountDestinationAssociatedAccountAddress extends string\n        ? WritableAccount<TAccountDestinationAssociatedAccountAddress>\n        : TAccountDestinationAssociatedAccountAddress,\n      TAccountOwnerAssociatedAccountAddress extends string\n        ? ReadonlyAccount<TAccountOwnerAssociatedAccountAddress>\n        : TAccountOwnerAssociatedAccountAddress,\n      TAccountOwnerTokenMintAddress extends string\n        ? ReadonlyAccount<TAccountOwnerTokenMintAddress>\n        : TAccountOwnerTokenMintAddress,\n      TAccountWalletAddress extends string\n        ? WritableSignerAccount<TAccountWalletAddress> &\n            IAccountSignerMeta<TAccountWalletAddress>\n        : TAccountWalletAddress,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type RecoverNestedAssociatedTokenInstructionData = {\n  discriminator: number;\n};\n\nexport type RecoverNestedAssociatedTokenInstructionDataArgs = {};\n\nexport function getRecoverNestedAssociatedTokenInstructionDataEncoder(): Encoder<RecoverNestedAssociatedTokenInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getRecoverNestedAssociatedTokenInstructionDataDecoder(): Decoder<RecoverNestedAssociatedTokenInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getRecoverNestedAssociatedTokenInstructionDataCodec(): Codec<\n  RecoverNestedAssociatedTokenInstructionDataArgs,\n  RecoverNestedAssociatedTokenInstructionData\n> {\n  return combineCodec(\n    getRecoverNestedAssociatedTokenInstructionDataEncoder(),\n    getRecoverNestedAssociatedTokenInstructionDataDecoder()\n  );\n}\n\nexport type RecoverNestedAssociatedTokenAsyncInput<\n  TAccountNestedAssociatedAccountAddress extends string = string,\n  TAccountNestedTokenMintAddress extends string = string,\n  TAccountDestinationAssociatedAccountAddress extends string = string,\n  TAccountOwnerAssociatedAccountAddress extends string = string,\n  TAccountOwnerTokenMintAddress extends string = string,\n  TAccountWalletAddress extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n  nestedAssociatedAccountAddress?: Address<TAccountNestedAssociatedAccountAddress>;\n  /** Token mint for the nested associated token account. */\n  nestedTokenMintAddress: Address<TAccountNestedTokenMintAddress>;\n  /** Wallet's associated token account. */\n  destinationAssociatedAccountAddress?: Address<TAccountDestinationAssociatedAccountAddress>;\n  /** Owner associated token account address, must be owned by `walletAddress`. */\n  ownerAssociatedAccountAddress?: Address<TAccountOwnerAssociatedAccountAddress>;\n  /** Token mint for the owner associated token account. */\n  ownerTokenMintAddress: Address<TAccountOwnerTokenMintAddress>;\n  /** Wallet address for the owner associated token account. */\n  walletAddress: TransactionSigner<TAccountWalletAddress>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getRecoverNestedAssociatedTokenInstructionAsync<\n  TAccountNestedAssociatedAccountAddress extends string,\n  TAccountNestedTokenMintAddress extends string,\n  TAccountDestinationAssociatedAccountAddress extends string,\n  TAccountOwnerAssociatedAccountAddress extends string,\n  TAccountOwnerTokenMintAddress extends string,\n  TAccountWalletAddress extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: RecoverNestedAssociatedTokenAsyncInput<\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nestedAssociatedAccountAddress: {\n      value: input.nestedAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    nestedTokenMintAddress: {\n      value: input.nestedTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    destinationAssociatedAccountAddress: {\n      value: input.destinationAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    ownerAssociatedAccountAddress: {\n      value: input.ownerAssociatedAccountAddress ?? null,\n      isWritable: false,\n    },\n    ownerTokenMintAddress: {\n      value: input.ownerTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    walletAddress: { value: input.walletAddress ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n  if (!accounts.ownerAssociatedAccountAddress.value) {\n    accounts.ownerAssociatedAccountAddress.value = await findAssociatedTokenPda(\n      {\n        owner: expectAddress(accounts.walletAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.ownerTokenMintAddress.value),\n      }\n    );\n  }\n  if (!accounts.nestedAssociatedAccountAddress.value) {\n    accounts.nestedAssociatedAccountAddress.value =\n      await findAssociatedTokenPda({\n        owner: expectAddress(accounts.ownerAssociatedAccountAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.nestedTokenMintAddress.value),\n      });\n  }\n  if (!accounts.destinationAssociatedAccountAddress.value) {\n    accounts.destinationAssociatedAccountAddress.value =\n      await findAssociatedTokenPda({\n        owner: expectAddress(accounts.walletAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.nestedTokenMintAddress.value),\n      });\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.nestedAssociatedAccountAddress),\n      getAccountMeta(accounts.nestedTokenMintAddress),\n      getAccountMeta(accounts.destinationAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerTokenMintAddress),\n      getAccountMeta(accounts.walletAddress),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getRecoverNestedAssociatedTokenInstructionDataEncoder().encode({}),\n  } as RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type RecoverNestedAssociatedTokenInput<\n  TAccountNestedAssociatedAccountAddress extends string = string,\n  TAccountNestedTokenMintAddress extends string = string,\n  TAccountDestinationAssociatedAccountAddress extends string = string,\n  TAccountOwnerAssociatedAccountAddress extends string = string,\n  TAccountOwnerTokenMintAddress extends string = string,\n  TAccountWalletAddress extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n  nestedAssociatedAccountAddress: Address<TAccountNestedAssociatedAccountAddress>;\n  /** Token mint for the nested associated token account. */\n  nestedTokenMintAddress: Address<TAccountNestedTokenMintAddress>;\n  /** Wallet's associated token account. */\n  destinationAssociatedAccountAddress: Address<TAccountDestinationAssociatedAccountAddress>;\n  /** Owner associated token account address, must be owned by `walletAddress`. */\n  ownerAssociatedAccountAddress: Address<TAccountOwnerAssociatedAccountAddress>;\n  /** Token mint for the owner associated token account. */\n  ownerTokenMintAddress: Address<TAccountOwnerTokenMintAddress>;\n  /** Wallet address for the owner associated token account. */\n  walletAddress: TransactionSigner<TAccountWalletAddress>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getRecoverNestedAssociatedTokenInstruction<\n  TAccountNestedAssociatedAccountAddress extends string,\n  TAccountNestedTokenMintAddress extends string,\n  TAccountDestinationAssociatedAccountAddress extends string,\n  TAccountOwnerAssociatedAccountAddress extends string,\n  TAccountOwnerTokenMintAddress extends string,\n  TAccountWalletAddress extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: RecoverNestedAssociatedTokenInput<\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): RecoverNestedAssociatedTokenInstruction<\n  TProgramAddress,\n  TAccountNestedAssociatedAccountAddress,\n  TAccountNestedTokenMintAddress,\n  TAccountDestinationAssociatedAccountAddress,\n  TAccountOwnerAssociatedAccountAddress,\n  TAccountOwnerTokenMintAddress,\n  TAccountWalletAddress,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nestedAssociatedAccountAddress: {\n      value: input.nestedAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    nestedTokenMintAddress: {\n      value: input.nestedTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    destinationAssociatedAccountAddress: {\n      value: input.destinationAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    ownerAssociatedAccountAddress: {\n      value: input.ownerAssociatedAccountAddress ?? null,\n      isWritable: false,\n    },\n    ownerTokenMintAddress: {\n      value: input.ownerTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    walletAddress: { value: input.walletAddress ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.nestedAssociatedAccountAddress),\n      getAccountMeta(accounts.nestedTokenMintAddress),\n      getAccountMeta(accounts.destinationAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerTokenMintAddress),\n      getAccountMeta(accounts.walletAddress),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getRecoverNestedAssociatedTokenInstructionDataEncoder().encode({}),\n  } as RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedRecoverNestedAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n    nestedAssociatedAccountAddress: TAccountMetas[0];\n    /** Token mint for the nested associated token account. */\n    nestedTokenMintAddress: TAccountMetas[1];\n    /** Wallet's associated token account. */\n    destinationAssociatedAccountAddress: TAccountMetas[2];\n    /** Owner associated token account address, must be owned by `walletAddress`. */\n    ownerAssociatedAccountAddress: TAccountMetas[3];\n    /** Token mint for the owner associated token account. */\n    ownerTokenMintAddress: TAccountMetas[4];\n    /** Wallet address for the owner associated token account. */\n    walletAddress: TAccountMetas[5];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[6];\n  };\n  data: RecoverNestedAssociatedTokenInstructionData;\n};\n\nexport function parseRecoverNestedAssociatedTokenInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedRecoverNestedAssociatedTokenInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 7) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nestedAssociatedAccountAddress: getNextAccount(),\n      nestedTokenMintAddress: getNextAccount(),\n      destinationAssociatedAccountAddress: getNextAccount(),\n      ownerAssociatedAccountAddress: getNextAccount(),\n      ownerTokenMintAddress: getNextAccount(),\n      walletAddress: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getRecoverNestedAssociatedTokenInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR = new Uint8Array([\n  234, 18, 32, 56, 89, 141, 37, 181,\n]);\n\nexport function getRemoveTokenMetadataKeyDiscriminatorBytes() {\n  return getBytesEncoder().encode(REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR);\n}\n\nexport type RemoveTokenMetadataKeyInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | IAccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMetadata extends string\n        ? WritableAccount<TAccountMetadata>\n        : TAccountMetadata,\n      TAccountUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountUpdateAuthority> &\n            IAccountSignerMeta<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type RemoveTokenMetadataKeyInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /**\n   * If the idempotent flag is set to true, then the instruction will not\n   * error if the key does not exist\n   */\n  idempotent: boolean;\n  /** Key to remove in the additional metadata portion. */\n  key: string;\n};\n\nexport type RemoveTokenMetadataKeyInstructionDataArgs = {\n  /**\n   * If the idempotent flag is set to true, then the instruction will not\n   * error if the key does not exist\n   */\n  idempotent?: boolean;\n  /** Key to remove in the additional metadata portion. */\n  key: string;\n};\n\nexport function getRemoveTokenMetadataKeyInstructionDataEncoder(): Encoder<RemoveTokenMetadataKeyInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      ['idempotent', getBooleanEncoder()],\n      ['key', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR,\n      idempotent: value.idempotent ?? false,\n    })\n  );\n}\n\nexport function getRemoveTokenMetadataKeyInstructionDataDecoder(): Decoder<RemoveTokenMetadataKeyInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    ['idempotent', getBooleanDecoder()],\n    ['key', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n  ]);\n}\n\nexport function getRemoveTokenMetadataKeyInstructionDataCodec(): Codec<\n  RemoveTokenMetadataKeyInstructionDataArgs,\n  RemoveTokenMetadataKeyInstructionData\n> {\n  return combineCodec(\n    getRemoveTokenMetadataKeyInstructionDataEncoder(),\n    getRemoveTokenMetadataKeyInstructionDataDecoder()\n  );\n}\n\nexport type RemoveTokenMetadataKeyInput<\n  TAccountMetadata extends string = string,\n  TAccountUpdateAuthority extends string = string,\n> = {\n  metadata: Address<TAccountMetadata>;\n  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;\n  idempotent?: RemoveTokenMetadataKeyInstructionDataArgs['idempotent'];\n  key: RemoveTokenMetadataKeyInstructionDataArgs['key'];\n};\n\nexport function getRemoveTokenMetadataKeyInstruction<\n  TAccountMetadata extends string,\n  TAccountUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: RemoveTokenMetadataKeyInput<TAccountMetadata, TAccountUpdateAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): RemoveTokenMetadataKeyInstruction<\n  TProgramAddress,\n  TAccountMetadata,\n  TAccountUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.updateAuthority),\n    ],\n    programAddress,\n    data: getRemoveTokenMetadataKeyInstructionDataEncoder().encode(\n      args as RemoveTokenMetadataKeyInstructionDataArgs\n    ),\n  } as RemoveTokenMetadataKeyInstruction<\n    TProgramAddress,\n    TAccountMetadata,\n    TAccountUpdateAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedRemoveTokenMetadataKeyInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    metadata: TAccountMetas[0];\n    updateAuthority: TAccountMetas[1];\n  };\n  data: RemoveTokenMetadataKeyInstructionData;\n};\n\nexport function parseRemoveTokenMetadataKeyInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedRemoveTokenMetadataKeyInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      metadata: getNextAccount(),\n      updateAuthority: getNextAccount(),\n    },\n    data: getRemoveTokenMetadataKeyInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const RESUME_DISCRIMINATOR = 44;\n\nexport function getResumeDiscriminatorBytes() {\n  return getU8Encoder().encode(RESUME_DISCRIMINATOR);\n}\n\nexport const RESUME_PAUSABLE_DISCRIMINATOR = 2;\n\nexport function getResumePausableDiscriminatorBytes() {\n  return getU8Encoder().encode(RESUME_PAUSABLE_DISCRIMINATOR);\n}\n\nexport type ResumeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ResumeInstructionData = {\n  discriminator: number;\n  pausableDiscriminator: number;\n};\n\nexport type ResumeInstructionDataArgs = {};\n\nexport function getResumeInstructionDataEncoder(): Encoder<ResumeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['pausableDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: RESUME_DISCRIMINATOR,\n      pausableDiscriminator: RESUME_PAUSABLE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getResumeInstructionDataDecoder(): Decoder<ResumeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['pausableDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getResumeInstructionDataCodec(): Codec<\n  ResumeInstructionDataArgs,\n  ResumeInstructionData\n> {\n  return combineCodec(\n    getResumeInstructionDataEncoder(),\n    getResumeInstructionDataDecoder()\n  );\n}\n\nexport type ResumeInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The pausable authority that can resume the mint. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n};\n\nexport function getResumeInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ResumeInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): ResumeInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n    ],\n    programAddress,\n    data: getResumeInstructionDataEncoder().encode({}),\n  } as ResumeInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedResumeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The pausable authority that can resume the mint. */\n    authority: TAccountMetas[1];\n  };\n  data: ResumeInstructionData;\n};\n\nexport function parseResumeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedResumeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getResumeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const REVOKE_DISCRIMINATOR = 5;\n\nexport function getRevokeDiscriminatorBytes() {\n  return getU8Encoder().encode(REVOKE_DISCRIMINATOR);\n}\n\nexport type RevokeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type RevokeInstructionData = { discriminator: number };\n\nexport type RevokeInstructionDataArgs = {};\n\nexport function getRevokeInstructionDataEncoder(): Encoder<RevokeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: REVOKE_DISCRIMINATOR })\n  );\n}\n\nexport function getRevokeInstructionDataDecoder(): Decoder<RevokeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getRevokeInstructionDataCodec(): Codec<\n  RevokeInstructionDataArgs,\n  RevokeInstructionData\n> {\n  return combineCodec(\n    getRevokeInstructionDataEncoder(),\n    getRevokeInstructionDataDecoder()\n  );\n}\n\nexport type RevokeInput<\n  TAccountSource extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The source account owner or its multisignature. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getRevokeInstruction<\n  TAccountSource extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: RevokeInput<TAccountSource, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): RevokeInstruction<\n  TProgramAddress,\n  TAccountSource,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getRevokeInstructionDataEncoder().encode({}),\n  } as RevokeInstruction<\n    TProgramAddress,\n    TAccountSource,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedRevokeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The source account owner or its multisignature. */\n    owner: TAccountMetas[1];\n  };\n  data: RevokeInstructionData;\n};\n\nexport function parseRevokeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedRevokeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getRevokeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getAuthorityTypeDecoder,\n  getAuthorityTypeEncoder,\n  type AuthorityType,\n  type AuthorityTypeArgs,\n} from '../types';\n\nexport const SET_AUTHORITY_DISCRIMINATOR = 6;\n\nexport function getSetAuthorityDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_AUTHORITY_DISCRIMINATOR);\n}\n\nexport type SetAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountOwned extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountOwned extends string\n        ? WritableAccount<TAccountOwned>\n        : TAccountOwned,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetAuthorityInstructionData = {\n  discriminator: number;\n  /** The type of authority to update. */\n  authorityType: AuthorityType;\n  /** The new authority */\n  newAuthority: Option<Address>;\n};\n\nexport type SetAuthorityInstructionDataArgs = {\n  /** The type of authority to update. */\n  authorityType: AuthorityTypeArgs;\n  /** The new authority */\n  newAuthority: OptionOrNullable<Address>;\n};\n\nexport function getSetAuthorityInstructionDataEncoder(): Encoder<SetAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['authorityType', getAuthorityTypeEncoder()],\n      ['newAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({ ...value, discriminator: SET_AUTHORITY_DISCRIMINATOR })\n  );\n}\n\nexport function getSetAuthorityInstructionDataDecoder(): Decoder<SetAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['authorityType', getAuthorityTypeDecoder()],\n    ['newAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getSetAuthorityInstructionDataCodec(): Codec<\n  SetAuthorityInstructionDataArgs,\n  SetAuthorityInstructionData\n> {\n  return combineCodec(\n    getSetAuthorityInstructionDataEncoder(),\n    getSetAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type SetAuthorityInput<\n  TAccountOwned extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The mint or account to change the authority of. */\n  owned: Address<TAccountOwned>;\n  /** The current authority or the multisignature account of the mint or account to update. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  authorityType: SetAuthorityInstructionDataArgs['authorityType'];\n  newAuthority: SetAuthorityInstructionDataArgs['newAuthority'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getSetAuthorityInstruction<\n  TAccountOwned extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: SetAuthorityInput<TAccountOwned, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): SetAuthorityInstruction<\n  TProgramAddress,\n  TAccountOwned,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    owned: { value: input.owned ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.owned),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getSetAuthorityInstructionDataEncoder().encode(\n      args as SetAuthorityInstructionDataArgs\n    ),\n  } as SetAuthorityInstruction<\n    TProgramAddress,\n    TAccountOwned,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint or account to change the authority of. */\n    owned: TAccountMetas[0];\n    /** The current authority or the multisignature account of the mint or account to update. */\n    owner: TAccountMetas[1];\n  };\n  data: SetAuthorityInstructionData;\n};\n\nexport function parseSetAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      owned: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getSetAuthorityInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_TRANSFER_FEE_DISCRIMINATOR = 26;\n\nexport function getSetTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_TRANSFER_FEE_DISCRIMINATOR);\n}\n\nexport const SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR = 5;\n\nexport function getSetTransferFeeTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR);\n}\n\nexport type SetTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountTransferFeeConfigAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountTransferFeeConfigAuthority extends string\n        ? ReadonlyAccount<TAccountTransferFeeConfigAuthority>\n        : TAccountTransferFeeConfigAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetTransferFeeInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n  /** Amount of transfer collected as fees, expressed as basis points of the transfer amount. */\n  transferFeeBasisPoints: number;\n  /** Maximum fee assessed on transfers. */\n  maximumFee: bigint;\n};\n\nexport type SetTransferFeeInstructionDataArgs = {\n  /** Amount of transfer collected as fees, expressed as basis points of the transfer amount. */\n  transferFeeBasisPoints: number;\n  /** Maximum fee assessed on transfers. */\n  maximumFee: number | bigint;\n};\n\nexport function getSetTransferFeeInstructionDataEncoder(): Encoder<SetTransferFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n      ['transferFeeBasisPoints', getU16Encoder()],\n      ['maximumFee', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_TRANSFER_FEE_DISCRIMINATOR,\n      transferFeeDiscriminator: SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetTransferFeeInstructionDataDecoder(): Decoder<SetTransferFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n    ['transferFeeBasisPoints', getU16Decoder()],\n    ['maximumFee', getU64Decoder()],\n  ]);\n}\n\nexport function getSetTransferFeeInstructionDataCodec(): Codec<\n  SetTransferFeeInstructionDataArgs,\n  SetTransferFeeInstructionData\n> {\n  return combineCodec(\n    getSetTransferFeeInstructionDataEncoder(),\n    getSetTransferFeeInstructionDataDecoder()\n  );\n}\n\nexport type SetTransferFeeInput<\n  TAccountMint extends string = string,\n  TAccountTransferFeeConfigAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The mint's fee account owner or its multisignature account. */\n  transferFeeConfigAuthority:\n    | Address<TAccountTransferFeeConfigAuthority>\n    | TransactionSigner<TAccountTransferFeeConfigAuthority>;\n  transferFeeBasisPoints: SetTransferFeeInstructionDataArgs['transferFeeBasisPoints'];\n  maximumFee: SetTransferFeeInstructionDataArgs['maximumFee'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getSetTransferFeeInstruction<\n  TAccountMint extends string,\n  TAccountTransferFeeConfigAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: SetTransferFeeInput<TAccountMint, TAccountTransferFeeConfigAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): SetTransferFeeInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['transferFeeConfigAuthority'] extends TransactionSigner<TAccountTransferFeeConfigAuthority>\n    ? ReadonlySignerAccount<TAccountTransferFeeConfigAuthority> &\n        IAccountSignerMeta<TAccountTransferFeeConfigAuthority>\n    : TAccountTransferFeeConfigAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    transferFeeConfigAuthority: {\n      value: input.transferFeeConfigAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.transferFeeConfigAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getSetTransferFeeInstructionDataEncoder().encode(\n      args as SetTransferFeeInstructionDataArgs\n    ),\n  } as SetTransferFeeInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['transferFeeConfigAuthority'] extends TransactionSigner<TAccountTransferFeeConfigAuthority>\n      ? ReadonlySignerAccount<TAccountTransferFeeConfigAuthority> &\n          IAccountSignerMeta<TAccountTransferFeeConfigAuthority>\n      : TAccountTransferFeeConfigAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The mint's fee account owner or its multisignature account. */\n    transferFeeConfigAuthority: TAccountMetas[1];\n  };\n  data: SetTransferFeeInstructionData;\n};\n\nexport function parseSetTransferFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetTransferFeeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      transferFeeConfigAuthority: getNextAccount(),\n    },\n    data: getSetTransferFeeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SYNC_NATIVE_DISCRIMINATOR = 17;\n\nexport function getSyncNativeDiscriminatorBytes() {\n  return getU8Encoder().encode(SYNC_NATIVE_DISCRIMINATOR);\n}\n\nexport type SyncNativeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SyncNativeInstructionData = { discriminator: number };\n\nexport type SyncNativeInstructionDataArgs = {};\n\nexport function getSyncNativeInstructionDataEncoder(): Encoder<SyncNativeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: SYNC_NATIVE_DISCRIMINATOR })\n  );\n}\n\nexport function getSyncNativeInstructionDataDecoder(): Decoder<SyncNativeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getSyncNativeInstructionDataCodec(): Codec<\n  SyncNativeInstructionDataArgs,\n  SyncNativeInstructionData\n> {\n  return combineCodec(\n    getSyncNativeInstructionDataEncoder(),\n    getSyncNativeInstructionDataDecoder()\n  );\n}\n\nexport type SyncNativeInput<TAccountAccount extends string = string> = {\n  /** The native token account to sync with its underlying lamports. */\n  account: Address<TAccountAccount>;\n};\n\nexport function getSyncNativeInstruction<\n  TAccountAccount extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: SyncNativeInput<TAccountAccount>,\n  config?: { programAddress?: TProgramAddress }\n): SyncNativeInstruction<TProgramAddress, TAccountAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.account)],\n    programAddress,\n    data: getSyncNativeInstructionDataEncoder().encode({}),\n  } as SyncNativeInstruction<TProgramAddress, TAccountAccount>;\n\n  return instruction;\n}\n\nexport type ParsedSyncNativeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The native token account to sync with its underlying lamports. */\n    account: TAccountMetas[0];\n  };\n  data: SyncNativeInstructionData;\n};\n\nexport function parseSyncNativeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSyncNativeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n    },\n    data: getSyncNativeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const THAW_ACCOUNT_DISCRIMINATOR = 11;\n\nexport function getThawAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(THAW_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type ThawAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ThawAccountInstructionData = { discriminator: number };\n\nexport type ThawAccountInstructionDataArgs = {};\n\nexport function getThawAccountInstructionDataEncoder(): Encoder<ThawAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: THAW_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getThawAccountInstructionDataDecoder(): Decoder<ThawAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getThawAccountInstructionDataCodec(): Codec<\n  ThawAccountInstructionDataArgs,\n  ThawAccountInstructionData\n> {\n  return combineCodec(\n    getThawAccountInstructionDataEncoder(),\n    getThawAccountInstructionDataDecoder()\n  );\n}\n\nexport type ThawAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to thaw. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The mint freeze authority or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getThawAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ThawAccountInput<TAccountAccount, TAccountMint, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): ThawAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getThawAccountInstructionDataEncoder().encode({}),\n  } as ThawAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & IAccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedThawAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to thaw. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The mint freeze authority or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: ThawAccountInstructionData;\n};\n\nexport function parseThawAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedThawAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getThawAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_DISCRIMINATOR = 3;\n\nexport function getTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_DISCRIMINATOR);\n}\n\nexport type TransferInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountDestination extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to transfer. */\n  amount: bigint;\n};\n\nexport type TransferInstructionDataArgs = {\n  /** The amount of tokens to transfer. */\n  amount: number | bigint;\n};\n\nexport function getTransferInstructionDataEncoder(): Encoder<TransferInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TRANSFER_DISCRIMINATOR })\n  );\n}\n\nexport function getTransferInstructionDataDecoder(): Decoder<TransferInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getTransferInstructionDataCodec(): Codec<\n  TransferInstructionDataArgs,\n  TransferInstructionData\n> {\n  return combineCodec(\n    getTransferInstructionDataEncoder(),\n    getTransferInstructionDataDecoder()\n  );\n}\n\nexport type TransferInput<\n  TAccountSource extends string = string,\n  TAccountDestination extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: TransferInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getTransferInstruction<\n  TAccountSource extends string,\n  TAccountDestination extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: TransferInput<TAccountSource, TAccountDestination, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): TransferInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountDestination,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getTransferInstructionDataEncoder().encode(\n      args as TransferInstructionDataArgs\n    ),\n  } as TransferInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountDestination,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedTransferInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The destination account. */\n    destination: TAccountMetas[1];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: TransferInstructionData;\n};\n\nexport function parseTransferInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedTransferInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getTransferInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_CHECKED_DISCRIMINATOR = 12;\n\nexport function getTransferCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_CHECKED_DISCRIMINATOR);\n}\n\nexport type TransferCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountDestination extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to transfer. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type TransferCheckedInstructionDataArgs = {\n  /** The amount of tokens to transfer. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getTransferCheckedInstructionDataEncoder(): Encoder<TransferCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TRANSFER_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getTransferCheckedInstructionDataDecoder(): Decoder<TransferCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getTransferCheckedInstructionDataCodec(): Codec<\n  TransferCheckedInstructionDataArgs,\n  TransferCheckedInstructionData\n> {\n  return combineCodec(\n    getTransferCheckedInstructionDataEncoder(),\n    getTransferCheckedInstructionDataDecoder()\n  );\n}\n\nexport type TransferCheckedInput<\n  TAccountSource extends string = string,\n  TAccountMint extends string = string,\n  TAccountDestination extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: TransferCheckedInstructionDataArgs['amount'];\n  decimals: TransferCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getTransferCheckedInstruction<\n  TAccountSource extends string,\n  TAccountMint extends string,\n  TAccountDestination extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: TransferCheckedInput<\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): TransferCheckedInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountMint,\n  TAccountDestination,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getTransferCheckedInstructionDataEncoder().encode(\n      args as TransferCheckedInstructionDataArgs\n    ),\n  } as TransferCheckedInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedTransferCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The destination account. */\n    destination: TAccountMetas[2];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[3];\n  };\n  data: TransferCheckedInstructionData;\n};\n\nexport function parseTransferCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedTransferCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getTransferCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR = 26;\n\nexport function getTransferCheckedWithFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR);\n}\n\nexport const TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR = 1;\n\nexport function getTransferCheckedWithFeeTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type TransferCheckedWithFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountDestination extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferCheckedWithFeeInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n  /** The amount of tokens to transfer. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /**\n   * Expected fee assessed on this transfer, calculated off-chain based\n   * on the transfer_fee_basis_points and maximum_fee of the mint. May\n   * be 0 for a mint without a configured transfer fee.\n   */\n  fee: bigint;\n};\n\nexport type TransferCheckedWithFeeInstructionDataArgs = {\n  /** The amount of tokens to transfer. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /**\n   * Expected fee assessed on this transfer, calculated off-chain based\n   * on the transfer_fee_basis_points and maximum_fee of the mint. May\n   * be 0 for a mint without a configured transfer fee.\n   */\n  fee: number | bigint;\n};\n\nexport function getTransferCheckedWithFeeInstructionDataEncoder(): Encoder<TransferCheckedWithFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n      ['fee', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR,\n      transferFeeDiscriminator:\n        TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getTransferCheckedWithFeeInstructionDataDecoder(): Decoder<TransferCheckedWithFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n    ['fee', getU64Decoder()],\n  ]);\n}\n\nexport function getTransferCheckedWithFeeInstructionDataCodec(): Codec<\n  TransferCheckedWithFeeInstructionDataArgs,\n  TransferCheckedWithFeeInstructionData\n> {\n  return combineCodec(\n    getTransferCheckedWithFeeInstructionDataEncoder(),\n    getTransferCheckedWithFeeInstructionDataDecoder()\n  );\n}\n\nexport type TransferCheckedWithFeeInput<\n  TAccountSource extends string = string,\n  TAccountMint extends string = string,\n  TAccountDestination extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source account. May include the `TransferFeeAmount` extension. */\n  source: Address<TAccountSource>;\n  /** The token mint. May include the `TransferFeeConfig` extension. */\n  mint: Address<TAccountMint>;\n  /** The destination account. May include the `TransferFeeAmount` extension. */\n  destination: Address<TAccountDestination>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: TransferCheckedWithFeeInstructionDataArgs['amount'];\n  decimals: TransferCheckedWithFeeInstructionDataArgs['decimals'];\n  fee: TransferCheckedWithFeeInstructionDataArgs['fee'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getTransferCheckedWithFeeInstruction<\n  TAccountSource extends string,\n  TAccountMint extends string,\n  TAccountDestination extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: TransferCheckedWithFeeInput<\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): TransferCheckedWithFeeInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountMint,\n  TAccountDestination,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getTransferCheckedWithFeeInstructionDataEncoder().encode(\n      args as TransferCheckedWithFeeInstructionDataArgs\n    ),\n  } as TransferCheckedWithFeeInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedTransferCheckedWithFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. May include the `TransferFeeAmount` extension. */\n    source: TAccountMetas[0];\n    /** The token mint. May include the `TransferFeeConfig` extension. */\n    mint: TAccountMetas[1];\n    /** The destination account. May include the `TransferFeeAmount` extension. */\n    destination: TAccountMetas[2];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[3];\n  };\n  data: TransferCheckedWithFeeInstructionData;\n};\n\nexport function parseTransferCheckedWithFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedTransferCheckedWithFeeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getTransferCheckedWithFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR = 24;\n\nexport function getUiAmountToAmountDiscriminatorBytes() {\n  return getU8Encoder().encode(UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR);\n}\n\nexport type UiAmountToAmountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UiAmountToAmountInstructionData = {\n  discriminator: number;\n  /** The ui_amount of tokens to reformat. */\n  uiAmount: string;\n};\n\nexport type UiAmountToAmountInstructionDataArgs = {\n  /** The ui_amount of tokens to reformat. */\n  uiAmount: string;\n};\n\nexport function getUiAmountToAmountInstructionDataEncoder(): Encoder<UiAmountToAmountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['uiAmount', getUtf8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getUiAmountToAmountInstructionDataDecoder(): Decoder<UiAmountToAmountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['uiAmount', getUtf8Decoder()],\n  ]);\n}\n\nexport function getUiAmountToAmountInstructionDataCodec(): Codec<\n  UiAmountToAmountInstructionDataArgs,\n  UiAmountToAmountInstructionData\n> {\n  return combineCodec(\n    getUiAmountToAmountInstructionDataEncoder(),\n    getUiAmountToAmountInstructionDataDecoder()\n  );\n}\n\nexport type UiAmountToAmountInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n  uiAmount: UiAmountToAmountInstructionDataArgs['uiAmount'];\n};\n\nexport function getUiAmountToAmountInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UiAmountToAmountInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): UiAmountToAmountInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getUiAmountToAmountInstructionDataEncoder().encode(\n      args as UiAmountToAmountInstructionDataArgs\n    ),\n  } as UiAmountToAmountInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedUiAmountToAmountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: UiAmountToAmountInstructionData;\n};\n\nexport function parseUiAmountToAmountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUiAmountToAmountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getUiAmountToAmountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR = 27;\n\nexport function getUpdateConfidentialTransferMintDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR);\n}\n\nexport const UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 1;\n\nexport function getUpdateConfidentialTransferMintConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type UpdateConfidentialTransferMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlySignerAccount<TAccountAuthority> &\n            IAccountSignerMeta<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateConfidentialTransferMintInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /**\n   * Determines if newly configured accounts must be approved by the\n   * `authority` before they may be used by the user.\n   */\n  autoApproveNewAccounts: boolean;\n  /** New authority to decode any transfer amount in a confidential transfer. */\n  auditorElgamalPubkey: Option<Address>;\n};\n\nexport type UpdateConfidentialTransferMintInstructionDataArgs = {\n  /**\n   * Determines if newly configured accounts must be approved by the\n   * `authority` before they may be used by the user.\n   */\n  autoApproveNewAccounts: boolean;\n  /** New authority to decode any transfer amount in a confidential transfer. */\n  auditorElgamalPubkey: OptionOrNullable<Address>;\n};\n\nexport function getUpdateConfidentialTransferMintInstructionDataEncoder(): Encoder<UpdateConfidentialTransferMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['autoApproveNewAccounts', getBooleanEncoder()],\n      [\n        'auditorElgamalPubkey',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateConfidentialTransferMintInstructionDataDecoder(): Decoder<UpdateConfidentialTransferMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['autoApproveNewAccounts', getBooleanDecoder()],\n    [\n      'auditorElgamalPubkey',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateConfidentialTransferMintInstructionDataCodec(): Codec<\n  UpdateConfidentialTransferMintInstructionDataArgs,\n  UpdateConfidentialTransferMintInstructionData\n> {\n  return combineCodec(\n    getUpdateConfidentialTransferMintInstructionDataEncoder(),\n    getUpdateConfidentialTransferMintInstructionDataDecoder()\n  );\n}\n\nexport type UpdateConfidentialTransferMintInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /** Confidential transfer mint authority. */\n  authority: TransactionSigner<TAccountAuthority>;\n  autoApproveNewAccounts: UpdateConfidentialTransferMintInstructionDataArgs['autoApproveNewAccounts'];\n  auditorElgamalPubkey: UpdateConfidentialTransferMintInstructionDataArgs['auditorElgamalPubkey'];\n};\n\nexport function getUpdateConfidentialTransferMintInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateConfidentialTransferMintInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateConfidentialTransferMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n    ],\n    programAddress,\n    data: getUpdateConfidentialTransferMintInstructionDataEncoder().encode(\n      args as UpdateConfidentialTransferMintInstructionDataArgs\n    ),\n  } as UpdateConfidentialTransferMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateConfidentialTransferMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token mint. */\n    mint: TAccountMetas[0];\n    /** Confidential transfer mint authority. */\n    authority: TAccountMetas[1];\n  };\n  data: UpdateConfidentialTransferMintInstructionData;\n};\n\nexport function parseUpdateConfidentialTransferMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateConfidentialTransferMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getUpdateConfidentialTransferMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getAccountStateDecoder,\n  getAccountStateEncoder,\n  type AccountState,\n  type AccountStateArgs,\n} from '../types';\n\nexport const UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 28;\n\nexport function getUpdateDefaultAccountStateDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR);\n}\n\nexport const UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 1;\n\nexport function getUpdateDefaultAccountStateDefaultAccountStateDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR\n  );\n}\n\nexport type UpdateDefaultAccountStateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountFreezeAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountFreezeAuthority extends string\n        ? ReadonlyAccount<TAccountFreezeAuthority>\n        : TAccountFreezeAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateDefaultAccountStateInstructionData = {\n  discriminator: number;\n  defaultAccountStateDiscriminator: number;\n  /** The state each new token account should start with. */\n  state: AccountState;\n};\n\nexport type UpdateDefaultAccountStateInstructionDataArgs = {\n  /** The state each new token account should start with. */\n  state: AccountStateArgs;\n};\n\nexport function getUpdateDefaultAccountStateInstructionDataEncoder(): Encoder<UpdateDefaultAccountStateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['defaultAccountStateDiscriminator', getU8Encoder()],\n      ['state', getAccountStateEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR,\n      defaultAccountStateDiscriminator:\n        UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateDefaultAccountStateInstructionDataDecoder(): Decoder<UpdateDefaultAccountStateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['defaultAccountStateDiscriminator', getU8Decoder()],\n    ['state', getAccountStateDecoder()],\n  ]);\n}\n\nexport function getUpdateDefaultAccountStateInstructionDataCodec(): Codec<\n  UpdateDefaultAccountStateInstructionDataArgs,\n  UpdateDefaultAccountStateInstructionData\n> {\n  return combineCodec(\n    getUpdateDefaultAccountStateInstructionDataEncoder(),\n    getUpdateDefaultAccountStateInstructionDataDecoder()\n  );\n}\n\nexport type UpdateDefaultAccountStateInput<\n  TAccountMint extends string = string,\n  TAccountFreezeAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The mint freeze authority or its multisignature account. */\n  freezeAuthority:\n    | Address<TAccountFreezeAuthority>\n    | TransactionSigner<TAccountFreezeAuthority>;\n  state: UpdateDefaultAccountStateInstructionDataArgs['state'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateDefaultAccountStateInstruction<\n  TAccountMint extends string,\n  TAccountFreezeAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateDefaultAccountStateInput<TAccountMint, TAccountFreezeAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateDefaultAccountStateInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['freezeAuthority'] extends TransactionSigner<TAccountFreezeAuthority>\n    ? ReadonlySignerAccount<TAccountFreezeAuthority> &\n        IAccountSignerMeta<TAccountFreezeAuthority>\n    : TAccountFreezeAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    freezeAuthority: {\n      value: input.freezeAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.freezeAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getUpdateDefaultAccountStateInstructionDataEncoder().encode(\n      args as UpdateDefaultAccountStateInstructionDataArgs\n    ),\n  } as UpdateDefaultAccountStateInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['freezeAuthority'] extends TransactionSigner<TAccountFreezeAuthority>\n      ? ReadonlySignerAccount<TAccountFreezeAuthority> &\n          IAccountSignerMeta<TAccountFreezeAuthority>\n      : TAccountFreezeAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateDefaultAccountStateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The mint freeze authority or its multisignature account. */\n    freezeAuthority: TAccountMetas[1];\n  };\n  data: UpdateDefaultAccountStateInstructionData;\n};\n\nexport function parseUpdateDefaultAccountStateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateDefaultAccountStateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      freezeAuthority: getNextAccount(),\n    },\n    data: getUpdateDefaultAccountStateInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR = 41;\n\nexport function getUpdateGroupMemberPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR);\n}\n\nexport const UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR = 1;\n\nexport function getUpdateGroupMemberPointerGroupMemberPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type UpdateGroupMemberPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountGroupMemberPointerAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountGroupMemberPointerAuthority extends string\n        ? ReadonlyAccount<TAccountGroupMemberPointerAuthority>\n        : TAccountGroupMemberPointerAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateGroupMemberPointerInstructionData = {\n  discriminator: number;\n  groupMemberPointerDiscriminator: number;\n  /** The new account address that holds the member. */\n  memberAddress: Option<Address>;\n};\n\nexport type UpdateGroupMemberPointerInstructionDataArgs = {\n  /** The new account address that holds the member. */\n  memberAddress: OptionOrNullable<Address>;\n};\n\nexport function getUpdateGroupMemberPointerInstructionDataEncoder(): Encoder<UpdateGroupMemberPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['groupMemberPointerDiscriminator', getU8Encoder()],\n      [\n        'memberAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR,\n      groupMemberPointerDiscriminator:\n        UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateGroupMemberPointerInstructionDataDecoder(): Decoder<UpdateGroupMemberPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['groupMemberPointerDiscriminator', getU8Decoder()],\n    [\n      'memberAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateGroupMemberPointerInstructionDataCodec(): Codec<\n  UpdateGroupMemberPointerInstructionDataArgs,\n  UpdateGroupMemberPointerInstructionData\n> {\n  return combineCodec(\n    getUpdateGroupMemberPointerInstructionDataEncoder(),\n    getUpdateGroupMemberPointerInstructionDataDecoder()\n  );\n}\n\nexport type UpdateGroupMemberPointerInput<\n  TAccountMint extends string = string,\n  TAccountGroupMemberPointerAuthority extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  /** The group member pointer authority or its multisignature account. */\n  groupMemberPointerAuthority:\n    | Address<TAccountGroupMemberPointerAuthority>\n    | TransactionSigner<TAccountGroupMemberPointerAuthority>;\n  memberAddress: UpdateGroupMemberPointerInstructionDataArgs['memberAddress'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateGroupMemberPointerInstruction<\n  TAccountMint extends string,\n  TAccountGroupMemberPointerAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateGroupMemberPointerInput<\n    TAccountMint,\n    TAccountGroupMemberPointerAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateGroupMemberPointerInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['groupMemberPointerAuthority'] extends TransactionSigner<TAccountGroupMemberPointerAuthority>\n    ? ReadonlySignerAccount<TAccountGroupMemberPointerAuthority> &\n        IAccountSignerMeta<TAccountGroupMemberPointerAuthority>\n    : TAccountGroupMemberPointerAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    groupMemberPointerAuthority: {\n      value: input.groupMemberPointerAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.groupMemberPointerAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getUpdateGroupMemberPointerInstructionDataEncoder().encode(\n      args as UpdateGroupMemberPointerInstructionDataArgs\n    ),\n  } as UpdateGroupMemberPointerInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['groupMemberPointerAuthority'] extends TransactionSigner<TAccountGroupMemberPointerAuthority>\n      ? ReadonlySignerAccount<TAccountGroupMemberPointerAuthority> &\n          IAccountSignerMeta<TAccountGroupMemberPointerAuthority>\n      : TAccountGroupMemberPointerAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateGroupMemberPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n    /** The group member pointer authority or its multisignature account. */\n    groupMemberPointerAuthority: TAccountMetas[1];\n  };\n  data: UpdateGroupMemberPointerInstructionData;\n};\n\nexport function parseUpdateGroupMemberPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateGroupMemberPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      groupMemberPointerAuthority: getNextAccount(),\n    },\n    data: getUpdateGroupMemberPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_GROUP_POINTER_DISCRIMINATOR = 40;\n\nexport function getUpdateGroupPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_GROUP_POINTER_DISCRIMINATOR);\n}\n\nexport const UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR = 1;\n\nexport function getUpdateGroupPointerGroupPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type UpdateGroupPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountGroupPointerAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountGroupPointerAuthority extends string\n        ? ReadonlyAccount<TAccountGroupPointerAuthority>\n        : TAccountGroupPointerAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateGroupPointerInstructionData = {\n  discriminator: number;\n  groupPointerDiscriminator: number;\n  /** The new account address that holds the group configurations. */\n  groupAddress: Option<Address>;\n};\n\nexport type UpdateGroupPointerInstructionDataArgs = {\n  /** The new account address that holds the group configurations. */\n  groupAddress: OptionOrNullable<Address>;\n};\n\nexport function getUpdateGroupPointerInstructionDataEncoder(): Encoder<UpdateGroupPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['groupPointerDiscriminator', getU8Encoder()],\n      [\n        'groupAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_GROUP_POINTER_DISCRIMINATOR,\n      groupPointerDiscriminator:\n        UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateGroupPointerInstructionDataDecoder(): Decoder<UpdateGroupPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['groupPointerDiscriminator', getU8Decoder()],\n    [\n      'groupAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateGroupPointerInstructionDataCodec(): Codec<\n  UpdateGroupPointerInstructionDataArgs,\n  UpdateGroupPointerInstructionData\n> {\n  return combineCodec(\n    getUpdateGroupPointerInstructionDataEncoder(),\n    getUpdateGroupPointerInstructionDataDecoder()\n  );\n}\n\nexport type UpdateGroupPointerInput<\n  TAccountMint extends string = string,\n  TAccountGroupPointerAuthority extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  /** The group pointer authority or its multisignature account. */\n  groupPointerAuthority:\n    | Address<TAccountGroupPointerAuthority>\n    | TransactionSigner<TAccountGroupPointerAuthority>;\n  groupAddress: UpdateGroupPointerInstructionDataArgs['groupAddress'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateGroupPointerInstruction<\n  TAccountMint extends string,\n  TAccountGroupPointerAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateGroupPointerInput<TAccountMint, TAccountGroupPointerAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateGroupPointerInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['groupPointerAuthority'] extends TransactionSigner<TAccountGroupPointerAuthority>\n    ? ReadonlySignerAccount<TAccountGroupPointerAuthority> &\n        IAccountSignerMeta<TAccountGroupPointerAuthority>\n    : TAccountGroupPointerAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    groupPointerAuthority: {\n      value: input.groupPointerAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.groupPointerAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getUpdateGroupPointerInstructionDataEncoder().encode(\n      args as UpdateGroupPointerInstructionDataArgs\n    ),\n  } as UpdateGroupPointerInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['groupPointerAuthority'] extends TransactionSigner<TAccountGroupPointerAuthority>\n      ? ReadonlySignerAccount<TAccountGroupPointerAuthority> &\n          IAccountSignerMeta<TAccountGroupPointerAuthority>\n      : TAccountGroupPointerAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateGroupPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n    /** The group pointer authority or its multisignature account. */\n    groupPointerAuthority: TAccountMetas[1];\n  };\n  data: UpdateGroupPointerInstructionData;\n};\n\nexport function parseUpdateGroupPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateGroupPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      groupPointerAuthority: getNextAccount(),\n    },\n    data: getUpdateGroupPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_METADATA_POINTER_DISCRIMINATOR = 39;\n\nexport function getUpdateMetadataPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_METADATA_POINTER_DISCRIMINATOR);\n}\n\nexport const UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR = 1;\n\nexport function getUpdateMetadataPointerMetadataPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type UpdateMetadataPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountMetadataPointerAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountMetadataPointerAuthority extends string\n        ? ReadonlyAccount<TAccountMetadataPointerAuthority>\n        : TAccountMetadataPointerAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateMetadataPointerInstructionData = {\n  discriminator: number;\n  metadataPointerDiscriminator: number;\n  /** The new account address that holds the metadata. */\n  metadataAddress: Option<Address>;\n};\n\nexport type UpdateMetadataPointerInstructionDataArgs = {\n  /** The new account address that holds the metadata. */\n  metadataAddress: OptionOrNullable<Address>;\n};\n\nexport function getUpdateMetadataPointerInstructionDataEncoder(): Encoder<UpdateMetadataPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['metadataPointerDiscriminator', getU8Encoder()],\n      [\n        'metadataAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_METADATA_POINTER_DISCRIMINATOR,\n      metadataPointerDiscriminator:\n        UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateMetadataPointerInstructionDataDecoder(): Decoder<UpdateMetadataPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['metadataPointerDiscriminator', getU8Decoder()],\n    [\n      'metadataAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateMetadataPointerInstructionDataCodec(): Codec<\n  UpdateMetadataPointerInstructionDataArgs,\n  UpdateMetadataPointerInstructionData\n> {\n  return combineCodec(\n    getUpdateMetadataPointerInstructionDataEncoder(),\n    getUpdateMetadataPointerInstructionDataDecoder()\n  );\n}\n\nexport type UpdateMetadataPointerInput<\n  TAccountMint extends string = string,\n  TAccountMetadataPointerAuthority extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  /** The metadata pointer authority or its multisignature account. */\n  metadataPointerAuthority:\n    | Address<TAccountMetadataPointerAuthority>\n    | TransactionSigner<TAccountMetadataPointerAuthority>;\n  metadataAddress: UpdateMetadataPointerInstructionDataArgs['metadataAddress'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateMetadataPointerInstruction<\n  TAccountMint extends string,\n  TAccountMetadataPointerAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateMetadataPointerInput<\n    TAccountMint,\n    TAccountMetadataPointerAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateMetadataPointerInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['metadataPointerAuthority'] extends TransactionSigner<TAccountMetadataPointerAuthority>\n    ? ReadonlySignerAccount<TAccountMetadataPointerAuthority> &\n        IAccountSignerMeta<TAccountMetadataPointerAuthority>\n    : TAccountMetadataPointerAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    metadataPointerAuthority: {\n      value: input.metadataPointerAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.metadataPointerAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getUpdateMetadataPointerInstructionDataEncoder().encode(\n      args as UpdateMetadataPointerInstructionDataArgs\n    ),\n  } as UpdateMetadataPointerInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['metadataPointerAuthority'] extends TransactionSigner<TAccountMetadataPointerAuthority>\n      ? ReadonlySignerAccount<TAccountMetadataPointerAuthority> &\n          IAccountSignerMeta<TAccountMetadataPointerAuthority>\n      : TAccountMetadataPointerAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateMetadataPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n    /** The metadata pointer authority or its multisignature account. */\n    metadataPointerAuthority: TAccountMetas[1];\n  };\n  data: UpdateMetadataPointerInstructionData;\n};\n\nexport function parseUpdateMetadataPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateMetadataPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      metadataPointerAuthority: getNextAccount(),\n    },\n    data: getUpdateMetadataPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getF64Decoder,\n  getF64Encoder,\n  getI64Decoder,\n  getI64Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_MULTIPLIER_SCALED_UI_MINT_DISCRIMINATOR = 43;\n\nexport function getUpdateMultiplierScaledUiMintDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_MULTIPLIER_SCALED_UI_MINT_DISCRIMINATOR);\n}\n\nexport const UPDATE_MULTIPLIER_SCALED_UI_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR = 1;\n\nexport function getUpdateMultiplierScaledUiMintScaledUiAmountMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_MULTIPLIER_SCALED_UI_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR\n  );\n}\n\nexport type UpdateMultiplierScaledUiMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? WritableAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateMultiplierScaledUiMintInstructionData = {\n  discriminator: number;\n  scaledUiAmountMintDiscriminator: number;\n  /** The new multiplier for the scaled UI extension */\n  multiplier: number;\n  /** The timestamp at which the new multiplier will take effect */\n  effectiveTimestamp: bigint;\n};\n\nexport type UpdateMultiplierScaledUiMintInstructionDataArgs = {\n  /** The new multiplier for the scaled UI extension */\n  multiplier: number;\n  /** The timestamp at which the new multiplier will take effect */\n  effectiveTimestamp: number | bigint;\n};\n\nexport function getUpdateMultiplierScaledUiMintInstructionDataEncoder(): Encoder<UpdateMultiplierScaledUiMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['scaledUiAmountMintDiscriminator', getU8Encoder()],\n      ['multiplier', getF64Encoder()],\n      ['effectiveTimestamp', getI64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_MULTIPLIER_SCALED_UI_MINT_DISCRIMINATOR,\n      scaledUiAmountMintDiscriminator:\n        UPDATE_MULTIPLIER_SCALED_UI_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateMultiplierScaledUiMintInstructionDataDecoder(): Decoder<UpdateMultiplierScaledUiMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['scaledUiAmountMintDiscriminator', getU8Decoder()],\n    ['multiplier', getF64Decoder()],\n    ['effectiveTimestamp', getI64Decoder()],\n  ]);\n}\n\nexport function getUpdateMultiplierScaledUiMintInstructionDataCodec(): Codec<\n  UpdateMultiplierScaledUiMintInstructionDataArgs,\n  UpdateMultiplierScaledUiMintInstructionData\n> {\n  return combineCodec(\n    getUpdateMultiplierScaledUiMintInstructionDataEncoder(),\n    getUpdateMultiplierScaledUiMintInstructionDataDecoder()\n  );\n}\n\nexport type UpdateMultiplierScaledUiMintInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The multiplier authority. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiplier: UpdateMultiplierScaledUiMintInstructionDataArgs['multiplier'];\n  effectiveTimestamp: UpdateMultiplierScaledUiMintInstructionDataArgs['effectiveTimestamp'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateMultiplierScaledUiMintInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateMultiplierScaledUiMintInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateMultiplierScaledUiMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? WritableSignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getUpdateMultiplierScaledUiMintInstructionDataEncoder().encode(\n      args as UpdateMultiplierScaledUiMintInstructionDataArgs\n    ),\n  } as UpdateMultiplierScaledUiMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? WritableSignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateMultiplierScaledUiMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The multiplier authority. */\n    authority: TAccountMetas[1];\n  };\n  data: UpdateMultiplierScaledUiMintInstructionData;\n};\n\nexport function parseUpdateMultiplierScaledUiMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateMultiplierScaledUiMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getUpdateMultiplierScaledUiMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI16Decoder,\n  getI16Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR = 33;\n\nexport function getUpdateRateInterestBearingMintDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR);\n}\n\nexport const UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR = 1;\n\nexport function getUpdateRateInterestBearingMintInterestBearingMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR\n  );\n}\n\nexport type UpdateRateInterestBearingMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountRateAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountRateAuthority extends string\n        ? WritableAccount<TAccountRateAuthority>\n        : TAccountRateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateRateInterestBearingMintInstructionData = {\n  discriminator: number;\n  interestBearingMintDiscriminator: number;\n  /** The interest rate to update. */\n  rate: number;\n};\n\nexport type UpdateRateInterestBearingMintInstructionDataArgs = {\n  /** The interest rate to update. */\n  rate: number;\n};\n\nexport function getUpdateRateInterestBearingMintInstructionDataEncoder(): Encoder<UpdateRateInterestBearingMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['interestBearingMintDiscriminator', getU8Encoder()],\n      ['rate', getI16Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR,\n      interestBearingMintDiscriminator:\n        UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateRateInterestBearingMintInstructionDataDecoder(): Decoder<UpdateRateInterestBearingMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['interestBearingMintDiscriminator', getU8Decoder()],\n    ['rate', getI16Decoder()],\n  ]);\n}\n\nexport function getUpdateRateInterestBearingMintInstructionDataCodec(): Codec<\n  UpdateRateInterestBearingMintInstructionDataArgs,\n  UpdateRateInterestBearingMintInstructionData\n> {\n  return combineCodec(\n    getUpdateRateInterestBearingMintInstructionDataEncoder(),\n    getUpdateRateInterestBearingMintInstructionDataDecoder()\n  );\n}\n\nexport type UpdateRateInterestBearingMintInput<\n  TAccountMint extends string = string,\n  TAccountRateAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The mint rate authority. */\n  rateAuthority:\n    | Address<TAccountRateAuthority>\n    | TransactionSigner<TAccountRateAuthority>;\n  rate: UpdateRateInterestBearingMintInstructionDataArgs['rate'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateRateInterestBearingMintInstruction<\n  TAccountMint extends string,\n  TAccountRateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateRateInterestBearingMintInput<\n    TAccountMint,\n    TAccountRateAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateRateInterestBearingMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['rateAuthority'] extends TransactionSigner<TAccountRateAuthority>\n    ? WritableSignerAccount<TAccountRateAuthority> &\n        IAccountSignerMeta<TAccountRateAuthority>\n    : TAccountRateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    rateAuthority: { value: input.rateAuthority ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.rateAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getUpdateRateInterestBearingMintInstructionDataEncoder().encode(\n      args as UpdateRateInterestBearingMintInstructionDataArgs\n    ),\n  } as UpdateRateInterestBearingMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['rateAuthority'] extends TransactionSigner<TAccountRateAuthority>\n      ? WritableSignerAccount<TAccountRateAuthority> &\n          IAccountSignerMeta<TAccountRateAuthority>\n      : TAccountRateAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateRateInterestBearingMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The mint rate authority. */\n    rateAuthority: TAccountMetas[1];\n  };\n  data: UpdateRateInterestBearingMintInstructionData;\n};\n\nexport function parseUpdateRateInterestBearingMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateRateInterestBearingMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      rateAuthority: getNextAccount(),\n    },\n    data: getUpdateRateInterestBearingMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR = new Uint8Array([\n  108, 37, 171, 143, 248, 30, 18, 110,\n]);\n\nexport function getUpdateTokenGroupMaxSizeDiscriminatorBytes() {\n  return getBytesEncoder().encode(UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR);\n}\n\nexport type UpdateTokenGroupMaxSizeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountGroup extends string | IAccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountGroup extends string\n        ? WritableAccount<TAccountGroup>\n        : TAccountGroup,\n      TAccountUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountUpdateAuthority> &\n            IAccountSignerMeta<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateTokenGroupMaxSizeInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** New max size for the group */\n  maxSize: bigint;\n};\n\nexport type UpdateTokenGroupMaxSizeInstructionDataArgs = {\n  /** New max size for the group */\n  maxSize: number | bigint;\n};\n\nexport function getUpdateTokenGroupMaxSizeInstructionDataEncoder(): Encoder<UpdateTokenGroupMaxSizeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      ['maxSize', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateTokenGroupMaxSizeInstructionDataDecoder(): Decoder<UpdateTokenGroupMaxSizeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    ['maxSize', getU64Decoder()],\n  ]);\n}\n\nexport function getUpdateTokenGroupMaxSizeInstructionDataCodec(): Codec<\n  UpdateTokenGroupMaxSizeInstructionDataArgs,\n  UpdateTokenGroupMaxSizeInstructionData\n> {\n  return combineCodec(\n    getUpdateTokenGroupMaxSizeInstructionDataEncoder(),\n    getUpdateTokenGroupMaxSizeInstructionDataDecoder()\n  );\n}\n\nexport type UpdateTokenGroupMaxSizeInput<\n  TAccountGroup extends string = string,\n  TAccountUpdateAuthority extends string = string,\n> = {\n  group: Address<TAccountGroup>;\n  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;\n  maxSize: UpdateTokenGroupMaxSizeInstructionDataArgs['maxSize'];\n};\n\nexport function getUpdateTokenGroupMaxSizeInstruction<\n  TAccountGroup extends string,\n  TAccountUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateTokenGroupMaxSizeInput<TAccountGroup, TAccountUpdateAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateTokenGroupMaxSizeInstruction<\n  TProgramAddress,\n  TAccountGroup,\n  TAccountUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    group: { value: input.group ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.group),\n      getAccountMeta(accounts.updateAuthority),\n    ],\n    programAddress,\n    data: getUpdateTokenGroupMaxSizeInstructionDataEncoder().encode(\n      args as UpdateTokenGroupMaxSizeInstructionDataArgs\n    ),\n  } as UpdateTokenGroupMaxSizeInstruction<\n    TProgramAddress,\n    TAccountGroup,\n    TAccountUpdateAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateTokenGroupMaxSizeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    group: TAccountMetas[0];\n    updateAuthority: TAccountMetas[1];\n  };\n  data: UpdateTokenGroupMaxSizeInstructionData;\n};\n\nexport function parseUpdateTokenGroupMaxSizeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateTokenGroupMaxSizeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      group: getNextAccount(),\n      updateAuthority: getNextAccount(),\n    },\n    data: getUpdateTokenGroupMaxSizeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR = new Uint8Array(\n  [161, 105, 88, 1, 237, 221, 216, 203]\n);\n\nexport function getUpdateTokenGroupUpdateAuthorityDiscriminatorBytes() {\n  return getBytesEncoder().encode(\n    UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR\n  );\n}\n\nexport type UpdateTokenGroupUpdateAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountGroup extends string | IAccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountGroup extends string\n        ? WritableAccount<TAccountGroup>\n        : TAccountGroup,\n      TAccountUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountUpdateAuthority> &\n            IAccountSignerMeta<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateTokenGroupUpdateAuthorityInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** New authority for the group, or unset if `None` */\n  newUpdateAuthority: Option<Address>;\n};\n\nexport type UpdateTokenGroupUpdateAuthorityInstructionDataArgs = {\n  /** New authority for the group, or unset if `None` */\n  newUpdateAuthority: OptionOrNullable<Address>;\n};\n\nexport function getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder(): Encoder<UpdateTokenGroupUpdateAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      [\n        'newUpdateAuthority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder(): Decoder<UpdateTokenGroupUpdateAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    [\n      'newUpdateAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateTokenGroupUpdateAuthorityInstructionDataCodec(): Codec<\n  UpdateTokenGroupUpdateAuthorityInstructionDataArgs,\n  UpdateTokenGroupUpdateAuthorityInstructionData\n> {\n  return combineCodec(\n    getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder(),\n    getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type UpdateTokenGroupUpdateAuthorityInput<\n  TAccountGroup extends string = string,\n  TAccountUpdateAuthority extends string = string,\n> = {\n  group: Address<TAccountGroup>;\n  /** Current update authority */\n  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;\n  newUpdateAuthority: UpdateTokenGroupUpdateAuthorityInstructionDataArgs['newUpdateAuthority'];\n};\n\nexport function getUpdateTokenGroupUpdateAuthorityInstruction<\n  TAccountGroup extends string,\n  TAccountUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateTokenGroupUpdateAuthorityInput<\n    TAccountGroup,\n    TAccountUpdateAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateTokenGroupUpdateAuthorityInstruction<\n  TProgramAddress,\n  TAccountGroup,\n  TAccountUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    group: { value: input.group ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.group),\n      getAccountMeta(accounts.updateAuthority),\n    ],\n    programAddress,\n    data: getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder().encode(\n      args as UpdateTokenGroupUpdateAuthorityInstructionDataArgs\n    ),\n  } as UpdateTokenGroupUpdateAuthorityInstruction<\n    TProgramAddress,\n    TAccountGroup,\n    TAccountUpdateAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateTokenGroupUpdateAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    group: TAccountMetas[0];\n    /** Current update authority */\n    updateAuthority: TAccountMetas[1];\n  };\n  data: UpdateTokenGroupUpdateAuthorityInstructionData;\n};\n\nexport function parseUpdateTokenGroupUpdateAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateTokenGroupUpdateAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      group: getNextAccount(),\n      updateAuthority: getNextAccount(),\n    },\n    data: getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getTokenMetadataFieldDecoder,\n  getTokenMetadataFieldEncoder,\n  type TokenMetadataField,\n  type TokenMetadataFieldArgs,\n} from '../types';\n\nexport const UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR = new Uint8Array([\n  221, 233, 49, 45, 181, 202, 220, 200,\n]);\n\nexport function getUpdateTokenMetadataFieldDiscriminatorBytes() {\n  return getBytesEncoder().encode(UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR);\n}\n\nexport type UpdateTokenMetadataFieldInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | IAccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMetadata extends string\n        ? WritableAccount<TAccountMetadata>\n        : TAccountMetadata,\n      TAccountUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountUpdateAuthority> &\n            IAccountSignerMeta<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateTokenMetadataFieldInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** Field to update in the metadata. */\n  field: TokenMetadataField;\n  /** Value to write for the field. */\n  value: string;\n};\n\nexport type UpdateTokenMetadataFieldInstructionDataArgs = {\n  /** Field to update in the metadata. */\n  field: TokenMetadataFieldArgs;\n  /** Value to write for the field. */\n  value: string;\n};\n\nexport function getUpdateTokenMetadataFieldInstructionDataEncoder(): Encoder<UpdateTokenMetadataFieldInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      ['field', getTokenMetadataFieldEncoder()],\n      ['value', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateTokenMetadataFieldInstructionDataDecoder(): Decoder<UpdateTokenMetadataFieldInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    ['field', getTokenMetadataFieldDecoder()],\n    ['value', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n  ]);\n}\n\nexport function getUpdateTokenMetadataFieldInstructionDataCodec(): Codec<\n  UpdateTokenMetadataFieldInstructionDataArgs,\n  UpdateTokenMetadataFieldInstructionData\n> {\n  return combineCodec(\n    getUpdateTokenMetadataFieldInstructionDataEncoder(),\n    getUpdateTokenMetadataFieldInstructionDataDecoder()\n  );\n}\n\nexport type UpdateTokenMetadataFieldInput<\n  TAccountMetadata extends string = string,\n  TAccountUpdateAuthority extends string = string,\n> = {\n  metadata: Address<TAccountMetadata>;\n  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;\n  field: UpdateTokenMetadataFieldInstructionDataArgs['field'];\n  value: UpdateTokenMetadataFieldInstructionDataArgs['value'];\n};\n\nexport function getUpdateTokenMetadataFieldInstruction<\n  TAccountMetadata extends string,\n  TAccountUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateTokenMetadataFieldInput<\n    TAccountMetadata,\n    TAccountUpdateAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateTokenMetadataFieldInstruction<\n  TProgramAddress,\n  TAccountMetadata,\n  TAccountUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.updateAuthority),\n    ],\n    programAddress,\n    data: getUpdateTokenMetadataFieldInstructionDataEncoder().encode(\n      args as UpdateTokenMetadataFieldInstructionDataArgs\n    ),\n  } as UpdateTokenMetadataFieldInstruction<\n    TProgramAddress,\n    TAccountMetadata,\n    TAccountUpdateAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateTokenMetadataFieldInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    metadata: TAccountMetas[0];\n    updateAuthority: TAccountMetas[1];\n  };\n  data: UpdateTokenMetadataFieldInstructionData;\n};\n\nexport function parseUpdateTokenMetadataFieldInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateTokenMetadataFieldInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      metadata: getNextAccount(),\n      updateAuthority: getNextAccount(),\n    },\n    data: getUpdateTokenMetadataFieldInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR =\n  new Uint8Array([215, 228, 166, 228, 84, 100, 86, 123]);\n\nexport function getUpdateTokenMetadataUpdateAuthorityDiscriminatorBytes() {\n  return getBytesEncoder().encode(\n    UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR\n  );\n}\n\nexport type UpdateTokenMetadataUpdateAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | IAccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMetadata extends string\n        ? WritableAccount<TAccountMetadata>\n        : TAccountMetadata,\n      TAccountUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountUpdateAuthority> &\n            IAccountSignerMeta<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateTokenMetadataUpdateAuthorityInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** New authority for the token metadata, or unset if `None` */\n  newUpdateAuthority: Option<Address>;\n};\n\nexport type UpdateTokenMetadataUpdateAuthorityInstructionDataArgs = {\n  /** New authority for the token metadata, or unset if `None` */\n  newUpdateAuthority: OptionOrNullable<Address>;\n};\n\nexport function getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder(): Encoder<UpdateTokenMetadataUpdateAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      [\n        'newUpdateAuthority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder(): Decoder<UpdateTokenMetadataUpdateAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    [\n      'newUpdateAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateTokenMetadataUpdateAuthorityInstructionDataCodec(): Codec<\n  UpdateTokenMetadataUpdateAuthorityInstructionDataArgs,\n  UpdateTokenMetadataUpdateAuthorityInstructionData\n> {\n  return combineCodec(\n    getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder(),\n    getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type UpdateTokenMetadataUpdateAuthorityInput<\n  TAccountMetadata extends string = string,\n  TAccountUpdateAuthority extends string = string,\n> = {\n  metadata: Address<TAccountMetadata>;\n  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;\n  newUpdateAuthority: UpdateTokenMetadataUpdateAuthorityInstructionDataArgs['newUpdateAuthority'];\n};\n\nexport function getUpdateTokenMetadataUpdateAuthorityInstruction<\n  TAccountMetadata extends string,\n  TAccountUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateTokenMetadataUpdateAuthorityInput<\n    TAccountMetadata,\n    TAccountUpdateAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateTokenMetadataUpdateAuthorityInstruction<\n  TProgramAddress,\n  TAccountMetadata,\n  TAccountUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.updateAuthority),\n    ],\n    programAddress,\n    data: getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder().encode(\n      args as UpdateTokenMetadataUpdateAuthorityInstructionDataArgs\n    ),\n  } as UpdateTokenMetadataUpdateAuthorityInstruction<\n    TProgramAddress,\n    TAccountMetadata,\n    TAccountUpdateAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateTokenMetadataUpdateAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    metadata: TAccountMetas[0];\n    updateAuthority: TAccountMetas[1];\n  };\n  data: UpdateTokenMetadataUpdateAuthorityInstructionData;\n};\n\nexport function parseUpdateTokenMetadataUpdateAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateTokenMetadataUpdateAuthorityInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      metadata: getNextAccount(),\n      updateAuthority: getNextAccount(),\n    },\n    data: getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_TRANSFER_HOOK_DISCRIMINATOR = 36;\n\nexport function getUpdateTransferHookDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_TRANSFER_HOOK_DISCRIMINATOR);\n}\n\nexport const UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR = 1;\n\nexport function getUpdateTransferHookTransferHookDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR\n  );\n}\n\nexport type UpdateTransferHookInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateTransferHookInstructionData = {\n  discriminator: number;\n  transferHookDiscriminator: number;\n  /** The program id that performs logic during transfers */\n  programId: Option<Address>;\n};\n\nexport type UpdateTransferHookInstructionDataArgs = {\n  /** The program id that performs logic during transfers */\n  programId: OptionOrNullable<Address>;\n};\n\nexport function getUpdateTransferHookInstructionDataEncoder(): Encoder<UpdateTransferHookInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferHookDiscriminator', getU8Encoder()],\n      [\n        'programId',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TRANSFER_HOOK_DISCRIMINATOR,\n      transferHookDiscriminator:\n        UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateTransferHookInstructionDataDecoder(): Decoder<UpdateTransferHookInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferHookDiscriminator', getU8Decoder()],\n    [\n      'programId',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateTransferHookInstructionDataCodec(): Codec<\n  UpdateTransferHookInstructionDataArgs,\n  UpdateTransferHookInstructionData\n> {\n  return combineCodec(\n    getUpdateTransferHookInstructionDataEncoder(),\n    getUpdateTransferHookInstructionDataDecoder()\n  );\n}\n\nexport type UpdateTransferHookInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The transfer hook authority. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  programId: UpdateTransferHookInstructionDataArgs['programId'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateTransferHookInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateTransferHookInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateTransferHookInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getUpdateTransferHookInstructionDataEncoder().encode(\n      args as UpdateTransferHookInstructionDataArgs\n    ),\n  } as UpdateTransferHookInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateTransferHookInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The transfer hook authority. */\n    authority: TAccountMetas[1];\n  };\n  data: UpdateTransferHookInstructionData;\n};\n\nexport function parseUpdateTransferHookInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateTransferHookInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getUpdateTransferHookInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR = 38;\n\nexport function getWithdrawExcessLamportsDiscriminatorBytes() {\n  return getU8Encoder().encode(WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR);\n}\n\nexport type WithdrawExcessLamportsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSourceAccount extends string | IAccountMeta<string> = string,\n  TAccountDestinationAccount extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSourceAccount extends string\n        ? WritableAccount<TAccountSourceAccount>\n        : TAccountSourceAccount,\n      TAccountDestinationAccount extends string\n        ? WritableAccount<TAccountDestinationAccount>\n        : TAccountDestinationAccount,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawExcessLamportsInstructionData = { discriminator: number };\n\nexport type WithdrawExcessLamportsInstructionDataArgs = {};\n\nexport function getWithdrawExcessLamportsInstructionDataEncoder(): Encoder<WithdrawExcessLamportsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawExcessLamportsInstructionDataDecoder(): Decoder<WithdrawExcessLamportsInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getWithdrawExcessLamportsInstructionDataCodec(): Codec<\n  WithdrawExcessLamportsInstructionDataArgs,\n  WithdrawExcessLamportsInstructionData\n> {\n  return combineCodec(\n    getWithdrawExcessLamportsInstructionDataEncoder(),\n    getWithdrawExcessLamportsInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawExcessLamportsInput<\n  TAccountSourceAccount extends string = string,\n  TAccountDestinationAccount extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** Account holding excess lamports. */\n  sourceAccount: Address<TAccountSourceAccount>;\n  /** Destination account for withdrawn lamports. */\n  destinationAccount: Address<TAccountDestinationAccount>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getWithdrawExcessLamportsInstruction<\n  TAccountSourceAccount extends string,\n  TAccountDestinationAccount extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: WithdrawExcessLamportsInput<\n    TAccountSourceAccount,\n    TAccountDestinationAccount,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawExcessLamportsInstruction<\n  TProgramAddress,\n  TAccountSourceAccount,\n  TAccountDestinationAccount,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    sourceAccount: { value: input.sourceAccount ?? null, isWritable: true },\n    destinationAccount: {\n      value: input.destinationAccount ?? null,\n      isWritable: true,\n    },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.sourceAccount),\n      getAccountMeta(accounts.destinationAccount),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getWithdrawExcessLamportsInstructionDataEncoder().encode({}),\n  } as WithdrawExcessLamportsInstruction<\n    TProgramAddress,\n    TAccountSourceAccount,\n    TAccountDestinationAccount,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedWithdrawExcessLamportsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Account holding excess lamports. */\n    sourceAccount: TAccountMetas[0];\n    /** Destination account for withdrawn lamports. */\n    destinationAccount: TAccountMetas[1];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: WithdrawExcessLamportsInstructionData;\n};\n\nexport function parseWithdrawExcessLamportsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedWithdrawExcessLamportsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      sourceAccount: getNextAccount(),\n      destinationAccount: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getWithdrawExcessLamportsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR = 26;\n\nexport function getWithdrawWithheldTokensFromAccountsDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR\n  );\n}\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR = 3;\n\nexport function getWithdrawWithheldTokensFromAccountsTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type WithdrawWithheldTokensFromAccountsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountFeeReceiver extends string | IAccountMeta<string> = string,\n  TAccountWithdrawWithheldAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountFeeReceiver extends string\n        ? WritableAccount<TAccountFeeReceiver>\n        : TAccountFeeReceiver,\n      TAccountWithdrawWithheldAuthority extends string\n        ? ReadonlyAccount<TAccountWithdrawWithheldAuthority>\n        : TAccountWithdrawWithheldAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawWithheldTokensFromAccountsInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n  /** Number of token accounts harvested. */\n  numTokenAccounts: number;\n};\n\nexport type WithdrawWithheldTokensFromAccountsInstructionDataArgs = {\n  /** Number of token accounts harvested. */\n  numTokenAccounts: number;\n};\n\nexport function getWithdrawWithheldTokensFromAccountsInstructionDataEncoder(): Encoder<WithdrawWithheldTokensFromAccountsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n      ['numTokenAccounts', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR,\n      transferFeeDiscriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawWithheldTokensFromAccountsInstructionDataDecoder(): Decoder<WithdrawWithheldTokensFromAccountsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n    ['numTokenAccounts', getU8Decoder()],\n  ]);\n}\n\nexport function getWithdrawWithheldTokensFromAccountsInstructionDataCodec(): Codec<\n  WithdrawWithheldTokensFromAccountsInstructionDataArgs,\n  WithdrawWithheldTokensFromAccountsInstructionData\n> {\n  return combineCodec(\n    getWithdrawWithheldTokensFromAccountsInstructionDataEncoder(),\n    getWithdrawWithheldTokensFromAccountsInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawWithheldTokensFromAccountsInput<\n  TAccountMint extends string = string,\n  TAccountFeeReceiver extends string = string,\n  TAccountWithdrawWithheldAuthority extends string = string,\n> = {\n  /** The token mint. Must include the `TransferFeeConfig` extension. */\n  mint: Address<TAccountMint>;\n  /**\n   * The fee receiver account. Must include the `TransferFeeAmount`\n   * extension associated with the provided mint.\n   */\n  feeReceiver: Address<TAccountFeeReceiver>;\n  /** The mint's `withdraw_withheld_authority` or its multisignature account. */\n  withdrawWithheldAuthority:\n    | Address<TAccountWithdrawWithheldAuthority>\n    | TransactionSigner<TAccountWithdrawWithheldAuthority>;\n  numTokenAccounts: WithdrawWithheldTokensFromAccountsInstructionDataArgs['numTokenAccounts'];\n  multiSigners?: Array<TransactionSigner>;\n  sources: Array<Address>;\n};\n\nexport function getWithdrawWithheldTokensFromAccountsInstruction<\n  TAccountMint extends string,\n  TAccountFeeReceiver extends string,\n  TAccountWithdrawWithheldAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: WithdrawWithheldTokensFromAccountsInput<\n    TAccountMint,\n    TAccountFeeReceiver,\n    TAccountWithdrawWithheldAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawWithheldTokensFromAccountsInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountFeeReceiver,\n  (typeof input)['withdrawWithheldAuthority'] extends TransactionSigner<TAccountWithdrawWithheldAuthority>\n    ? ReadonlySignerAccount<TAccountWithdrawWithheldAuthority> &\n        IAccountSignerMeta<TAccountWithdrawWithheldAuthority>\n    : TAccountWithdrawWithheldAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n    feeReceiver: { value: input.feeReceiver ?? null, isWritable: true },\n    withdrawWithheldAuthority: {\n      value: input.withdrawWithheldAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = [\n    ...(args.multiSigners ?? []).map((signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })),\n    ...args.sources.map((address) => ({ address, role: AccountRole.WRITABLE })),\n  ];\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.feeReceiver),\n      getAccountMeta(accounts.withdrawWithheldAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getWithdrawWithheldTokensFromAccountsInstructionDataEncoder().encode(\n      args as WithdrawWithheldTokensFromAccountsInstructionDataArgs\n    ),\n  } as WithdrawWithheldTokensFromAccountsInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountFeeReceiver,\n    (typeof input)['withdrawWithheldAuthority'] extends TransactionSigner<TAccountWithdrawWithheldAuthority>\n      ? ReadonlySignerAccount<TAccountWithdrawWithheldAuthority> &\n          IAccountSignerMeta<TAccountWithdrawWithheldAuthority>\n      : TAccountWithdrawWithheldAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedWithdrawWithheldTokensFromAccountsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. Must include the `TransferFeeConfig` extension. */\n    mint: TAccountMetas[0];\n    /**\n     * The fee receiver account. Must include the `TransferFeeAmount`\n     * extension associated with the provided mint.\n     */\n\n    feeReceiver: TAccountMetas[1];\n    /** The mint's `withdraw_withheld_authority` or its multisignature account. */\n    withdrawWithheldAuthority: TAccountMetas[2];\n  };\n  data: WithdrawWithheldTokensFromAccountsInstructionData;\n};\n\nexport function parseWithdrawWithheldTokensFromAccountsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedWithdrawWithheldTokensFromAccountsInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      feeReceiver: getNextAccount(),\n      withdrawWithheldAuthority: getNextAccount(),\n    },\n    data: getWithdrawWithheldTokensFromAccountsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 2;\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountDestination extends string | IAccountMeta<string> = string,\n  TAccountInstructionsSysvarOrContextState extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountRecord extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountInstructionsSysvarOrContextState extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvarOrContextState>\n        : TAccountInstructionsSysvarOrContextState,\n      TAccountRecord extends string\n        ? ReadonlyAccount<TAccountRecord>\n        : TAccountRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionData =\n  {\n    discriminator: number;\n    confidentialTransferFeeDiscriminator: number;\n    /** Number of token accounts harvested */\n    numTokenAccounts: number;\n    /** Proof instruction offset */\n    proofInstructionOffset: number;\n    /** The new decryptable balance in the destination token account */\n    newDecryptableAvailableBalance: DecryptableBalance;\n  };\n\nexport type WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs =\n  {\n    /** Number of token accounts harvested */\n    numTokenAccounts: number;\n    /** Proof instruction offset */\n    proofInstructionOffset: number;\n    /** The new decryptable balance in the destination token account */\n    newDecryptableAvailableBalance: DecryptableBalanceArgs;\n  };\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder(): Encoder<WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n      ['numTokenAccounts', getU8Encoder()],\n      ['proofInstructionOffset', getI8Encoder()],\n      ['newDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder(): Decoder<WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n    ['numTokenAccounts', getU8Decoder()],\n    ['proofInstructionOffset', getI8Decoder()],\n    ['newDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n  ]);\n}\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataCodec(): Codec<\n  WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs,\n  WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionData\n> {\n  return combineCodec(\n    getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder(),\n    getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInput<\n  TAccountMint extends string = string,\n  TAccountDestination extends string = string,\n  TAccountInstructionsSysvarOrContextState extends string = string,\n  TAccountRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The fee receiver account. */\n  destination: Address<TAccountDestination>;\n  /** Instructions sysvar or context state account */\n  instructionsSysvarOrContextState: Address<TAccountInstructionsSysvarOrContextState>;\n  /** Optional record account */\n  record?: Address<TAccountRecord>;\n  /** The mint's withdraw_withheld_authority */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  numTokenAccounts: WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs['numTokenAccounts'];\n  proofInstructionOffset: WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs['proofInstructionOffset'];\n  newDecryptableAvailableBalance: WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs['newDecryptableAvailableBalance'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TAccountMint extends string,\n  TAccountDestination extends string,\n  TAccountInstructionsSysvarOrContextState extends string,\n  TAccountRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInput<\n    TAccountMint,\n    TAccountDestination,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountDestination,\n  TAccountInstructionsSysvarOrContextState,\n  TAccountRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n    instructionsSysvarOrContextState: {\n      value: input.instructionsSysvarOrContextState ?? null,\n      isWritable: false,\n    },\n    record: { value: input.record ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.instructionsSysvarOrContextState),\n      getAccountMeta(accounts.record),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder().encode(\n      args as WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs\n    ),\n  } as WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountDestination,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. */\n    mint: TAccountMetas[0];\n    /** The fee receiver account. */\n    destination: TAccountMetas[1];\n    /** Instructions sysvar or context state account */\n    instructionsSysvarOrContextState: TAccountMetas[2];\n    /** Optional record account */\n    record?: TAccountMetas[3] | undefined;\n    /** The mint's withdraw_withheld_authority */\n    authority: TAccountMetas[4];\n  };\n  data: WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionData;\n};\n\nexport function parseWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      instructionsSysvarOrContextState: getNextAccount(),\n      record: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR = 26;\n\nexport function getWithdrawWithheldTokensFromMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR\n  );\n}\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR = 2;\n\nexport function getWithdrawWithheldTokensFromMintTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type WithdrawWithheldTokensFromMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountFeeReceiver extends string | IAccountMeta<string> = string,\n  TAccountWithdrawWithheldAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountFeeReceiver extends string\n        ? WritableAccount<TAccountFeeReceiver>\n        : TAccountFeeReceiver,\n      TAccountWithdrawWithheldAuthority extends string\n        ? ReadonlyAccount<TAccountWithdrawWithheldAuthority>\n        : TAccountWithdrawWithheldAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawWithheldTokensFromMintInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n};\n\nexport type WithdrawWithheldTokensFromMintInstructionDataArgs = {};\n\nexport function getWithdrawWithheldTokensFromMintInstructionDataEncoder(): Encoder<WithdrawWithheldTokensFromMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR,\n      transferFeeDiscriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawWithheldTokensFromMintInstructionDataDecoder(): Decoder<WithdrawWithheldTokensFromMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getWithdrawWithheldTokensFromMintInstructionDataCodec(): Codec<\n  WithdrawWithheldTokensFromMintInstructionDataArgs,\n  WithdrawWithheldTokensFromMintInstructionData\n> {\n  return combineCodec(\n    getWithdrawWithheldTokensFromMintInstructionDataEncoder(),\n    getWithdrawWithheldTokensFromMintInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawWithheldTokensFromMintInput<\n  TAccountMint extends string = string,\n  TAccountFeeReceiver extends string = string,\n  TAccountWithdrawWithheldAuthority extends string = string,\n> = {\n  /** The token mint. Must include the `TransferFeeConfig` extension. */\n  mint: Address<TAccountMint>;\n  /**\n   * The fee receiver account. Must include the `TransferFeeAmount`\n   * extension associated with the provided mint.\n   */\n  feeReceiver: Address<TAccountFeeReceiver>;\n  /** The mint's `withdraw_withheld_authority` or its multisignature account. */\n  withdrawWithheldAuthority:\n    | Address<TAccountWithdrawWithheldAuthority>\n    | TransactionSigner<TAccountWithdrawWithheldAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getWithdrawWithheldTokensFromMintInstruction<\n  TAccountMint extends string,\n  TAccountFeeReceiver extends string,\n  TAccountWithdrawWithheldAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: WithdrawWithheldTokensFromMintInput<\n    TAccountMint,\n    TAccountFeeReceiver,\n    TAccountWithdrawWithheldAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawWithheldTokensFromMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountFeeReceiver,\n  (typeof input)['withdrawWithheldAuthority'] extends TransactionSigner<TAccountWithdrawWithheldAuthority>\n    ? ReadonlySignerAccount<TAccountWithdrawWithheldAuthority> &\n        IAccountSignerMeta<TAccountWithdrawWithheldAuthority>\n    : TAccountWithdrawWithheldAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    feeReceiver: { value: input.feeReceiver ?? null, isWritable: true },\n    withdrawWithheldAuthority: {\n      value: input.withdrawWithheldAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.feeReceiver),\n      getAccountMeta(accounts.withdrawWithheldAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getWithdrawWithheldTokensFromMintInstructionDataEncoder().encode({}),\n  } as WithdrawWithheldTokensFromMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountFeeReceiver,\n    (typeof input)['withdrawWithheldAuthority'] extends TransactionSigner<TAccountWithdrawWithheldAuthority>\n      ? ReadonlySignerAccount<TAccountWithdrawWithheldAuthority> &\n          IAccountSignerMeta<TAccountWithdrawWithheldAuthority>\n      : TAccountWithdrawWithheldAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedWithdrawWithheldTokensFromMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. Must include the `TransferFeeConfig` extension. */\n    mint: TAccountMetas[0];\n    /**\n     * The fee receiver account. Must include the `TransferFeeAmount`\n     * extension associated with the provided mint.\n     */\n\n    feeReceiver: TAccountMetas[1];\n    /** The mint's `withdraw_withheld_authority` or its multisignature account. */\n    withdrawWithheldAuthority: TAccountMetas[2];\n  };\n  data: WithdrawWithheldTokensFromMintInstructionData;\n};\n\nexport function parseWithdrawWithheldTokensFromMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedWithdrawWithheldTokensFromMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      feeReceiver: getNextAccount(),\n      withdrawWithheldAuthority: getNextAccount(),\n    },\n    data: getWithdrawWithheldTokensFromMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 1;\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountDestination extends string | IAccountMeta<string> = string,\n  TAccountInstructionsSysvarOrContextState extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountRecord extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountInstructionsSysvarOrContextState extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvarOrContextState>\n        : TAccountInstructionsSysvarOrContextState,\n      TAccountRecord extends string\n        ? ReadonlyAccount<TAccountRecord>\n        : TAccountRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionData =\n  {\n    discriminator: number;\n    confidentialTransferFeeDiscriminator: number;\n    /** Proof instruction offset */\n    proofInstructionOffset: number;\n    /** The new decryptable balance in the destination token account */\n    newDecryptableAvailableBalance: DecryptableBalance;\n  };\n\nexport type WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs =\n  {\n    /** Proof instruction offset */\n    proofInstructionOffset: number;\n    /** The new decryptable balance in the destination token account */\n    newDecryptableAvailableBalance: DecryptableBalanceArgs;\n  };\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder(): Encoder<WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n      ['proofInstructionOffset', getI8Encoder()],\n      ['newDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder(): Decoder<WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n    ['proofInstructionOffset', getI8Decoder()],\n    ['newDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n  ]);\n}\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataCodec(): Codec<\n  WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs,\n  WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionData\n> {\n  return combineCodec(\n    getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder(),\n    getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawWithheldTokensFromMintForConfidentialTransferFeeInput<\n  TAccountMint extends string = string,\n  TAccountDestination extends string = string,\n  TAccountInstructionsSysvarOrContextState extends string = string,\n  TAccountRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The fee receiver account. */\n  destination: Address<TAccountDestination>;\n  /** Instructions sysvar or context state account */\n  instructionsSysvarOrContextState: Address<TAccountInstructionsSysvarOrContextState>;\n  /** Optional record account if proof is read from record */\n  record?: Address<TAccountRecord>;\n  /** The mint's withdraw_withheld_authority */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  proofInstructionOffset: WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs['proofInstructionOffset'];\n  newDecryptableAvailableBalance: WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs['newDecryptableAvailableBalance'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TAccountMint extends string,\n  TAccountDestination extends string,\n  TAccountInstructionsSysvarOrContextState extends string,\n  TAccountRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: WithdrawWithheldTokensFromMintForConfidentialTransferFeeInput<\n    TAccountMint,\n    TAccountDestination,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountDestination,\n  TAccountInstructionsSysvarOrContextState,\n  TAccountRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        IAccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    instructionsSysvarOrContextState: {\n      value: input.instructionsSysvarOrContextState ?? null,\n      isWritable: false,\n    },\n    record: { value: input.record ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: IAccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.instructionsSysvarOrContextState),\n      getAccountMeta(accounts.record),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder().encode(\n      args as WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs\n    ),\n  } as WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountDestination,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          IAccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. */\n    mint: TAccountMetas[0];\n    /** The fee receiver account. */\n    destination: TAccountMetas[1];\n    /** Instructions sysvar or context state account */\n    instructionsSysvarOrContextState: TAccountMetas[2];\n    /** Optional record account if proof is read from record */\n    record?: TAccountMetas[3] | undefined;\n    /** The mint's withdraw_withheld_authority */\n    authority: TAccountMetas[4];\n  };\n  data: WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionData;\n};\n\nexport function parseWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      instructionsSysvarOrContextState: getNextAccount(),\n      record: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "import {\n  type GetAccountInfoApi,\n  type Rpc,\n  Address,\n  UnixTimestamp,\n  unwrapOption,\n} from '@solana/kit';\nimport { fetchSysvarClock } from '@solana/sysvars';\nimport { fetchMint } from './generated';\n\n// Constants\nconst ONE_IN_BASIS_POINTS = 10000;\nconst SECONDS_PER_YEAR = 60 * 60 * 24 * 365.24;\n\n/**\n * Calculates the exponent for the interest rate formula.\n * @param t1 - The start time in seconds.\n * @param t2 - The end time in seconds.\n * @param r  - The interest rate in basis points.\n *\n * @returns The calculated exponent.\n */\nfunction calculateExponentForTimesAndRate(t1: number, t2: number, r: number) {\n  const timespan = t2 - t1;\n  if (timespan < 0) {\n    throw new Error('Invalid timespan: end time before start time');\n  }\n\n  const numerator = r * timespan;\n  const exponent = numerator / (SECONDS_PER_YEAR * ONE_IN_BASIS_POINTS);\n  return Math.exp(exponent);\n}\n\n/**\n * Calculates the total scale factor for an interest bearing token by combining two exponential functions:\n * One for the period between initialization and last update using the pre-update average rate,\n * and another for the period between last update and current time using the current rate.\n *\n * @param currentTimestamp         Current timestamp in seconds\n * @param lastUpdateTimestamp      Last time the interest rate was updated in seconds\n * @param initializationTimestamp  Time the interest bearing extension was initialized in seconds\n * @param preUpdateAverageRate     Interest rate in basis points before last update\n * @param currentRate              Current interest rate in basis points\n *\n * @returns The total scale factor as a product of the two exponential functions\n */\nfunction calculateTotalScale({\n  currentTimestamp,\n  lastUpdateTimestamp,\n  initializationTimestamp,\n  preUpdateAverageRate,\n  currentRate,\n}: {\n  currentTimestamp: number;\n  lastUpdateTimestamp: number;\n  initializationTimestamp: number;\n  preUpdateAverageRate: number;\n  currentRate: number;\n}): number {\n  // Calculate pre-update exponent\n  const preUpdateExp = calculateExponentForTimesAndRate(\n    initializationTimestamp,\n    lastUpdateTimestamp,\n    preUpdateAverageRate\n  );\n\n  // Calculate post-update exponent\n  const postUpdateExp = calculateExponentForTimesAndRate(\n    lastUpdateTimestamp,\n    currentTimestamp,\n    currentRate\n  );\n\n  return preUpdateExp * postUpdateExp;\n}\n\n/**\n * Calculates the decimal factor for a given number of decimals\n * @param decimals - Number of decimals\n * @returns The decimal factor (e.g., 100 for 2 decimals)\n */\nfunction getDecimalFactor(decimals: number): number {\n  return Math.pow(10, decimals);\n}\n\n/**\n * Retrieves the current timestamp from the Solana clock sysvar.\n * @param rpc - The Solana rpc object.\n * @returns A promise that resolves to the current timestamp in seconds.\n * @throws An error if the sysvar clock cannot be fetched or parsed.\n */\nasync function getSysvarClockTimestamp(\n  rpc: Rpc<GetAccountInfoApi>\n): Promise<UnixTimestamp> {\n  const info = await fetchSysvarClock(rpc);\n  if (!info) {\n    throw new Error('Failed to fetch sysvar clock');\n  }\n  return info.unixTimestamp;\n}\n\n// ========== INTEREST BEARING MINT FUNCTIONS ==========\n\n/**\n * Convert amount to UiAmount for a mint with interest bearing extension without simulating a transaction\n * This implements the same logic as the CPI instruction available in /token/program-2022/src/extension/interest_bearing_mint/mod.rs\n * In general to calculate compounding interest over a period of time, the formula is:\n * A = P * e^(r * t) where\n * A = final amount after interest\n * P = principal amount (initial investment)\n * r = annual interest rate (as a decimal, e.g., 5% = 0.05)\n * t = time in years\n * e = mathematical constant (~2.718)\n *\n * In this case, we are calculating the total scale factor for the interest bearing extension which is the product of two exponential functions:\n * totalScale = e^(r1 * t1) * e^(r2 * t2)\n * where r1 and r2 are the interest rates before and after the last update, and t1 and t2 are the times in years between\n * the initialization timestamp and the last update timestamp, and between the last update timestamp and the current timestamp.\n *\n * @param amount                   Amount of tokens to be converted\n * @param decimals                 Number of decimals of the mint\n * @param currentTimestamp         Current timestamp in seconds\n * @param lastUpdateTimestamp      Last time the interest rate was updated in seconds\n * @param initializationTimestamp  Time the interest bearing extension was initialized in seconds\n * @param preUpdateAverageRate     Interest rate in basis points (1 basis point = 0.01%) before last update\n * @param currentRate              Current interest rate in basis points\n *\n * @return Amount scaled by accrued interest as a string with appropriate decimal places\n */\nexport function amountToUiAmountForInterestBearingMintWithoutSimulation(\n  amount: bigint,\n  decimals: number,\n  currentTimestamp: number,\n  lastUpdateTimestamp: number,\n  initializationTimestamp: number,\n  preUpdateAverageRate: number,\n  currentRate: number\n): string {\n  const totalScale = calculateTotalScale({\n    currentTimestamp,\n    lastUpdateTimestamp,\n    initializationTimestamp,\n    preUpdateAverageRate,\n    currentRate,\n  });\n\n  // Scale the amount by the total interest factor\n  const scaledAmount = Number(amount) * totalScale;\n  const decimalFactor = getDecimalFactor(decimals);\n\n  return (Math.trunc(scaledAmount) / decimalFactor).toString();\n}\n\n/**\n * Convert an amount with interest back to the original amount without interest\n * This implements the same logic as the CPI instruction available in /token/program-2022/src/extension/interest_bearing_mint/mod.rs\n *\n * @param uiAmount                  UI Amount (principal plus continuously compounding interest) to be converted back to original principal\n * @param decimals                  Number of decimals for the mint\n * @param currentTimestamp          Current timestamp in seconds\n * @param lastUpdateTimestamp       Last time the interest rate was updated in seconds\n * @param initializationTimestamp   Time the interest bearing extension was initialized in seconds\n * @param preUpdateAverageRate      Interest rate in basis points (hundredths of a percent) before the last update\n * @param currentRate              Current interest rate in basis points\n *\n * In general to calculate the principal from the UI amount, the formula is:\n * P = A / (e^(r * t)) where\n * P = principal\n * A = UI amount\n * r = annual interest rate (as a decimal, e.g., 5% = 0.05)\n * t = time in years\n *\n * In this case, we are calculating the principal by dividing the UI amount by the total scale factor which is the product of two exponential functions:\n * totalScale = e^(r1 * t1) * e^(r2 * t2)\n * where r1 is the pre-update average rate, r2 is the current rate, t1 is the time in years between the initialization timestamp and the last update timestamp,\n * and t2 is the time in years between the last update timestamp and the current timestamp.\n * then to calculate the principal, we divide the UI amount by the total scale factor:\n * P = A / totalScale\n *\n * @return Original amount (principal) without interest\n */\nexport function uiAmountToAmountForInterestBearingMintWithoutSimulation(\n  uiAmount: string,\n  decimals: number,\n  currentTimestamp: number,\n  lastUpdateTimestamp: number,\n  initializationTimestamp: number,\n  preUpdateAverageRate: number,\n  currentRate: number\n): bigint {\n  const uiAmountNumber = parseFloat(uiAmount);\n  const decimalsFactor = getDecimalFactor(decimals);\n  const uiAmountScaled = uiAmountNumber * decimalsFactor;\n\n  const totalScale = calculateTotalScale({\n    currentTimestamp,\n    lastUpdateTimestamp,\n    initializationTimestamp,\n    preUpdateAverageRate,\n    currentRate,\n  });\n\n  // Calculate original principal by dividing the UI amount by the total scale\n  const originalPrincipal = uiAmountScaled / totalScale;\n  return BigInt(Math.trunc(originalPrincipal));\n}\n\n// ========== SCALED UI AMOUNT MINT FUNCTIONS ==========\n\n/**\n * Convert amount to UiAmount for a mint with scaled UI amount extension\n * @param amount     Amount of tokens to be converted\n * @param decimals   Number of decimals of the mint\n * @param multiplier Multiplier to scale the amount\n * @return Scaled UI amount as a string\n */\nexport function amountToUiAmountForScaledUiAmountMintWithoutSimulation(\n  amount: bigint,\n  decimals: number,\n  multiplier: number\n): string {\n  const scaledAmount = Number(amount) * multiplier;\n  const decimalFactor = getDecimalFactor(decimals);\n  return (Math.trunc(scaledAmount) / decimalFactor).toString();\n}\n\n/**\n * Convert a UI amount back to the raw amount for a mint with a scaled UI amount extension\n * @param uiAmount       UI Amount to be converted back to raw amount\n * @param decimals       Number of decimals for the mint\n * @param multiplier     Multiplier for the scaled UI amount\n *\n * @return Raw amount\n */\nexport function uiAmountToAmountForScaledUiAmountMintWithoutSimulation(\n  uiAmount: string,\n  decimals: number,\n  multiplier: number\n): bigint {\n  const uiAmountNumber = parseFloat(uiAmount);\n  const decimalsFactor = getDecimalFactor(decimals);\n  const uiAmountScaled = uiAmountNumber * decimalsFactor;\n  const rawAmount = uiAmountScaled / multiplier;\n  return BigInt(Math.trunc(rawAmount));\n}\n\n// ========== MAIN ENTRY POINT FUNCTIONS ==========\n\n/**\n * Convert amount to UiAmount for a mint without simulating a transaction\n * This implements the same logic as `process_amount_to_ui_amount` in\n * solana-labs/solana-program-library/token/program-2022/src/processor.rs\n * and `process_amount_to_ui_amount` in solana-labs/solana-program-library/token/program/src/processor.rs\n *\n * @param rpc     Rpc to use\n * @param mint    Mint to use for calculations\n * @param amount  Amount of tokens to be converted to Ui Amount\n *\n * @return Ui Amount generated\n */\nexport async function amountToUiAmountForMintWithoutSimulation(\n  rpc: Rpc<GetAccountInfoApi>,\n  mint: Address,\n  amount: bigint\n): Promise<string> {\n  const accountInfo = await fetchMint(rpc, mint);\n  const extensions = unwrapOption(accountInfo.data.extensions);\n\n  // Check for interest bearing mint extension\n  const interestBearingMintConfigState = extensions?.find(\n    (ext) => ext.__kind === 'InterestBearingConfig'\n  );\n\n  // Check for scaled UI amount extension\n  const scaledUiAmountConfig = extensions?.find(\n    (ext) => ext.__kind === 'ScaledUiAmountConfig'\n  );\n\n  // If no special extension, do standard conversion\n  if (!interestBearingMintConfigState && !scaledUiAmountConfig) {\n    const amountNumber = Number(amount);\n    const decimalsFactor = getDecimalFactor(accountInfo.data.decimals);\n    return (amountNumber / decimalsFactor).toString();\n  }\n\n  // Get timestamp if needed for special mint types\n  const timestamp = await getSysvarClockTimestamp(rpc);\n\n  // Handle interest bearing mint\n  if (interestBearingMintConfigState) {\n    return amountToUiAmountForInterestBearingMintWithoutSimulation(\n      amount,\n      accountInfo.data.decimals,\n      Number(timestamp),\n      Number(interestBearingMintConfigState.lastUpdateTimestamp),\n      Number(interestBearingMintConfigState.initializationTimestamp),\n      interestBearingMintConfigState.preUpdateAverageRate,\n      interestBearingMintConfigState.currentRate\n    );\n  }\n\n  // At this point, we know it must be a scaled UI amount mint\n  if (scaledUiAmountConfig) {\n    let multiplier = scaledUiAmountConfig.multiplier;\n    // Use new multiplier if it's effective\n    if (timestamp >= scaledUiAmountConfig.newMultiplierEffectiveTimestamp) {\n      multiplier = scaledUiAmountConfig.newMultiplier;\n    }\n    return amountToUiAmountForScaledUiAmountMintWithoutSimulation(\n      amount,\n      accountInfo.data.decimals,\n      multiplier\n    );\n  }\n\n  // This should never happen due to the conditions above\n  throw new Error('Unknown mint extension type');\n}\n\n/**\n * Convert a UI amount back to the raw amount\n *\n * @param rpc      Rpc to use\n * @param mint     Mint to use for calculations\n * @param uiAmount UI Amount to be converted back to raw amount\n *\n * @return Raw amount\n */\nexport async function uiAmountToAmountForMintWithoutSimulation(\n  rpc: Rpc<GetAccountInfoApi>,\n  mint: Address,\n  uiAmount: string\n): Promise<bigint> {\n  const accountInfo = await fetchMint(rpc, mint);\n  const extensions = unwrapOption(accountInfo.data.extensions);\n\n  // Check for interest bearing mint extension\n  const interestBearingMintConfigState = extensions?.find(\n    (ext) => ext.__kind === 'InterestBearingConfig'\n  );\n\n  // Check for scaled UI amount extension\n  const scaledUiAmountConfig = extensions?.find(\n    (ext) => ext.__kind === 'ScaledUiAmountConfig'\n  );\n\n  // If no special extension, do standard conversion\n  if (!interestBearingMintConfigState && !scaledUiAmountConfig) {\n    const uiAmountScaled =\n      parseFloat(uiAmount) * getDecimalFactor(accountInfo.data.decimals);\n    return BigInt(Math.trunc(uiAmountScaled));\n  }\n\n  // Get timestamp if needed for special mint types\n  const timestamp = await getSysvarClockTimestamp(rpc);\n\n  // Handle interest bearing mint\n  if (interestBearingMintConfigState) {\n    return uiAmountToAmountForInterestBearingMintWithoutSimulation(\n      uiAmount,\n      accountInfo.data.decimals,\n      Number(timestamp),\n      Number(interestBearingMintConfigState.lastUpdateTimestamp),\n      Number(interestBearingMintConfigState.initializationTimestamp),\n      interestBearingMintConfigState.preUpdateAverageRate,\n      interestBearingMintConfigState.currentRate\n    );\n  }\n\n  // At this point, we know it must be a scaled UI amount mint\n  if (scaledUiAmountConfig) {\n    let multiplier = scaledUiAmountConfig.multiplier;\n    // Use new multiplier if it's effective\n    if (timestamp >= scaledUiAmountConfig.newMultiplierEffectiveTimestamp) {\n      multiplier = scaledUiAmountConfig.newMultiplier;\n    }\n    return uiAmountToAmountForScaledUiAmountMintWithoutSimulation(\n      uiAmount,\n      accountInfo.data.decimals,\n      multiplier\n    );\n  }\n\n  // This should never happen due to the conditions above\n  throw new Error('Unknown mint extension type');\n}\n", "import {\n  Address,\n  IInstruction,\n  isNone,\n  isOption,\n  TransactionSigner,\n  wrapNullable,\n} from '@solana/kit';\nimport {\n  ExtensionArgs,\n  getDisableMemoTransfersInstruction,\n  getEnableMemoTransfersInstruction,\n  getEnableCpiGuardInstruction,\n  getDisableCpiGuardInstruction,\n  getInitializeConfidentialTransferMintInstruction,\n  getInitializeDefaultAccountStateInstruction,\n  getInitializeGroupMemberPointerInstruction,\n  getInitializeGroupPointerInstruction,\n  getInitializeInterestBearingMintInstruction,\n  getInitializeMetadataPointerInstruction,\n  getInitializeMintCloseAuthorityInstruction,\n  getInitializeTokenGroupInstruction,\n  getInitializeTokenMetadataInstruction,\n  getInitializeTransferFeeConfigInstruction,\n  getInitializeNonTransferableMintInstruction,\n  getInitializeTransferHookInstruction,\n  getInitializePermanentDelegateInstruction,\n  getInitializeScaledUiAmountMintInstruction,\n  getInitializeConfidentialTransferFeeInstruction,\n  getInitializePausableConfigInstruction,\n} from './generated';\n\n/**\n * Given a mint address and a list of mint extensions, returns a list of\n * instructions that MUST be run _before_ the `initializeMint` instruction\n * to properly initialize the given extensions on the mint account.\n */\nexport function getPreInitializeInstructionsForMintExtensions(\n  mint: Address,\n  extensions: ExtensionArgs[]\n): IInstruction[] {\n  return extensions.flatMap((extension) => {\n    switch (extension.__kind) {\n      case 'ConfidentialTransferMint':\n        return [\n          getInitializeConfidentialTransferMintInstruction({\n            mint,\n            ...extension,\n          }),\n        ];\n      case 'DefaultAccountState':\n        return [\n          getInitializeDefaultAccountStateInstruction({\n            mint,\n            state: extension.state,\n          }),\n        ];\n      case 'TransferFeeConfig':\n        return [\n          getInitializeTransferFeeConfigInstruction({\n            mint,\n            transferFeeConfigAuthority: extension.transferFeeConfigAuthority,\n            withdrawWithheldAuthority: extension.withdrawWithheldAuthority,\n            transferFeeBasisPoints:\n              extension.newerTransferFee.transferFeeBasisPoints,\n            maximumFee: extension.newerTransferFee.maximumFee,\n          }),\n        ];\n      case 'MetadataPointer':\n        return [\n          getInitializeMetadataPointerInstruction({\n            mint,\n            authority: extension.authority,\n            metadataAddress: extension.metadataAddress,\n          }),\n        ];\n      case 'InterestBearingConfig':\n        return [\n          getInitializeInterestBearingMintInstruction({\n            mint,\n            rateAuthority: extension.rateAuthority,\n            rate: extension.currentRate,\n          }),\n        ];\n      case 'ScaledUiAmountConfig':\n        return [\n          getInitializeScaledUiAmountMintInstruction({\n            mint,\n            authority: extension.authority,\n            multiplier: extension.multiplier,\n          }),\n        ];\n      case 'PausableConfig':\n        return [\n          getInitializePausableConfigInstruction({\n            mint,\n            authority: extension.authority,\n          }),\n        ];\n      case 'GroupPointer':\n        return [\n          getInitializeGroupPointerInstruction({\n            mint,\n            authority: extension.authority,\n            groupAddress: extension.groupAddress,\n          }),\n        ];\n      case 'GroupMemberPointer':\n        return [\n          getInitializeGroupMemberPointerInstruction({\n            mint,\n            authority: extension.authority,\n            memberAddress: extension.memberAddress,\n          }),\n        ];\n      case 'NonTransferable':\n        return getInitializeNonTransferableMintInstruction({ mint });\n      case 'TransferHook':\n        return [\n          getInitializeTransferHookInstruction({\n            mint,\n            authority: extension.authority,\n            programId: extension.programId,\n          }),\n        ];\n      case 'PermanentDelegate':\n        return getInitializePermanentDelegateInstruction({\n          mint,\n          delegate: extension.delegate,\n        });\n      case 'ConfidentialTransferFee':\n        return [\n          getInitializeConfidentialTransferFeeInstruction({\n            mint,\n            authority: extension.authority,\n            withdrawWithheldAuthorityElGamalPubkey: extension.elgamalPubkey,\n          }),\n        ];\n      case 'MintCloseAuthority':\n        return getInitializeMintCloseAuthorityInstruction({\n          closeAuthority: extension.closeAuthority,\n          mint,\n        });\n      default:\n        return [];\n    }\n  });\n}\n\n/**\n * Given a mint address and a list of mint extensions, returns a list of\n * instructions that MUST be run _after_ the `initializeMint` instruction\n * to properly initialize the given extensions on the mint account.\n */\nexport function getPostInitializeInstructionsForMintExtensions(\n  mint: Address,\n  authority: TransactionSigner,\n  extensions: ExtensionArgs[]\n): IInstruction[] {\n  return extensions.flatMap((extension): IInstruction[] => {\n    switch (extension.__kind) {\n      case 'TokenMetadata':\n        // eslint-disable-next-line no-case-declarations\n        const tokenMetadataUpdateAuthority = isOption(extension.updateAuthority)\n          ? extension.updateAuthority\n          : wrapNullable(extension.updateAuthority);\n        if (isNone(tokenMetadataUpdateAuthority)) {\n          return [];\n        }\n        return [\n          getInitializeTokenMetadataInstruction({\n            metadata: mint,\n            updateAuthority: tokenMetadataUpdateAuthority.value,\n            mint,\n            mintAuthority: authority,\n            name: extension.name,\n            symbol: extension.symbol,\n            uri: extension.uri,\n          }),\n        ];\n      case 'TokenGroup':\n        return [\n          getInitializeTokenGroupInstruction({\n            group: mint,\n            updateAuthority: isOption(extension.updateAuthority)\n              ? extension.updateAuthority\n              : wrapNullable(extension.updateAuthority),\n            mint,\n            mintAuthority: authority,\n            maxSize: extension.maxSize,\n          }),\n        ];\n      default:\n        return [];\n    }\n  });\n}\n\n/**\n * Given a token address, its owner and a list of token extensions, returns a list\n * of instructions that MUST be run _after_ the `initializeAccount` instruction\n * to properly initialize the given extensions on the token account.\n */\nexport function getPostInitializeInstructionsForTokenExtensions(\n  token: Address,\n  owner: TransactionSigner | Address,\n  extensions: ExtensionArgs[],\n  multiSigners?: TransactionSigner[]\n): IInstruction[] {\n  return extensions.flatMap((extension) => {\n    switch (extension.__kind) {\n      case 'MemoTransfer':\n        return [\n          extension.requireIncomingTransferMemos\n            ? getEnableMemoTransfersInstruction({ owner, token, multiSigners })\n            : getDisableMemoTransfersInstruction({\n                owner,\n                token,\n                multiSigners,\n              }),\n        ];\n      case 'CpiGuard':\n        return [\n          extension.lockCpi\n            ? getEnableCpiGuardInstruction({ owner, token, multiSigners })\n            : getDisableCpiGuardInstruction({\n                owner,\n                token,\n                multiSigners,\n              }),\n        ];\n      default:\n        return [];\n    }\n  });\n}\n", "import {\n  getArrayEncoder,\n  getConstantEncoder,\n  getHiddenPrefixEncoder,\n  getU8Encoder,\n} from '@solana/kit';\nimport { ExtensionArgs, getExtensionEncoder } from './generated';\n\nconst TOKEN_BASE_SIZE = 165;\n\nexport function getTokenSize(extensions?: ExtensionArgs[]): number {\n  if (extensions == null) return TOKEN_BASE_SIZE;\n  const tvlEncoder = getHiddenPrefixEncoder(\n    getArrayEncoder(getExtensionEncoder(), { size: 'remainder' }),\n    [getConstantEncoder(getU8Encoder().encode(2))]\n  );\n  return TOKEN_BASE_SIZE + tvlEncoder.encode(extensions).length;\n}\n", "import {\n  getArrayEncoder,\n  getConstantEncoder,\n  getHiddenPrefixEncoder,\n  getU8Encoder,\n  padLeftEncoder,\n} from '@solana/kit';\nimport { ExtensionArgs, getExtensionEncoder } from './generated';\n\nconst MINT_BASE_SIZE = 82;\n\nexport function getMintSize(extensions?: ExtensionArgs[]): number {\n  if (extensions == null) return MINT_BASE_SIZE;\n  const tvlEncoder = getHiddenPrefixEncoder(\n    getArrayEncoder(getExtensionEncoder(), { size: 'remainder' }),\n    [getConstantEncoder(padLeftEncoder(getU8Encoder(), 83).encode(1))]\n  );\n  return MINT_BASE_SIZE + tvlEncoder.encode(extensions).length;\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport enum NonceState {\n  Uninitialized,\n  Initialized,\n}\n\nexport type NonceStateArgs = NonceState;\n\nexport function getNonceStateEncoder(): Encoder<NonceStateArgs> {\n  return getEnumEncoder(NonceState, { size: getU32Encoder() });\n}\n\nexport function getNonceStateDecoder(): Decoder<NonceState> {\n  return getEnumDecoder(NonceState, { size: getU32Decoder() });\n}\n\nexport function getNonceStateCodec(): Codec<NonceStateArgs, NonceState> {\n  return combineCodec(getNonceStateEncoder(), getNonceStateDecoder());\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport enum NonceVersion {\n  Legacy,\n  Current,\n}\n\nexport type NonceVersionArgs = NonceVersion;\n\nexport function getNonceVersionEncoder(): Encoder<NonceVersionArgs> {\n  return getEnumEncoder(NonceVersion, { size: getU32Encoder() });\n}\n\nexport function getNonceVersionDecoder(): Decoder<NonceVersion> {\n  return getEnumDecoder(NonceVersion, { size: getU32Decoder() });\n}\n\nexport function getNonceVersionCodec(): Codec<NonceVersionArgs, NonceVersion> {\n  return combineCodec(getNonceVersionEncoder(), getNonceVersionDecoder());\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n} from '@solana/kit';\nimport {\n  getNonceStateDecoder,\n  getNonceStateEncoder,\n  getNonceVersionDecoder,\n  getNonceVersionEncoder,\n  type NonceState,\n  type NonceStateArgs,\n  type NonceVersion,\n  type NonceVersionArgs,\n} from '../types';\n\nexport type Nonce = {\n  version: NonceVersion;\n  state: NonceState;\n  authority: Address;\n  blockhash: Address;\n  lamportsPerSignature: bigint;\n};\n\nexport type NonceArgs = {\n  version: NonceVersionArgs;\n  state: NonceStateArgs;\n  authority: Address;\n  blockhash: Address;\n  lamportsPerSignature: number | bigint;\n};\n\nexport function getNonceEncoder(): Encoder<NonceArgs> {\n  return getStructEncoder([\n    ['version', getNonceVersionEncoder()],\n    ['state', getNonceStateEncoder()],\n    ['authority', getAddressEncoder()],\n    ['blockhash', getAddressEncoder()],\n    ['lamportsPerSignature', getU64Encoder()],\n  ]);\n}\n\nexport function getNonceDecoder(): Decoder<Nonce> {\n  return getStructDecoder([\n    ['version', getNonceVersionDecoder()],\n    ['state', getNonceStateDecoder()],\n    ['authority', getAddressDecoder()],\n    ['blockhash', getAddressDecoder()],\n    ['lamportsPerSignature', getU64Decoder()],\n  ]);\n}\n\nexport function getNonceCodec(): Codec<NonceArgs, Nonce> {\n  return combineCodec(getNonceEncoder(), getNonceDecoder());\n}\n\nexport function decodeNonce<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Nonce, TAddress>;\nexport function decodeNonce<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Nonce, TAddress>;\nexport function decodeNonce<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Nonce, TAddress> | MaybeAccount<Nonce, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getNonceDecoder()\n  );\n}\n\nexport async function fetchNonce<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Nonce, TAddress>> {\n  const maybeAccount = await fetchMaybeNonce(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeNonce<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Nonce, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeNonce(maybeAccount);\n}\n\nexport async function fetchAllNonce(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Nonce>[]> {\n  const maybeAccounts = await fetchAllMaybeNonce(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeNonce(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Nonce>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeNonce(maybeAccount));\n}\n\nexport function getNonceSize(): number {\n  return 80;\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU32Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedAdvanceNonceAccountInstruction,\n  type ParsedAllocateInstruction,\n  type ParsedAllocateWithSeedInstruction,\n  type ParsedAssignInstruction,\n  type ParsedAssignWithSeedInstruction,\n  type ParsedAuthorizeNonceAccountInstruction,\n  type ParsedCreateAccountInstruction,\n  type ParsedCreateAccountWithSeedInstruction,\n  type ParsedInitializeNonceAccountInstruction,\n  type ParsedTransferSolInstruction,\n  type ParsedTransferSolWithSeedInstruction,\n  type ParsedUpgradeNonceAccountInstruction,\n  type ParsedWithdrawNonceAccountInstruction,\n} from '../instructions';\n\nexport const SYSTEM_PROGRAM_ADDRESS =\n  '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n\nexport enum SystemAccount {\n  Nonce,\n}\n\nexport enum SystemInstruction {\n  CreateAccount,\n  Assign,\n  TransferSol,\n  CreateAccountWithSeed,\n  AdvanceNonceAccount,\n  WithdrawNonceAccount,\n  InitializeNonceAccount,\n  AuthorizeNonceAccount,\n  Allocate,\n  AllocateWithSeed,\n  AssignWithSeed,\n  TransferSolWithSeed,\n  UpgradeNonceAccount,\n}\n\nexport function identifySystemInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): SystemInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU32Encoder().encode(0), 0)) {\n    return SystemInstruction.CreateAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(1), 0)) {\n    return SystemInstruction.Assign;\n  }\n  if (containsBytes(data, getU32Encoder().encode(2), 0)) {\n    return SystemInstruction.TransferSol;\n  }\n  if (containsBytes(data, getU32Encoder().encode(3), 0)) {\n    return SystemInstruction.CreateAccountWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(4), 0)) {\n    return SystemInstruction.AdvanceNonceAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(5), 0)) {\n    return SystemInstruction.WithdrawNonceAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(6), 0)) {\n    return SystemInstruction.InitializeNonceAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(7), 0)) {\n    return SystemInstruction.AuthorizeNonceAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(8), 0)) {\n    return SystemInstruction.Allocate;\n  }\n  if (containsBytes(data, getU32Encoder().encode(9), 0)) {\n    return SystemInstruction.AllocateWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(10), 0)) {\n    return SystemInstruction.AssignWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(11), 0)) {\n    return SystemInstruction.TransferSolWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(12), 0)) {\n    return SystemInstruction.UpgradeNonceAccount;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a system instruction.'\n  );\n}\n\nexport type ParsedSystemInstruction<\n  TProgram extends string = '11111111111111111111111111111111',\n> =\n  | ({\n      instructionType: SystemInstruction.CreateAccount;\n    } & ParsedCreateAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.Assign;\n    } & ParsedAssignInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.TransferSol;\n    } & ParsedTransferSolInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.CreateAccountWithSeed;\n    } & ParsedCreateAccountWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.AdvanceNonceAccount;\n    } & ParsedAdvanceNonceAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.WithdrawNonceAccount;\n    } & ParsedWithdrawNonceAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.InitializeNonceAccount;\n    } & ParsedInitializeNonceAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.AuthorizeNonceAccount;\n    } & ParsedAuthorizeNonceAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.Allocate;\n    } & ParsedAllocateInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.AllocateWithSeed;\n    } & ParsedAllocateWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.AssignWithSeed;\n    } & ParsedAssignWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.TransferSolWithSeed;\n    } & ParsedTransferSolWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.UpgradeNonceAccount;\n    } & ParsedUpgradeNonceAccountInstruction<TProgram>);\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\n\n/** AccountAlreadyInUse: an account with the same address already exists */\nexport const SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE = 0x0; // 0\n/** ResultWithNegativeLamports: account does not have enough SOL to perform the operation */\nexport const SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS = 0x1; // 1\n/** InvalidProgramId: cannot assign account to this program id */\nexport const SYSTEM_ERROR__INVALID_PROGRAM_ID = 0x2; // 2\n/** InvalidAccountDataLength: cannot allocate account data of this length */\nexport const SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH = 0x3; // 3\n/** MaxSeedLengthExceeded: length of requested seed is too long */\nexport const SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED = 0x4; // 4\n/** AddressWithSeedMismatch: provided address does not match addressed derived from seed */\nexport const SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH = 0x5; // 5\n/** NonceNoRecentBlockhashes: advancing stored nonce requires a populated RecentBlockhashes sysvar */\nexport const SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES = 0x6; // 6\n/** NonceBlockhashNotExpired: stored nonce is still in recent_blockhashes */\nexport const SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED = 0x7; // 7\n/** NonceUnexpectedBlockhashValue: specified nonce does not match stored nonce */\nexport const SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE = 0x8; // 8\n\nexport type SystemError =\n  | typeof SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE\n  | typeof SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH\n  | typeof SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH\n  | typeof SYSTEM_ERROR__INVALID_PROGRAM_ID\n  | typeof SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED\n  | typeof SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED\n  | typeof SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES\n  | typeof SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE\n  | typeof SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS;\n\nlet systemErrorMessages: Record<SystemError, string> | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  systemErrorMessages = {\n    [SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE]: `an account with the same address already exists`,\n    [SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH]: `provided address does not match addressed derived from seed`,\n    [SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH]: `cannot allocate account data of this length`,\n    [SYSTEM_ERROR__INVALID_PROGRAM_ID]: `cannot assign account to this program id`,\n    [SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED]: `length of requested seed is too long`,\n    [SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED]: `stored nonce is still in recent_blockhashes`,\n    [SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES]: `advancing stored nonce requires a populated RecentBlockhashes sysvar`,\n    [SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE]: `specified nonce does not match stored nonce`,\n    [SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS]: `account does not have enough SOL to perform the operation`,\n  };\n}\n\nexport function getSystemErrorMessage(code: SystemError): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (systemErrorMessages as Record<SystemError, string>)[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isSystemError<TProgramErrorCode extends SystemError>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    SYSTEM_PROGRAM_ADDRESS,\n    code\n  );\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  isProgramDerivedAddress,\n  isTransactionSigner as kitIsTransactionSigner,\n  type Address,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type ProgramDerivedAddress,\n  type TransactionSigner,\n  upgradeRoleToSigner,\n} from '@solana/kit';\n\n/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value == null) {\n    throw new Error('Expected a value but received null or undefined.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): Address<T> {\n  if (!value) {\n    throw new Error('Expected a Address.');\n  }\n  if (typeof value === 'object' && 'address' in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0];\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error('Expected a ProgramDerivedAddress.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error('Expected a TransactionSigner.');\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<\n  T extends string = string,\n  U extends\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null =\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null,\n> = {\n  isWritable: boolean;\n  value: U;\n};\n\n/**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type IInstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n * Get account metas and signers from resolved accounts.\n * @internal\n */\nexport function getAccountMetaFactory(\n  programAddress: Address,\n  optionalAccountStrategy: 'omitted' | 'programId'\n) {\n  return (\n    account: ResolvedAccount\n  ): IAccountMeta | IAccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === 'omitted') return;\n      return Object.freeze({\n        address: programAddress,\n        role: AccountRole.READONLY,\n      });\n    }\n\n    const writableRole = account.isWritable\n      ? AccountRole.WRITABLE\n      : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value)\n        ? upgradeRoleToSigner(writableRole)\n        : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(\n  value:\n    | Address<TAddress>\n    | ProgramDerivedAddress<TAddress>\n    | TransactionSigner<TAddress>\n): value is TransactionSigner<TAddress> {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'address' in value &&\n    kitIsTransactionSigner(value)\n  );\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ADVANCE_NONCE_ACCOUNT_DISCRIMINATOR = 4;\n\nexport function getAdvanceNonceAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(ADVANCE_NONCE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type AdvanceNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNonceAccount extends string | IAccountMeta<string> = string,\n  TAccountRecentBlockhashesSysvar extends\n    | string\n    | IAccountMeta<string> = 'SysvarRecentB1ockHashes11111111111111111111',\n  TAccountNonceAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountNonceAccount extends string\n        ? WritableAccount<TAccountNonceAccount>\n        : TAccountNonceAccount,\n      TAccountRecentBlockhashesSysvar extends string\n        ? ReadonlyAccount<TAccountRecentBlockhashesSysvar>\n        : TAccountRecentBlockhashesSysvar,\n      TAccountNonceAuthority extends string\n        ? ReadonlySignerAccount<TAccountNonceAuthority> &\n            IAccountSignerMeta<TAccountNonceAuthority>\n        : TAccountNonceAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AdvanceNonceAccountInstructionData = { discriminator: number };\n\nexport type AdvanceNonceAccountInstructionDataArgs = {};\n\nexport function getAdvanceNonceAccountInstructionDataEncoder(): Encoder<AdvanceNonceAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU32Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: ADVANCE_NONCE_ACCOUNT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getAdvanceNonceAccountInstructionDataDecoder(): Decoder<AdvanceNonceAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU32Decoder()]]);\n}\n\nexport function getAdvanceNonceAccountInstructionDataCodec(): Codec<\n  AdvanceNonceAccountInstructionDataArgs,\n  AdvanceNonceAccountInstructionData\n> {\n  return combineCodec(\n    getAdvanceNonceAccountInstructionDataEncoder(),\n    getAdvanceNonceAccountInstructionDataDecoder()\n  );\n}\n\nexport type AdvanceNonceAccountInput<\n  TAccountNonceAccount extends string = string,\n  TAccountRecentBlockhashesSysvar extends string = string,\n  TAccountNonceAuthority extends string = string,\n> = {\n  nonceAccount: Address<TAccountNonceAccount>;\n  recentBlockhashesSysvar?: Address<TAccountRecentBlockhashesSysvar>;\n  nonceAuthority: TransactionSigner<TAccountNonceAuthority>;\n};\n\nexport function getAdvanceNonceAccountInstruction<\n  TAccountNonceAccount extends string,\n  TAccountRecentBlockhashesSysvar extends string,\n  TAccountNonceAuthority extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AdvanceNonceAccountInput<\n    TAccountNonceAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountNonceAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): AdvanceNonceAccountInstruction<\n  TProgramAddress,\n  TAccountNonceAccount,\n  TAccountRecentBlockhashesSysvar,\n  TAccountNonceAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nonceAccount: { value: input.nonceAccount ?? null, isWritable: true },\n    recentBlockhashesSysvar: {\n      value: input.recentBlockhashesSysvar ?? null,\n      isWritable: false,\n    },\n    nonceAuthority: { value: input.nonceAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.recentBlockhashesSysvar.value) {\n    accounts.recentBlockhashesSysvar.value =\n      'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.nonceAccount),\n      getAccountMeta(accounts.recentBlockhashesSysvar),\n      getAccountMeta(accounts.nonceAuthority),\n    ],\n    programAddress,\n    data: getAdvanceNonceAccountInstructionDataEncoder().encode({}),\n  } as AdvanceNonceAccountInstruction<\n    TProgramAddress,\n    TAccountNonceAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountNonceAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedAdvanceNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    nonceAccount: TAccountMetas[0];\n    recentBlockhashesSysvar: TAccountMetas[1];\n    nonceAuthority: TAccountMetas[2];\n  };\n  data: AdvanceNonceAccountInstructionData;\n};\n\nexport function parseAdvanceNonceAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAdvanceNonceAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nonceAccount: getNextAccount(),\n      recentBlockhashesSysvar: getNextAccount(),\n      nonceAuthority: getNextAccount(),\n    },\n    data: getAdvanceNonceAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type TransactionSigner,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ALLOCATE_DISCRIMINATOR = 8;\n\nexport function getAllocateDiscriminatorBytes() {\n  return getU32Encoder().encode(ALLOCATE_DISCRIMINATOR);\n}\n\nexport type AllocateInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNewAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountNewAccount extends string\n        ? WritableSignerAccount<TAccountNewAccount> &\n            IAccountSignerMeta<TAccountNewAccount>\n        : TAccountNewAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AllocateInstructionData = { discriminator: number; space: bigint };\n\nexport type AllocateInstructionDataArgs = { space: number | bigint };\n\nexport function getAllocateInstructionDataEncoder(): Encoder<AllocateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['space', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: ALLOCATE_DISCRIMINATOR })\n  );\n}\n\nexport function getAllocateInstructionDataDecoder(): Decoder<AllocateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['space', getU64Decoder()],\n  ]);\n}\n\nexport function getAllocateInstructionDataCodec(): Codec<\n  AllocateInstructionDataArgs,\n  AllocateInstructionData\n> {\n  return combineCodec(\n    getAllocateInstructionDataEncoder(),\n    getAllocateInstructionDataDecoder()\n  );\n}\n\nexport type AllocateInput<TAccountNewAccount extends string = string> = {\n  newAccount: TransactionSigner<TAccountNewAccount>;\n  space: AllocateInstructionDataArgs['space'];\n};\n\nexport function getAllocateInstruction<\n  TAccountNewAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AllocateInput<TAccountNewAccount>,\n  config?: { programAddress?: TProgramAddress }\n): AllocateInstruction<TProgramAddress, TAccountNewAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    newAccount: { value: input.newAccount ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.newAccount)],\n    programAddress,\n    data: getAllocateInstructionDataEncoder().encode(\n      args as AllocateInstructionDataArgs\n    ),\n  } as AllocateInstruction<TProgramAddress, TAccountNewAccount>;\n\n  return instruction;\n}\n\nexport type ParsedAllocateInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    newAccount: TAccountMetas[0];\n  };\n  data: AllocateInstructionData;\n};\n\nexport function parseAllocateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAllocateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      newAccount: getNextAccount(),\n    },\n    data: getAllocateInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ALLOCATE_WITH_SEED_DISCRIMINATOR = 9;\n\nexport function getAllocateWithSeedDiscriminatorBytes() {\n  return getU32Encoder().encode(ALLOCATE_WITH_SEED_DISCRIMINATOR);\n}\n\nexport type AllocateWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNewAccount extends string | IAccountMeta<string> = string,\n  TAccountBaseAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountNewAccount extends string\n        ? WritableAccount<TAccountNewAccount>\n        : TAccountNewAccount,\n      TAccountBaseAccount extends string\n        ? ReadonlySignerAccount<TAccountBaseAccount> &\n            IAccountSignerMeta<TAccountBaseAccount>\n        : TAccountBaseAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AllocateWithSeedInstructionData = {\n  discriminator: number;\n  base: Address;\n  seed: string;\n  space: bigint;\n  programAddress: Address;\n};\n\nexport type AllocateWithSeedInstructionDataArgs = {\n  base: Address;\n  seed: string;\n  space: number | bigint;\n  programAddress: Address;\n};\n\nexport function getAllocateWithSeedInstructionDataEncoder(): Encoder<AllocateWithSeedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['base', getAddressEncoder()],\n      ['seed', addEncoderSizePrefix(getUtf8Encoder(), getU64Encoder())],\n      ['space', getU64Encoder()],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: ALLOCATE_WITH_SEED_DISCRIMINATOR })\n  );\n}\n\nexport function getAllocateWithSeedInstructionDataDecoder(): Decoder<AllocateWithSeedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['base', getAddressDecoder()],\n    ['seed', addDecoderSizePrefix(getUtf8Decoder(), getU64Decoder())],\n    ['space', getU64Decoder()],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getAllocateWithSeedInstructionDataCodec(): Codec<\n  AllocateWithSeedInstructionDataArgs,\n  AllocateWithSeedInstructionData\n> {\n  return combineCodec(\n    getAllocateWithSeedInstructionDataEncoder(),\n    getAllocateWithSeedInstructionDataDecoder()\n  );\n}\n\nexport type AllocateWithSeedInput<\n  TAccountNewAccount extends string = string,\n  TAccountBaseAccount extends string = string,\n> = {\n  newAccount: Address<TAccountNewAccount>;\n  baseAccount: TransactionSigner<TAccountBaseAccount>;\n  base: AllocateWithSeedInstructionDataArgs['base'];\n  seed: AllocateWithSeedInstructionDataArgs['seed'];\n  space: AllocateWithSeedInstructionDataArgs['space'];\n  programAddress: AllocateWithSeedInstructionDataArgs['programAddress'];\n};\n\nexport function getAllocateWithSeedInstruction<\n  TAccountNewAccount extends string,\n  TAccountBaseAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AllocateWithSeedInput<TAccountNewAccount, TAccountBaseAccount>,\n  config?: { programAddress?: TProgramAddress }\n): AllocateWithSeedInstruction<\n  TProgramAddress,\n  TAccountNewAccount,\n  TAccountBaseAccount\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    newAccount: { value: input.newAccount ?? null, isWritable: true },\n    baseAccount: { value: input.baseAccount ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.newAccount),\n      getAccountMeta(accounts.baseAccount),\n    ],\n    programAddress,\n    data: getAllocateWithSeedInstructionDataEncoder().encode(\n      args as AllocateWithSeedInstructionDataArgs\n    ),\n  } as AllocateWithSeedInstruction<\n    TProgramAddress,\n    TAccountNewAccount,\n    TAccountBaseAccount\n  >;\n\n  return instruction;\n}\n\nexport type ParsedAllocateWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    newAccount: TAccountMetas[0];\n    baseAccount: TAccountMetas[1];\n  };\n  data: AllocateWithSeedInstructionData;\n};\n\nexport function parseAllocateWithSeedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAllocateWithSeedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      newAccount: getNextAccount(),\n      baseAccount: getNextAccount(),\n    },\n    data: getAllocateWithSeedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type TransactionSigner,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ASSIGN_DISCRIMINATOR = 1;\n\nexport function getAssignDiscriminatorBytes() {\n  return getU32Encoder().encode(ASSIGN_DISCRIMINATOR);\n}\n\nexport type AssignInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableSignerAccount<TAccountAccount> &\n            IAccountSignerMeta<TAccountAccount>\n        : TAccountAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AssignInstructionData = {\n  discriminator: number;\n  programAddress: Address;\n};\n\nexport type AssignInstructionDataArgs = { programAddress: Address };\n\nexport function getAssignInstructionDataEncoder(): Encoder<AssignInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: ASSIGN_DISCRIMINATOR })\n  );\n}\n\nexport function getAssignInstructionDataDecoder(): Decoder<AssignInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getAssignInstructionDataCodec(): Codec<\n  AssignInstructionDataArgs,\n  AssignInstructionData\n> {\n  return combineCodec(\n    getAssignInstructionDataEncoder(),\n    getAssignInstructionDataDecoder()\n  );\n}\n\nexport type AssignInput<TAccountAccount extends string = string> = {\n  account: TransactionSigner<TAccountAccount>;\n  programAddress: AssignInstructionDataArgs['programAddress'];\n};\n\nexport function getAssignInstruction<\n  TAccountAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AssignInput<TAccountAccount>,\n  config?: { programAddress?: TProgramAddress }\n): AssignInstruction<TProgramAddress, TAccountAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.account)],\n    programAddress,\n    data: getAssignInstructionDataEncoder().encode(\n      args as AssignInstructionDataArgs\n    ),\n  } as AssignInstruction<TProgramAddress, TAccountAccount>;\n\n  return instruction;\n}\n\nexport type ParsedAssignInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    account: TAccountMetas[0];\n  };\n  data: AssignInstructionData;\n};\n\nexport function parseAssignInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAssignInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n    },\n    data: getAssignInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ASSIGN_WITH_SEED_DISCRIMINATOR = 10;\n\nexport function getAssignWithSeedDiscriminatorBytes() {\n  return getU32Encoder().encode(ASSIGN_WITH_SEED_DISCRIMINATOR);\n}\n\nexport type AssignWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountBaseAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountBaseAccount extends string\n        ? ReadonlySignerAccount<TAccountBaseAccount> &\n            IAccountSignerMeta<TAccountBaseAccount>\n        : TAccountBaseAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AssignWithSeedInstructionData = {\n  discriminator: number;\n  base: Address;\n  seed: string;\n  programAddress: Address;\n};\n\nexport type AssignWithSeedInstructionDataArgs = {\n  base: Address;\n  seed: string;\n  programAddress: Address;\n};\n\nexport function getAssignWithSeedInstructionDataEncoder(): Encoder<AssignWithSeedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['base', getAddressEncoder()],\n      ['seed', addEncoderSizePrefix(getUtf8Encoder(), getU64Encoder())],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: ASSIGN_WITH_SEED_DISCRIMINATOR })\n  );\n}\n\nexport function getAssignWithSeedInstructionDataDecoder(): Decoder<AssignWithSeedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['base', getAddressDecoder()],\n    ['seed', addDecoderSizePrefix(getUtf8Decoder(), getU64Decoder())],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getAssignWithSeedInstructionDataCodec(): Codec<\n  AssignWithSeedInstructionDataArgs,\n  AssignWithSeedInstructionData\n> {\n  return combineCodec(\n    getAssignWithSeedInstructionDataEncoder(),\n    getAssignWithSeedInstructionDataDecoder()\n  );\n}\n\nexport type AssignWithSeedInput<\n  TAccountAccount extends string = string,\n  TAccountBaseAccount extends string = string,\n> = {\n  account: Address<TAccountAccount>;\n  baseAccount: TransactionSigner<TAccountBaseAccount>;\n  base: AssignWithSeedInstructionDataArgs['base'];\n  seed: AssignWithSeedInstructionDataArgs['seed'];\n  programAddress: AssignWithSeedInstructionDataArgs['programAddress'];\n};\n\nexport function getAssignWithSeedInstruction<\n  TAccountAccount extends string,\n  TAccountBaseAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AssignWithSeedInput<TAccountAccount, TAccountBaseAccount>,\n  config?: { programAddress?: TProgramAddress }\n): AssignWithSeedInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountBaseAccount\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    baseAccount: { value: input.baseAccount ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.baseAccount),\n    ],\n    programAddress,\n    data: getAssignWithSeedInstructionDataEncoder().encode(\n      args as AssignWithSeedInstructionDataArgs\n    ),\n  } as AssignWithSeedInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountBaseAccount\n  >;\n\n  return instruction;\n}\n\nexport type ParsedAssignWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    account: TAccountMetas[0];\n    baseAccount: TAccountMetas[1];\n  };\n  data: AssignWithSeedInstructionData;\n};\n\nexport function parseAssignWithSeedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAssignWithSeedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      baseAccount: getNextAccount(),\n    },\n    data: getAssignWithSeedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const AUTHORIZE_NONCE_ACCOUNT_DISCRIMINATOR = 7;\n\nexport function getAuthorizeNonceAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(AUTHORIZE_NONCE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type AuthorizeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNonceAccount extends string | IAccountMeta<string> = string,\n  TAccountNonceAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountNonceAccount extends string\n        ? WritableAccount<TAccountNonceAccount>\n        : TAccountNonceAccount,\n      TAccountNonceAuthority extends string\n        ? ReadonlySignerAccount<TAccountNonceAuthority> &\n            IAccountSignerMeta<TAccountNonceAuthority>\n        : TAccountNonceAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AuthorizeNonceAccountInstructionData = {\n  discriminator: number;\n  newNonceAuthority: Address;\n};\n\nexport type AuthorizeNonceAccountInstructionDataArgs = {\n  newNonceAuthority: Address;\n};\n\nexport function getAuthorizeNonceAccountInstructionDataEncoder(): Encoder<AuthorizeNonceAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['newNonceAuthority', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: AUTHORIZE_NONCE_ACCOUNT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getAuthorizeNonceAccountInstructionDataDecoder(): Decoder<AuthorizeNonceAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['newNonceAuthority', getAddressDecoder()],\n  ]);\n}\n\nexport function getAuthorizeNonceAccountInstructionDataCodec(): Codec<\n  AuthorizeNonceAccountInstructionDataArgs,\n  AuthorizeNonceAccountInstructionData\n> {\n  return combineCodec(\n    getAuthorizeNonceAccountInstructionDataEncoder(),\n    getAuthorizeNonceAccountInstructionDataDecoder()\n  );\n}\n\nexport type AuthorizeNonceAccountInput<\n  TAccountNonceAccount extends string = string,\n  TAccountNonceAuthority extends string = string,\n> = {\n  nonceAccount: Address<TAccountNonceAccount>;\n  nonceAuthority: TransactionSigner<TAccountNonceAuthority>;\n  newNonceAuthority: AuthorizeNonceAccountInstructionDataArgs['newNonceAuthority'];\n};\n\nexport function getAuthorizeNonceAccountInstruction<\n  TAccountNonceAccount extends string,\n  TAccountNonceAuthority extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AuthorizeNonceAccountInput<\n    TAccountNonceAccount,\n    TAccountNonceAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): AuthorizeNonceAccountInstruction<\n  TProgramAddress,\n  TAccountNonceAccount,\n  TAccountNonceAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nonceAccount: { value: input.nonceAccount ?? null, isWritable: true },\n    nonceAuthority: { value: input.nonceAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.nonceAccount),\n      getAccountMeta(accounts.nonceAuthority),\n    ],\n    programAddress,\n    data: getAuthorizeNonceAccountInstructionDataEncoder().encode(\n      args as AuthorizeNonceAccountInstructionDataArgs\n    ),\n  } as AuthorizeNonceAccountInstruction<\n    TProgramAddress,\n    TAccountNonceAccount,\n    TAccountNonceAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedAuthorizeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    nonceAccount: TAccountMetas[0];\n    nonceAuthority: TAccountMetas[1];\n  };\n  data: AuthorizeNonceAccountInstructionData;\n};\n\nexport function parseAuthorizeNonceAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAuthorizeNonceAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nonceAccount: getNextAccount(),\n      nonceAuthority: getNextAccount(),\n    },\n    data: getAuthorizeNonceAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  BASE_ACCOUNT_SIZE,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type TransactionSigner,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport {\n  getAccountMetaFactory,\n  type IInstructionWithByteDelta,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const CREATE_ACCOUNT_DISCRIMINATOR = 0;\n\nexport function getCreateAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(CREATE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type CreateAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountNewAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountNewAccount extends string\n        ? WritableSignerAccount<TAccountNewAccount> &\n            IAccountSignerMeta<TAccountNewAccount>\n        : TAccountNewAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAccountInstructionData = {\n  discriminator: number;\n  lamports: bigint;\n  space: bigint;\n  programAddress: Address;\n};\n\nexport type CreateAccountInstructionDataArgs = {\n  lamports: number | bigint;\n  space: number | bigint;\n  programAddress: Address;\n};\n\nexport function getCreateAccountInstructionDataEncoder(): Encoder<CreateAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['lamports', getU64Encoder()],\n      ['space', getU64Encoder()],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: CREATE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getCreateAccountInstructionDataDecoder(): Decoder<CreateAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['lamports', getU64Decoder()],\n    ['space', getU64Decoder()],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getCreateAccountInstructionDataCodec(): Codec<\n  CreateAccountInstructionDataArgs,\n  CreateAccountInstructionData\n> {\n  return combineCodec(\n    getCreateAccountInstructionDataEncoder(),\n    getCreateAccountInstructionDataDecoder()\n  );\n}\n\nexport type CreateAccountInput<\n  TAccountPayer extends string = string,\n  TAccountNewAccount extends string = string,\n> = {\n  payer: TransactionSigner<TAccountPayer>;\n  newAccount: TransactionSigner<TAccountNewAccount>;\n  lamports: CreateAccountInstructionDataArgs['lamports'];\n  space: CreateAccountInstructionDataArgs['space'];\n  programAddress: CreateAccountInstructionDataArgs['programAddress'];\n};\n\nexport function getCreateAccountInstruction<\n  TAccountPayer extends string,\n  TAccountNewAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: CreateAccountInput<TAccountPayer, TAccountNewAccount>,\n  config?: { programAddress?: TProgramAddress }\n): CreateAccountInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountNewAccount\n> &\n  IInstructionWithByteDelta {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    newAccount: { value: input.newAccount ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Bytes created or reallocated by the instruction.\n  const byteDelta: number = [Number(args.space) + BASE_ACCOUNT_SIZE].reduce(\n    (a, b) => a + b,\n    0\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.newAccount),\n    ],\n    programAddress,\n    data: getCreateAccountInstructionDataEncoder().encode(\n      args as CreateAccountInstructionDataArgs\n    ),\n  } as CreateAccountInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountNewAccount\n  >;\n\n  return Object.freeze({ ...instruction, byteDelta });\n}\n\nexport type ParsedCreateAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    payer: TAccountMetas[0];\n    newAccount: TAccountMetas[1];\n  };\n  data: CreateAccountInstructionData;\n};\n\nexport function parseCreateAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCreateAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      newAccount: getNextAccount(),\n    },\n    data: getCreateAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CREATE_ACCOUNT_WITH_SEED_DISCRIMINATOR = 3;\n\nexport function getCreateAccountWithSeedDiscriminatorBytes() {\n  return getU32Encoder().encode(CREATE_ACCOUNT_WITH_SEED_DISCRIMINATOR);\n}\n\nexport type CreateAccountWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountNewAccount extends string | IAccountMeta<string> = string,\n  TAccountBaseAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountNewAccount extends string\n        ? WritableAccount<TAccountNewAccount>\n        : TAccountNewAccount,\n      TAccountBaseAccount extends string\n        ? ReadonlySignerAccount<TAccountBaseAccount> &\n            IAccountSignerMeta<TAccountBaseAccount>\n        : TAccountBaseAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAccountWithSeedInstructionData = {\n  discriminator: number;\n  base: Address;\n  seed: string;\n  amount: bigint;\n  space: bigint;\n  programAddress: Address;\n};\n\nexport type CreateAccountWithSeedInstructionDataArgs = {\n  base: Address;\n  seed: string;\n  amount: number | bigint;\n  space: number | bigint;\n  programAddress: Address;\n};\n\nexport function getCreateAccountWithSeedInstructionDataEncoder(): Encoder<CreateAccountWithSeedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['base', getAddressEncoder()],\n      ['seed', addEncoderSizePrefix(getUtf8Encoder(), getU64Encoder())],\n      ['amount', getU64Encoder()],\n      ['space', getU64Encoder()],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_ACCOUNT_WITH_SEED_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCreateAccountWithSeedInstructionDataDecoder(): Decoder<CreateAccountWithSeedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['base', getAddressDecoder()],\n    ['seed', addDecoderSizePrefix(getUtf8Decoder(), getU64Decoder())],\n    ['amount', getU64Decoder()],\n    ['space', getU64Decoder()],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getCreateAccountWithSeedInstructionDataCodec(): Codec<\n  CreateAccountWithSeedInstructionDataArgs,\n  CreateAccountWithSeedInstructionData\n> {\n  return combineCodec(\n    getCreateAccountWithSeedInstructionDataEncoder(),\n    getCreateAccountWithSeedInstructionDataDecoder()\n  );\n}\n\nexport type CreateAccountWithSeedInput<\n  TAccountPayer extends string = string,\n  TAccountNewAccount extends string = string,\n  TAccountBaseAccount extends string = string,\n> = {\n  payer: TransactionSigner<TAccountPayer>;\n  newAccount: Address<TAccountNewAccount>;\n  baseAccount: TransactionSigner<TAccountBaseAccount>;\n  base: CreateAccountWithSeedInstructionDataArgs['base'];\n  seed: CreateAccountWithSeedInstructionDataArgs['seed'];\n  amount: CreateAccountWithSeedInstructionDataArgs['amount'];\n  space: CreateAccountWithSeedInstructionDataArgs['space'];\n  programAddress: CreateAccountWithSeedInstructionDataArgs['programAddress'];\n};\n\nexport function getCreateAccountWithSeedInstruction<\n  TAccountPayer extends string,\n  TAccountNewAccount extends string,\n  TAccountBaseAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: CreateAccountWithSeedInput<\n    TAccountPayer,\n    TAccountNewAccount,\n    TAccountBaseAccount\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateAccountWithSeedInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountNewAccount,\n  TAccountBaseAccount\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    newAccount: { value: input.newAccount ?? null, isWritable: true },\n    baseAccount: { value: input.baseAccount ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.newAccount),\n      getAccountMeta(accounts.baseAccount),\n    ],\n    programAddress,\n    data: getCreateAccountWithSeedInstructionDataEncoder().encode(\n      args as CreateAccountWithSeedInstructionDataArgs\n    ),\n  } as CreateAccountWithSeedInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountNewAccount,\n    TAccountBaseAccount\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCreateAccountWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    payer: TAccountMetas[0];\n    newAccount: TAccountMetas[1];\n    baseAccount: TAccountMetas[2];\n  };\n  data: CreateAccountWithSeedInstructionData;\n};\n\nexport function parseCreateAccountWithSeedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCreateAccountWithSeedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      newAccount: getNextAccount(),\n      baseAccount: getNextAccount(),\n    },\n    data: getCreateAccountWithSeedInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_NONCE_ACCOUNT_DISCRIMINATOR = 6;\n\nexport function getInitializeNonceAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(INITIALIZE_NONCE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type InitializeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNonceAccount extends string | IAccountMeta<string> = string,\n  TAccountRecentBlockhashesSysvar extends\n    | string\n    | IAccountMeta<string> = 'SysvarRecentB1ockHashes11111111111111111111',\n  TAccountRentSysvar extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountNonceAccount extends string\n        ? WritableAccount<TAccountNonceAccount>\n        : TAccountNonceAccount,\n      TAccountRecentBlockhashesSysvar extends string\n        ? ReadonlyAccount<TAccountRecentBlockhashesSysvar>\n        : TAccountRecentBlockhashesSysvar,\n      TAccountRentSysvar extends string\n        ? ReadonlyAccount<TAccountRentSysvar>\n        : TAccountRentSysvar,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeNonceAccountInstructionData = {\n  discriminator: number;\n  nonceAuthority: Address;\n};\n\nexport type InitializeNonceAccountInstructionDataArgs = {\n  nonceAuthority: Address;\n};\n\nexport function getInitializeNonceAccountInstructionDataEncoder(): Encoder<InitializeNonceAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['nonceAuthority', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_NONCE_ACCOUNT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeNonceAccountInstructionDataDecoder(): Decoder<InitializeNonceAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['nonceAuthority', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializeNonceAccountInstructionDataCodec(): Codec<\n  InitializeNonceAccountInstructionDataArgs,\n  InitializeNonceAccountInstructionData\n> {\n  return combineCodec(\n    getInitializeNonceAccountInstructionDataEncoder(),\n    getInitializeNonceAccountInstructionDataDecoder()\n  );\n}\n\nexport type InitializeNonceAccountInput<\n  TAccountNonceAccount extends string = string,\n  TAccountRecentBlockhashesSysvar extends string = string,\n  TAccountRentSysvar extends string = string,\n> = {\n  nonceAccount: Address<TAccountNonceAccount>;\n  recentBlockhashesSysvar?: Address<TAccountRecentBlockhashesSysvar>;\n  rentSysvar?: Address<TAccountRentSysvar>;\n  nonceAuthority: InitializeNonceAccountInstructionDataArgs['nonceAuthority'];\n};\n\nexport function getInitializeNonceAccountInstruction<\n  TAccountNonceAccount extends string,\n  TAccountRecentBlockhashesSysvar extends string,\n  TAccountRentSysvar extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: InitializeNonceAccountInput<\n    TAccountNonceAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountRentSysvar\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeNonceAccountInstruction<\n  TProgramAddress,\n  TAccountNonceAccount,\n  TAccountRecentBlockhashesSysvar,\n  TAccountRentSysvar\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nonceAccount: { value: input.nonceAccount ?? null, isWritable: true },\n    recentBlockhashesSysvar: {\n      value: input.recentBlockhashesSysvar ?? null,\n      isWritable: false,\n    },\n    rentSysvar: { value: input.rentSysvar ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.recentBlockhashesSysvar.value) {\n    accounts.recentBlockhashesSysvar.value =\n      'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\n  }\n  if (!accounts.rentSysvar.value) {\n    accounts.rentSysvar.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.nonceAccount),\n      getAccountMeta(accounts.recentBlockhashesSysvar),\n      getAccountMeta(accounts.rentSysvar),\n    ],\n    programAddress,\n    data: getInitializeNonceAccountInstructionDataEncoder().encode(\n      args as InitializeNonceAccountInstructionDataArgs\n    ),\n  } as InitializeNonceAccountInstruction<\n    TProgramAddress,\n    TAccountNonceAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountRentSysvar\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    nonceAccount: TAccountMetas[0];\n    recentBlockhashesSysvar: TAccountMetas[1];\n    rentSysvar: TAccountMetas[2];\n  };\n  data: InitializeNonceAccountInstructionData;\n};\n\nexport function parseInitializeNonceAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeNonceAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nonceAccount: getNextAccount(),\n      recentBlockhashesSysvar: getNextAccount(),\n      rentSysvar: getNextAccount(),\n    },\n    data: getInitializeNonceAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_SOL_DISCRIMINATOR = 2;\n\nexport function getTransferSolDiscriminatorBytes() {\n  return getU32Encoder().encode(TRANSFER_SOL_DISCRIMINATOR);\n}\n\nexport type TransferSolInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountDestination extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableSignerAccount<TAccountSource> &\n            IAccountSignerMeta<TAccountSource>\n        : TAccountSource,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferSolInstructionData = {\n  discriminator: number;\n  amount: bigint;\n};\n\nexport type TransferSolInstructionDataArgs = { amount: number | bigint };\n\nexport function getTransferSolInstructionDataEncoder(): Encoder<TransferSolInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TRANSFER_SOL_DISCRIMINATOR })\n  );\n}\n\nexport function getTransferSolInstructionDataDecoder(): Decoder<TransferSolInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getTransferSolInstructionDataCodec(): Codec<\n  TransferSolInstructionDataArgs,\n  TransferSolInstructionData\n> {\n  return combineCodec(\n    getTransferSolInstructionDataEncoder(),\n    getTransferSolInstructionDataDecoder()\n  );\n}\n\nexport type TransferSolInput<\n  TAccountSource extends string = string,\n  TAccountDestination extends string = string,\n> = {\n  source: TransactionSigner<TAccountSource>;\n  destination: Address<TAccountDestination>;\n  amount: TransferSolInstructionDataArgs['amount'];\n};\n\nexport function getTransferSolInstruction<\n  TAccountSource extends string,\n  TAccountDestination extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: TransferSolInput<TAccountSource, TAccountDestination>,\n  config?: { programAddress?: TProgramAddress }\n): TransferSolInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountDestination\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.destination),\n    ],\n    programAddress,\n    data: getTransferSolInstructionDataEncoder().encode(\n      args as TransferSolInstructionDataArgs\n    ),\n  } as TransferSolInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountDestination\n  >;\n\n  return instruction;\n}\n\nexport type ParsedTransferSolInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    source: TAccountMetas[0];\n    destination: TAccountMetas[1];\n  };\n  data: TransferSolInstructionData;\n};\n\nexport function parseTransferSolInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedTransferSolInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      destination: getNextAccount(),\n    },\n    data: getTransferSolInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_SOL_WITH_SEED_DISCRIMINATOR = 11;\n\nexport function getTransferSolWithSeedDiscriminatorBytes() {\n  return getU32Encoder().encode(TRANSFER_SOL_WITH_SEED_DISCRIMINATOR);\n}\n\nexport type TransferSolWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountBaseAccount extends string | IAccountMeta<string> = string,\n  TAccountDestination extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountBaseAccount extends string\n        ? ReadonlySignerAccount<TAccountBaseAccount> &\n            IAccountSignerMeta<TAccountBaseAccount>\n        : TAccountBaseAccount,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferSolWithSeedInstructionData = {\n  discriminator: number;\n  amount: bigint;\n  fromSeed: string;\n  fromOwner: Address;\n};\n\nexport type TransferSolWithSeedInstructionDataArgs = {\n  amount: number | bigint;\n  fromSeed: string;\n  fromOwner: Address;\n};\n\nexport function getTransferSolWithSeedInstructionDataEncoder(): Encoder<TransferSolWithSeedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['amount', getU64Encoder()],\n      ['fromSeed', addEncoderSizePrefix(getUtf8Encoder(), getU64Encoder())],\n      ['fromOwner', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: TRANSFER_SOL_WITH_SEED_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getTransferSolWithSeedInstructionDataDecoder(): Decoder<TransferSolWithSeedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['amount', getU64Decoder()],\n    ['fromSeed', addDecoderSizePrefix(getUtf8Decoder(), getU64Decoder())],\n    ['fromOwner', getAddressDecoder()],\n  ]);\n}\n\nexport function getTransferSolWithSeedInstructionDataCodec(): Codec<\n  TransferSolWithSeedInstructionDataArgs,\n  TransferSolWithSeedInstructionData\n> {\n  return combineCodec(\n    getTransferSolWithSeedInstructionDataEncoder(),\n    getTransferSolWithSeedInstructionDataDecoder()\n  );\n}\n\nexport type TransferSolWithSeedInput<\n  TAccountSource extends string = string,\n  TAccountBaseAccount extends string = string,\n  TAccountDestination extends string = string,\n> = {\n  source: Address<TAccountSource>;\n  baseAccount: TransactionSigner<TAccountBaseAccount>;\n  destination: Address<TAccountDestination>;\n  amount: TransferSolWithSeedInstructionDataArgs['amount'];\n  fromSeed: TransferSolWithSeedInstructionDataArgs['fromSeed'];\n  fromOwner: TransferSolWithSeedInstructionDataArgs['fromOwner'];\n};\n\nexport function getTransferSolWithSeedInstruction<\n  TAccountSource extends string,\n  TAccountBaseAccount extends string,\n  TAccountDestination extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: TransferSolWithSeedInput<\n    TAccountSource,\n    TAccountBaseAccount,\n    TAccountDestination\n  >,\n  config?: { programAddress?: TProgramAddress }\n): TransferSolWithSeedInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountBaseAccount,\n  TAccountDestination\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    baseAccount: { value: input.baseAccount ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.baseAccount),\n      getAccountMeta(accounts.destination),\n    ],\n    programAddress,\n    data: getTransferSolWithSeedInstructionDataEncoder().encode(\n      args as TransferSolWithSeedInstructionDataArgs\n    ),\n  } as TransferSolWithSeedInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountBaseAccount,\n    TAccountDestination\n  >;\n\n  return instruction;\n}\n\nexport type ParsedTransferSolWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    source: TAccountMetas[0];\n    baseAccount: TAccountMetas[1];\n    destination: TAccountMetas[2];\n  };\n  data: TransferSolWithSeedInstructionData;\n};\n\nexport function parseTransferSolWithSeedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedTransferSolWithSeedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      baseAccount: getNextAccount(),\n      destination: getNextAccount(),\n    },\n    data: getTransferSolWithSeedInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPGRADE_NONCE_ACCOUNT_DISCRIMINATOR = 12;\n\nexport function getUpgradeNonceAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(UPGRADE_NONCE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type UpgradeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNonceAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountNonceAccount extends string\n        ? WritableAccount<TAccountNonceAccount>\n        : TAccountNonceAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpgradeNonceAccountInstructionData = { discriminator: number };\n\nexport type UpgradeNonceAccountInstructionDataArgs = {};\n\nexport function getUpgradeNonceAccountInstructionDataEncoder(): Encoder<UpgradeNonceAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU32Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: UPGRADE_NONCE_ACCOUNT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpgradeNonceAccountInstructionDataDecoder(): Decoder<UpgradeNonceAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU32Decoder()]]);\n}\n\nexport function getUpgradeNonceAccountInstructionDataCodec(): Codec<\n  UpgradeNonceAccountInstructionDataArgs,\n  UpgradeNonceAccountInstructionData\n> {\n  return combineCodec(\n    getUpgradeNonceAccountInstructionDataEncoder(),\n    getUpgradeNonceAccountInstructionDataDecoder()\n  );\n}\n\nexport type UpgradeNonceAccountInput<\n  TAccountNonceAccount extends string = string,\n> = {\n  nonceAccount: Address<TAccountNonceAccount>;\n};\n\nexport function getUpgradeNonceAccountInstruction<\n  TAccountNonceAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: UpgradeNonceAccountInput<TAccountNonceAccount>,\n  config?: { programAddress?: TProgramAddress }\n): UpgradeNonceAccountInstruction<TProgramAddress, TAccountNonceAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nonceAccount: { value: input.nonceAccount ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.nonceAccount)],\n    programAddress,\n    data: getUpgradeNonceAccountInstructionDataEncoder().encode({}),\n  } as UpgradeNonceAccountInstruction<TProgramAddress, TAccountNonceAccount>;\n\n  return instruction;\n}\n\nexport type ParsedUpgradeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    nonceAccount: TAccountMetas[0];\n  };\n  data: UpgradeNonceAccountInstructionData;\n};\n\nexport function parseUpgradeNonceAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpgradeNonceAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nonceAccount: getNextAccount(),\n    },\n    data: getUpgradeNonceAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const WITHDRAW_NONCE_ACCOUNT_DISCRIMINATOR = 5;\n\nexport function getWithdrawNonceAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(WITHDRAW_NONCE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type WithdrawNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNonceAccount extends string | IAccountMeta<string> = string,\n  TAccountRecipientAccount extends string | IAccountMeta<string> = string,\n  TAccountRecentBlockhashesSysvar extends\n    | string\n    | IAccountMeta<string> = 'SysvarRecentB1ockHashes11111111111111111111',\n  TAccountRentSysvar extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TAccountNonceAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountNonceAccount extends string\n        ? WritableAccount<TAccountNonceAccount>\n        : TAccountNonceAccount,\n      TAccountRecipientAccount extends string\n        ? WritableAccount<TAccountRecipientAccount>\n        : TAccountRecipientAccount,\n      TAccountRecentBlockhashesSysvar extends string\n        ? ReadonlyAccount<TAccountRecentBlockhashesSysvar>\n        : TAccountRecentBlockhashesSysvar,\n      TAccountRentSysvar extends string\n        ? ReadonlyAccount<TAccountRentSysvar>\n        : TAccountRentSysvar,\n      TAccountNonceAuthority extends string\n        ? ReadonlySignerAccount<TAccountNonceAuthority> &\n            IAccountSignerMeta<TAccountNonceAuthority>\n        : TAccountNonceAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawNonceAccountInstructionData = {\n  discriminator: number;\n  withdrawAmount: bigint;\n};\n\nexport type WithdrawNonceAccountInstructionDataArgs = {\n  withdrawAmount: number | bigint;\n};\n\nexport function getWithdrawNonceAccountInstructionDataEncoder(): Encoder<WithdrawNonceAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['withdrawAmount', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_NONCE_ACCOUNT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawNonceAccountInstructionDataDecoder(): Decoder<WithdrawNonceAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['withdrawAmount', getU64Decoder()],\n  ]);\n}\n\nexport function getWithdrawNonceAccountInstructionDataCodec(): Codec<\n  WithdrawNonceAccountInstructionDataArgs,\n  WithdrawNonceAccountInstructionData\n> {\n  return combineCodec(\n    getWithdrawNonceAccountInstructionDataEncoder(),\n    getWithdrawNonceAccountInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawNonceAccountInput<\n  TAccountNonceAccount extends string = string,\n  TAccountRecipientAccount extends string = string,\n  TAccountRecentBlockhashesSysvar extends string = string,\n  TAccountRentSysvar extends string = string,\n  TAccountNonceAuthority extends string = string,\n> = {\n  nonceAccount: Address<TAccountNonceAccount>;\n  recipientAccount: Address<TAccountRecipientAccount>;\n  recentBlockhashesSysvar?: Address<TAccountRecentBlockhashesSysvar>;\n  rentSysvar?: Address<TAccountRentSysvar>;\n  nonceAuthority: TransactionSigner<TAccountNonceAuthority>;\n  withdrawAmount: WithdrawNonceAccountInstructionDataArgs['withdrawAmount'];\n};\n\nexport function getWithdrawNonceAccountInstruction<\n  TAccountNonceAccount extends string,\n  TAccountRecipientAccount extends string,\n  TAccountRecentBlockhashesSysvar extends string,\n  TAccountRentSysvar extends string,\n  TAccountNonceAuthority extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: WithdrawNonceAccountInput<\n    TAccountNonceAccount,\n    TAccountRecipientAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountRentSysvar,\n    TAccountNonceAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawNonceAccountInstruction<\n  TProgramAddress,\n  TAccountNonceAccount,\n  TAccountRecipientAccount,\n  TAccountRecentBlockhashesSysvar,\n  TAccountRentSysvar,\n  TAccountNonceAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nonceAccount: { value: input.nonceAccount ?? null, isWritable: true },\n    recipientAccount: {\n      value: input.recipientAccount ?? null,\n      isWritable: true,\n    },\n    recentBlockhashesSysvar: {\n      value: input.recentBlockhashesSysvar ?? null,\n      isWritable: false,\n    },\n    rentSysvar: { value: input.rentSysvar ?? null, isWritable: false },\n    nonceAuthority: { value: input.nonceAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.recentBlockhashesSysvar.value) {\n    accounts.recentBlockhashesSysvar.value =\n      'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\n  }\n  if (!accounts.rentSysvar.value) {\n    accounts.rentSysvar.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.nonceAccount),\n      getAccountMeta(accounts.recipientAccount),\n      getAccountMeta(accounts.recentBlockhashesSysvar),\n      getAccountMeta(accounts.rentSysvar),\n      getAccountMeta(accounts.nonceAuthority),\n    ],\n    programAddress,\n    data: getWithdrawNonceAccountInstructionDataEncoder().encode(\n      args as WithdrawNonceAccountInstructionDataArgs\n    ),\n  } as WithdrawNonceAccountInstruction<\n    TProgramAddress,\n    TAccountNonceAccount,\n    TAccountRecipientAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountRentSysvar,\n    TAccountNonceAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedWithdrawNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    nonceAccount: TAccountMetas[0];\n    recipientAccount: TAccountMetas[1];\n    recentBlockhashesSysvar: TAccountMetas[2];\n    rentSysvar: TAccountMetas[3];\n    nonceAuthority: TAccountMetas[4];\n  };\n  data: WithdrawNonceAccountInstructionData;\n};\n\nexport function parseWithdrawNonceAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedWithdrawNonceAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nonceAccount: getNextAccount(),\n      recipientAccount: getNextAccount(),\n      recentBlockhashesSysvar: getNextAccount(),\n      rentSysvar: getNextAccount(),\n      nonceAuthority: getNextAccount(),\n    },\n    data: getWithdrawNonceAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "import { findAssociatedTokenPda, TOKEN_2022_PROGRAM_ADDRESS } from \"@solana-program/token-2022\";\nimport { isAddress, type Address, type TransactionSigner } from \"@solana/kit\";\nimport { checkedAddress } from \"../../core/utils\";\n\nexport type LegacyTokenProgramMonikers = \"legacy\" | \"token\";\n\nexport type TokenExtensionProgramMonikers = \"token22\" | \"tokenExtension\" | \"tokenExtensions\" | \"token2022\";\n\nexport type TokenProgramMonikers = LegacyTokenProgramMonikers | TokenExtensionProgramMonikers;\n\nexport const TOKEN_PROGRAM_ADDRESS =\n  \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\" as Address<\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\">;\n\n/**\n * Derive the associated token account (ata) address for an owner and mint/tokenProgram\n *\n * @argument `mint` - the token mint itself\n * @argument `owner` - destination wallet address to own tokens from `mint`\n * @argument `tokenProgram` - token program that the token `mint` was created with\n *\n * - (default) {@link TOKEN_PROGRAM_ADDRESS} - the original SPL Token Program\n * - {@link TOKEN_2022_PROGRAM_ADDRESS} - the SPL Token Extensions Program (aka Token22)\n */\nexport async function getAssociatedTokenAccountAddress(\n  mint: Address | TransactionSigner,\n  owner: Address | TransactionSigner,\n  tokenProgram?: Address,\n): Promise<Address> {\n  return (\n    await findAssociatedTokenPda({\n      mint: checkedAddress(mint),\n      owner: checkedAddress(owner),\n      tokenProgram: checkedTokenProgramAddress(tokenProgram),\n    })\n  )[0];\n}\n\nexport function parseTokenProgramAddressOrMoniker(tokenProgram: Address | TokenProgramMonikers): Address {\n  if (!isAddress(tokenProgram)) {\n    tokenProgram = tokenProgram.toLowerCase() as TokenProgramMonikers;\n  }\n  switch (tokenProgram) {\n    case \"legacy\":\n    case \"token\":\n    case TOKEN_PROGRAM_ADDRESS: {\n      return TOKEN_PROGRAM_ADDRESS;\n    }\n    case \"token22\":\n    case \"token2022\":\n    case \"tokenextension\":\n    case \"tokenextensions\":\n    case TOKEN_2022_PROGRAM_ADDRESS: {\n      return TOKEN_2022_PROGRAM_ADDRESS;\n    }\n    default:\n      throw Error(\"Unsupported token program. Try 'TOKEN_PROGRAM_ADDRESS' or 'TOKEN_2022_PROGRAM_ADDRESS'\");\n  }\n}\n\nexport function assertIsSupportedTokenProgram(\n  tokenProgram: Address,\n): asserts tokenProgram is Address<typeof tokenProgram> {\n  if (tokenProgram !== TOKEN_PROGRAM_ADDRESS && tokenProgram !== TOKEN_2022_PROGRAM_ADDRESS) {\n    throw Error(\"Unsupported token program. Try 'TOKEN_PROGRAM_ADDRESS' or 'TOKEN_2022_PROGRAM_ADDRESS'\");\n  }\n}\n\n/**\n * Check the provided program is one of the supported token programs.\n * Including setting the default to {@link TOKEN_PROGRAM_ADDRESS} (the original SPL token program)\n *\n * @example\n * ```\n * args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n * ```\n */\nexport function checkedTokenProgramAddress(tokenProgram?: Address | TokenProgramMonikers): Address {\n  if (!tokenProgram) return TOKEN_PROGRAM_ADDRESS;\n  tokenProgram = parseTokenProgramAddressOrMoniker(tokenProgram);\n  assertIsSupportedTokenProgram(tokenProgram);\n  return tokenProgram;\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from \"@solana/kit\";\n\nexport type Collection = { verified: boolean; key: Address };\n\nexport type CollectionArgs = Collection;\n\nexport function getCollectionEncoder(): Encoder<CollectionArgs> {\n  return getStructEncoder([\n    [\"verified\", getBooleanEncoder()],\n    [\"key\", getAddressEncoder()],\n  ]);\n}\n\nexport function getCollectionDecoder(): Decoder<Collection> {\n  return getStructDecoder([\n    [\"verified\", getBooleanDecoder()],\n    [\"key\", getAddressDecoder()],\n  ]);\n}\n\nexport function getCollectionCodec(): Codec<CollectionArgs, Collection> {\n  return combineCodec(getCollectionEncoder(), getCollectionDecoder());\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getDiscriminatedUnionDecoder,\n  getDiscriminatedUnionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type GetDiscriminatedUnionVariant,\n  type GetDiscriminatedUnionVariantContent,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\n\nexport type CollectionDetails =\n  | { __kind: 'V1'; size: bigint }\n  | { __kind: 'V2'; padding: ReadonlyUint8Array };\n\nexport type CollectionDetailsArgs =\n  | { __kind: 'V1'; size: number | bigint }\n  | { __kind: 'V2'; padding: ReadonlyUint8Array };\n\nexport function getCollectionDetailsEncoder(): Encoder<CollectionDetailsArgs> {\n  return getDiscriminatedUnionEncoder([\n    ['V1', getStructEncoder([['size', getU64Encoder()]])],\n    [\n      'V2',\n      getStructEncoder([['padding', fixEncoderSize(getBytesEncoder(), 8)]]),\n    ],\n  ]);\n}\n\nexport function getCollectionDetailsDecoder(): Decoder<CollectionDetails> {\n  return getDiscriminatedUnionDecoder([\n    ['V1', getStructDecoder([['size', getU64Decoder()]])],\n    [\n      'V2',\n      getStructDecoder([['padding', fixDecoderSize(getBytesDecoder(), 8)]]),\n    ],\n  ]);\n}\n\nexport function getCollectionDetailsCodec(): Codec<\n  CollectionDetailsArgs,\n  CollectionDetails\n> {\n  return combineCodec(\n    getCollectionDetailsEncoder(),\n    getCollectionDetailsDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function collectionDetails(\n  kind: 'V1',\n  data: GetDiscriminatedUnionVariantContent<\n    CollectionDetailsArgs,\n    '__kind',\n    'V1'\n  >\n): GetDiscriminatedUnionVariant<CollectionDetailsArgs, '__kind', 'V1'>;\nexport function collectionDetails(\n  kind: 'V2',\n  data: GetDiscriminatedUnionVariantContent<\n    CollectionDetailsArgs,\n    '__kind',\n    'V2'\n  >\n): GetDiscriminatedUnionVariant<CollectionDetailsArgs, '__kind', 'V2'>;\nexport function collectionDetails<\n  K extends CollectionDetailsArgs['__kind'],\n  Data,\n>(kind: K, data?: Data) {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isCollectionDetails<K extends CollectionDetails['__kind']>(\n  kind: K,\n  value: CollectionDetails\n): value is CollectionDetails & { __kind: K } {\n  return value.__kind === kind;\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport type Creator = { address: Address; verified: boolean; share: number };\n\nexport type CreatorArgs = Creator;\n\nexport function getCreatorEncoder(): Encoder<CreatorArgs> {\n  return getStructEncoder([\n    ['address', getAddressEncoder()],\n    ['verified', getBooleanEncoder()],\n    ['share', getU8Encoder()],\n  ]);\n}\n\nexport function getCreatorDecoder(): Decoder<Creator> {\n  return getStructDecoder([\n    ['address', getAddressDecoder()],\n    ['verified', getBooleanDecoder()],\n    ['share', getU8Decoder()],\n  ]);\n}\n\nexport function getCreatorCodec(): Codec<CreatorArgs, Creator> {\n  return combineCodec(getCreatorEncoder(), getCreatorDecoder());\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getArrayDecoder,\n  getArrayEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/kit';\nimport {\n  getCollectionDecoder,\n  getCollectionEncoder,\n  getCreatorDecoder,\n  getCreatorEncoder,\n  getUsesDecoder,\n  getUsesEncoder,\n  type Collection,\n  type CollectionArgs,\n  type Creator,\n  type CreatorArgs,\n  type Uses,\n  type UsesArgs,\n} from '.';\n\nexport type DataV2 = {\n  name: string;\n  symbol: string;\n  uri: string;\n  sellerFeeBasisPoints: number;\n  creators: Option<Array<Creator>>;\n  collection: Option<Collection>;\n  uses: Option<Uses>;\n};\n\nexport type DataV2Args = {\n  name: string;\n  symbol: string;\n  uri: string;\n  sellerFeeBasisPoints: number;\n  creators: OptionOrNullable<Array<CreatorArgs>>;\n  collection: OptionOrNullable<CollectionArgs>;\n  uses: OptionOrNullable<UsesArgs>;\n};\n\nexport function getDataV2Encoder(): Encoder<DataV2Args> {\n  return getStructEncoder([\n    ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ['symbol', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ['sellerFeeBasisPoints', getU16Encoder()],\n    ['creators', getOptionEncoder(getArrayEncoder(getCreatorEncoder()))],\n    ['collection', getOptionEncoder(getCollectionEncoder())],\n    ['uses', getOptionEncoder(getUsesEncoder())],\n  ]);\n}\n\nexport function getDataV2Decoder(): Decoder<DataV2> {\n  return getStructDecoder([\n    ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['symbol', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['sellerFeeBasisPoints', getU16Decoder()],\n    ['creators', getOptionDecoder(getArrayDecoder(getCreatorDecoder()))],\n    ['collection', getOptionDecoder(getCollectionDecoder())],\n    ['uses', getOptionDecoder(getUsesDecoder())],\n  ]);\n}\n\nexport function getDataV2Codec(): Codec<DataV2Args, DataV2> {\n  return combineCodec(getDataV2Encoder(), getDataV2Decoder());\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\nimport {\n  getUseMethodDecoder,\n  getUseMethodEncoder,\n  type UseMethod,\n  type UseMethodArgs,\n} from '.';\n\nexport type Uses = { useMethod: UseMethod; remaining: bigint; total: bigint };\n\nexport type UsesArgs = {\n  useMethod: UseMethodArgs;\n  remaining: number | bigint;\n  total: number | bigint;\n};\n\nexport function getUsesEncoder(): Encoder<UsesArgs> {\n  return getStructEncoder([\n    ['useMethod', getUseMethodEncoder()],\n    ['remaining', getU64Encoder()],\n    ['total', getU64Encoder()],\n  ]);\n}\n\nexport function getUsesDecoder(): Decoder<Uses> {\n  return getStructDecoder([\n    ['useMethod', getUseMethodDecoder()],\n    ['remaining', getU64Decoder()],\n    ['total', getU64Decoder()],\n  ]);\n}\n\nexport function getUsesCodec(): Codec<UsesArgs, Uses> {\n  return combineCodec(getUsesEncoder(), getUsesDecoder());\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport enum UseMethod {\n  Burn,\n  Multiple,\n  Single,\n}\n\nexport type UseMethodArgs = UseMethod;\n\nexport function getUseMethodEncoder(): Encoder<UseMethodArgs> {\n  return getEnumEncoder(UseMethod);\n}\n\nexport function getUseMethodDecoder(): Decoder<UseMethod> {\n  return getEnumDecoder(UseMethod);\n}\n\nexport function getUseMethodCodec(): Codec<UseMethodArgs, UseMethod> {\n  return combineCodec(getUseMethodEncoder(), getUseMethodDecoder());\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport { type Address } from \"@solana/kit\";\n\nexport const TOKEN_METADATA_PROGRAM_ADDRESS =\n  \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\" as Address<\"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\">;\n\nexport enum TokenMetadataAccount {\n  CollectionAuthorityRecord,\n  MetadataDelegateRecord,\n  HolderDelegateRecord,\n  Edition,\n  EditionMarker,\n  EditionMarkerV2,\n  TokenOwnedEscrow,\n  MasterEditionV2,\n  MasterEditionV1,\n  Metadata,\n  TokenRecord,\n  ReservationListV2,\n  ReservationListV1,\n  UseAuthorityRecord,\n}\n\nexport enum TokenMetadataInstruction {\n  CreateMetadataAccount,\n  UpdateMetadataAccount,\n  DeprecatedCreateMasterEdition,\n  DeprecatedMintNewEditionFromMasterEditionViaPrintingToken,\n  UpdatePrimarySaleHappenedViaToken,\n  DeprecatedSetReservationList,\n  DeprecatedCreateReservationList,\n  SignMetadata,\n  DeprecatedMintPrintingTokensViaToken,\n  DeprecatedMintPrintingTokens,\n  CreateMasterEdition,\n  MintNewEditionFromMasterEditionViaToken,\n  ConvertMasterEditionV1ToV2,\n  MintNewEditionFromMasterEditionViaVaultProxy,\n  PuffMetadata,\n  UpdateMetadataAccountV2,\n  CreateMetadataAccountV2,\n  CreateMasterEditionV3,\n  VerifyCollection,\n  Utilize,\n  ApproveUseAuthority,\n  RevokeUseAuthority,\n  UnverifyCollection,\n  ApproveCollectionAuthority,\n  RevokeCollectionAuthority,\n  SetAndVerifyCollection,\n  FreezeDelegatedAccount,\n  ThawDelegatedAccount,\n  RemoveCreatorVerification,\n  BurnNft,\n  VerifySizedCollectionItem,\n  UnverifySizedCollectionItem,\n  SetAndVerifySizedCollectionItem,\n  CreateMetadataAccountV3,\n  SetCollectionSize,\n  SetTokenStandard,\n  BubblegumSetCollectionSize,\n  BurnEditionNft,\n  CreateEscrowAccount,\n  CloseEscrowAccount,\n  TransferOutOfEscrow,\n  Burn,\n  Create,\n  Mint,\n  Delegate,\n  Revoke,\n  Lock,\n  Unlock,\n  Migrate,\n  Transfer,\n  Update,\n  Use,\n  Verify,\n  Unverify,\n  Collect,\n  Print,\n  Resize,\n  CloseAccounts,\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * And vendored in from various codama generated client to help\n * minimize redundancy and bundle sizes\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport { isProgramDerivedAddress, type Address, type ProgramDerivedAddress } from \"@solana/kit\";\nimport { AccountRole, type IAccountMeta, upgradeRoleToSigner } from \"@solana/kit\";\nimport {\n  isTransactionSigner as web3JsIsTransactionSigner,\n  type IAccountSignerMeta,\n  type TransactionSigner,\n} from \"@solana/kit\";\n\n/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value == null) {\n    throw new Error(\"Expected a value but received null or undefined.\");\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value: Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null | undefined,\n): Address<T> {\n  if (!value) {\n    throw new Error(\"Expected a Address.\");\n  }\n  if (typeof value === \"object\" && \"address\" in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0];\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value: Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null | undefined,\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error(\"Expected a ProgramDerivedAddress.\");\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value: Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null | undefined,\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error(\"Expected a TransactionSigner.\");\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<\n  T extends string = string,\n  U extends Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null =\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null,\n> = {\n  isWritable: boolean;\n  value: U;\n};\n\n/**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type IInstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n * Get account metas and signers from resolved accounts.\n * @internal\n */\nexport function getAccountMetaFactory(programAddress: Address, optionalAccountStrategy: \"omitted\" | \"programId\") {\n  return (account: ResolvedAccount): IAccountMeta | IAccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === \"omitted\") return;\n      return Object.freeze({\n        address: programAddress,\n        role: AccountRole.READONLY,\n      });\n    }\n\n    const writableRole = account.isWritable ? AccountRole.WRITABLE : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value) ? upgradeRoleToSigner(writableRole) : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(\n  value: Address<TAddress> | ProgramDerivedAddress<TAddress> | TransactionSigner<TAddress>,\n): value is TransactionSigner<TAddress> {\n  return !!value && typeof value === \"object\" && \"address\" in value && web3JsIsTransactionSigner(value);\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n} from \"@solana/codecs\";\nimport type {\n  Address,\n  IAccountMeta,\n  IAccountSignerMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n  ReadonlySignerAccount,\n  TransactionSigner,\n  WritableAccount,\n  WritableSignerAccount,\n} from \"@solana/kit\";\n\nimport { getAccountMetaFactory, type ResolvedAccount } from \"../../../shared\";\nimport { TOKEN_METADATA_PROGRAM_ADDRESS } from \"../programs\";\nimport {\n  getCollectionDetailsDecoder,\n  getCollectionDetailsEncoder,\n  getDataV2Decoder,\n  getDataV2Encoder,\n  type CollectionDetails,\n  type CollectionDetailsArgs,\n  type DataV2,\n  type DataV2Args,\n} from \"../types\";\n\nexport const CREATE_METADATA_ACCOUNT_V3_DISCRIMINATOR = 33;\n\nexport function getCreateMetadataAccountV3DiscriminatorBytes(): ReadonlyUint8Array {\n  return getU8Encoder().encode(CREATE_METADATA_ACCOUNT_V3_DISCRIMINATOR);\n}\n\nexport type CreateMetadataAccountV3Instruction<\n  TProgram extends string = typeof TOKEN_METADATA_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountMintAuthority extends string | IAccountMeta<string> = string,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends string | IAccountMeta<string> = \"11111111111111111111111111111111\",\n  TAccountRent extends string | IAccountMeta<string> | undefined = undefined,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMetadata extends string ? WritableAccount<TAccountMetadata> : TAccountMetadata,\n      TAccountMint extends string ? ReadonlyAccount<TAccountMint> : TAccountMint,\n      TAccountMintAuthority extends string\n        ? ReadonlySignerAccount<TAccountMintAuthority> & IAccountSignerMeta<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> & IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountUpdateAuthority extends string ? ReadonlyAccount<TAccountUpdateAuthority> : TAccountUpdateAuthority,\n      TAccountSystemProgram extends string ? ReadonlyAccount<TAccountSystemProgram> : TAccountSystemProgram,\n      ...(TAccountRent extends undefined\n        ? []\n        : [TAccountRent extends string ? ReadonlyAccount<TAccountRent> : TAccountRent]),\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateMetadataAccountV3InstructionData = {\n  discriminator: number;\n  data: DataV2;\n  isMutable: boolean;\n  collectionDetails: Option<CollectionDetails>;\n};\n\nexport type CreateMetadataAccountV3InstructionDataArgs = {\n  data: DataV2Args;\n  isMutable: boolean;\n  collectionDetails: OptionOrNullable<CollectionDetailsArgs>;\n};\n\nexport function getCreateMetadataAccountV3InstructionDataEncoder(): Encoder<CreateMetadataAccountV3InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"data\", getDataV2Encoder()],\n      [\"isMutable\", getBooleanEncoder()],\n      [\"collectionDetails\", getOptionEncoder(getCollectionDetailsEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_METADATA_ACCOUNT_V3_DISCRIMINATOR,\n    }),\n  );\n}\n\nexport function getCreateMetadataAccountV3InstructionDataDecoder(): Decoder<CreateMetadataAccountV3InstructionData> {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"data\", getDataV2Decoder()],\n    [\"isMutable\", getBooleanDecoder()],\n    [\"collectionDetails\", getOptionDecoder(getCollectionDetailsDecoder())],\n  ]);\n}\n\nexport function getCreateMetadataAccountV3InstructionDataCodec(): Codec<\n  CreateMetadataAccountV3InstructionDataArgs,\n  CreateMetadataAccountV3InstructionData\n> {\n  return combineCodec(\n    getCreateMetadataAccountV3InstructionDataEncoder(),\n    getCreateMetadataAccountV3InstructionDataDecoder(),\n  );\n}\n\nexport type CreateMetadataAccountV3Input<\n  TAccountMetadata extends string = string,\n  TAccountMint extends string = string,\n  TAccountMintAuthority extends string = string,\n  TAccountPayer extends string = string,\n  TAccountUpdateAuthority extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** Metadata key (pda of ['metadata', program id, mint id]) */\n  metadata: Address<TAccountMetadata>;\n  /** Mint of token asset */\n  mint: Address<TAccountMint>;\n  /** Mint authority */\n  mintAuthority: TransactionSigner<TAccountMintAuthority>;\n  /** payer */\n  payer: TransactionSigner<TAccountPayer>;\n  /** update authority info */\n  updateAuthority: Address<TAccountUpdateAuthority> | TransactionSigner<TAccountUpdateAuthority>;\n  /** System program */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** Rent info */\n  rent?: Address<TAccountRent>;\n  data: CreateMetadataAccountV3InstructionDataArgs[\"data\"];\n  isMutable: CreateMetadataAccountV3InstructionDataArgs[\"isMutable\"];\n  collectionDetails: CreateMetadataAccountV3InstructionDataArgs[\"collectionDetails\"];\n};\n\nexport function getCreateMetadataAccountV3Instruction<\n  TAccountMetadata extends string,\n  TAccountMint extends string,\n  TAccountMintAuthority extends string,\n  TAccountPayer extends string,\n  TAccountUpdateAuthority extends string,\n  TAccountSystemProgram extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_METADATA_PROGRAM_ADDRESS,\n>(\n  input: CreateMetadataAccountV3Input<\n    TAccountMetadata,\n    TAccountMint,\n    TAccountMintAuthority,\n    TAccountPayer,\n    TAccountUpdateAuthority,\n    TAccountSystemProgram,\n    TAccountRent\n  >,\n  config?: { programAddress?: TProgramAddress },\n): CreateMetadataAccountV3Instruction<\n  TProgramAddress,\n  TAccountMetadata,\n  TAccountMint,\n  TAccountMintAuthority,\n  TAccountPayer,\n  (typeof input)[\"updateAuthority\"] extends TransactionSigner<TAccountUpdateAuthority>\n    ? ReadonlySignerAccount<TAccountUpdateAuthority> & IAccountSignerMeta<TAccountUpdateAuthority>\n    : TAccountUpdateAuthority,\n  TAccountSystemProgram,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_METADATA_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n    payer: { value: input.payer ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value = \"11111111111111111111111111111111\" as Address<\"11111111111111111111111111111111\">;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, \"omitted\");\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.mintAuthority),\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.updateAuthority),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.rent),\n    ].filter(<T>(x: T | undefined): x is T => x !== undefined),\n    programAddress,\n    data: getCreateMetadataAccountV3InstructionDataEncoder().encode(args as CreateMetadataAccountV3InstructionDataArgs),\n  } as CreateMetadataAccountV3Instruction<\n    TProgramAddress,\n    TAccountMetadata,\n    TAccountMint,\n    TAccountMintAuthority,\n    TAccountPayer,\n    (typeof input)[\"updateAuthority\"] extends TransactionSigner<TAccountUpdateAuthority>\n      ? ReadonlySignerAccount<TAccountUpdateAuthority> & IAccountSignerMeta<TAccountUpdateAuthority>\n      : TAccountUpdateAuthority,\n    TAccountSystemProgram,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCreateMetadataAccountV3Instruction<\n  TProgram extends string = typeof TOKEN_METADATA_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Metadata key (pda of ['metadata', program id, mint id]) */\n    metadata: TAccountMetas[0];\n    /** Mint of token asset */\n    mint: TAccountMetas[1];\n    /** Mint authority */\n    mintAuthority: TAccountMetas[2];\n    /** payer */\n    payer: TAccountMetas[3];\n    /** update authority info */\n    updateAuthority: TAccountMetas[4];\n    /** System program */\n    systemProgram: TAccountMetas[5];\n    /** Rent info */\n    rent?: TAccountMetas[6] | undefined;\n  };\n  data: CreateMetadataAccountV3InstructionData;\n};\n\nexport function parseCreateMetadataAccountV3Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> & IInstructionWithAccounts<TAccountMetas> & IInstructionWithData<Uint8Array>,\n): ParsedCreateMetadataAccountV3Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  let optionalAccountsRemaining = instruction.accounts.length - 6;\n  const getNextOptionalAccount = () => {\n    if (optionalAccountsRemaining === 0) return undefined;\n    optionalAccountsRemaining -= 1;\n    return getNextAccount();\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      metadata: getNextAccount(),\n      mint: getNextAccount(),\n      mintAuthority: getNextAccount(),\n      payer: getNextAccount(),\n      updateAuthority: getNextAccount(),\n      systemProgram: getNextAccount(),\n      rent: getNextOptionalAccount(),\n    },\n    data: getCreateMetadataAccountV3InstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "import { type Address, type KeyPairSigner, getAddressEncoder, getProgramDerivedAddress } from \"@solana/kit\";\nimport { checkedAddress } from \"../../core/utils\";\nimport { TOKEN_METADATA_PROGRAM_ADDRESS } from \"./generated\";\n\n/**\n * Derive the Token Metadata address from a token's mint address\n *\n * @param `mint` - `Address` or `KeyPairSigner` of the token mint\n */\nexport async function getTokenMetadataAddress(mint: Address | KeyPairSigner): Promise<Address> {\n  return (\n    await getProgramDerivedAddress({\n      programAddress: TOKEN_METADATA_PROGRAM_ADDRESS,\n      seeds: [\n        Buffer.from(\"metadata\"),\n        getAddressEncoder().encode(TOKEN_METADATA_PROGRAM_ADDRESS),\n        getAddressEncoder().encode(checkedAddress(mint)),\n      ],\n    })\n  )[0];\n}\n", "import { getCreateAccountInstruction } from \"@solana-program/system\";\nimport type { Address, IInstruction, KeyPairSigner, TransactionSigner } from \"@solana/kit\";\nimport { checkedAddress, checkedTransactionSigner, getMinimumBalanceForRentExemption } from \"../../../core\";\nimport { getCreateMetadataAccountV3Instruction, getTokenMetadataAddress } from \"../../token-metadata\";\n\nimport {\n  extension,\n  getInitializeMetadataPointerInstruction,\n  getInitializeMintInstruction,\n  getInitializeTokenMetadataInstruction,\n  getMintSize,\n  TOKEN_2022_PROGRAM_ADDRESS,\n} from \"@solana-program/token-2022\";\nimport { checkedTokenProgramAddress } from \"../addresses\";\nimport type { TokenInstructionBase } from \"./types\";\n\nexport type GetCreateTokenInstructionsArgs = TokenInstructionBase<KeyPairSigner> & {\n  /**\n   * The number of decimal places this token should have\n   *\n   * @default `9` - the most commonly used decimals value\n   **/\n  decimals?: bigint | number;\n  /**\n   * Authority address that is allowed to mint new tokens\n   *\n   * When not provided, defaults to: `feePayer`\n   **/\n  mintAuthority?: TransactionSigner;\n  /**\n   * Authority address that is able to freeze (and thaw) user owned token accounts.\n   * When a user's token account is frozen, they will not be able to transfer their tokens.\n   *\n   * When not provided, defaults to: `null`\n   **/\n  freezeAuthority?: Address | TransactionSigner;\n  /**\n   * Authority address that is allowed to update the metadata\n   *\n   * When not provided, defaults to: `feePayer`\n   **/\n  updateAuthority?: TransactionSigner;\n  /**\n   * Optional (but highly recommended) metadata to attach to this token\n   */\n  metadata: {\n    /** Name of this token */\n    name: string;\n    /** Symbol for this token */\n    symbol: string;\n    /** URI pointing to additional metadata for this token. Typically an offchain json file. */\n    uri: string;\n    /** Whether or not the onchain metadata will be editable after minting */\n    isMutable: boolean;\n  };\n  /**\n   * Metadata address for this token\n   *\n   * @example\n   * For `TOKEN_PROGRAM_ADDRESS` use the {@link getTokenMetadataAddress} function:\n   * ```\n   * metadataAddress: await getTokenMetadataAddress(mint.address);\n   * ```\n   *\n   * @example\n   * For `TOKEN_2022_PROGRAM_ADDRESS` use the mint's address:\n   * ```\n   * metadataAddress: mint.address;\n   * ```\n   * */\n  metadataAddress: Address;\n  // extensions // todo\n};\n\n/**\n * Create the instructions required to initialize a new token's mint\n */\nexport function getCreateTokenInstructions(args: GetCreateTokenInstructionsArgs): IInstruction[] {\n  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n  args.feePayer = checkedTransactionSigner(args.feePayer);\n\n  if (args.decimals == null) args.decimals = 9;\n  if (!args.mintAuthority) args.mintAuthority = args.feePayer;\n  if (!args.updateAuthority) args.updateAuthority = args.feePayer;\n  if (args.freezeAuthority) args.freezeAuthority = checkedAddress(args.freezeAuthority);\n\n  if (args.tokenProgram === TOKEN_2022_PROGRAM_ADDRESS) {\n    const metadataPointer = extension(\"MetadataPointer\", {\n      metadataAddress: args.mint.address,\n      authority: args.updateAuthority.address,\n    });\n\n    const metadataExtensionData = extension(\"TokenMetadata\", {\n      updateAuthority: args.updateAuthority.address,\n      mint: args.mint.address,\n      name: args.metadata.name,\n      symbol: args.metadata.symbol,\n      uri: args.metadata.uri,\n      // todo: support token22 additional metadata\n      additionalMetadata: new Map(),\n    });\n\n    return [\n      getCreateAccountInstruction({\n        payer: args.feePayer,\n        newAccount: args.mint,\n        /**\n         * token22 requires only the pre-mint-initialization extensions (like metadata pointer)\n         * to be the `space`. then it will extend the account's space for each applicable extension\n         * */\n        space: BigInt(getMintSize([metadataPointer])),\n        /**\n         * token22 requires the total lamport balance for all extensions,\n         * including pre-initialization and post-initialization\n         */\n        lamports: getMinimumBalanceForRentExemption(BigInt(getMintSize([metadataPointer, metadataExtensionData]))),\n        programAddress: args.tokenProgram,\n      }),\n      getInitializeMetadataPointerInstruction({\n        authority: args.mintAuthority.address,\n        metadataAddress: args.metadataAddress,\n        mint: args.mint.address,\n      }),\n      getInitializeMintInstruction(\n        {\n          mint: args.mint.address,\n          decimals: Number(args.decimals),\n          mintAuthority: args.mintAuthority.address,\n          freezeAuthority: args.freezeAuthority || null,\n        },\n        {\n          programAddress: args.tokenProgram,\n        },\n      ),\n      getInitializeTokenMetadataInstruction({\n        metadata: args.mint.address,\n        mint: args.mint.address,\n        mintAuthority: args.mintAuthority,\n        name: args.metadata.name,\n        symbol: args.metadata.symbol,\n        uri: args.metadata.uri,\n        updateAuthority: args.updateAuthority.address,\n      }),\n      // todo: support token22 additional metadata by adding that instruction(s) here\n    ];\n  } else {\n    // the token22 `getMintSize` is fully compatible with the original token program\n    const space: bigint = BigInt(getMintSize());\n\n    return [\n      getCreateAccountInstruction({\n        payer: args.feePayer,\n        newAccount: args.mint,\n        lamports: getMinimumBalanceForRentExemption(space),\n        space,\n        programAddress: args.tokenProgram,\n      }),\n      getInitializeMintInstruction(\n        {\n          mint: args.mint.address,\n          decimals: Number(args.decimals),\n          mintAuthority: args.mintAuthority.address,\n          freezeAuthority: args.freezeAuthority || null,\n        },\n        {\n          programAddress: args.tokenProgram,\n        },\n      ),\n      getCreateMetadataAccountV3Instruction({\n        metadata: args.metadataAddress,\n        mint: args.mint.address,\n        mintAuthority: args.mintAuthority,\n        payer: args.feePayer,\n        updateAuthority: args.updateAuthority,\n        data: {\n          name: args.metadata.name,\n          symbol: args.metadata.symbol,\n          uri: args.metadata.uri,\n          sellerFeeBasisPoints: 0,\n          creators: null,\n          collection: null,\n          uses: null,\n        },\n        isMutable: args.metadata.isMutable,\n        collectionDetails: null,\n      }),\n    ];\n  }\n}\n", "import type { Address, IInstruction, TransactionSigner } from \"@solana/kit\";\n\nimport { getCreateAssociatedTokenIdempotentInstruction, getMintToInstruction } from \"@solana-program/token-2022\";\nimport { checkedAddress, checkedTransactionSigner } from \"../../../core\";\nimport { checkedTokenProgramAddress } from \"../addresses\";\nimport type { TokenInstructionBase } from \"./types\";\n\nexport type GetMintTokensInstructionsArgs = TokenInstructionBase & {\n  /**\n   * The authority address capable of authorizing minting of new tokens.\n   *\n   * - this should normally by a `TransactionSigner`\n   * - only for multi-sig authorities (like Squads Protocol), should you supply an `Address`\n   * */\n  mintAuthority: TransactionSigner | Address;\n  /** Wallet address to receive the tokens being minted, via their associated token account (ata) */\n  destination: TransactionSigner | Address;\n  /**\n   * Associated token account (ata) address for `destination` and this `mint`\n   *\n   * See {@link getAssociatedTokenAccountAddress}\n   *\n   * @example\n   * ```\n   * getAssociatedTokenAccountAddress(mint, destination, tokenProgram);\n   * ```\n   * */\n  ata: Address;\n  /** Amount of tokens to mint to the `owner` via their `ata` */\n  amount: bigint | number;\n};\n\n/**\n * Create the instructions required to mint tokens to any wallet/owner,\n * including creating their ATA if it does not exist\n *\n * @example\n *\n * ```\n * const mint = await generateKeyPairSigner();\n * const destination = address(\"nicktrLHhYzLmoVbuZQzHUTicd2sfP571orwo9jfc8c\");\n *\n * const instructions = getMintTokensInstructions({\n *   mint,\n *   feePayer: signer,\n *   mintAuthority: signer,\n *   amount: 1000, // note: be sure to consider the mint's `decimals` value\n *   // if decimals=2 => this will mint 10.00 tokens\n *   // if decimals=4 => this will mint 0.100 tokens\n *   destination,\n *   // be sure to set the correct token program when getting the `ata`\n *   ata: await getAssociatedTokenAccountAddress(mint, destination, tokenProgram),\n *   // tokenProgram: TOKEN_PROGRAM_ADDRESS, // default\n *   // tokenProgram: TOKEN_2022_PROGRAM_ADDRESS,\n * });\n * ```\n */\nexport function getMintTokensInstructions(args: GetMintTokensInstructionsArgs): IInstruction[] {\n  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n  args.feePayer = checkedTransactionSigner(args.feePayer);\n  args.mint = checkedAddress(args.mint);\n\n  return [\n    // create idempotent will gracefully fail if the ata already exists. this is the gold standard!\n    getCreateAssociatedTokenIdempotentInstruction({\n      owner: checkedAddress(args.destination),\n      mint: args.mint,\n      ata: args.ata,\n      payer: args.feePayer,\n      tokenProgram: args.tokenProgram,\n    }),\n    getMintToInstruction(\n      {\n        mint: args.mint,\n        mintAuthority: args.mintAuthority,\n        token: args.ata,\n        amount: args.amount,\n      },\n      {\n        programAddress: args.tokenProgram,\n      },\n    ),\n  ];\n}\n", "import type { Address, IInstruction, TransactionSigner } from \"@solana/kit\";\n\nimport { getCreateAssociatedTokenIdempotentInstruction, getTransferInstruction } from \"@solana-program/token-2022\";\nimport { checkedAddress, checkedTransactionSigner } from \"../../../core\";\nimport { checkedTokenProgramAddress } from \"../addresses\";\nimport type { TokenInstructionBase } from \"./types\";\n\nexport type GetTransferTokensInstructionsArgs = TokenInstructionBase & {\n  /**\n   * The source account's owner/delegate or its multi-signature account:\n   * - this should normally by a `TransactionSigner`\n   * - only for multi-sig authorities (like Squads Protocol), should you supply an `Address`\n   * */\n  authority: TransactionSigner | Address;\n  /**\n   * Associated token account (ata) address for `authority` and this `mint`\n   *\n   * See {@link getAssociatedTokenAccountAddress}\n   *\n   * @example\n   * ```\n   * getAssociatedTokenAccountAddress(mint, authority, tokenProgram);\n   * ```\n   * */\n  sourceAta: Address;\n  /** Wallet address to receive the tokens, via their associated token account: `destinationAta` */\n  destination: TransactionSigner | Address;\n  /**\n   * Associated token account (ata) address for `destination` and this `mint`\n   *\n   * See {@link getAssociatedTokenAccountAddress}\n   *\n   * @example\n   * ```\n   * getAssociatedTokenAccountAddress(mint, destination, tokenProgram);\n   * ```\n   * */\n  destinationAta: Address;\n  /** Amount of tokens to be transferred to the `destination` via their `destinationAta` */\n  amount: bigint | number;\n};\n\n/**\n * Create the instructions required to transfer tokens from one wallet to another,\n * including creating the destination ATA if it does not exist\n *\n * @example\n *\n * ```\n * const sourceAta = await getAssociatedTokenAccountAddress(mint, authority, tokenProgram);\n *\n * const destination = address(...);\n * const destinationAta = await getAssociatedTokenAccountAddress(mint, destination, tokenProgram);\n *\n * const instructions = getTransferTokensInstructions({\n *    feePayer: signer,\n *    mint,\n *    amount: 10,\n *    authority: signer, // the source wallet for the tokens to be transferred\n *    sourceAta, // normally derived from the `authority`\n *    destination,\n *    destinationAta, // derived from the `destination`\n *    tokenProgram,\n * });\n * ```\n */\nexport function getTransferTokensInstructions(args: GetTransferTokensInstructionsArgs): IInstruction[] {\n  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n  args.feePayer = checkedTransactionSigner(args.feePayer);\n  args.mint = checkedAddress(args.mint);\n\n  return [\n    // create idempotent will gracefully fail if the ata already exists. this is the gold standard!\n    getCreateAssociatedTokenIdempotentInstruction({\n      owner: checkedAddress(args.destination),\n      mint: args.mint,\n      ata: args.destinationAta,\n      payer: args.feePayer,\n      tokenProgram: args.tokenProgram,\n    }),\n    getTransferInstruction(\n      {\n        authority: args.authority,\n        source: args.sourceAta,\n        destination: args.destinationAta,\n        amount: args.amount,\n      },\n      {\n        programAddress: args.tokenProgram,\n      },\n    ),\n  ];\n}\n", "import { TOKEN_2022_PROGRAM_ADDRESS } from \"@solana-program/token-2022\";\nimport type {\n  ITransactionMessageWithFeePayer,\n  KeyPairSigner,\n  TransactionMessageWithBlockhashLifetime,\n  TransactionSigner,\n  TransactionVersion,\n} from \"@solana/kit\";\nimport { checkedTransactionSigner, createTransaction } from \"../../../core\";\nimport type { FullTransaction, Simplify } from \"../../../types\";\nimport { getTokenMetadataAddress } from \"../../token-metadata\";\nimport { checkedTokenProgramAddress, TOKEN_PROGRAM_ADDRESS } from \"../addresses\";\nimport { getCreateTokenInstructions, type GetCreateTokenInstructionsArgs } from \"../instructions/create-token\";\nimport type { TransactionBuilderInput } from \"./types\";\n\ntype GetCreateTokenTransactionInput = Simplify<\n  Omit<GetCreateTokenInstructionsArgs, \"metadataAddress\"> &\n    Partial<Pick<GetCreateTokenInstructionsArgs, \"metadataAddress\">>\n>;\n\n/**\n * Create a transaction that can create a token with metadata\n *\n * The transaction has the following defaults:\n * - Default `version` = `legacy`\n * - Default `computeUnitLimit`:\n *    - for TOKEN_PROGRAM_ADDRESS => `60_000`\n *    - for TOKEN_2022_PROGRAM_ADDRESS => `10_000`\n *\n * @example\n *\n * ```\n * const mint = await generateKeyPairSigner();\n *\n * const transaction = await buildCreateTokenTransaction({\n *   feePayer: signer,\n *   latestBlockhash,\n *   mint,\n *   metadata: {\n *     name: \"Test Token\",\n *     symbol: \"TEST\",\n *     uri: \"https://example.com/metadata.json\",\n *     isMutable: true,\n *   },\n *   // tokenProgram: TOKEN_PROGRAM_ADDRESS, // default\n *   // tokenProgram: TOKEN_2022_PROGRAM_ADDRESS,\n * });\n * ```\n */\nexport async function buildCreateTokenTransaction<\n  TVersion extends TransactionVersion = \"legacy\",\n  TFeePayer extends TransactionSigner = TransactionSigner,\n>(\n  args: TransactionBuilderInput<TVersion, TFeePayer> & GetCreateTokenTransactionInput,\n): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer>>;\nexport async function buildCreateTokenTransaction<\n  TVersion extends TransactionVersion = \"legacy\",\n  TFeePayer extends TransactionSigner = TransactionSigner,\n  TLifetimeConstraint extends\n    TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"] = TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetCreateTokenTransactionInput,\n): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;\nexport async function buildCreateTokenTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends TransactionSigner,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetCreateTokenTransactionInput) {\n  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n  args.feePayer = checkedTransactionSigner(args.feePayer);\n\n  let metadataAddress = args.mint.address;\n\n  if (args.tokenProgram === TOKEN_PROGRAM_ADDRESS) {\n    metadataAddress = await getTokenMetadataAddress(args.mint);\n\n    // default a reasonably low computeUnitLimit based on simulation data\n    if (!args.computeUnitLimit) {\n      // creating the token's mint is around 3219cu (and stable?)\n      // token metadata is the rest... and fluctuates a lot based on the pda and amount of metadata\n      args.computeUnitLimit = 60_000;\n    }\n  } else if (args.tokenProgram === TOKEN_2022_PROGRAM_ADDRESS) {\n    if (!args.computeUnitLimit) {\n      // token22 token creation, with metadata is (seemingly stable) around 7647cu,\n      // but consume more with more metadata provided\n      args.computeUnitLimit = 10_000;\n    }\n  }\n\n  return createTransaction(\n    (({ feePayer, version, computeUnitLimit, computeUnitPrice, latestBlockhash }: typeof args) => ({\n      feePayer,\n      version: version || \"legacy\",\n      computeUnitLimit,\n      computeUnitPrice,\n      latestBlockhash,\n      instructions: getCreateTokenInstructions(\n        (({\n          decimals,\n          mintAuthority,\n          freezeAuthority,\n          updateAuthority,\n          metadata,\n          feePayer,\n          tokenProgram,\n          mint,\n        }: typeof args) => ({\n          mint: mint as KeyPairSigner,\n          feePayer,\n          metadataAddress,\n          metadata,\n          decimals,\n          mintAuthority,\n          freezeAuthority,\n          updateAuthority,\n          tokenProgram,\n        }))(args),\n      ),\n    }))(args),\n  );\n}\n", "import type {\n  Address,\n  ITransactionMessageWithFeePayer,\n  TransactionMessageWithBlockhashLifetime,\n  TransactionSigner,\n  TransactionVersion,\n} from \"@solana/kit\";\nimport { checkedAddress, checkedTransactionSigner, createTransaction } from \"../../../core\";\nimport type { FullTransaction, Simplify } from \"../../../types\";\nimport { checkedTokenProgramAddress, getAssociatedTokenAccountAddress } from \"../addresses\";\nimport { getMintTokensInstructions, type GetMintTokensInstructionsArgs } from \"../instructions/mint-tokens\";\nimport type { TransactionBuilderInput } from \"./types\";\n\ntype GetCreateTokenTransactionInput = Simplify<\n  Omit<GetMintTokensInstructionsArgs, \"ata\"> & Partial<Pick<GetMintTokensInstructionsArgs, \"ata\">>\n>;\n\n/**\n * Create a transaction that can mint tokens to the desired wallet/owner,\n * including creating their ATA if it does not exist\n *\n * The transaction has the following defaults:\n * - Default `version` = `legacy`\n * - Default `computeUnitLimit` = `31_000`\n *\n * @remarks\n *\n * - minting without creating the ata is generally < 10_000cu\n * - validating the ata onchain during creation results in a ~5000cu fluctuation\n *\n * @example\n * ```\n * const destination = address(\"nicktrLHhYzLmoVbuZQzHUTicd2sfP571orwo9jfc8c\");\n *\n * const mint = address(...);\n * // or mint can be a keypair from a freshly created token\n *\n * const transaction = await buildMintTokensTransaction({\n *   feePayer: signer,\n *   latestBlockhash,\n *   mint,\n *   mintAuthority: signer,\n *   amount: 1000, // note: be sure to consider the mint's `decimals` value\n *   // if decimals=2 => this will mint 10.00 tokens\n *   // if decimals=4 => this will mint 0.100 tokens\n *   destination,\n *   // tokenProgram: TOKEN_PROGRAM_ADDRESS, // default\n *   // tokenProgram: TOKEN_2022_PROGRAM_ADDRESS,\n * });\n * ```\n */\nexport async function buildMintTokensTransaction<\n  TVersion extends TransactionVersion = \"legacy\",\n  TFeePayer extends TransactionSigner = TransactionSigner,\n>(\n  args: TransactionBuilderInput<TVersion, TFeePayer> & GetCreateTokenTransactionInput,\n): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer>>;\nexport async function buildMintTokensTransaction<\n  TVersion extends TransactionVersion = \"legacy\",\n  TFeePayer extends TransactionSigner = TransactionSigner,\n  TLifetimeConstraint extends\n    TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"] = TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetCreateTokenTransactionInput,\n): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;\nexport async function buildMintTokensTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends TransactionSigner,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetCreateTokenTransactionInput) {\n  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n  args.feePayer = checkedTransactionSigner(args.feePayer);\n  args.mint = checkedAddress(args.mint);\n\n  if (!args.ata) {\n    args.ata = await getAssociatedTokenAccountAddress(args.mint, args.destination, args.tokenProgram);\n  }\n\n  // default a reasonably low computeUnitLimit based on simulation data\n  if (!args.computeUnitLimit) {\n    /**\n     * for TOKEN_PROGRAM_ADDRESS and multiple simulation attempts,\n     * minting tokens costs the following:\n     * - when not creating the ata: 9156cu\n     * - when creating the ata: 26535cu\n     *\n     * for TOKEN_2022_PROGRAM_ADDRESS and multiple simulation attempts,\n     * minting tokens costs the following:\n     * - when not creating the ata: 8978cu\n     * - when creating the ata: 22567cu\n     */\n    args.computeUnitLimit = 31_000;\n  }\n\n  return createTransaction(\n    (({ feePayer, version, computeUnitLimit, computeUnitPrice, latestBlockhash }: typeof args) => ({\n      feePayer,\n      version: version || \"legacy\",\n      computeUnitLimit,\n      computeUnitPrice,\n      latestBlockhash,\n      instructions: getMintTokensInstructions(\n        (({ tokenProgram, feePayer, mint, ata, mintAuthority, amount, destination }: typeof args) => ({\n          tokenProgram,\n          feePayer,\n          mint,\n          mintAuthority,\n          ata: ata as Address,\n          amount,\n          destination,\n        }))(args),\n      ),\n    }))(args),\n  );\n}\n", "import type {\n  Address,\n  ITransactionMessageWithFeePayer,\n  TransactionMessageWithBlockhashLifetime,\n  TransactionSigner,\n  TransactionVersion,\n} from \"@solana/kit\";\nimport { checkedAddress, checkedTransactionSigner, createTransaction } from \"../../../core\";\nimport type { FullTransaction, Simplify } from \"../../../types\";\nimport { checkedTokenProgramAddress, getAssociatedTokenAccountAddress } from \"../addresses\";\nimport { getTransferTokensInstructions, type GetTransferTokensInstructionsArgs } from \"../instructions\";\nimport type { TransactionBuilderInput } from \"./types\";\n\ntype GetTransferTokensTransactionInput = Simplify<\n  Omit<GetTransferTokensInstructionsArgs, \"sourceAta\" | \"destinationAta\"> &\n    Partial<Pick<GetTransferTokensInstructionsArgs, \"sourceAta\" | \"destinationAta\">>\n>;\n\n/**\n * Create a transaction that can transfer tokens to the desired wallet/owner,\n * including creating their ATA if it does not exist\n *\n * The transaction has the following defaults:\n * - Default `version` = `legacy`\n * - Default `computeUnitLimit` = `31_000`\n *\n * @remarks\n *\n * - transferring without creating the ata is generally < 10_000cu\n * - validating the ata onchain during creation results in a ~15000cu fluctuation\n *\n * @example\n * ```\n * const destination = address(...);\n *\n * const transferTokensTx = await buildTransferTokensTransaction({\n *   feePayer: signer,\n *   latestBlockhash,\n *   mint,\n *   authority: signer,\n *   amount: 900, // note: be sure to consider the mint's `decimals` value\n *   // if decimals=2 => this will transfer 9.00 tokens\n *   // if decimals=4 => this will transfer 0.090 tokens\n *   destination,\n *   // use the correct token program for the `mint`\n *   tokenProgram, // default=TOKEN_PROGRAM_ADDRESS\n *   // default cu limit set to be optimized, but can be overridden here\n *   // computeUnitLimit?: number,\n *   // obtain from your favorite priority fee api\n *   // computeUnitPrice?: number, // no default set\n * });\n * ```\n */\nexport async function buildTransferTokensTransaction<\n  TVersion extends TransactionVersion = \"legacy\",\n  TFeePayer extends TransactionSigner = TransactionSigner,\n>(\n  args: TransactionBuilderInput<TVersion, TFeePayer> & GetTransferTokensTransactionInput,\n): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer>>;\nexport async function buildTransferTokensTransaction<\n  TVersion extends TransactionVersion = \"legacy\",\n  TFeePayer extends TransactionSigner = TransactionSigner,\n  TLifetimeConstraint extends\n    TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"] = TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetTransferTokensTransactionInput,\n): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;\nexport async function buildTransferTokensTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends Address | TransactionSigner,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetTransferTokensTransactionInput) {\n  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n  args.feePayer = checkedTransactionSigner(args.feePayer);\n  args.mint = checkedAddress(args.mint);\n\n  [args.destinationAta, args.sourceAta] = await Promise.all([\n    !args.destinationAta\n      ? getAssociatedTokenAccountAddress(args.mint, args.destination, args.tokenProgram)\n      : args.destinationAta,\n    !args.sourceAta ? getAssociatedTokenAccountAddress(args.mint, args.authority, args.tokenProgram) : args.sourceAta,\n  ]);\n\n  // default a reasonably low computeUnitLimit based on simulation data\n  if (!args.computeUnitLimit) {\n    /**\n     * for TOKEN_PROGRAM_ADDRESS and multiple simulation attempts,\n     * minting tokens costs the following:\n     * - when not creating the ata: 6336cu - 12336cu\n     * - when creating the ata: 19428cu - 25034cu\n     *\n     * for TOKEN_2022_PROGRAM_ADDRESS and multiple simulation attempts,\n     * minting tokens costs the following:\n     * - when not creating the ata: 6157cu - 15157cu\n     * - when creating the ata: 18722cu - 27722cu\n     */\n    args.computeUnitLimit = 31_000;\n  }\n\n  return createTransaction(\n    (({ feePayer, version, computeUnitLimit, computeUnitPrice, latestBlockhash }: typeof args) => ({\n      feePayer,\n      version: version || \"legacy\",\n      computeUnitLimit,\n      computeUnitPrice,\n      latestBlockhash,\n      instructions: getTransferTokensInstructions(\n        (({\n          tokenProgram,\n          feePayer,\n          mint,\n          amount,\n          destination,\n          authority,\n          destinationAta,\n          sourceAta,\n        }: typeof args) => ({\n          tokenProgram,\n          feePayer,\n          mint,\n          amount,\n          authority,\n          destination,\n          sourceAta: sourceAta as Address,\n          destinationAta: destinationAta as Address,\n        }))(args),\n      ),\n    }))(args),\n  );\n}\n", "/**\n * Converts a UI amount (human-readable) to raw amount (BigInt)\n * @param uiAmount The human-readable token amount (e.g., 1.5)\n * @param decimals The number of decimals for the token\n * @returns BigInt representation of the amount\n */\nexport function tokenUiAmountToAmount(uiAmount: number, decimals: number): bigint {\n  // Handle potential scientific notation by using the built-in toFixed\n  // This ensures we get a decimal string representation without scientific notation\n  const uiAmountStr = uiAmount.toFixed(decimals);\n\n  // Find decimal point position\n  const decimalPointIndex = uiAmountStr.indexOf(\".\");\n\n  let wholeNumber: string;\n  let fractionalPart: string;\n\n  if (decimalPointIndex === -1) {\n    // No decimal point\n    wholeNumber = uiAmountStr;\n    fractionalPart = \"\";\n  } else {\n    wholeNumber = uiAmountStr.substring(0, decimalPointIndex);\n    fractionalPart = uiAmountStr.substring(decimalPointIndex + 1);\n  }\n\n  // Pad or truncate fractional part based on decimals\n  if (fractionalPart.length > decimals) {\n    fractionalPart = fractionalPart.substring(0, decimals);\n  } else {\n    fractionalPart = fractionalPart.padEnd(decimals, \"0\");\n  }\n\n  // Combine and convert to BigInt, stripping any potential leading zeros\n  const rawAmountStr = wholeNumber + fractionalPart;\n  if (rawAmountStr.replace(/0/g, \"\") === \"\") {\n    return BigInt(0);\n  }\n  return BigInt(rawAmountStr);\n}\n\n/**\n * Converts a raw amount (BigInt) to UI amount (human-readable)\n * @param amount The raw token amount as BigInt\n * @param decimals The number of decimals for the token\n * @returns UI representation of the amount as a number\n */\nexport function tokenAmountToUiAmount(amount: bigint, decimals: number): number {\n  // Convert to string for easier manipulation\n  let amountStr = amount.toString();\n\n  // Pad with leading zeros if necessary\n  if (amountStr.length <= decimals) {\n    amountStr = amountStr.padStart(decimals + 1, \"0\");\n  }\n\n  // Split into whole and fractional parts\n  const wholePartLength = amountStr.length - decimals;\n  const wholePart = amountStr.substring(0, wholePartLength);\n  const fractionalPart = amountStr.substring(wholePartLength);\n\n  // Combine with decimal point\n  const uiAmountStr = `${wholePart || \"0\"}.${fractionalPart}`;\n\n  // Convert back to number\n  return parseFloat(uiAmountStr);\n}\n", "/**\n * @private\n */\nexport const GILL_NAME = \"gill\";\n\nexport const GILL_HOOK_CLIENT_KEY = \"gill-client\";\n", "\"use client\";\n\nimport React from \"react\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport { GILL_HOOK_CLIENT_KEY } from \"./const\";\nimport type { SolanaClient } from \"gill\";\n\n/**\n * Provider to utilize gill hooks for Solana\n */\nexport function SolanaProvider({\n  client,\n  children,\n  queryClient = new QueryClient(),\n}: {\n  client: SolanaClient;\n  children: React.ReactNode;\n  queryClient?: QueryClient;\n}) {\n  queryClient.setQueryData([GILL_HOOK_CLIENT_KEY], client);\n  return <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>;\n}\n", "import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { createSolanaClient, type SolanaClient } from \"gill\";\nimport { GILL_HOOK_CLIENT_KEY } from \"../const\";\n\n/**\n * Get the current Solana client (including `rpc` and `rpcSubscriptions`)\n */\nexport function useSolanaClient(): SolanaClient {\n  const { data: config } = useQuery<SolanaClient>({\n    queryKey: [GILL_HOOK_CLIENT_KEY],\n    staleTime: Infinity,\n    // fallback data should not be reached if used within `SolanaProvider`\n    // since we set the initial value. but just in case => devnet\n    initialData: createSolanaClient({\n      urlOrMoniker: \"devnet\",\n    }),\n  });\n  return config;\n}\n\n/**\n * Update your Solana client (including `rpc` and `rpcSubscriptions`)\n */\nexport function useUpdateSolanaClient() {\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: async (newClient: SolanaClient): Promise<SolanaClient> => {\n      queryClient.setQueryData([GILL_HOOK_CLIENT_KEY], newClient);\n      return newClient;\n    },\n    onSuccess: () => {\n      // Invalidate any queries that might depend on the Solana client\n      queryClient.invalidateQueries({ queryKey: [GILL_HOOK_CLIENT_KEY] });\n\n      /**\n       * todo: research more here\n       * removing queries here will force the cache to update automatically, but can result in the waterfall of data fetching\n       * but it seems that without it, the client side data does not auto refetch when the SolanaClient is changed :/\n       */\n      // queryClient.removeQueries({\n      //   predicate: (query) => {\n      //     return query.queryKey.length >= 2 && query.queryKey[0] === GILL_HOOK_CLIENT_KEY;\n      //   },\n      // });\n\n      queryClient.prefetchQuery({ queryKey: [GILL_HOOK_CLIENT_KEY] });\n      queryClient.refetchQueries({\n        queryKey: [GILL_HOOK_CLIENT_KEY],\n      });\n    },\n  });\n}\n", "\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport type { Account, Address, Decoder, FetchAccountConfig, Simplify } from \"gill\";\nimport { assertAccountExists, decodeAccount, fetchEncodedAccount } from \"gill\";\nimport { GILL_HOOK_CLIENT_KEY } from \"../const\";\nimport { useSolanaClient } from \"./client\";\nimport type { GillUseRpcHook } from \"./types\";\n\ntype RpcConfig = Simplify<Omit<FetchAccountConfig, \"abortSignal\">>;\n\ntype UseAccountResponse<TAddress extends string = string, TData extends Uint8Array | object = Uint8Array> = Account<\n  TData,\n  TAddress\n> & {\n  exists: true;\n};\n\ntype UseAccountInput<\n  TConfig extends RpcConfig = RpcConfig,\n  TAddress extends string = string,\n  TDecodedData extends object = Uint8Array,\n> = GillUseRpcHook<TConfig> & {\n  /**\n   * Address of the account to get the balance of\n   */\n  address: TAddress | Address;\n  /**\n   * Account decoder that can decode the account's `data` byte array value\n   */\n  decoder?: Decoder<TDecodedData>;\n};\n\n/**\n * Get the account info for an address using the Solana RPC method of\n * [`getAccountInfo`](https://solana.com/docs/rpc/http/getaccountinfo)\n */\nexport function useAccount<\n  TConfig extends RpcConfig = RpcConfig,\n  TAddress extends string = string,\n  TDecodedData extends object = Uint8Array,\n>({ options, config, abortSignal, address, decoder }: UseAccountInput<TConfig, TAddress, TDecodedData>) {\n  const { rpc } = useSolanaClient();\n\n  if (abortSignal) {\n    // @ts-expect-error we stripped the `abortSignal` from the type but are now adding it back in\n    config = {\n      ...(config || {}),\n      abortSignal,\n    };\n  }\n\n  const { data, ...rest } = useQuery({\n    networkMode: \"offlineFirst\",\n    ...options,\n    queryKey: [GILL_HOOK_CLIENT_KEY, \"getAccountInfo\", address],\n    queryFn: async () => {\n      const account = await fetchEncodedAccount(rpc, address as Address, config);\n      assertAccountExists(account);\n      if (decoder) return decodeAccount(account, decoder as Decoder<TDecodedData>);\n      return account;\n    },\n    enabled: !!address,\n  });\n  return {\n    ...rest,\n    account: data as UseAccountResponse<TAddress, TDecodedData>,\n  };\n}\n", "\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport type { Address, GetBalanceApi, Simplify } from \"gill\";\nimport { GILL_HOOK_CLIENT_KEY } from \"../const\";\nimport { useSolanaClient } from \"./client\";\nimport type { GillUseRpcHook } from \"./types\";\n\ntype RpcConfig = Simplify<Parameters<GetBalanceApi[\"getBalance\"]>>[1];\n\ntype UseBalanceResponse = ReturnType<GetBalanceApi[\"getBalance\"]>[\"value\"];\n\ntype UseBalanceInput<TConfig extends RpcConfig = RpcConfig> = GillUseRpcHook<TConfig> & {\n  /**\n   * Address of the account to get the balance of\n   */\n  address: Address | string;\n};\n\n/**\n * Get an account's balance (in lamports) using the Solana RPC method of\n * [`getBalance`](https://solana.com/docs/rpc/http/getbalance)\n */\nexport function useBalance<TConfig extends RpcConfig = RpcConfig>({\n  options,\n  config,\n  abortSignal,\n  address,\n}: UseBalanceInput<TConfig>) {\n  const { rpc } = useSolanaClient();\n  const { data, ...rest } = useQuery({\n    networkMode: \"offlineFirst\",\n    ...options,\n    enabled: !!address,\n    queryKey: [GILL_HOOK_CLIENT_KEY, \"getBalance\", address],\n    queryFn: async () => {\n      const { value } = await rpc.getBalance(address as Address, config).send({ abortSignal });\n      return value;\n    },\n  });\n  return {\n    ...rest,\n    balance: data as UseBalanceResponse,\n  };\n}\n", "\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport type { GetLatestBlockhashApi, Simplify } from \"gill\";\nimport { GILL_HOOK_CLIENT_KEY } from \"../const\";\nimport { useSolanaClient } from \"./client\";\nimport type { GillUseRpcHook } from \"./types\";\n\ntype RpcConfig = Simplify<Parameters<GetLatestBlockhashApi[\"getLatestBlockhash\"]>>[0];\n\ntype UseLatestBlockhashResponse = ReturnType<GetLatestBlockhashApi[\"getLatestBlockhash\"]>[\"value\"];\n\ntype UseLatestBlockhashInput<TConfig extends RpcConfig = RpcConfig> = GillUseRpcHook<TConfig>;\n\n/**\n * Get the latest blockhash using the Solana RPC method of\n * [`getLatestBlockhash`](https://solana.com/docs/rpc/http/getlatestblockhash)\n *\n * To auto refetch the latest blockhash, provide a `options.refetchInterval` value\n */\nexport function useLatestBlockhash<TConfig extends RpcConfig = RpcConfig>({\n  options,\n  config,\n  abortSignal,\n}: UseLatestBlockhashInput<TConfig> = {}) {\n  const { rpc } = useSolanaClient();\n  const { data, ...rest } = useQuery({\n    ...options,\n    queryKey: [GILL_HOOK_CLIENT_KEY, \"getLatestBlockhash\"],\n    queryFn: async () => {\n      const { value } = await rpc.getLatestBlockhash(config).send({ abortSignal });\n      return value;\n    },\n  });\n  return {\n    ...rest,\n    latestBlockhash: data as UseLatestBlockhashResponse,\n  };\n}\n", "\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport type {\n  AccountInfoBase,\n  AccountInfoWithBase58Bytes,\n  AccountInfoWithBase58EncodedData,\n  AccountInfoWithBase64EncodedData,\n  AccountInfoWithBase64EncodedZStdCompressedData,\n  AccountInfoWithJsonData,\n  AccountInfoWithPubkey,\n  Address,\n  GetProgramAccountsApi,\n  Simplify,\n  SolanaRpcResponse,\n} from \"gill\";\nimport { GILL_HOOK_CLIENT_KEY } from \"../const\";\nimport { useSolanaClient } from \"./client\";\nimport type { GillUseRpcHook } from \"./types\";\n\ntype Encoding = \"base64\" | \"jsonParsed\" | \"base64+zstd\" | \"base58\";\n\ntype RpcConfig = Simplify<\n  Parameters<GetProgramAccountsApi[\"getProgramAccounts\"]>[1] &\n    Readonly<{\n      encoding?: Encoding;\n    }>\n>;\n\ntype UseProgramAccountsInput<TConfig extends RpcConfig = RpcConfig> = GillUseRpcHook<TConfig> & {\n  /**\n   * Address of the program used to call\n   * [`getProgramAccounts`](https://solana.com/docs/rpc/http/getprogramaccounts)\n   */\n  program: Address | string;\n};\n\ntype UseProgramAccountsResponse<TConfig extends RpcConfig> = TConfig extends {\n  encoding: \"base64\";\n  withContext: true;\n}\n  ? SolanaRpcResponse<AccountInfoWithPubkey<AccountInfoBase & AccountInfoWithBase64EncodedData>[]>\n  : TConfig extends { encoding: \"base64\" }\n    ? AccountInfoWithPubkey<AccountInfoBase & AccountInfoWithBase64EncodedData>[]\n    : TConfig extends { encoding: \"base64+zstd\"; withContext: true }\n      ? SolanaRpcResponse<AccountInfoWithPubkey<AccountInfoBase & AccountInfoWithBase64EncodedZStdCompressedData>[]>\n      : TConfig extends { encoding: \"base64+zstd\" }\n        ? AccountInfoWithPubkey<AccountInfoBase & AccountInfoWithBase64EncodedZStdCompressedData>[]\n        : TConfig extends { encoding: \"jsonParsed\"; withContext: true }\n          ? SolanaRpcResponse<AccountInfoWithPubkey<AccountInfoBase & AccountInfoWithJsonData>[]>\n          : TConfig extends { encoding: \"jsonParsed\" }\n            ? AccountInfoWithPubkey<AccountInfoBase & AccountInfoWithJsonData>[]\n            : TConfig extends { encoding: \"base58\"; withContext: true }\n              ? SolanaRpcResponse<AccountInfoWithPubkey<AccountInfoBase & AccountInfoWithBase58EncodedData>[]>\n              : TConfig extends { encoding: \"base58\" }\n                ? AccountInfoWithPubkey<AccountInfoBase & AccountInfoWithBase58EncodedData>[]\n                : TConfig extends { withContext: true }\n                  ? SolanaRpcResponse<AccountInfoWithPubkey<AccountInfoBase & AccountInfoWithBase58Bytes>[]>\n                  : AccountInfoWithPubkey<AccountInfoBase & AccountInfoWithBase58Bytes>[];\n\n/**\n * Get all the accounts owned by a `program` using the Solana RPC method of\n * [`getProgramAccounts`](https://solana.com/docs/rpc/http/getprogramaccounts)\n */\nexport function useProgramAccounts<TConfig extends RpcConfig = RpcConfig>({\n  options,\n  config,\n  abortSignal,\n  program,\n}: UseProgramAccountsInput<TConfig>) {\n  const { rpc } = useSolanaClient();\n\n  const { data, ...rest } = useQuery({\n    ...options,\n    enabled: !!program,\n    queryKey: [GILL_HOOK_CLIENT_KEY, \"getProgramAccounts\", program],\n    queryFn: async () => {\n      const accounts = await rpc.getProgramAccounts(program as Address, config).send({ abortSignal });\n      return accounts;\n    },\n  });\n\n  return {\n    ...rest,\n    accounts: data as Simplify<UseProgramAccountsResponse<TConfig>>,\n  };\n}\n", "\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport type { GetRecentPrioritizationFeesApi, Simplify } from \"gill\";\nimport { GILL_HOOK_CLIENT_KEY } from \"../const\";\nimport { useSolanaClient } from \"./client\";\nimport type { GillUseRpcHook } from \"./types\";\n\ntype UseRecentPrioritizationFeesInput = Simplify<\n  Pick<GillUseRpcHook<{}>, \"options\" | \"abortSignal\"> & {\n    addresses?: Parameters<GetRecentPrioritizationFeesApi[\"getRecentPrioritizationFees\"]>[0];\n  }\n>;\n\ntype UseRecentPrioritizationFeesResponse = ReturnType<GetRecentPrioritizationFeesApi[\"getRecentPrioritizationFees\"]>;\n\n/**\n * Get the recent prioritization fees for a list of addresses using the Solana RPC method of\n * [`getRecentPrioritizationFees`](https://solana.com/docs/rpc/http/getrecentprioritizationfees)\n */\nexport function useRecentPrioritizationFees({\n  options,\n  abortSignal,\n  addresses,\n}: UseRecentPrioritizationFeesInput = {}) {\n  const { rpc } = useSolanaClient();\n\n  const { data, ...rest } = useQuery({\n    ...options,\n    queryKey: [GILL_HOOK_CLIENT_KEY, \"getRecentPrioritizationFees\", addresses],\n    queryFn: async () => {\n      const fees = await rpc.getRecentPrioritizationFees(addresses).send({ abortSignal });\n      return fees;\n    },\n  });\n\n  return {\n    ...rest,\n    fees: data as UseRecentPrioritizationFeesResponse,\n  };\n}\n", "\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport type { GetSignatureStatusesApi, Signature, Simplify } from \"gill\";\nimport { GILL_HOOK_CLIENT_KEY } from \"../const\";\nimport { useSolanaClient } from \"./client\";\nimport type { GillUseRpcHook } from \"./types\";\n\ntype RpcConfig = Simplify<Parameters<GetSignatureStatusesApi[\"getSignatureStatuses\"]>[1]>;\n\ntype UseSignatureStatusesInput<TConfig extends RpcConfig = RpcConfig> = GillUseRpcHook<TConfig> & {\n  /**\n   * List of signatures used to call\n   * [`getSignatureStatuses`](https://solana.com/docs/rpc/http/getsignaturestatuses)\n   */\n  signatures: Signature[] | string[];\n};\n\ntype UseSignatureStatusesResponse = ReturnType<GetSignatureStatusesApi[\"getSignatureStatuses\"]>[\"value\"];\n\n/**\n * Get the statuses of signatures using the Solana RPC method of\n * [`getSignatureStatuses`](https://solana.com/docs/rpc/http/getsignaturestatuses)\n */\nexport function useSignatureStatuses<TConfig extends RpcConfig = RpcConfig>({\n  options,\n  config,\n  abortSignal,\n  signatures,\n}: UseSignatureStatusesInput<TConfig>) {\n  const { rpc } = useSolanaClient();\n  const { data, ...rest } = useQuery({\n    ...options,\n    enabled: signatures && signatures.length > 0,\n    queryKey: [GILL_HOOK_CLIENT_KEY, \"getSignatureStatuses\", signatures],\n    queryFn: async () => {\n      const { value } = await rpc.getSignatureStatuses(signatures as Signature[], config).send({ abortSignal });\n      return value;\n    },\n  });\n  return {\n    ...rest,\n    statuses: data as UseSignatureStatusesResponse,\n  };\n}\n", "\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { Address, GetSignaturesForAddressApi, Simplify } from \"gill\";\nimport { GILL_HOOK_CLIENT_KEY } from \"../const\";\nimport { useSolanaClient } from \"./client\";\nimport { GillUseRpcHook } from \"./types\";\n\ntype RpcConfig = Simplify<Parameters<GetSignaturesForAddressApi[\"getSignaturesForAddress\"]>[1]>;\n\ntype UseSignaturesForAddressInput<TConfig extends RpcConfig = RpcConfig> = GillUseRpcHook<TConfig> & {\n  /**\n   * Address of the account to fetch signatures of\n   */\n  address: Address | string;\n};\n\ntype UseSignaturesForAddressResponse = ReturnType<GetSignaturesForAddressApi[\"getSignaturesForAddress\"]>;\n\n/**\n * Returns signatures for confirmed transactions that include the given address\n * in their `accountKeys` list. Returns signatures backwards in time from the\n * provided signature or most recent confirmed block using the Solana RPC method of\n * [`getSignaturesForAddress`](https://solana.com/docs/rpc/http/getsignaturesforaddress)\n */\nexport function useSignaturesForAddress<TConfig extends RpcConfig = RpcConfig>({\n  options,\n  config,\n  abortSignal,\n  address,\n}: UseSignaturesForAddressInput<TConfig>) {\n  const { rpc } = useSolanaClient();\n  const { data, ...rest } = useQuery({\n    networkMode: \"offlineFirst\",\n    ...options,\n    enabled: !!address,\n    queryKey: [GILL_HOOK_CLIENT_KEY, \"getSignaturesForAddress\", address],\n    queryFn: async () => {\n      const signatures = await rpc.getSignaturesForAddress(address as Address, config).send({ abortSignal });\n      return signatures;\n    },\n  });\n  return {\n    ...rest,\n    signatures: data as UseSignaturesForAddressResponse,\n  };\n}\n", "\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport type { GetSlotApi, Simplify } from \"gill\";\nimport { GILL_HOOK_CLIENT_KEY } from \"../const\";\nimport { useSolanaClient } from \"./client\";\nimport type { GillUseRpcHook } from \"./types\";\n\ntype RpcConfig = Simplify<Parameters<GetSlotApi[\"getSlot\"]>>[0];\n\ntype UseSlotResponse = ReturnType<GetSlotApi[\"getSlot\"]>;\n\ntype UseSlotInput<TConfig extends RpcConfig = RpcConfig> = GillUseRpcHook<TConfig>;\n\n/**\n * Get the current slot using the Solana RPC method of\n * [`getSlot`](https://solana.com/docs/rpc/http/getslot)\n *\n * To auto refetch the slot, provide a `options.refetchInterval` value\n */\nexport function useSlot<TConfig extends RpcConfig = RpcConfig>({\n  options,\n  config,\n  abortSignal,\n}: UseSlotInput<TConfig> = {}) {\n  const { rpc } = useSolanaClient();\n\n  const { data, ...rest } = useQuery({\n    ...options,\n    queryKey: [GILL_HOOK_CLIENT_KEY, \"getSlot\"],\n    queryFn: async () => {\n      const slot = await rpc.getSlot(config).send({ abortSignal });\n      return slot;\n    },\n  });\n\n  return {\n    ...rest,\n    slot: data as UseSlotResponse,\n  };\n}\n", "\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { GILL_HOOK_CLIENT_KEY } from \"../const\";\nimport { useSolanaClient } from \"./client\";\nimport type { GillUseRpcHook } from \"./types\";\n\nimport type { Account, Address, FetchAccountConfig, Simplify } from \"gill\";\nimport { address, assertAccountExists, assertIsAddress, fetchEncodedAccount } from \"gill\";\nimport {\n  checkedTokenProgramAddress,\n  decodeToken,\n  fetchMint,\n  getAssociatedTokenAccountAddress,\n  type Token,\n} from \"gill/programs/token\";\n\ntype RpcConfig = Simplify<Omit<FetchAccountConfig, \"abortSignal\">>;\n\ntype UseTokenAccountResponse<TAddress extends Address = Address> = Simplify<\n  Account<Token, TAddress> & {\n    exists: true;\n  }\n>;\n\ntype TokenAccountInputWithDeclaredAta<TAddress extends Address = Address> = {\n  /**\n   * Address of the {@link https://solana.com/docs/tokens#associated-token-account | Token Account} to get and decode\n   */\n  ata: TAddress;\n};\n\ntype TokenAccountInputWithDerivedAtaDetails = {\n  /**\n   * Address of the {@link https://solana.com/docs/tokens#token-account | Token Account}'s `owner`\n   */\n  owner: Address;\n  /**\n   * Address of the {@link https://solana.com/docs/tokens#token-account | Token Account}'s `mint`\n   */\n  mint: Address;\n  /**\n   * The {@link https://solana.com/docs/tokens#token-programs | Token Program} used to create the `mint`\n   *\n   * If no `tokenProgram` is provided, the hook will automatically fetch the\n   * {@link https://solana.com/docs/tokens#mint-account | Mint account} to retrieve the correct Token Program address\n   */\n  tokenProgram?: Address;\n};\n\ntype UseTokenAccountInput<\n  TConfig extends RpcConfig = RpcConfig,\n  TAddress extends Address = Address,\n> = GillUseRpcHook<TConfig> & (TokenAccountInputWithDeclaredAta<TAddress> | TokenAccountInputWithDerivedAtaDetails);\n\nfunction hasDeclaredAta(\n  input: TokenAccountInputWithDeclaredAta | TokenAccountInputWithDerivedAtaDetails,\n): input is TokenAccountInputWithDeclaredAta {\n  return (input as TokenAccountInputWithDeclaredAta).ata !== undefined;\n}\n\n/**\n * Get and parse an owner's {@link https://solana.com/docs/tokens#token-account | Token account} for a\n * {@link https://solana.com/docs/tokens#mint-account | Mint} and {@link https://solana.com/docs/tokens#token-programs | Token Program}\n */\nexport function useTokenAccount<TConfig extends RpcConfig = RpcConfig, TAddress extends Address = Address>({\n  options,\n  config,\n  abortSignal,\n  // tokenProgram,\n  ...tokenAccountOptions\n}: UseTokenAccountInput<TConfig, TAddress>) {\n  const { rpc } = useSolanaClient();\n\n  if (abortSignal) {\n    // @ts-expect-error the `abortSignal` was stripped from the type but is now being added back in\n    config = {\n      ...(config || {}),\n      abortSignal,\n    };\n  }\n\n  const { data, ...rest } = useQuery({\n    networkMode: \"offlineFirst\",\n    ...options,\n    enabled: hasDeclaredAta(tokenAccountOptions)\n      ? !!tokenAccountOptions.ata\n      : Boolean(tokenAccountOptions.mint && tokenAccountOptions.owner),\n    queryFn: async () => {\n      let ata: Address;\n\n      if (hasDeclaredAta(tokenAccountOptions)) {\n        // if the user manually provides the ata, we will use that\n        ata = tokenAccountOptions.ata;\n      } else {\n        // auto fetch the token program address if not provided\n        if (!tokenAccountOptions.tokenProgram) {\n          const mint = await fetchMint(rpc, address(tokenAccountOptions.mint));\n          tokenAccountOptions.tokenProgram = mint.programAddress;\n        }\n\n        checkedTokenProgramAddress(tokenAccountOptions.tokenProgram);\n\n        ata = await getAssociatedTokenAccountAddress(\n          tokenAccountOptions.mint,\n          tokenAccountOptions.owner,\n          tokenAccountOptions.tokenProgram,\n        );\n      }\n\n      assertIsAddress(ata);\n      const account = await fetchEncodedAccount(rpc, ata, config);\n      assertAccountExists(account);\n      return decodeToken(account);\n    },\n    queryKey: [\n      GILL_HOOK_CLIENT_KEY,\n      \"getTokenAccount\",\n      hasDeclaredAta(tokenAccountOptions)\n        ? [{ ata: tokenAccountOptions.ata }]\n        : [\n            {\n              mint: tokenAccountOptions.mint,\n              owner: tokenAccountOptions.owner,\n            },\n          ],\n    ],\n  });\n\n  return {\n    ...rest,\n    account: data as UseTokenAccountResponse<TAddress>,\n  };\n}\n", "\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { GILL_HOOK_CLIENT_KEY } from \"../const\";\nimport { useSolanaClient } from \"./client\";\nimport type { GillUseRpcHook } from \"./types\";\n\nimport type { Account, Address, FetchAccountConfig, Simplify } from \"gill\";\nimport { assertAccountExists, fetchEncodedAccount } from \"gill\";\nimport { decodeMint, type Mint } from \"gill/programs/token\";\n\ntype RpcConfig = Simplify<Omit<FetchAccountConfig, \"abortSignal\">>;\n\ntype UseTokenMintResponse<TAddress extends string = string> = Simplify<\n  Account<Mint, TAddress> & {\n    exists: true;\n  }\n>;\n\ntype UseTokenMintInput<\n  TConfig extends RpcConfig = RpcConfig,\n  TAddress extends string = string,\n> = GillUseRpcHook<TConfig> & {\n  /**\n   * Address of the Mint account to get and decode\n   */\n  mint: TAddress | Address<TAddress>;\n};\n\n/**\n * Get and parse a token's {@link https://solana.com/docs/tokens#mint-account | Mint account}\n */\nexport function useTokenMint<TConfig extends RpcConfig = RpcConfig, TAddress extends string = string>({\n  options,\n  config,\n  abortSignal,\n  mint,\n}: UseTokenMintInput<TConfig, TAddress>) {\n  const { rpc } = useSolanaClient();\n\n  if (abortSignal) {\n    // @ts-expect-error we stripped the `abortSignal` from the type but are now adding it back in\n    config = {\n      ...(config || {}),\n      abortSignal,\n    };\n  }\n\n  const { data, ...rest } = useQuery({\n    networkMode: \"offlineFirst\",\n    ...options,\n    enabled: !!mint,\n    queryKey: [GILL_HOOK_CLIENT_KEY, \"getMintAccount\", mint],\n    queryFn: async () => {\n      const account = await fetchEncodedAccount(rpc, mint as Address<TAddress>, config);\n      assertAccountExists(account);\n      return decodeMint(account);\n    },\n  });\n  return {\n    ...rest,\n    account: data as UseTokenMintResponse<TAddress>,\n  };\n}\n", "\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport type { GetTransactionApi, Signature, Simplify } from \"gill\";\nimport { GILL_HOOK_CLIENT_KEY } from \"../const\";\nimport { useSolanaClient } from \"./client\";\nimport type { GillUseRpcHook } from \"./types\";\n\ntype RpcConfig = Simplify<Parameters<GetTransactionApi[\"getTransaction\"]>[1]>;\n\ntype UseTransactionResponse = ReturnType<GetTransactionApi[\"getTransaction\"]>;\n\ntype UseTransactionInput<TConfig extends RpcConfig = RpcConfig> = GillUseRpcHook<TConfig> & {\n  /**\n   * Transaction signature as a base-58 encoded string\n   */\n  signature: Signature | string;\n};\n\n/**\n * Get transaction details for a confirmed transaction using the Solana RPC method of\n * [`getTransaction`](https://solana.com/docs/rpc/http/gettransaction)\n *\n * Default `config` includes:\n * - `maxSupportedTransactionVersion` of `0`\n * - `encoding` of `json`\n */\nexport function useTransaction<TConfig extends RpcConfig = RpcConfig>({\n  options,\n  config,\n  abortSignal,\n  signature,\n}: UseTransactionInput<TConfig>) {\n  const { rpc } = useSolanaClient();\n  const { data, ...rest } = useQuery({\n    networkMode: \"offlineFirst\",\n    ...options,\n    enabled: !!signature,\n    queryKey: [GILL_HOOK_CLIENT_KEY, \"getTransaction\", signature],\n    queryFn: async () => {\n      const response = await rpc\n        .getTransaction(signature as Signature, {\n          // set default values for better DX\n          maxSupportedTransactionVersion: 0,\n          encoding: \"json\",\n          ...(config || {}),\n        })\n        .send({ abortSignal });\n      return response;\n    },\n  });\n  return {\n    ...rest,\n    transaction: data as UseTransactionResponse,\n  };\n}\n", "// @ts-ignore - Patch BigInt to allow calling `JSON.stringify` on objects that use\ninterface BigInt {\n  /** Convert a BigInt to string form when calling `JSON.stringify()` */\n  toJSON: () => string;\n}\n\n// @ts-ignore - Only add the toJSON method if it doesn't already exist\nif (BigInt.prototype.toJSON === undefined) {\n  // @ts-ignore - toJSON does not exist which is why we are patching it\n  BigInt.prototype.toJSON = function () {\n    return String(this);\n  };\n}\n\nexport * from \"./const\";\nexport * from \"./providers\";\nexport * from \"./hooks\";\n"],
  "mappings": "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",
  "names": ["process", "process", "process", "process", "queryFnContext", "context", "queryFnContext", "getDefaultState", "getDefaultState", "React", "React", "React", "import_jsx_runtime", "React", "React", "process", "React", "React", "React", "React", "AccountState", "AuthorityType", "fixDecoderSize", "getBytesDecoder", "ExtensionType", "getStructDecoder", "getU64Decoder", "getU16Decoder", "getStructDecoder", "getOptionDecoder", "getAddressDecoder", "getU32Decoder", "getU64Decoder", "getBooleanDecoder", "address", "getStructDecoder", "getAddressDecoder", "getU64Decoder", "getOptionDecoder", "getU32Decoder", "getHiddenPrefixDecoder", "getArrayDecoder", "getConstantDecoder", "getU8Encoder", "decodeAccount", "AssociatedTokenInstruction", "Token2022Account", "Token2022Instruction", "process", "process", "getAddressEncoder", "NonceState", "NonceVersion", "SystemAccount", "SystemInstruction", "process", "UseMethod", "TokenMetadataAccount", "TokenMetadataInstruction", "React", "address", "useQuery", "fetchEncodedAccount", "assertAccountExists"]
}
