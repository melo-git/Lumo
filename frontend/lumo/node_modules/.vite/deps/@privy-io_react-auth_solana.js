import {
  $m,
  Ao,
  Bo,
  CheckCircleIcon_default,
  Ci,
  Cl,
  Df,
  Di,
  Eo,
  Fo,
  Go,
  Hf,
  I2 as I,
  Il,
  Io,
  Jh,
  Kh,
  Km,
  Ko,
  Ku,
  L2 as L,
  Lo,
  M2 as M,
  Ml,
  Mo,
  Nl,
  No,
  Or,
  Po,
  Pr,
  Ra2 as Ra,
  Sl,
  So,
  Uc,
  Vl,
  Vo,
  Xo,
  Yr,
  Zg,
  Zr,
  _,
  _o,
  a3 as a,
  b2 as b,
  bn,
  ci,
  cp,
  dr,
  dt,
  eg,
  f2 as f,
  fg,
  i3 as i,
  la2 as la,
  m2 as m,
  mg,
  n2 as n,
  ny,
  p,
  p4 as p2,
  pp,
  pr,
  q2 as q,
  qf,
  r4 as r,
  r6 as r2,
  r7 as r3,
  require_browser,
  require_es5,
  require_lib,
  s,
  u,
  v2 as v,
  vg,
  vm,
  y2 as y,
  yg,
  z,
  zc,
  zi
} from "./chunk-UDZM6VGO.js";
import "./chunk-RHY4GUXE.js";
import "./chunk-VRS73S24.js";
import {
  base58,
  base64
} from "./chunk-DRSJMV4G.js";
import "./chunk-BVEVOLUJ.js";
import "./chunk-MLKXWGQV.js";
import "./chunk-PKYTL2RT.js";
import "./chunk-UU5WQT5Y.js";
import "./chunk-YIZCVY2B.js";
import "./chunk-OFYYQGW5.js";
import "./chunk-A5EXECA2.js";
import "./chunk-4A34GHET.js";
import "./chunk-3HCG2SZW.js";
import "./chunk-OISTZNKL.js";
import "./chunk-IZNJ6FWV.js";
import {
  eventemitter3_default
} from "./chunk-NSRIWIO5.js";
import "./chunk-O6QMZTUY.js";
import "./chunk-UXERXID2.js";
import {
  require_jsx_runtime
} from "./chunk-RCILDZKZ.js";
import {
  require_react
} from "./chunk-PEG7TMOV.js";
import {
  __toESM,
  import_buffer,
  import_process,
  init_shim
} from "./chunk-HEPQZC56.js";

// node_modules/@privy-io/react-auth/dist/esm/solana.mjs
init_shim();
var import_react2 = __toESM(require_react(), 1);

// node_modules/@solana/kit/dist/index.browser.mjs
init_shim();

// node_modules/@solana/accounts/dist/index.browser.mjs
init_shim();

// node_modules/@solana/errors/dist/index.browser.mjs
init_shim();
var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;
var SOLANA_ERROR__INVALID_NONCE = 2;
var SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;
var SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;
var SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;
var SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;
var SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;
var SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;
var SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;
var SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;
var SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;
var SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;
var SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;
var SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;
var SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE = -32019;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY = -32018;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE = -32017;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;
var SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;
var SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 28e5;
var SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;
var SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;
var SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;
var SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;
var SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;
var SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;
var SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;
var SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;
var SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;
var SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;
var SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;
var SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 323e4;
var SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;
var SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;
var SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;
var SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;
var SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 361e4;
var SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;
var SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;
var SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;
var SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;
var SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;
var SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;
var SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;
var SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611e3;
var SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704e3;
var SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;
var SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;
var SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;
var SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;
var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128e3;
var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;
var SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615e3;
var SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;
var SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;
var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;
var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;
var SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;
var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;
var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;
var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;
var SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;
var SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;
var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;
var SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;
var SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;
var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;
var SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;
var SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;
var SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;
var SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;
var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;
var SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;
var SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;
var SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;
var SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;
var SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508e3;
var SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;
var SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;
var SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;
var SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;
var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663e3;
var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;
var SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;
var SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;
var SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;
var SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;
var SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;
var SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;
var SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;
var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;
var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;
var SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;
var SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;
var SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;
var SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;
var SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;
var SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 705e4;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;
var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;
var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;
var SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;
var SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;
var SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;
var SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;
var SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;
var SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;
var SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;
var SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;
var SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;
var SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;
var SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;
var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;
var SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;
var SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;
var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;
var SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;
var SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN = 7618e3;
var SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE = 7618001;
var SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN = 7618002;
var SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN = 7618003;
var SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3;
var SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;
var SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;
var SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;
var SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;
var SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;
var SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;
var SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;
var SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;
var SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;
var SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;
var SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;
var SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;
var SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;
var SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;
var SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;
var SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;
var SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;
var SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;
var SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;
var SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 81e5;
var SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;
var SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;
var SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 819e4;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;
var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 99e5;
var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;
var SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;
var SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;
var SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;
var SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND = 9900005;
var SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND = 9900006;
function encodeValue(value) {
  if (Array.isArray(value)) {
    const commaSeparatedValues = value.map(encodeValue).join(
      "%2C%20"
      /* ", " */
    );
    return "%5B" + commaSeparatedValues + /* "]" */
    "%5D";
  } else if (typeof value === "bigint") {
    return `${value}n`;
  } else {
    return encodeURIComponent(
      String(
        value != null && Object.getPrototypeOf(value) === null ? (
          // Plain objects with no prototype don't have a `toString` method.
          // Convert them before stringifying them.
          { ...value }
        ) : value
      )
    );
  }
}
function encodeObjectContextEntry([key, value]) {
  return `${key}=${encodeValue(value)}`;
}
function encodeContextObject(context) {
  const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join("&");
  return btoa(searchParamsString);
}
var SolanaErrorMessages = {
  [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: "Account not found at address: $address",
  [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
  [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: "Expected decoded account at address: $address",
  [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: "Failed to decode account data at address: $address",
  [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: "Accounts not found at addresses: $addresses",
  [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: "Unable to find a viable program address bump seed.",
  [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: "$putativeAddress is not a base58-encoded address.",
  [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: "The `CryptoKey` must be an `Ed25519` public key.",
  [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]: "$putativeOffCurveAddress is not a base58-encoded off-curve address.",
  [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: "Invalid seeds; point must fall off the Ed25519 curve.",
  [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
  [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
  [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
  [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
  [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: "Program address cannot end with PDA marker.",
  [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
  [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
  [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: "The network has progressed past the last block for which this transaction could have been committed.",
  [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: "Codec [$codecDescription] cannot decode empty byte arrays.",
  [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
  [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: "Encoder and decoder must either both be fixed-size or variable-size.",
  [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
  [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: "Expected a fixed-size codec, got a variable-size one.",
  [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
  [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: "Expected a variable-size codec, got a fixed-size one.",
  [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
  [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
  [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
  [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
  [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
  [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: "Invalid literal union variant. Expected one of [$variants], got $value.",
  [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: "Expected [$codecDescription] to have $expected items, got $actual.",
  [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: "Invalid value $value for base $base with alphabet $alphabet.",
  [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
  [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
  [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
  [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
  [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
  [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: "No random values implementation could be found.",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: "instruction requires an uninitialized account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: "instruction tries to borrow reference for an account which is already borrowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "instruction left account with an outstanding borrowed reference",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: "program other than the account's owner changed the size of the account data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: "account data too small for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: "instruction expected an executable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: "An account does not have enough lamports to be rent-exempt",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: "Program arithmetic overflowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: "Failed to serialize or deserialize account data: $encodedData",
  [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: "Builtin programs must consume compute units",
  [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: "Cross-program invocation call depth too deep",
  [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: "Computational budget exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: "custom program error: #$code",
  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: "instruction contains duplicate accounts",
  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: "instruction modifications of multiply-passed account differ",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: "executable accounts must be rent exempt",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: "instruction changed executable accounts data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: "instruction changed the balance of an executable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: "instruction changed executable bit of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: "instruction modified data of an account it does not own",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: "instruction spent from the balance of an account it does not own",
  [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: "generic instruction error",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: "Provided owner is not allowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: "Account is immutable",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: "Incorrect authority provided",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: "incorrect program id for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: "insufficient funds for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: "invalid account data for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: "Invalid account owner",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: "invalid program argument",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: "program returned invalid error code",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: "invalid instruction data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: "Failed to reallocate account data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: "Provided seeds do not result in a valid address",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: "Accounts data allocations exceeded the maximum allowed per transaction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: "Max accounts exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: "Max instruction trace length exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: "Length of the seed is too long for address generation",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: "An account required by the instruction is missing",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: "missing required signature for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: "instruction illegally modified the program id of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: "insufficient account keys for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: "Cross-program invocation with unauthorized signer or writable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: "Failed to create program execution environment",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: "Program failed to compile",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: "Program failed to complete",
  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: "instruction modified data of a read-only account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: "instruction changed the balance of a read-only account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: "Cross-program invocation reentrancy not allowed for this instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: "instruction modified rent epoch of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: "sum of account balances before and after instruction do not match",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: "instruction requires an initialized account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: "",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: "Unsupported program id",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: "Unsupported sysvar",
  [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND]: "Invalid instruction plan kind: $kind.",
  [SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN]: "The provided instruction plan is empty.",
  [SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN]: "The provided transaction plan failed to execute. See the `transactionPlanResult` attribute and the `cause` error for more details.",
  [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN]: "The provided message has insufficient capacity to accommodate the next instruction(s) in this plan. Expected at least $numBytesRequired free byte(s), got $numFreeBytes byte(s).",
  [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND]: "Invalid transaction plan kind: $kind.",
  [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE]: "No more instructions to pack; the message packer has completed the instruction plan.",
  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: "The instruction does not have any accounts.",
  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: "The instruction does not have any data.",
  [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
  [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__INVALID_NONCE]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
  [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: "Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE]: "Epoch rewards period still active at slot $slot",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE]: "Failed to query long-term storage; please try again",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: "Minimum context slot has not been reached",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: "Node is unhealthy; behind by $numSlotsBehind slots",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: "No snapshot",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: "Transaction simulation failed",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY]: "Rewards cannot be found because slot $slot is not the epoch boundary. This may be due to gap in the queried node's local ledger or long-term storage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: "Transaction history is not available from this node",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: "Transaction signature length mismatch",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: "Transaction signature verification failure",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: "$__serverMessage",
  [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: "Key pair bytes must be of length 64, got $byteLength.",
  [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: "Expected private key bytes with length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
  [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: "The provided private key does not match the provided public key.",
  [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
  [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: "Lamports value must be in the range [0, 2e64-1]",
  [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: "`$value` cannot be parsed as a `BigInt`",
  [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: "$message",
  [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: "`$value` cannot be parsed as a `Number`",
  [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: "No nonce account could be found at address `$nonceAccountAddress`",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: "The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]: "WebSocket was closed before payload could be added to the send buffer",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: "WebSocket connection closed",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: "WebSocket failed to connect",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: "Failed to obtain a subscription id from the server",
  [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: "Could not find an API plan for RPC method: `$method`",
  [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: "HTTP error ($statusCode): $message",
  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
  [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
  [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: "The provided value does not implement the `KeyPairSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: "The provided value does not implement the `MessageModifyingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: "The provided value does not implement the `MessagePartialSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: "The provided value does not implement any of the `MessageSigner` interfaces",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: "The provided value does not implement the `TransactionModifyingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: "The provided value does not implement the `TransactionPartialSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: "The provided value does not implement the `TransactionSendingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: "The provided value does not implement any of the `TransactionSigner` interfaces",
  [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: "More than one `TransactionSendingSigner` was identified.",
  [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: "No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.",
  [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
  [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: "Cannot export a non-extractable key.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: "No digest implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: "This runtime does not support the generation of Ed25519 key pairs.\n\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\n\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: "No signature verification implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: "No key generation implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: "No signing implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: "No key export implementation could be found.",
  [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: "Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "Transaction processing left an account with an outstanding borrowed reference",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: "Account in use",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: "Account loaded twice",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: "Attempt to debit an account but found no record of a prior credit.",
  [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: "Transaction loads an address table account that doesn't exist",
  [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: "This transaction has already been processed",
  [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: "Blockhash not found",
  [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: "Loader call chain is too deep",
  [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: "Transactions are currently disabled due to cluster maintenance",
  [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: "Transaction contains a duplicate instruction ($index) that is not allowed",
  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: "Insufficient funds for fee",
  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: "This account may not be used to pay transaction fees",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: "Transaction contains an invalid account reference",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: "Transaction loads an address table account with invalid data",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: "Transaction address table lookup uses an invalid index",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: "Transaction loads an address table account with an invalid owner",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: "This program may not be used for executing instructions",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: "Transaction loads a writable account that cannot be written",
  [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: "Transaction exceeded max loaded accounts data size cap",
  [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: "Transaction requires a fee but has no signature present",
  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: "Attempt to load a program that does not exist",
  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
  [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: "ResanitizationNeeded",
  [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: "Transaction failed to sanitize accounts offsets correctly",
  [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: "Transaction did not pass signature verification",
  [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: "Transaction locked too many accounts",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: "Sum of account balances before and after transaction do not match",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: "The transaction failed with the error `$errorName`",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: "Transaction version is unsupported",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: "Transaction would exceed account data limit within the block",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: "Transaction would exceed total account data limit",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: "Transaction would exceed max account limit within the block",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: "Transaction would exceed max Block Cost Limit",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: "Transaction would exceed max Vote Cost Limit",
  [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: "Attempted to sign a transaction with an address that is not a signer for it",
  [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: "Transaction is missing an address at index: $index.",
  [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: "Transaction has no expected signers therefore it cannot be encoded",
  [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: "Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes",
  [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: "Transaction does not have a blockhash lifetime",
  [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: "Transaction is not a durable nonce transaction",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: "No fee payer set in CompiledTransaction",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: "Could not find program address at index $index",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
  [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: "Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",
  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: "Transaction is missing a fee payer.",
  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: "Transaction first instruction is not advance nonce account instruction.",
  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: "Transaction with no instructions cannot be durable nonce transaction.",
  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
  [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: "The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",
  [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: "Transaction is missing signatures for addresses: $addresses.",
  [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: "Transaction version must be in the range [0, 127]. `$actualVersion` given"
};
var START_INDEX = "i";
var TYPE = "t";
function getHumanReadableErrorMessage(code, context = {}) {
  const messageFormatString = SolanaErrorMessages[code];
  if (messageFormatString.length === 0) {
    return "";
  }
  let state;
  function commitStateUpTo(endIndex) {
    if (state[TYPE] === 2) {
      const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);
      fragments.push(
        variableName in context ? (
          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
          `${context[variableName]}`
        ) : `$${variableName}`
      );
    } else if (state[TYPE] === 1) {
      fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));
    }
  }
  const fragments = [];
  messageFormatString.split("").forEach((char, ii) => {
    if (ii === 0) {
      state = {
        [START_INDEX]: 0,
        [TYPE]: messageFormatString[0] === "\\" ? 0 : messageFormatString[0] === "$" ? 2 : 1
        /* Text */
      };
      return;
    }
    let nextState;
    switch (state[TYPE]) {
      case 0:
        nextState = {
          [START_INDEX]: ii,
          [TYPE]: 1
          /* Text */
        };
        break;
      case 1:
        if (char === "\\") {
          nextState = {
            [START_INDEX]: ii,
            [TYPE]: 0
            /* EscapeSequence */
          };
        } else if (char === "$") {
          nextState = {
            [START_INDEX]: ii,
            [TYPE]: 2
            /* Variable */
          };
        }
        break;
      case 2:
        if (char === "\\") {
          nextState = {
            [START_INDEX]: ii,
            [TYPE]: 0
            /* EscapeSequence */
          };
        } else if (char === "$") {
          nextState = {
            [START_INDEX]: ii,
            [TYPE]: 2
            /* Variable */
          };
        } else if (!char.match(/\w/)) {
          nextState = {
            [START_INDEX]: ii,
            [TYPE]: 1
            /* Text */
          };
        }
        break;
    }
    if (nextState) {
      if (state !== nextState) {
        commitStateUpTo(ii);
      }
      state = nextState;
    }
  });
  commitStateUpTo();
  return fragments.join("");
}
function getErrorMessage(code, context = {}) {
  if (import_process.default.env.NODE_ENV !== "production") {
    return getHumanReadableErrorMessage(code, context);
  } else {
    let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \`npx @solana/errors decode -- ${code}`;
    if (Object.keys(context).length) {
      decodingAdviceMessage += ` '${encodeContextObject(context)}'`;
    }
    return `${decodingAdviceMessage}\``;
  }
}
function isSolanaError(e3, code) {
  const isSolanaError2 = e3 instanceof Error && e3.name === "SolanaError";
  if (isSolanaError2) {
    if (code !== void 0) {
      return e3.context.__code === code;
    }
    return true;
  }
  return false;
}
var SolanaError = class extends Error {
  /**
   * Indicates the root cause of this {@link SolanaError}, if any.
   *
   * For example, a transaction error might have an instruction error as its root cause. In this
   * case, you will be able to access the instruction error on the transaction error as `cause`.
   */
  cause = this.cause;
  /**
   * Contains context that can assist in understanding or recovering from a {@link SolanaError}.
   */
  context;
  constructor(...[code, contextAndErrorOptions]) {
    let context;
    let errorOptions;
    if (contextAndErrorOptions) {
      Object.entries(Object.getOwnPropertyDescriptors(contextAndErrorOptions)).forEach(([name, descriptor]) => {
        if (name === "cause") {
          errorOptions = { cause: descriptor.value };
        } else {
          if (context === void 0) {
            context = {};
          }
          Object.defineProperty(context, name, descriptor);
        }
      });
    }
    const message = getErrorMessage(code, context);
    super(message, errorOptions);
    this.context = context === void 0 ? {} : context;
    this.context.__code = code;
    this.name = "SolanaError";
  }
};

// node_modules/@solana/codecs-strings/dist/index.browser.mjs
init_shim();

// node_modules/@solana/codecs-core/dist/index.browser.mjs
init_shim();
function padBytes(bytes, length) {
  if (bytes.length >= length) return bytes;
  const paddedBytes = new Uint8Array(length).fill(0);
  paddedBytes.set(bytes);
  return paddedBytes;
}
var fixBytes = (bytes, length) => padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);
function getEncodedSize(value, encoder) {
  return "fixedSize" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);
}
function createEncoder(encoder) {
  return Object.freeze({
    ...encoder,
    encode: (value) => {
      const bytes = new Uint8Array(getEncodedSize(value, encoder));
      encoder.write(value, bytes, 0);
      return bytes;
    }
  });
}
function createDecoder(decoder) {
  return Object.freeze({
    ...decoder,
    decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0]
  });
}
function isFixedSize(codec) {
  return "fixedSize" in codec && typeof codec.fixedSize === "number";
}
function isVariableSize(codec) {
  return !isFixedSize(codec);
}
function combineCodec(encoder, decoder) {
  if (isFixedSize(encoder) !== isFixedSize(decoder)) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);
  }
  if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {
      decoderFixedSize: decoder.fixedSize,
      encoderFixedSize: encoder.fixedSize
    });
  }
  if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {
      decoderMaxSize: decoder.maxSize,
      encoderMaxSize: encoder.maxSize
    });
  }
  return {
    ...decoder,
    ...encoder,
    decode: decoder.decode,
    encode: encoder.encode,
    read: decoder.read,
    write: encoder.write
  };
}
function assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {
  if (bytes.length - offset <= 0) {
    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {
      codecDescription
    });
  }
}
function assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {
  const bytesLength = bytes.length - offset;
  if (bytesLength < expected) {
    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {
      bytesLength,
      codecDescription,
      expected
    });
  }
}
function assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {
  if (offset < 0 || offset > bytesLength) {
    throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {
      bytesLength,
      codecDescription,
      offset
    });
  }
}
function addEncoderSizePrefix(encoder, prefix) {
  const write = (value, bytes, offset) => {
    const encoderBytes = encoder.encode(value);
    offset = prefix.write(encoderBytes.length, bytes, offset);
    bytes.set(encoderBytes, offset);
    return offset + encoderBytes.length;
  };
  if (isFixedSize(prefix) && isFixedSize(encoder)) {
    return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });
  }
  const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;
  const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;
  const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;
  return createEncoder({
    ...encoder,
    ...maxSize !== null ? { maxSize } : {},
    getSizeFromValue: (value) => {
      const encoderSize = getEncodedSize(value, encoder);
      return getEncodedSize(encoderSize, prefix) + encoderSize;
    },
    write
  });
}
function addDecoderSizePrefix(decoder, prefix) {
  const read = (bytes, offset) => {
    const [bigintSize, decoderOffset] = prefix.read(bytes, offset);
    const size = Number(bigintSize);
    offset = decoderOffset;
    if (offset > 0 || bytes.length > size) {
      bytes = bytes.slice(offset, offset + size);
    }
    assertByteArrayHasEnoughBytesForCodec("addDecoderSizePrefix", size, bytes);
    return [decoder.decode(bytes), offset + size];
  };
  if (isFixedSize(prefix) && isFixedSize(decoder)) {
    return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });
  }
  const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;
  const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;
  const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;
  return createDecoder({ ...decoder, ...maxSize !== null ? { maxSize } : {}, read });
}
function fixEncoderSize(encoder, fixedBytes) {
  return createEncoder({
    fixedSize: fixedBytes,
    write: (value, bytes, offset) => {
      const variableByteArray = encoder.encode(value);
      const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;
      bytes.set(fixedByteArray, offset);
      return offset + fixedBytes;
    }
  });
}
function fixDecoderSize(decoder, fixedBytes) {
  return createDecoder({
    fixedSize: fixedBytes,
    read: (bytes, offset) => {
      assertByteArrayHasEnoughBytesForCodec("fixCodecSize", fixedBytes, bytes, offset);
      if (offset > 0 || bytes.length > fixedBytes) {
        bytes = bytes.slice(offset, offset + fixedBytes);
      }
      if (isFixedSize(decoder)) {
        bytes = fixBytes(bytes, decoder.fixedSize);
      }
      const [value] = decoder.read(bytes, 0);
      return [value, offset + fixedBytes];
    }
  });
}
function offsetDecoder(decoder, config) {
  return createDecoder({
    ...decoder,
    read: (bytes, preOffset) => {
      const wrapBytes = (offset) => modulo(offset, bytes.length);
      const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;
      assertByteArrayOffsetIsNotOutOfRange("offsetDecoder", newPreOffset, bytes.length);
      const [value, postOffset] = decoder.read(bytes, newPreOffset);
      const newPostOffset = config.postOffset ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;
      assertByteArrayOffsetIsNotOutOfRange("offsetDecoder", newPostOffset, bytes.length);
      return [value, newPostOffset];
    }
  });
}
function modulo(dividend, divisor) {
  if (divisor === 0) return 0;
  return (dividend % divisor + divisor) % divisor;
}
function resizeDecoder(decoder, resize) {
  if (isFixedSize(decoder)) {
    const fixedSize = resize(decoder.fixedSize);
    if (fixedSize < 0) {
      throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {
        bytesLength: fixedSize,
        codecDescription: "resizeDecoder"
      });
    }
    return createDecoder({ ...decoder, fixedSize });
  }
  return decoder;
}
function padRightDecoder(decoder, offset) {
  return offsetDecoder(
    resizeDecoder(decoder, (size) => size + offset),
    { postOffset: ({ postOffset }) => postOffset + offset }
  );
}
function transformEncoder(encoder, unmap) {
  return createEncoder({
    ...isVariableSize(encoder) ? { ...encoder, getSizeFromValue: (value) => encoder.getSizeFromValue(unmap(value)) } : encoder,
    write: (value, bytes, offset) => encoder.write(unmap(value), bytes, offset)
  });
}
function transformDecoder(decoder, map) {
  return createDecoder({
    ...decoder,
    read: (bytes, offset) => {
      const [value, newOffset] = decoder.read(bytes, offset);
      return [map(value, bytes, offset), newOffset];
    }
  });
}

// node_modules/@solana/codecs-strings/dist/index.browser.mjs
function assertValidBaseString(alphabet4, testValue, givenValue = testValue) {
  if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {
    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
      alphabet: alphabet4,
      base: alphabet4.length,
      value: givenValue
    });
  }
}
var getBaseXEncoder = (alphabet4) => {
  return createEncoder({
    getSizeFromValue: (value) => {
      const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);
      if (!tailChars) return value.length;
      const base10Number = getBigIntFromBaseX(tailChars, alphabet4);
      return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);
    },
    write(value, bytes, offset) {
      assertValidBaseString(alphabet4, value);
      if (value === "") return offset;
      const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);
      if (!tailChars) {
        bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);
        return offset + leadingZeroes.length;
      }
      let base10Number = getBigIntFromBaseX(tailChars, alphabet4);
      const tailBytes = [];
      while (base10Number > 0n) {
        tailBytes.unshift(Number(base10Number % 256n));
        base10Number /= 256n;
      }
      const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];
      bytes.set(bytesToAdd, offset);
      return offset + bytesToAdd.length;
    }
  });
};
var getBaseXDecoder = (alphabet4) => {
  return createDecoder({
    read(rawBytes, offset) {
      const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);
      if (bytes.length === 0) return ["", 0];
      let trailIndex = bytes.findIndex((n2) => n2 !== 0);
      trailIndex = trailIndex === -1 ? bytes.length : trailIndex;
      const leadingZeroes = alphabet4[0].repeat(trailIndex);
      if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];
      const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);
      const tailChars = getBaseXFromBigInt(base10Number, alphabet4);
      return [leadingZeroes + tailChars, rawBytes.length];
    }
  });
};
function partitionLeadingZeroes(value, zeroCharacter) {
  const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));
  return [leadingZeros, tailChars];
}
function getBigIntFromBaseX(value, alphabet4) {
  const base = BigInt(alphabet4.length);
  let sum = 0n;
  for (const char of value) {
    sum *= base;
    sum += BigInt(alphabet4.indexOf(char));
  }
  return sum;
}
function getBaseXFromBigInt(value, alphabet4) {
  const base = BigInt(alphabet4.length);
  const tailChars = [];
  while (value > 0n) {
    tailChars.unshift(alphabet4[Number(value % base)]);
    value /= base;
  }
  return tailChars.join("");
}
var alphabet2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var getBase58Encoder = () => getBaseXEncoder(alphabet2);
var getBase58Decoder = () => getBaseXDecoder(alphabet2);
var alphabet3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var getBase64Encoder = () => {
  {
    return createEncoder({
      getSizeFromValue: (value) => {
        try {
          return atob(value).length;
        } catch {
          throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
            alphabet: alphabet3,
            base: 64,
            value
          });
        }
      },
      write(value, bytes, offset) {
        try {
          const bytesToAdd = atob(value).split("").map((c) => c.charCodeAt(0));
          bytes.set(bytesToAdd, offset);
          return bytesToAdd.length + offset;
        } catch {
          throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
            alphabet: alphabet3,
            base: 64,
            value
          });
        }
      }
    });
  }
};
var getBase64Decoder = () => {
  {
    return createDecoder({
      read(bytes, offset = 0) {
        const slice = bytes.slice(offset);
        const value = btoa(String.fromCharCode(...slice));
        return [value, bytes.length];
      }
    });
  }
};
var e = globalThis.TextDecoder;
var o = globalThis.TextEncoder;
var getUtf8Encoder = () => {
  let textEncoder;
  return createEncoder({
    getSizeFromValue: (value) => (textEncoder ||= new o()).encode(value).length,
    write: (value, bytes, offset) => {
      const bytesToAdd = (textEncoder ||= new o()).encode(value);
      bytes.set(bytesToAdd, offset);
      return offset + bytesToAdd.length;
    }
  });
};

// node_modules/@solana/accounts/dist/index.browser.mjs
function accountExists(account) {
  return !("exists" in account) || "exists" in account && account.exists;
}
function assertAccountsDecoded(accounts) {
  const encoded = accounts.filter((a2) => accountExists(a2) && a2.data instanceof Uint8Array);
  if (encoded.length > 0) {
    const encodedAddresses = encoded.map((a2) => a2.address);
    throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, {
      addresses: encodedAddresses
    });
  }
}
function parseBase64RpcAccount(address2, rpcAccount) {
  if (!rpcAccount) return Object.freeze({ address: address2, exists: false });
  const data = getBase64Encoder().encode(rpcAccount.data[0]);
  return Object.freeze({ ...parseBaseAccount(rpcAccount), address: address2, data, exists: true });
}
function parseJsonRpcAccount(address2, rpcAccount) {
  if (!rpcAccount) return Object.freeze({ address: address2, exists: false });
  const data = rpcAccount.data.parsed.info;
  return Object.freeze({ ...parseBaseAccount(rpcAccount), address: address2, data, exists: true });
}
function parseBaseAccount(rpcAccount) {
  return Object.freeze({
    executable: rpcAccount.executable,
    lamports: rpcAccount.lamports,
    programAddress: rpcAccount.owner,
    space: rpcAccount.space
  });
}
async function fetchJsonParsedAccounts(rpc, addresses, config = {}) {
  const { abortSignal, ...rpcConfig } = config;
  const response = await rpc.getMultipleAccounts(addresses, { ...rpcConfig, encoding: "jsonParsed" }).send({ abortSignal });
  return response.value.map((account, index) => {
    return !!account && typeof account === "object" && "parsed" in account.data ? parseJsonRpcAccount(addresses[index], account) : parseBase64RpcAccount(addresses[index], account);
  });
}
function assertAccountsExist(accounts) {
  const missingAccounts = accounts.filter((a2) => !a2.exists);
  if (missingAccounts.length > 0) {
    const missingAddresses = missingAccounts.map((a2) => a2.address);
    throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND, { addresses: missingAddresses });
  }
}

// node_modules/@solana/addresses/dist/index.browser.mjs
init_shim();

// node_modules/@solana/assertions/dist/index.browser.mjs
init_shim();
function assertIsSecureContext() {
  if (!globalThis.isSecureContext) {
    throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT);
  }
}
function assertDigestCapabilityIsAvailable() {
  assertIsSecureContext();
  if (typeof globalThis.crypto === "undefined" || typeof globalThis.crypto.subtle?.digest !== "function") {
    throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED);
  }
}

// node_modules/@solana/addresses/dist/index.browser.mjs
var memoizedBase58Encoder;
var memoizedBase58Decoder;
function getMemoizedBase58Encoder() {
  if (!memoizedBase58Encoder) memoizedBase58Encoder = getBase58Encoder();
  return memoizedBase58Encoder;
}
function getMemoizedBase58Decoder() {
  if (!memoizedBase58Decoder) memoizedBase58Decoder = getBase58Decoder();
  return memoizedBase58Decoder;
}
function isAddress(putativeAddress) {
  if (
    // Lowest address (32 bytes of zeroes)
    putativeAddress.length < 32 || // Highest address (32 bytes of 255)
    putativeAddress.length > 44
  ) {
    return false;
  }
  const base58Encoder = getMemoizedBase58Encoder();
  try {
    return base58Encoder.encode(putativeAddress).byteLength === 32;
  } catch {
    return false;
  }
}
function assertIsAddress(putativeAddress) {
  if (
    // Lowest address (32 bytes of zeroes)
    putativeAddress.length < 32 || // Highest address (32 bytes of 255)
    putativeAddress.length > 44
  ) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, {
      actualLength: putativeAddress.length
    });
  }
  const base58Encoder = getMemoizedBase58Encoder();
  const bytes = base58Encoder.encode(putativeAddress);
  const numBytes = bytes.byteLength;
  if (numBytes !== 32) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, {
      actualLength: numBytes
    });
  }
}
function address(putativeAddress) {
  assertIsAddress(putativeAddress);
  return putativeAddress;
}
function getAddressEncoder() {
  return transformEncoder(
    fixEncoderSize(getMemoizedBase58Encoder(), 32),
    (putativeAddress) => address(putativeAddress)
  );
}
function getAddressDecoder() {
  return fixDecoderSize(getMemoizedBase58Decoder(), 32);
}
function getAddressCodec() {
  return combineCodec(getAddressEncoder(), getAddressDecoder());
}
function getAddressComparator() {
  return new Intl.Collator("en", {
    caseFirst: "lower",
    ignorePunctuation: false,
    localeMatcher: "best fit",
    numeric: false,
    sensitivity: "variant",
    usage: "sort"
  }).compare;
}
var D = 37095705934669439343138083508754565189542113879843219016388785533085940283555n;
var P = 57896044618658097711785492504343953926634992332820282019728792003956564819949n;
var RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n;
function mod(a2) {
  const r4 = a2 % P;
  return r4 >= 0n ? r4 : P + r4;
}
function pow2(x, power) {
  let r4 = x;
  while (power-- > 0n) {
    r4 *= r4;
    r4 %= P;
  }
  return r4;
}
function pow_2_252_3(x) {
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, 2n) * b2 % P;
  const b5 = pow2(b4, 1n) * x % P;
  const b10 = pow2(b5, 5n) * b5 % P;
  const b20 = pow2(b10, 10n) * b10 % P;
  const b40 = pow2(b20, 20n) * b20 % P;
  const b80 = pow2(b40, 40n) * b40 % P;
  const b160 = pow2(b80, 80n) * b80 % P;
  const b240 = pow2(b160, 80n) * b80 % P;
  const b250 = pow2(b240, 10n) * b10 % P;
  const pow_p_5_8 = pow2(b250, 2n) * x % P;
  return pow_p_5_8;
}
function uvRatio(u2, v2) {
  const v3 = mod(v2 * v2 * v2);
  const v7 = mod(v3 * v3 * v2);
  const pow = pow_2_252_3(u2 * v7);
  let x = mod(u2 * v3 * pow);
  const vx2 = mod(v2 * x * x);
  const root1 = x;
  const root2 = mod(x * RM1);
  const useRoot1 = vx2 === u2;
  const useRoot2 = vx2 === mod(-u2);
  const noRoot = vx2 === mod(-u2 * RM1);
  if (useRoot1) x = root1;
  if (useRoot2 || noRoot) x = root2;
  if ((mod(x) & 1n) === 1n) x = mod(-x);
  if (!useRoot1 && !useRoot2) {
    return null;
  }
  return x;
}
function pointIsOnCurve(y2, lastByte) {
  const y22 = mod(y2 * y2);
  const u2 = mod(y22 - 1n);
  const v2 = mod(D * y22 + 1n);
  const x = uvRatio(u2, v2);
  if (x === null) {
    return false;
  }
  const isLastByteOdd = (lastByte & 128) !== 0;
  if (x === 0n && isLastByteOdd) {
    return false;
  }
  return true;
}
function byteToHex(byte) {
  const hexString = byte.toString(16);
  if (hexString.length === 1) {
    return `0${hexString}`;
  } else {
    return hexString;
  }
}
function decompressPointBytes(bytes) {
  const hexString = bytes.reduce((acc, byte, ii) => `${byteToHex(ii === 31 ? byte & -129 : byte)}${acc}`, "");
  const integerLiteralString = `0x${hexString}`;
  return BigInt(integerLiteralString);
}
function compressedPointBytesAreOnCurve(bytes) {
  if (bytes.byteLength !== 32) {
    return false;
  }
  const y2 = decompressPointBytes(bytes);
  return pointIsOnCurve(y2, bytes[31]);
}
var MAX_SEED_LENGTH = 32;
var MAX_SEEDS = 16;
var PDA_MARKER_BYTES = [
  // The string 'ProgramDerivedAddress'
  80,
  114,
  111,
  103,
  114,
  97,
  109,
  68,
  101,
  114,
  105,
  118,
  101,
  100,
  65,
  100,
  100,
  114,
  101,
  115,
  115
];
async function createProgramDerivedAddress({ programAddress, seeds }) {
  assertDigestCapabilityIsAvailable();
  if (seeds.length > MAX_SEEDS) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED, {
      actual: seeds.length,
      maxSeeds: MAX_SEEDS
    });
  }
  let textEncoder;
  const seedBytes = seeds.reduce((acc, seed, ii) => {
    const bytes = typeof seed === "string" ? (textEncoder ||= new TextEncoder()).encode(seed) : seed;
    if (bytes.byteLength > MAX_SEED_LENGTH) {
      throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {
        actual: bytes.byteLength,
        index: ii,
        maxSeedLength: MAX_SEED_LENGTH
      });
    }
    acc.push(...bytes);
    return acc;
  }, []);
  const base58EncodedAddressCodec = getAddressCodec();
  const programAddressBytes = base58EncodedAddressCodec.encode(programAddress);
  const addressBytesBuffer = await crypto.subtle.digest(
    "SHA-256",
    new Uint8Array([...seedBytes, ...programAddressBytes, ...PDA_MARKER_BYTES])
  );
  const addressBytes = new Uint8Array(addressBytesBuffer);
  if (compressedPointBytesAreOnCurve(addressBytes)) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE);
  }
  return base58EncodedAddressCodec.decode(addressBytes);
}
async function getProgramDerivedAddress({
  programAddress,
  seeds
}) {
  let bumpSeed = 255;
  while (bumpSeed > 0) {
    try {
      const address2 = await createProgramDerivedAddress({
        programAddress,
        seeds: [...seeds, new Uint8Array([bumpSeed])]
      });
      return [address2, bumpSeed];
    } catch (e3) {
      if (isSolanaError(e3, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE)) {
        bumpSeed--;
      } else {
        throw e3;
      }
    }
  }
  throw new SolanaError(SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED);
}

// node_modules/@solana/codecs/dist/index.browser.mjs
init_shim();

// node_modules/@solana/codecs-data-structures/dist/index.browser.mjs
init_shim();

// node_modules/@solana/codecs-numbers/dist/index.browser.mjs
init_shim();
function assertNumberIsBetweenForCodec(codecDescription, min, max, value) {
  if (value < min || value > max) {
    throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {
      codecDescription,
      max,
      min,
      value
    });
  }
}
var Endian = ((Endian2) => {
  Endian2[Endian2["Little"] = 0] = "Little";
  Endian2[Endian2["Big"] = 1] = "Big";
  return Endian2;
})(Endian || {});
function isLittleEndian(config) {
  return config?.endian === 1 ? false : true;
}
function numberEncoderFactory(input) {
  return createEncoder({
    fixedSize: input.size,
    write(value, bytes, offset) {
      if (input.range) {
        assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);
      }
      const arrayBuffer = new ArrayBuffer(input.size);
      input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));
      bytes.set(new Uint8Array(arrayBuffer), offset);
      return offset + input.size;
    }
  });
}
function numberDecoderFactory(input) {
  return createDecoder({
    fixedSize: input.size,
    read(bytes, offset = 0) {
      assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);
      assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);
      const view = new DataView(toArrayBuffer(bytes, offset, input.size));
      return [input.get(view, isLittleEndian(input.config)), offset + input.size];
    }
  });
}
function toArrayBuffer(bytes, offset, length) {
  const bytesOffset = bytes.byteOffset + (offset ?? 0);
  const bytesLength = length ?? bytes.byteLength;
  return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);
}
var getShortU16Encoder = () => createEncoder({
  getSizeFromValue: (value) => {
    if (value <= 127) return 1;
    if (value <= 16383) return 2;
    return 3;
  },
  maxSize: 3,
  write: (value, bytes, offset) => {
    assertNumberIsBetweenForCodec("shortU16", 0, 65535, value);
    const shortU16Bytes = [0];
    for (let ii = 0; ; ii += 1) {
      const alignedValue = Number(value) >> ii * 7;
      if (alignedValue === 0) {
        break;
      }
      const nextSevenBits = 127 & alignedValue;
      shortU16Bytes[ii] = nextSevenBits;
      if (ii > 0) {
        shortU16Bytes[ii - 1] |= 128;
      }
    }
    bytes.set(shortU16Bytes, offset);
    return offset + shortU16Bytes.length;
  }
});
var getShortU16Decoder = () => createDecoder({
  maxSize: 3,
  read: (bytes, offset) => {
    let value = 0;
    let byteCount = 0;
    while (++byteCount) {
      const byteIndex = byteCount - 1;
      const currentByte = bytes[offset + byteIndex];
      const nextSevenBits = 127 & currentByte;
      value |= nextSevenBits << byteIndex * 7;
      if ((currentByte & 128) === 0) {
        break;
      }
    }
    return [value, offset + byteCount];
  }
});
var getU32Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "u32",
  range: [0, Number("0xffffffff")],
  set: (view, value, le) => view.setUint32(0, Number(value), le),
  size: 4
});
var getU32Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => view.getUint32(0, le),
  name: "u32",
  size: 4
});
var getU64Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "u64",
  range: [0n, BigInt("0xffffffffffffffff")],
  set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),
  size: 8
});
var getU8Encoder = () => numberEncoderFactory({
  name: "u8",
  range: [0, Number("0xff")],
  set: (view, value) => view.setUint8(0, Number(value)),
  size: 1
});
var getU8Decoder = () => numberDecoderFactory({
  get: (view) => view.getUint8(0),
  name: "u8",
  size: 1
});

// node_modules/@solana/codecs-data-structures/dist/index.browser.mjs
function assertValidNumberOfItemsForCodec(codecDescription, expected, actual) {
  if (expected !== actual) {
    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {
      actual,
      codecDescription,
      expected
    });
  }
}
function maxCodecSizes(sizes) {
  return sizes.reduce(
    (all, size) => all === null || size === null ? null : Math.max(all, size),
    0
  );
}
function sumCodecSizes(sizes) {
  return sizes.reduce((all, size) => all === null || size === null ? null : all + size, 0);
}
function getFixedSize(codec) {
  return isFixedSize(codec) ? codec.fixedSize : null;
}
function getMaxSize(codec) {
  return isFixedSize(codec) ? codec.fixedSize : codec.maxSize ?? null;
}
function getArrayEncoder(item, config = {}) {
  const size = config.size ?? getU32Encoder();
  const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));
  const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;
  return createEncoder({
    ...fixedSize !== null ? { fixedSize } : {
      getSizeFromValue: (array) => {
        const prefixSize = typeof size === "object" ? getEncodedSize(array.length, size) : 0;
        return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);
      },
      maxSize
    },
    write: (array, bytes, offset) => {
      if (typeof size === "number") {
        assertValidNumberOfItemsForCodec("array", size, array.length);
      }
      if (typeof size === "object") {
        offset = size.write(array.length, bytes, offset);
      }
      array.forEach((value) => {
        offset = item.write(value, bytes, offset);
      });
      return offset;
    }
  });
}
function getArrayDecoder(item, config = {}) {
  const size = config.size ?? getU32Decoder();
  const itemSize = getFixedSize(item);
  const fixedSize = computeArrayLikeCodecSize(size, itemSize);
  const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;
  return createDecoder({
    ...fixedSize !== null ? { fixedSize } : { maxSize },
    read: (bytes, offset) => {
      const array = [];
      if (typeof size === "object" && bytes.slice(offset).length === 0) {
        return [array, offset];
      }
      if (size === "remainder") {
        while (offset < bytes.length) {
          const [value, newOffset2] = item.read(bytes, offset);
          offset = newOffset2;
          array.push(value);
        }
        return [array, offset];
      }
      const [resolvedSize, newOffset] = typeof size === "number" ? [size, offset] : size.read(bytes, offset);
      offset = newOffset;
      for (let i2 = 0; i2 < resolvedSize; i2 += 1) {
        const [value, newOffset2] = item.read(bytes, offset);
        offset = newOffset2;
        array.push(value);
      }
      return [array, offset];
    }
  });
}
function computeArrayLikeCodecSize(size, itemSize) {
  if (typeof size !== "number") return null;
  if (size === 0) return 0;
  return itemSize === null ? null : itemSize * size;
}
function getBytesEncoder() {
  return createEncoder({
    getSizeFromValue: (value) => value.length,
    write: (value, bytes, offset) => {
      bytes.set(value, offset);
      return offset + value.length;
    }
  });
}
function getBytesDecoder() {
  return createDecoder({
    read: (bytes, offset) => {
      const slice = bytes.slice(offset);
      return [slice, offset + slice.length];
    }
  });
}
function getConstantEncoder(constant) {
  return createEncoder({
    fixedSize: constant.length,
    write: (_2, bytes, offset) => {
      bytes.set(constant, offset);
      return offset + constant.length;
    }
  });
}
function getTupleDecoder(items) {
  const fixedSize = sumCodecSizes(items.map(getFixedSize));
  const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;
  return createDecoder({
    ...fixedSize === null ? { maxSize } : { fixedSize },
    read: (bytes, offset) => {
      const values = [];
      items.forEach((item) => {
        const [newValue, newOffset] = item.read(bytes, offset);
        values.push(newValue);
        offset = newOffset;
      });
      return [values, offset];
    }
  });
}
function getUnionEncoder(variants, getIndexFromValue) {
  const fixedSize = getUnionFixedSize(variants);
  const write = (variant, bytes, offset) => {
    const index = getIndexFromValue(variant);
    assertValidVariantIndex(variants, index);
    return variants[index].write(variant, bytes, offset);
  };
  if (fixedSize !== null) {
    return createEncoder({ fixedSize, write });
  }
  const maxSize = getUnionMaxSize(variants);
  return createEncoder({
    ...maxSize !== null ? { maxSize } : {},
    getSizeFromValue: (variant) => {
      const index = getIndexFromValue(variant);
      assertValidVariantIndex(variants, index);
      return getEncodedSize(variant, variants[index]);
    },
    write
  });
}
function assertValidVariantIndex(variants, index) {
  if (typeof variants[index] === "undefined") {
    throw new SolanaError(SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {
      maxRange: variants.length - 1,
      minRange: 0,
      variant: index
    });
  }
}
function getUnionFixedSize(variants) {
  if (variants.length === 0) return 0;
  if (!isFixedSize(variants[0])) return null;
  const variantSize = variants[0].fixedSize;
  const sameSizedVariants = variants.every((variant) => isFixedSize(variant) && variant.fixedSize === variantSize);
  return sameSizedVariants ? variantSize : null;
}
function getUnionMaxSize(variants) {
  return maxCodecSizes(variants.map((variant) => getMaxSize(variant)));
}
function getStructEncoder(fields) {
  const fieldCodecs = fields.map(([, codec]) => codec);
  const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));
  const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;
  return createEncoder({
    ...fixedSize === null ? {
      getSizeFromValue: (value) => fields.map(([key, codec]) => getEncodedSize(value[key], codec)).reduce((all, one) => all + one, 0),
      maxSize
    } : { fixedSize },
    write: (struct, bytes, offset) => {
      fields.forEach(([key, codec]) => {
        offset = codec.write(struct[key], bytes, offset);
      });
      return offset;
    }
  });
}
function getStructDecoder(fields) {
  const fieldCodecs = fields.map(([, codec]) => codec);
  const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));
  const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;
  return createDecoder({
    ...fixedSize === null ? { maxSize } : { fixedSize },
    read: (bytes, offset) => {
      const struct = {};
      fields.forEach(([key, codec]) => {
        const [value, newOffset] = codec.read(bytes, offset);
        offset = newOffset;
        struct[key] = value;
      });
      return [struct, offset];
    }
  });
}

// node_modules/@solana/options/dist/index.browser.mjs
init_shim();

// node_modules/@solana/functional/dist/index.browser.mjs
init_shim();
function pipe(init, ...fns) {
  return fns.reduce((acc, fn2) => fn2(acc), init);
}

// node_modules/@solana/instructions/dist/index.browser.mjs
init_shim();
var AccountRole = ((AccountRole2) => {
  AccountRole2[AccountRole2["WRITABLE_SIGNER"] = /* 3 */
  3] = "WRITABLE_SIGNER";
  AccountRole2[AccountRole2["READONLY_SIGNER"] = /* 2 */
  2] = "READONLY_SIGNER";
  AccountRole2[AccountRole2["WRITABLE"] = /* 1 */
  1] = "WRITABLE";
  AccountRole2[AccountRole2["READONLY"] = /* 0 */
  0] = "READONLY";
  return AccountRole2;
})(AccountRole || {});
var IS_SIGNER_BITMASK = 2;
var IS_WRITABLE_BITMASK = 1;
function isSignerRole(role) {
  return role >= 2;
}
function isWritableRole(role) {
  return (role & IS_WRITABLE_BITMASK) !== 0;
}
function mergeRoles(roleA, roleB) {
  return roleA | roleB;
}
function upgradeRoleToSigner(role) {
  return role | IS_SIGNER_BITMASK;
}

// node_modules/@solana/instruction-plans/dist/index.browser.mjs
init_shim();

// node_modules/@solana/transaction-messages/dist/index.browser.mjs
init_shim();

// node_modules/@solana/rpc-types/dist/index.browser.mjs
init_shim();
function isBlockhash(putativeBlockhash) {
  return isAddress(putativeBlockhash);
}
function assertIsBlockhash(putativeBlockhash) {
  try {
    assertIsAddress(putativeBlockhash);
  } catch (error) {
    if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE)) {
      throw new SolanaError(SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, error.context);
    }
    if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH)) {
      throw new SolanaError(SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, error.context);
    }
    throw error;
  }
}
function blockhash(putativeBlockhash) {
  assertIsBlockhash(putativeBlockhash);
  return putativeBlockhash;
}

// node_modules/@solana/transaction-messages/dist/index.browser.mjs
function isTransactionMessageWithBlockhashLifetime(transactionMessage) {
  return "lifetimeConstraint" in transactionMessage && typeof transactionMessage.lifetimeConstraint.blockhash === "string" && typeof transactionMessage.lifetimeConstraint.lastValidBlockHeight === "bigint" && isBlockhash(transactionMessage.lifetimeConstraint.blockhash);
}
function setTransactionMessageLifetimeUsingBlockhash(blockhashLifetimeConstraint, transactionMessage) {
  if ("lifetimeConstraint" in transactionMessage && transactionMessage.lifetimeConstraint && "blockhash" in transactionMessage.lifetimeConstraint && transactionMessage.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash && transactionMessage.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight) {
    return transactionMessage;
  }
  return Object.freeze({
    ...transactionMessage,
    lifetimeConstraint: Object.freeze(blockhashLifetimeConstraint)
  });
}
function assertValidBaseString2(alphabet4, testValue, givenValue = testValue) {
  if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {
    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
      alphabet: alphabet4,
      base: alphabet4.length,
      value: givenValue
    });
  }
}
var getBaseXEncoder2 = (alphabet4) => {
  return createEncoder({
    getSizeFromValue: (value) => {
      const [leadingZeroes, tailChars] = partitionLeadingZeroes2(value, alphabet4[0]);
      if (!tailChars) return value.length;
      const base10Number = getBigIntFromBaseX2(tailChars, alphabet4);
      return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);
    },
    write(value, bytes, offset) {
      assertValidBaseString2(alphabet4, value);
      if (value === "") return offset;
      const [leadingZeroes, tailChars] = partitionLeadingZeroes2(value, alphabet4[0]);
      if (!tailChars) {
        bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);
        return offset + leadingZeroes.length;
      }
      let base10Number = getBigIntFromBaseX2(tailChars, alphabet4);
      const tailBytes = [];
      while (base10Number > 0n) {
        tailBytes.unshift(Number(base10Number % 256n));
        base10Number /= 256n;
      }
      const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];
      bytes.set(bytesToAdd, offset);
      return offset + bytesToAdd.length;
    }
  });
};
var getBaseXDecoder2 = (alphabet4) => {
  return createDecoder({
    read(rawBytes, offset) {
      const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);
      if (bytes.length === 0) return ["", 0];
      let trailIndex = bytes.findIndex((n2) => n2 !== 0);
      trailIndex = trailIndex === -1 ? bytes.length : trailIndex;
      const leadingZeroes = alphabet4[0].repeat(trailIndex);
      if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];
      const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);
      const tailChars = getBaseXFromBigInt2(base10Number, alphabet4);
      return [leadingZeroes + tailChars, rawBytes.length];
    }
  });
};
function partitionLeadingZeroes2(value, zeroCharacter) {
  const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));
  return [leadingZeros, tailChars];
}
function getBigIntFromBaseX2(value, alphabet4) {
  const base = BigInt(alphabet4.length);
  let sum = 0n;
  for (const char of value) {
    sum *= base;
    sum += BigInt(alphabet4.indexOf(char));
  }
  return sum;
}
function getBaseXFromBigInt2(value, alphabet4) {
  const base = BigInt(alphabet4.length);
  const tailChars = [];
  while (value > 0n) {
    tailChars.unshift(alphabet4[Number(value % base)]);
    value /= base;
  }
  return tailChars.join("");
}
var alphabet22 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var getBase58Encoder2 = () => getBaseXEncoder2(alphabet22);
var getBase58Decoder2 = () => getBaseXDecoder2(alphabet22);
var memoizedAddressTableLookupEncoder;
function getAddressTableLookupEncoder() {
  if (!memoizedAddressTableLookupEncoder) {
    const indexEncoder = getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() });
    memoizedAddressTableLookupEncoder = getStructEncoder([
      ["lookupTableAddress", getAddressEncoder()],
      ["writableIndexes", indexEncoder],
      ["readonlyIndexes", indexEncoder]
    ]);
  }
  return memoizedAddressTableLookupEncoder;
}
var memoizedAddressTableLookupDecoder;
function getAddressTableLookupDecoder() {
  if (!memoizedAddressTableLookupDecoder) {
    const indexEncoder = getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() });
    memoizedAddressTableLookupDecoder = getStructDecoder([
      ["lookupTableAddress", getAddressDecoder()],
      ["writableIndexes", indexEncoder],
      ["readonlyIndexes", indexEncoder]
    ]);
  }
  return memoizedAddressTableLookupDecoder;
}
var memoizedU8Encoder;
function getMemoizedU8Encoder() {
  if (!memoizedU8Encoder) memoizedU8Encoder = getU8Encoder();
  return memoizedU8Encoder;
}
var memoizedU8Decoder;
function getMemoizedU8Decoder() {
  if (!memoizedU8Decoder) memoizedU8Decoder = getU8Decoder();
  return memoizedU8Decoder;
}
function getMessageHeaderEncoder() {
  return getStructEncoder([
    ["numSignerAccounts", getMemoizedU8Encoder()],
    ["numReadonlySignerAccounts", getMemoizedU8Encoder()],
    ["numReadonlyNonSignerAccounts", getMemoizedU8Encoder()]
  ]);
}
function getMessageHeaderDecoder() {
  return getStructDecoder([
    ["numSignerAccounts", getMemoizedU8Decoder()],
    ["numReadonlySignerAccounts", getMemoizedU8Decoder()],
    ["numReadonlyNonSignerAccounts", getMemoizedU8Decoder()]
  ]);
}
var memoizedGetInstructionEncoder;
function getInstructionEncoder() {
  if (!memoizedGetInstructionEncoder) {
    memoizedGetInstructionEncoder = transformEncoder(
      getStructEncoder([
        ["programAddressIndex", getU8Encoder()],
        ["accountIndices", getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() })],
        ["data", addEncoderSizePrefix(getBytesEncoder(), getShortU16Encoder())]
      ]),
      // Convert an instruction to have all fields defined
      (instruction) => {
        if (instruction.accountIndices !== void 0 && instruction.data !== void 0) {
          return instruction;
        }
        return {
          ...instruction,
          accountIndices: instruction.accountIndices ?? [],
          data: instruction.data ?? new Uint8Array(0)
        };
      }
    );
  }
  return memoizedGetInstructionEncoder;
}
var memoizedGetInstructionDecoder;
function getInstructionDecoder() {
  if (!memoizedGetInstructionDecoder) {
    memoizedGetInstructionDecoder = transformDecoder(
      getStructDecoder([
        ["programAddressIndex", getU8Decoder()],
        ["accountIndices", getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],
        [
          "data",
          addDecoderSizePrefix(getBytesDecoder(), getShortU16Decoder())
        ]
      ]),
      // Convert an instruction to exclude optional fields if they are empty
      (instruction) => {
        if (instruction.accountIndices.length && instruction.data.byteLength) {
          return instruction;
        }
        const { accountIndices, data, ...rest } = instruction;
        return {
          ...rest,
          ...accountIndices.length ? { accountIndices } : null,
          ...data.byteLength ? { data } : null
        };
      }
    );
  }
  return memoizedGetInstructionDecoder;
}
var VERSION_FLAG_MASK = 128;
function getTransactionVersionEncoder() {
  return createEncoder({
    getSizeFromValue: (value) => value === "legacy" ? 0 : 1,
    maxSize: 1,
    write: (value, bytes, offset) => {
      if (value === "legacy") {
        return offset;
      }
      if (value < 0 || value > 127) {
        throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, {
          actualVersion: value
        });
      }
      bytes.set([value | VERSION_FLAG_MASK], offset);
      return offset + 1;
    }
  });
}
function getTransactionVersionDecoder() {
  return createDecoder({
    maxSize: 1,
    read: (bytes, offset) => {
      const firstByte = bytes[offset];
      if ((firstByte & VERSION_FLAG_MASK) === 0) {
        return ["legacy", offset];
      } else {
        const version = firstByte ^ VERSION_FLAG_MASK;
        return [version, offset + 1];
      }
    }
  });
}
function getCompiledMessageLegacyEncoder() {
  return getStructEncoder(getPreludeStructEncoderTuple());
}
function getCompiledMessageVersionedEncoder() {
  return transformEncoder(
    getStructEncoder([
      ...getPreludeStructEncoderTuple(),
      ["addressTableLookups", getAddressTableLookupArrayEncoder()]
    ]),
    (value) => {
      if (value.version === "legacy") {
        return value;
      }
      return {
        ...value,
        addressTableLookups: value.addressTableLookups ?? []
      };
    }
  );
}
function getPreludeStructEncoderTuple() {
  const lifetimeTokenEncoder = getUnionEncoder(
    [
      // Use a 32-byte constant encoder for a missing lifetime token (index 0).
      getConstantEncoder(new Uint8Array(32)),
      // Use a 32-byte base58 encoder for a valid lifetime token (index 1).
      fixEncoderSize(getBase58Encoder2(), 32)
    ],
    (value) => value === void 0 ? 0 : 1
  );
  return [
    ["version", getTransactionVersionEncoder()],
    ["header", getMessageHeaderEncoder()],
    ["staticAccounts", getArrayEncoder(getAddressEncoder(), { size: getShortU16Encoder() })],
    ["lifetimeToken", lifetimeTokenEncoder],
    ["instructions", getArrayEncoder(getInstructionEncoder(), { size: getShortU16Encoder() })]
  ];
}
function getPreludeStructDecoderTuple() {
  return [
    ["version", getTransactionVersionDecoder()],
    ["header", getMessageHeaderDecoder()],
    ["staticAccounts", getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })],
    ["lifetimeToken", fixDecoderSize(getBase58Decoder2(), 32)],
    ["instructions", getArrayDecoder(getInstructionDecoder(), { size: getShortU16Decoder() })],
    ["addressTableLookups", getAddressTableLookupArrayDecoder()]
  ];
}
function getAddressTableLookupArrayEncoder() {
  return getArrayEncoder(getAddressTableLookupEncoder(), { size: getShortU16Encoder() });
}
function getAddressTableLookupArrayDecoder() {
  return getArrayDecoder(getAddressTableLookupDecoder(), { size: getShortU16Decoder() });
}
function getCompiledTransactionMessageEncoder() {
  return createEncoder({
    getSizeFromValue: (compiledMessage) => {
      if (compiledMessage.version === "legacy") {
        return getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);
      } else {
        return getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);
      }
    },
    write: (compiledMessage, bytes, offset) => {
      if (compiledMessage.version === "legacy") {
        return getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);
      } else {
        return getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);
      }
    }
  });
}
function getCompiledTransactionMessageDecoder() {
  return transformDecoder(
    getStructDecoder(getPreludeStructDecoderTuple()),
    ({ addressTableLookups, ...restOfMessage }) => {
      if (restOfMessage.version === "legacy" || !addressTableLookups?.length) {
        return restOfMessage;
      }
      return { ...restOfMessage, addressTableLookups };
    }
  );
}
function upsert(addressMap, address2, update) {
  addressMap[address2] = update(addressMap[address2] ?? { role: AccountRole.READONLY });
}
var TYPE2 = Symbol("AddressMapTypeProperty");
function getAddressMapFromInstructions(feePayer, instructions) {
  const addressMap = {
    [feePayer]: { [TYPE2]: 0, role: AccountRole.WRITABLE_SIGNER }
  };
  const addressesOfInvokedPrograms = /* @__PURE__ */ new Set();
  for (const instruction of instructions) {
    upsert(addressMap, instruction.programAddress, (entry) => {
      addressesOfInvokedPrograms.add(instruction.programAddress);
      if (TYPE2 in entry) {
        if (isWritableRole(entry.role)) {
          switch (entry[TYPE2]) {
            case 0:
              throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, {
                programAddress: instruction.programAddress
              });
            default:
              throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {
                programAddress: instruction.programAddress
              });
          }
        }
        if (entry[TYPE2] === 2) {
          return entry;
        }
      }
      return { [TYPE2]: 2, role: AccountRole.READONLY };
    });
    let addressComparator;
    if (!instruction.accounts) {
      continue;
    }
    for (const account of instruction.accounts) {
      upsert(addressMap, account.address, (entry) => {
        const {
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          address: _2,
          ...accountMeta
        } = account;
        if (TYPE2 in entry) {
          switch (entry[TYPE2]) {
            case 0:
              return entry;
            case 1: {
              const nextRole = mergeRoles(entry.role, accountMeta.role);
              if ("lookupTableAddress" in accountMeta) {
                const shouldReplaceEntry = (
                  // Consider using the new LOOKUP_TABLE if its address is different...
                  entry.lookupTableAddress !== accountMeta.lookupTableAddress && // ...and sorts before the existing one.
                  (addressComparator ||= getAddressComparator())(
                    accountMeta.lookupTableAddress,
                    entry.lookupTableAddress
                  ) < 0
                );
                if (shouldReplaceEntry) {
                  return {
                    [TYPE2]: 1,
                    ...accountMeta,
                    role: nextRole
                  };
                }
              } else if (isSignerRole(accountMeta.role)) {
                return {
                  [TYPE2]: 2,
                  role: nextRole
                };
              }
              if (entry.role !== nextRole) {
                return {
                  ...entry,
                  role: nextRole
                };
              } else {
                return entry;
              }
            }
            case 2: {
              const nextRole = mergeRoles(entry.role, accountMeta.role);
              if (
                // Check to see if this address represents a program that is invoked
                // in this transaction.
                addressesOfInvokedPrograms.has(account.address)
              ) {
                if (isWritableRole(accountMeta.role)) {
                  throw new SolanaError(
                    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,
                    {
                      programAddress: account.address
                    }
                  );
                }
                if (entry.role !== nextRole) {
                  return {
                    ...entry,
                    role: nextRole
                  };
                } else {
                  return entry;
                }
              } else if ("lookupTableAddress" in accountMeta && // Static accounts can be 'upgraded' to lookup table accounts as
              // long as they are not require to sign the transaction.
              !isSignerRole(entry.role)) {
                return {
                  ...accountMeta,
                  [TYPE2]: 1,
                  role: nextRole
                };
              } else {
                if (entry.role !== nextRole) {
                  return {
                    ...entry,
                    role: nextRole
                  };
                } else {
                  return entry;
                }
              }
            }
          }
        }
        if ("lookupTableAddress" in accountMeta) {
          return {
            ...accountMeta,
            [TYPE2]: 1
            /* LOOKUP_TABLE */
          };
        } else {
          return {
            ...accountMeta,
            [TYPE2]: 2
            /* STATIC */
          };
        }
      });
    }
  }
  return addressMap;
}
function getOrderedAccountsFromAddressMap(addressMap) {
  let addressComparator;
  const orderedAccounts = Object.entries(addressMap).sort(([leftAddress, leftEntry], [rightAddress, rightEntry]) => {
    if (leftEntry[TYPE2] !== rightEntry[TYPE2]) {
      if (leftEntry[TYPE2] === 0) {
        return -1;
      } else if (rightEntry[TYPE2] === 0) {
        return 1;
      } else if (leftEntry[TYPE2] === 2) {
        return -1;
      } else if (rightEntry[TYPE2] === 2) {
        return 1;
      }
    }
    const leftIsSigner = isSignerRole(leftEntry.role);
    if (leftIsSigner !== isSignerRole(rightEntry.role)) {
      return leftIsSigner ? -1 : 1;
    }
    const leftIsWritable = isWritableRole(leftEntry.role);
    if (leftIsWritable !== isWritableRole(rightEntry.role)) {
      return leftIsWritable ? -1 : 1;
    }
    addressComparator ||= getAddressComparator();
    if (leftEntry[TYPE2] === 1 && rightEntry[TYPE2] === 1 && leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress) {
      return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);
    } else {
      return addressComparator(leftAddress, rightAddress);
    }
  }).map(([address2, addressMeta]) => ({
    address: address2,
    ...addressMeta
  }));
  return orderedAccounts;
}
function getCompiledAddressTableLookups(orderedAccounts) {
  const index = {};
  for (const account of orderedAccounts) {
    if (!("lookupTableAddress" in account)) {
      continue;
    }
    const entry = index[account.lookupTableAddress] ||= {
      readonlyIndexes: [],
      writableIndexes: []
    };
    if (account.role === AccountRole.WRITABLE) {
      entry.writableIndexes.push(account.addressIndex);
    } else {
      entry.readonlyIndexes.push(account.addressIndex);
    }
  }
  return Object.keys(index).sort(getAddressComparator()).map((lookupTableAddress) => ({
    lookupTableAddress,
    ...index[lookupTableAddress]
  }));
}
function getCompiledMessageHeader(orderedAccounts) {
  let numReadonlyNonSignerAccounts = 0;
  let numReadonlySignerAccounts = 0;
  let numSignerAccounts = 0;
  for (const account of orderedAccounts) {
    if ("lookupTableAddress" in account) {
      break;
    }
    const accountIsWritable = isWritableRole(account.role);
    if (isSignerRole(account.role)) {
      numSignerAccounts++;
      if (!accountIsWritable) {
        numReadonlySignerAccounts++;
      }
    } else if (!accountIsWritable) {
      numReadonlyNonSignerAccounts++;
    }
  }
  return {
    numReadonlyNonSignerAccounts,
    numReadonlySignerAccounts,
    numSignerAccounts
  };
}
function getAccountIndex(orderedAccounts) {
  const out = {};
  for (const [index, account] of orderedAccounts.entries()) {
    out[account.address] = index;
  }
  return out;
}
function getCompiledInstructions(instructions, orderedAccounts) {
  const accountIndex = getAccountIndex(orderedAccounts);
  return instructions.map(({ accounts, data, programAddress }) => {
    return {
      programAddressIndex: accountIndex[programAddress],
      ...accounts ? { accountIndices: accounts.map(({ address: address2 }) => accountIndex[address2]) } : null,
      ...data ? { data } : null
    };
  });
}
function getCompiledLifetimeToken(lifetimeConstraint) {
  if ("nonce" in lifetimeConstraint) {
    return lifetimeConstraint.nonce;
  }
  return lifetimeConstraint.blockhash;
}
function getCompiledStaticAccounts(orderedAccounts) {
  const firstLookupTableAccountIndex = orderedAccounts.findIndex((account) => "lookupTableAddress" in account);
  const orderedStaticAccounts = firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);
  return orderedStaticAccounts.map(({ address: address2 }) => address2);
}
function compileTransactionMessage(transactionMessage) {
  const addressMap = getAddressMapFromInstructions(
    transactionMessage.feePayer.address,
    transactionMessage.instructions
  );
  const orderedAccounts = getOrderedAccountsFromAddressMap(addressMap);
  const lifetimeConstraint = transactionMessage.lifetimeConstraint;
  return {
    ...transactionMessage.version !== "legacy" ? { addressTableLookups: getCompiledAddressTableLookups(orderedAccounts) } : null,
    ...lifetimeConstraint ? { lifetimeToken: getCompiledLifetimeToken(lifetimeConstraint) } : null,
    header: getCompiledMessageHeader(orderedAccounts),
    instructions: getCompiledInstructions(transactionMessage.instructions, orderedAccounts),
    staticAccounts: getCompiledStaticAccounts(orderedAccounts),
    version: transactionMessage.version
  };
}
function createTransactionMessage(config) {
  return Object.freeze({
    instructions: Object.freeze([]),
    version: config.version
  });
}
var RECENT_BLOCKHASHES_SYSVAR_ADDRESS = "SysvarRecentB1ockHashes11111111111111111111";
var SYSTEM_PROGRAM_ADDRESS = "11111111111111111111111111111111";
function createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress) {
  return {
    accounts: [
      { address: nonceAccountAddress, role: AccountRole.WRITABLE },
      {
        address: RECENT_BLOCKHASHES_SYSVAR_ADDRESS,
        role: AccountRole.READONLY
      },
      { address: nonceAuthorityAddress, role: AccountRole.READONLY_SIGNER }
    ],
    data: new Uint8Array([4, 0, 0, 0]),
    programAddress: SYSTEM_PROGRAM_ADDRESS
  };
}
function isAdvanceNonceAccountInstruction(instruction) {
  return instruction.programAddress === SYSTEM_PROGRAM_ADDRESS && // Test for `AdvanceNonceAccount` instruction data
  instruction.data != null && isAdvanceNonceAccountInstructionData(instruction.data) && // Test for exactly 3 accounts
  instruction.accounts?.length === 3 && // First account is nonce account address
  instruction.accounts[0].address != null && instruction.accounts[0].role === AccountRole.WRITABLE && // Second account is recent blockhashes sysvar
  instruction.accounts[1].address === RECENT_BLOCKHASHES_SYSVAR_ADDRESS && instruction.accounts[1].role === AccountRole.READONLY && // Third account is nonce authority account
  instruction.accounts[2].address != null && isSignerRole(instruction.accounts[2].role);
}
function isAdvanceNonceAccountInstructionData(data) {
  return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;
}
function isTransactionMessageWithDurableNonceLifetime(transactionMessage) {
  return "lifetimeConstraint" in transactionMessage && typeof transactionMessage.lifetimeConstraint.nonce === "string" && transactionMessage.instructions[0] != null && isAdvanceNonceAccountInstruction(transactionMessage.instructions[0]);
}
function isAdvanceNonceAccountInstructionForNonce(instruction, nonceAccountAddress, nonceAuthorityAddress) {
  return instruction.accounts[0].address === nonceAccountAddress && instruction.accounts[2].address === nonceAuthorityAddress;
}
function setTransactionMessageLifetimeUsingDurableNonce({
  nonce,
  nonceAccountAddress,
  nonceAuthorityAddress
}, transactionMessage) {
  let newInstructions;
  const firstInstruction = transactionMessage.instructions[0];
  if (firstInstruction && isAdvanceNonceAccountInstruction(firstInstruction)) {
    if (isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {
      if (isTransactionMessageWithDurableNonceLifetime(transactionMessage) && transactionMessage.lifetimeConstraint.nonce === nonce) {
        return transactionMessage;
      } else {
        newInstructions = [firstInstruction, ...transactionMessage.instructions.slice(1)];
      }
    } else {
      newInstructions = [
        Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),
        ...transactionMessage.instructions.slice(1)
      ];
    }
  } else {
    newInstructions = [
      Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),
      ...transactionMessage.instructions
    ];
  }
  return Object.freeze({
    ...transactionMessage,
    instructions: Object.freeze(newInstructions),
    lifetimeConstraint: Object.freeze({ nonce })
  });
}
function setTransactionMessageFeePayer(feePayer, transactionMessage) {
  if ("feePayer" in transactionMessage && feePayer === transactionMessage.feePayer?.address && isAddressOnlyFeePayer(transactionMessage.feePayer)) {
    return transactionMessage;
  }
  const out = {
    ...transactionMessage,
    feePayer: Object.freeze({ address: feePayer })
  };
  Object.freeze(out);
  return out;
}
function isAddressOnlyFeePayer(feePayer) {
  return !!feePayer && "address" in feePayer && typeof feePayer.address === "string" && Object.keys(feePayer).length === 1;
}
function appendTransactionMessageInstruction(instruction, transactionMessage) {
  return appendTransactionMessageInstructions([instruction], transactionMessage);
}
function appendTransactionMessageInstructions(instructions, transactionMessage) {
  return Object.freeze({
    ...transactionMessage,
    instructions: Object.freeze([
      ...transactionMessage.instructions,
      ...instructions
    ])
  });
}
function getAccountMetas(message) {
  const { header } = message;
  const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;
  const numWritableNonSignerAccounts = message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;
  const accountMetas = [];
  let accountIndex = 0;
  for (let i2 = 0; i2 < numWritableSignerAccounts; i2++) {
    accountMetas.push({
      address: message.staticAccounts[accountIndex],
      role: AccountRole.WRITABLE_SIGNER
    });
    accountIndex++;
  }
  for (let i2 = 0; i2 < header.numReadonlySignerAccounts; i2++) {
    accountMetas.push({
      address: message.staticAccounts[accountIndex],
      role: AccountRole.READONLY_SIGNER
    });
    accountIndex++;
  }
  for (let i2 = 0; i2 < numWritableNonSignerAccounts; i2++) {
    accountMetas.push({
      address: message.staticAccounts[accountIndex],
      role: AccountRole.WRITABLE
    });
    accountIndex++;
  }
  for (let i2 = 0; i2 < header.numReadonlyNonSignerAccounts; i2++) {
    accountMetas.push({
      address: message.staticAccounts[accountIndex],
      role: AccountRole.READONLY
    });
    accountIndex++;
  }
  return accountMetas;
}
function getAddressLookupMetas(compiledAddressTableLookups, addressesByLookupTableAddress) {
  const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map((l) => l.lookupTableAddress);
  const missing = compiledAddressTableLookupAddresses.filter((a2) => addressesByLookupTableAddress[a2] === void 0);
  if (missing.length > 0) {
    throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, {
      lookupTableAddresses: missing
    });
  }
  const readOnlyMetas = [];
  const writableMetas = [];
  for (const lookup of compiledAddressTableLookups) {
    const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];
    const readonlyIndexes = lookup.readonlyIndexes;
    const writableIndexes = lookup.writableIndexes;
    const highestIndex = Math.max(...readonlyIndexes, ...writableIndexes);
    if (highestIndex >= addresses.length) {
      throw new SolanaError(
        SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,
        {
          highestKnownIndex: addresses.length - 1,
          highestRequestedIndex: highestIndex,
          lookupTableAddress: lookup.lookupTableAddress
        }
      );
    }
    const readOnlyForLookup = readonlyIndexes.map((r4) => ({
      address: addresses[r4],
      addressIndex: r4,
      lookupTableAddress: lookup.lookupTableAddress,
      role: AccountRole.READONLY
    }));
    readOnlyMetas.push(...readOnlyForLookup);
    const writableForLookup = writableIndexes.map((w) => ({
      address: addresses[w],
      addressIndex: w,
      lookupTableAddress: lookup.lookupTableAddress,
      role: AccountRole.WRITABLE
    }));
    writableMetas.push(...writableForLookup);
  }
  return [...writableMetas, ...readOnlyMetas];
}
function convertInstruction(instruction, accountMetas) {
  const programAddress = accountMetas[instruction.programAddressIndex]?.address;
  if (!programAddress) {
    throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, {
      index: instruction.programAddressIndex
    });
  }
  const accounts = instruction.accountIndices?.map((accountIndex) => accountMetas[accountIndex]);
  const { data } = instruction;
  return Object.freeze({
    programAddress,
    ...accounts && accounts.length ? { accounts: Object.freeze(accounts) } : {},
    ...data && data.length ? { data } : {}
  });
}
function getLifetimeConstraint(messageLifetimeToken, firstInstruction, lastValidBlockHeight) {
  if (!firstInstruction || !isAdvanceNonceAccountInstruction(firstInstruction)) {
    return {
      blockhash: messageLifetimeToken,
      lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n
      // U64 MAX
    };
  } else {
    const nonceAccountAddress = firstInstruction.accounts[0].address;
    assertIsAddress(nonceAccountAddress);
    const nonceAuthorityAddress = firstInstruction.accounts[2].address;
    assertIsAddress(nonceAuthorityAddress);
    return {
      nonce: messageLifetimeToken,
      nonceAccountAddress,
      nonceAuthorityAddress
    };
  }
}
function decompileTransactionMessage(compiledTransactionMessage, config) {
  const feePayer = compiledTransactionMessage.staticAccounts[0];
  if (!feePayer) {
    throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING);
  }
  const accountMetas = getAccountMetas(compiledTransactionMessage);
  const accountLookupMetas = "addressTableLookups" in compiledTransactionMessage && compiledTransactionMessage.addressTableLookups !== void 0 && compiledTransactionMessage.addressTableLookups.length > 0 ? getAddressLookupMetas(
    compiledTransactionMessage.addressTableLookups,
    config?.addressesByLookupTableAddress ?? {}
  ) : [];
  const transactionMetas = [...accountMetas, ...accountLookupMetas];
  const instructions = compiledTransactionMessage.instructions.map(
    (compiledInstruction) => convertInstruction(compiledInstruction, transactionMetas)
  );
  const firstInstruction = instructions[0];
  const lifetimeConstraint = getLifetimeConstraint(
    compiledTransactionMessage.lifetimeToken,
    firstInstruction,
    config?.lastValidBlockHeight
  );
  return pipe(
    createTransactionMessage({ version: compiledTransactionMessage.version }),
    (m2) => setTransactionMessageFeePayer(feePayer, m2),
    (m2) => instructions.reduce(
      (acc, instruction) => appendTransactionMessageInstruction(instruction, acc),
      m2
    ),
    (m2) => "blockhash" in lifetimeConstraint ? setTransactionMessageLifetimeUsingBlockhash(lifetimeConstraint, m2) : setTransactionMessageLifetimeUsingDurableNonce(lifetimeConstraint, m2)
  );
}

// node_modules/@solana/transactions/dist/index.browser.mjs
init_shim();

// node_modules/@solana/keys/dist/index.browser.mjs
init_shim();
var ED25519_ALGORITHM_IDENTIFIER = (
  // Resist the temptation to convert this to a simple string; As of version 133.0.3, Firefox
  // requires the object form of `AlgorithmIdentifier` and will throw a `DOMException` otherwise.
  Object.freeze({ name: "Ed25519" })
);

// node_modules/@solana/transactions/dist/index.browser.mjs
function getSignaturesToEncode(signaturesMap) {
  const signatures = Object.values(signaturesMap);
  if (signatures.length === 0) {
    throw new SolanaError(SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES);
  }
  return signatures.map((signature) => {
    if (!signature) {
      return new Uint8Array(64).fill(0);
    }
    return signature;
  });
}
function getSignaturesEncoder() {
  return transformEncoder(
    getArrayEncoder(fixEncoderSize(getBytesEncoder(), 64), { size: getShortU16Encoder() }),
    getSignaturesToEncode
  );
}
function getTransactionEncoder() {
  return getStructEncoder([
    ["signatures", getSignaturesEncoder()],
    ["messageBytes", getBytesEncoder()]
  ]);
}
function getTransactionDecoder() {
  return transformDecoder(
    getStructDecoder([
      ["signatures", getArrayDecoder(fixDecoderSize(getBytesDecoder(), 64), { size: getShortU16Decoder() })],
      ["messageBytes", getBytesDecoder()]
    ]),
    decodePartiallyDecodedTransaction
  );
}
function decodePartiallyDecodedTransaction(transaction) {
  const { messageBytes, signatures } = transaction;
  const signerAddressesDecoder = getTupleDecoder([
    // read transaction version
    getTransactionVersionDecoder(),
    // read first byte of header, `numSignerAccounts`
    // padRight to skip the next 2 bytes, `numReadOnlySignedAccounts` and `numReadOnlyUnsignedAccounts` which we don't need
    padRightDecoder(getU8Decoder(), 2),
    // read static addresses
    getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })
  ]);
  const [_txVersion, numRequiredSignatures, staticAddresses] = signerAddressesDecoder.decode(messageBytes);
  const signerAddresses = staticAddresses.slice(0, numRequiredSignatures);
  if (signerAddresses.length !== signatures.length) {
    throw new SolanaError(SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, {
      numRequiredSignatures,
      signaturesLength: signatures.length,
      signerAddresses
    });
  }
  const signaturesMap = {};
  signerAddresses.forEach((address2, index) => {
    const signatureForAddress = signatures[index];
    if (signatureForAddress.every((b2) => b2 === 0)) {
      signaturesMap[address2] = null;
    } else {
      signaturesMap[address2] = signatureForAddress;
    }
  });
  return {
    messageBytes,
    signatures: Object.freeze(signaturesMap)
  };
}
function compileTransaction(transactionMessage) {
  const compiledMessage = compileTransactionMessage(transactionMessage);
  const messageBytes = getCompiledTransactionMessageEncoder().encode(compiledMessage);
  const transactionSigners = compiledMessage.staticAccounts.slice(0, compiledMessage.header.numSignerAccounts);
  const signatures = {};
  for (const signerAddress of transactionSigners) {
    signatures[signerAddress] = null;
  }
  let lifetimeConstraint;
  if (isTransactionMessageWithBlockhashLifetime(transactionMessage)) {
    lifetimeConstraint = {
      blockhash: transactionMessage.lifetimeConstraint.blockhash,
      lastValidBlockHeight: transactionMessage.lifetimeConstraint.lastValidBlockHeight
    };
  } else if (isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {
    lifetimeConstraint = {
      nonce: transactionMessage.lifetimeConstraint.nonce,
      nonceAccountAddress: transactionMessage.instructions[0].accounts[0].address
    };
  }
  return Object.freeze({
    ...lifetimeConstraint ? { lifetimeConstraint } : void 0,
    messageBytes,
    signatures: Object.freeze(signatures)
  });
}
var TRANSACTION_PACKET_SIZE = 1280;
var TRANSACTION_PACKET_HEADER = 40 + 8;
var TRANSACTION_SIZE_LIMIT = TRANSACTION_PACKET_SIZE - TRANSACTION_PACKET_HEADER;

// node_modules/@solana/promises/dist/index.browser.mjs
init_shim();

// node_modules/@solana/programs/dist/index.browser.mjs
init_shim();

// node_modules/@solana/rpc/dist/index.browser.mjs
init_shim();

// node_modules/@solana/rpc-api/dist/index.browser.mjs
init_shim();

// node_modules/@solana/rpc-spec/dist/index.browser.mjs
init_shim();

// node_modules/@solana/rpc-spec-types/dist/index.browser.mjs
init_shim();

// node_modules/@solana/rpc-transformers/dist/index.browser.mjs
init_shim();
var KEYPATH_WILDCARD = {};
var jsonParsedTokenAccountsConfigs = [
  // parsed Token/Token22 token account
  ["data", "parsed", "info", "tokenAmount", "decimals"],
  ["data", "parsed", "info", "tokenAmount", "uiAmount"],
  ["data", "parsed", "info", "rentExemptReserve", "decimals"],
  ["data", "parsed", "info", "rentExemptReserve", "uiAmount"],
  ["data", "parsed", "info", "delegatedAmount", "decimals"],
  ["data", "parsed", "info", "delegatedAmount", "uiAmount"],
  ["data", "parsed", "info", "extensions", KEYPATH_WILDCARD, "state", "olderTransferFee", "transferFeeBasisPoints"],
  ["data", "parsed", "info", "extensions", KEYPATH_WILDCARD, "state", "newerTransferFee", "transferFeeBasisPoints"],
  ["data", "parsed", "info", "extensions", KEYPATH_WILDCARD, "state", "preUpdateAverageRate"],
  ["data", "parsed", "info", "extensions", KEYPATH_WILDCARD, "state", "currentRate"]
];
var jsonParsedAccountsConfigs = [
  ...jsonParsedTokenAccountsConfigs,
  // parsed AddressTableLookup account
  ["data", "parsed", "info", "lastExtendedSlotStartIndex"],
  // parsed Config account
  ["data", "parsed", "info", "slashPenalty"],
  ["data", "parsed", "info", "warmupCooldownRate"],
  // parsed Token/Token22 mint account
  ["data", "parsed", "info", "decimals"],
  // parsed Token/Token22 multisig account
  ["data", "parsed", "info", "numRequiredSigners"],
  ["data", "parsed", "info", "numValidSigners"],
  // parsed Stake account
  ["data", "parsed", "info", "stake", "delegation", "warmupCooldownRate"],
  // parsed Sysvar rent account
  ["data", "parsed", "info", "exemptionThreshold"],
  ["data", "parsed", "info", "burnPercent"],
  // parsed Vote account
  ["data", "parsed", "info", "commission"],
  ["data", "parsed", "info", "votes", KEYPATH_WILDCARD, "confirmationCount"]
];

// node_modules/@solana/rpc-transport-http/dist/index.browser.mjs
init_shim();
var FORBIDDEN_HEADERS = Object.assign(
  {
    "accept-charset": true,
    "access-control-request-headers": true,
    "access-control-request-method": true,
    connection: true,
    "content-length": true,
    cookie: true,
    date: true,
    dnt: true,
    expect: true,
    host: true,
    "keep-alive": true,
    origin: true,
    "permissions-policy": true,
    // Prefix matching is implemented in code, below.
    // 'proxy-': true,
    // 'sec-': true,
    referer: true,
    te: true,
    trailer: true,
    "transfer-encoding": true,
    upgrade: true,
    via: true
  },
  { "accept-encoding": true }
);

// node_modules/@solana/fast-stable-stringify/dist/index.browser.mjs
init_shim();

// node_modules/@solana/rpc/dist/index.browser.mjs
var o2 = globalThis.AbortController;

// node_modules/@solana/rpc-parsed-types/dist/index.browser.mjs
init_shim();

// node_modules/@solana/rpc-subscriptions/dist/index.browser.mjs
init_shim();

// node_modules/@solana/rpc-subscriptions-api/dist/index.browser.mjs
init_shim();

// node_modules/@solana/rpc-subscriptions-spec/dist/index.browser.mjs
init_shim();

// node_modules/@solana/subscribable/dist/index.browser.mjs
init_shim();
var o3 = globalThis.AbortController;
var t = globalThis.EventTarget;
var UNINITIALIZED = Symbol();

// node_modules/@solana/rpc-subscriptions-spec/dist/index.browser.mjs
var o4 = globalThis.AbortController;

// node_modules/@solana/rpc-subscriptions-channel-websocket/dist/index.browser.mjs
init_shim();
var t2 = globalThis.EventTarget;
var e2 = globalThis.WebSocket;

// node_modules/@solana/rpc-subscriptions/dist/index.browser.mjs
var o5 = globalThis.AbortController;

// node_modules/@solana/signers/dist/index.browser.mjs
init_shim();
function isTransactionModifyingSigner(value) {
  return "modifyAndSignTransactions" in value && typeof value.modifyAndSignTransactions === "function";
}
function isTransactionPartialSigner(value) {
  return "signTransactions" in value && typeof value.signTransactions === "function";
}
function isTransactionSendingSigner(value) {
  return "signAndSendTransactions" in value && typeof value.signAndSendTransactions === "function";
}
function isTransactionSigner(value) {
  return isTransactionPartialSigner(value) || isTransactionModifyingSigner(value) || isTransactionSendingSigner(value);
}
function setTransactionMessageFeePayerSigner(feePayer, transactionMessage) {
  Object.freeze(feePayer);
  const out = { ...transactionMessage, feePayer };
  Object.freeze(out);
  return out;
}
var o6 = globalThis.TextEncoder;

// node_modules/@solana/transaction-confirmation/dist/index.browser.mjs
init_shim();
var o7 = globalThis.AbortController;
var NONCE_VALUE_OFFSET = 4 + // version(u32)
4 + // state(u32)
32;

// node_modules/@solana/kit/dist/index.browser.mjs
async function fetchAddressesForLookupTables(lookupTableAddresses, rpc, config) {
  if (lookupTableAddresses.length === 0) {
    return {};
  }
  const fetchedLookupTables = await fetchJsonParsedAccounts(
    rpc,
    lookupTableAddresses,
    config
  );
  assertAccountsDecoded(fetchedLookupTables);
  assertAccountsExist(fetchedLookupTables);
  return fetchedLookupTables.reduce((acc, lookup) => {
    return {
      ...acc,
      [lookup.address]: lookup.data.addresses
    };
  }, {});
}

// node_modules/@privy-io/react-auth/dist/esm/use-export-wallet-Duyde2UB.mjs
init_shim();
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);

// node_modules/@solana-program/system/dist/src/index.mjs
init_shim();
var NonceState = ((NonceState2) => {
  NonceState2[NonceState2["Uninitialized"] = 0] = "Uninitialized";
  NonceState2[NonceState2["Initialized"] = 1] = "Initialized";
  return NonceState2;
})(NonceState || {});
var NonceVersion = ((NonceVersion2) => {
  NonceVersion2[NonceVersion2["Legacy"] = 0] = "Legacy";
  NonceVersion2[NonceVersion2["Current"] = 1] = "Current";
  return NonceVersion2;
})(NonceVersion || {});
var SYSTEM_PROGRAM_ADDRESS2 = "11111111111111111111111111111111";
var SystemAccount = ((SystemAccount2) => {
  SystemAccount2[SystemAccount2["Nonce"] = 0] = "Nonce";
  return SystemAccount2;
})(SystemAccount || {});
var SystemInstruction = ((SystemInstruction2) => {
  SystemInstruction2[SystemInstruction2["CreateAccount"] = 0] = "CreateAccount";
  SystemInstruction2[SystemInstruction2["Assign"] = 1] = "Assign";
  SystemInstruction2[SystemInstruction2["TransferSol"] = 2] = "TransferSol";
  SystemInstruction2[SystemInstruction2["CreateAccountWithSeed"] = 3] = "CreateAccountWithSeed";
  SystemInstruction2[SystemInstruction2["AdvanceNonceAccount"] = 4] = "AdvanceNonceAccount";
  SystemInstruction2[SystemInstruction2["WithdrawNonceAccount"] = 5] = "WithdrawNonceAccount";
  SystemInstruction2[SystemInstruction2["InitializeNonceAccount"] = 6] = "InitializeNonceAccount";
  SystemInstruction2[SystemInstruction2["AuthorizeNonceAccount"] = 7] = "AuthorizeNonceAccount";
  SystemInstruction2[SystemInstruction2["Allocate"] = 8] = "Allocate";
  SystemInstruction2[SystemInstruction2["AllocateWithSeed"] = 9] = "AllocateWithSeed";
  SystemInstruction2[SystemInstruction2["AssignWithSeed"] = 10] = "AssignWithSeed";
  SystemInstruction2[SystemInstruction2["TransferSolWithSeed"] = 11] = "TransferSolWithSeed";
  SystemInstruction2[SystemInstruction2["UpgradeNonceAccount"] = 12] = "UpgradeNonceAccount";
  return SystemInstruction2;
})(SystemInstruction || {});
var SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE = 0;
var SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS = 1;
var SYSTEM_ERROR__INVALID_PROGRAM_ID = 2;
var SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH = 3;
var SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4;
var SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH = 5;
var SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES = 6;
var SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED = 7;
var SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE = 8;
var systemErrorMessages;
if (import_process.default.env.NODE_ENV !== "production") {
  systemErrorMessages = {
    [SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE]: `an account with the same address already exists`,
    [SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH]: `provided address does not match addressed derived from seed`,
    [SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH]: `cannot allocate account data of this length`,
    [SYSTEM_ERROR__INVALID_PROGRAM_ID]: `cannot assign account to this program id`,
    [SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED]: `length of requested seed is too long`,
    [SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED]: `stored nonce is still in recent_blockhashes`,
    [SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES]: `advancing stored nonce requires a populated RecentBlockhashes sysvar`,
    [SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE]: `specified nonce does not match stored nonce`,
    [SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS]: `account does not have enough SOL to perform the operation`
  };
}
function expectAddress(value) {
  if (!value) {
    throw new Error("Expected a Address.");
  }
  if (typeof value === "object" && "address" in value) {
    return value.address;
  }
  if (Array.isArray(value)) {
    return value[0];
  }
  return value;
}
function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
  return (account) => {
    if (!account.value) {
      return Object.freeze({
        address: programAddress,
        role: AccountRole.READONLY
      });
    }
    const writableRole = account.isWritable ? AccountRole.WRITABLE : AccountRole.READONLY;
    return Object.freeze({
      address: expectAddress(account.value),
      role: isTransactionSigner2(account.value) ? upgradeRoleToSigner(writableRole) : writableRole,
      ...isTransactionSigner2(account.value) ? { signer: account.value } : {}
    });
  };
}
function isTransactionSigner2(value) {
  return !!value && typeof value === "object" && "address" in value && isTransactionSigner(value);
}
var TRANSFER_SOL_DISCRIMINATOR = 2;
function getTransferSolInstructionDataEncoder() {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", getU32Encoder()],
      ["amount", getU64Encoder()]
    ]),
    (value) => ({ ...value, discriminator: TRANSFER_SOL_DISCRIMINATOR })
  );
}
function getTransferSolInstruction(input, config) {
  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS2;
  const originalAccounts = {
    source: { value: input.source ?? null, isWritable: true },
    destination: { value: input.destination ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.source),
      getAccountMeta(accounts.destination)
    ],
    programAddress,
    data: getTransferSolInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}

// node_modules/@solana-program/token/dist/src/index.mjs
init_shim();
var AccountState = ((AccountState2) => {
  AccountState2[AccountState2["Uninitialized"] = 0] = "Uninitialized";
  AccountState2[AccountState2["Initialized"] = 1] = "Initialized";
  AccountState2[AccountState2["Frozen"] = 2] = "Frozen";
  return AccountState2;
})(AccountState || {});
var AuthorityType = ((AuthorityType2) => {
  AuthorityType2[AuthorityType2["MintTokens"] = 0] = "MintTokens";
  AuthorityType2[AuthorityType2["FreezeAccount"] = 1] = "FreezeAccount";
  AuthorityType2[AuthorityType2["AccountOwner"] = 2] = "AccountOwner";
  AuthorityType2[AuthorityType2["CloseAccount"] = 3] = "CloseAccount";
  return AuthorityType2;
})(AuthorityType || {});
var ASSOCIATED_TOKEN_PROGRAM_ADDRESS = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL";
var AssociatedTokenInstruction = ((AssociatedTokenInstruction2) => {
  AssociatedTokenInstruction2[AssociatedTokenInstruction2["CreateAssociatedToken"] = 0] = "CreateAssociatedToken";
  AssociatedTokenInstruction2[AssociatedTokenInstruction2["CreateAssociatedTokenIdempotent"] = 1] = "CreateAssociatedTokenIdempotent";
  AssociatedTokenInstruction2[AssociatedTokenInstruction2["RecoverNestedAssociatedToken"] = 2] = "RecoverNestedAssociatedToken";
  return AssociatedTokenInstruction2;
})(AssociatedTokenInstruction || {});
var TOKEN_PROGRAM_ADDRESS = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
var TokenAccount = ((TokenAccount2) => {
  TokenAccount2[TokenAccount2["Mint"] = 0] = "Mint";
  TokenAccount2[TokenAccount2["Token"] = 1] = "Token";
  TokenAccount2[TokenAccount2["Multisig"] = 2] = "Multisig";
  return TokenAccount2;
})(TokenAccount || {});
var TokenInstruction = ((TokenInstruction2) => {
  TokenInstruction2[TokenInstruction2["InitializeMint"] = 0] = "InitializeMint";
  TokenInstruction2[TokenInstruction2["InitializeAccount"] = 1] = "InitializeAccount";
  TokenInstruction2[TokenInstruction2["InitializeMultisig"] = 2] = "InitializeMultisig";
  TokenInstruction2[TokenInstruction2["Transfer"] = 3] = "Transfer";
  TokenInstruction2[TokenInstruction2["Approve"] = 4] = "Approve";
  TokenInstruction2[TokenInstruction2["Revoke"] = 5] = "Revoke";
  TokenInstruction2[TokenInstruction2["SetAuthority"] = 6] = "SetAuthority";
  TokenInstruction2[TokenInstruction2["MintTo"] = 7] = "MintTo";
  TokenInstruction2[TokenInstruction2["Burn"] = 8] = "Burn";
  TokenInstruction2[TokenInstruction2["CloseAccount"] = 9] = "CloseAccount";
  TokenInstruction2[TokenInstruction2["FreezeAccount"] = 10] = "FreezeAccount";
  TokenInstruction2[TokenInstruction2["ThawAccount"] = 11] = "ThawAccount";
  TokenInstruction2[TokenInstruction2["TransferChecked"] = 12] = "TransferChecked";
  TokenInstruction2[TokenInstruction2["ApproveChecked"] = 13] = "ApproveChecked";
  TokenInstruction2[TokenInstruction2["MintToChecked"] = 14] = "MintToChecked";
  TokenInstruction2[TokenInstruction2["BurnChecked"] = 15] = "BurnChecked";
  TokenInstruction2[TokenInstruction2["InitializeAccount2"] = 16] = "InitializeAccount2";
  TokenInstruction2[TokenInstruction2["SyncNative"] = 17] = "SyncNative";
  TokenInstruction2[TokenInstruction2["InitializeAccount3"] = 18] = "InitializeAccount3";
  TokenInstruction2[TokenInstruction2["InitializeMultisig2"] = 19] = "InitializeMultisig2";
  TokenInstruction2[TokenInstruction2["InitializeMint2"] = 20] = "InitializeMint2";
  TokenInstruction2[TokenInstruction2["GetAccountDataSize"] = 21] = "GetAccountDataSize";
  TokenInstruction2[TokenInstruction2["InitializeImmutableOwner"] = 22] = "InitializeImmutableOwner";
  TokenInstruction2[TokenInstruction2["AmountToUiAmount"] = 23] = "AmountToUiAmount";
  TokenInstruction2[TokenInstruction2["UiAmountToAmount"] = 24] = "UiAmountToAmount";
  return TokenInstruction2;
})(TokenInstruction || {});
var ASSOCIATED_TOKEN_ERROR__INVALID_OWNER = 0;
var associatedTokenErrorMessages;
if (import_process.default.env.NODE_ENV !== "production") {
  associatedTokenErrorMessages = {
    [ASSOCIATED_TOKEN_ERROR__INVALID_OWNER]: `Associated token account owner does not match address derivation`
  };
}
var TOKEN_ERROR__NOT_RENT_EXEMPT = 0;
var TOKEN_ERROR__INSUFFICIENT_FUNDS = 1;
var TOKEN_ERROR__INVALID_MINT = 2;
var TOKEN_ERROR__MINT_MISMATCH = 3;
var TOKEN_ERROR__OWNER_MISMATCH = 4;
var TOKEN_ERROR__FIXED_SUPPLY = 5;
var TOKEN_ERROR__ALREADY_IN_USE = 6;
var TOKEN_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS = 7;
var TOKEN_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS = 8;
var TOKEN_ERROR__UNINITIALIZED_STATE = 9;
var TOKEN_ERROR__NATIVE_NOT_SUPPORTED = 10;
var TOKEN_ERROR__NON_NATIVE_HAS_BALANCE = 11;
var TOKEN_ERROR__INVALID_INSTRUCTION = 12;
var TOKEN_ERROR__INVALID_STATE = 13;
var TOKEN_ERROR__OVERFLOW = 14;
var TOKEN_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED = 15;
var TOKEN_ERROR__MINT_CANNOT_FREEZE = 16;
var TOKEN_ERROR__ACCOUNT_FROZEN = 17;
var TOKEN_ERROR__MINT_DECIMALS_MISMATCH = 18;
var TOKEN_ERROR__NON_NATIVE_NOT_SUPPORTED = 19;
var tokenErrorMessages;
if (import_process.default.env.NODE_ENV !== "production") {
  tokenErrorMessages = {
    [TOKEN_ERROR__ACCOUNT_FROZEN]: `Account is frozen`,
    [TOKEN_ERROR__ALREADY_IN_USE]: `Already in use`,
    [TOKEN_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED]: `Account does not support specified authority type`,
    [TOKEN_ERROR__FIXED_SUPPLY]: `Fixed supply`,
    [TOKEN_ERROR__INSUFFICIENT_FUNDS]: `Insufficient funds`,
    [TOKEN_ERROR__INVALID_INSTRUCTION]: `Invalid instruction`,
    [TOKEN_ERROR__INVALID_MINT]: `Invalid Mint`,
    [TOKEN_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS]: `Invalid number of provided signers`,
    [TOKEN_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS]: `Invalid number of required signers`,
    [TOKEN_ERROR__INVALID_STATE]: `State is invalid for requested operation`,
    [TOKEN_ERROR__MINT_CANNOT_FREEZE]: `This token mint cannot freeze accounts`,
    [TOKEN_ERROR__MINT_DECIMALS_MISMATCH]: `The provided decimals value different from the Mint decimals`,
    [TOKEN_ERROR__MINT_MISMATCH]: `Account not associated with this Mint`,
    [TOKEN_ERROR__NATIVE_NOT_SUPPORTED]: `Instruction does not support native tokens`,
    [TOKEN_ERROR__NON_NATIVE_HAS_BALANCE]: `Non-native account can only be closed if its balance is zero`,
    [TOKEN_ERROR__NON_NATIVE_NOT_SUPPORTED]: `Instruction does not support non-native tokens`,
    [TOKEN_ERROR__NOT_RENT_EXEMPT]: `Lamport balance below rent-exempt threshold`,
    [TOKEN_ERROR__OVERFLOW]: `Operation overflowed`,
    [TOKEN_ERROR__OWNER_MISMATCH]: `Owner does not match`,
    [TOKEN_ERROR__UNINITIALIZED_STATE]: `State is unititialized`
  };
}
function expectAddress2(value) {
  if (!value) {
    throw new Error("Expected a Address.");
  }
  if (typeof value === "object" && "address" in value) {
    return value.address;
  }
  if (Array.isArray(value)) {
    return value[0];
  }
  return value;
}
function getAccountMetaFactory2(programAddress, optionalAccountStrategy) {
  return (account) => {
    if (!account.value) {
      return Object.freeze({
        address: programAddress,
        role: AccountRole.READONLY
      });
    }
    const writableRole = account.isWritable ? AccountRole.WRITABLE : AccountRole.READONLY;
    return Object.freeze({
      address: expectAddress2(account.value),
      role: isTransactionSigner3(account.value) ? upgradeRoleToSigner(writableRole) : writableRole,
      ...isTransactionSigner3(account.value) ? { signer: account.value } : {}
    });
  };
}
function isTransactionSigner3(value) {
  return !!value && typeof value === "object" && "address" in value && isTransactionSigner(value);
}
async function findAssociatedTokenPda(seeds, config = {}) {
  const {
    programAddress = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
  } = config;
  return await getProgramDerivedAddress({
    programAddress,
    seeds: [
      getAddressEncoder().encode(seeds.owner),
      getAddressEncoder().encode(seeds.tokenProgram),
      getAddressEncoder().encode(seeds.mint)
    ]
  });
}
var CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR = 1;
function getCreateAssociatedTokenIdempotentInstructionDataEncoder() {
  return transformEncoder(
    getStructEncoder([["discriminator", getU8Encoder()]]),
    (value) => ({
      ...value,
      discriminator: CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR
    })
  );
}
function getCreateAssociatedTokenIdempotentInstruction(input, config) {
  const programAddress = config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    ata: { value: input.ata ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    mint: { value: input.mint ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory2(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.ata),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({})
  };
  return instruction;
}
var TRANSFER_DISCRIMINATOR = 3;
function getTransferInstructionDataEncoder() {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", getU8Encoder()],
      ["amount", getU64Encoder()]
    ]),
    (value) => ({ ...value, discriminator: TRANSFER_DISCRIMINATOR })
  );
}
function getTransferInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;
  const originalAccounts = {
    source: { value: input.source ?? null, isWritable: true },
    destination: { value: input.destination ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory2(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.source),
      getAccountMeta(accounts.destination),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getTransferInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}

// node_modules/@privy-io/react-auth/dist/esm/use-export-wallet-Duyde2UB.mjs
function Ve({ rows: i2 }) {
  return (0, import_jsx_runtime.jsx)(mg, { children: i2.filter(((e3) => !!e3)).map(((e3, i3) => null != e3.value || e3.isLoading ? (0, import_jsx_runtime.jsxs)(fg, { children: [(0, import_jsx_runtime.jsx)(yg, { children: e3.label }), (0, import_jsx_runtime.jsx)(vg, { $isLoading: e3.isLoading, children: e3.value })] }, i3) : null)) });
}
var Je = ["solana:mainnet", "solana:devnet", "solana:testnet"];
function He(e3, n2) {
  if (!Object.prototype.hasOwnProperty.call(e3, n2)) throw TypeError("attempted to use private field on non-instance");
  return e3;
}
var Qe = 0;
var qe = "__private_" + Qe++ + "__implementation";
function Ke(e3, n2) {
  if (!Object.prototype.hasOwnProperty.call(e3, n2)) throw TypeError("attempted to use private field on non-instance");
  return e3;
}
var Ye = 0;
function Ge(e3) {
  return "__private_" + Ye++ + "_" + e3;
}
var Ze = Ge("_address");
var ze = Ge("_publicKey");
var Xe = Ge("_chains");
var en = Ge("_features");
var nn = Ge("_label");
var tn = Ge("_icon");
var an = class _an {
  get address() {
    return Ke(this, Ze)[Ze];
  }
  get publicKey() {
    return Ke(this, ze)[ze].slice();
  }
  get chains() {
    return Ke(this, Xe)[Xe].slice();
  }
  get features() {
    return Ke(this, en)[en].slice();
  }
  get label() {
    return Ke(this, nn)[nn];
  }
  get icon() {
    return Ke(this, tn)[tn];
  }
  constructor({ address: e3, publicKey: n2, label: t3, icon: a2 }) {
    Object.defineProperty(this, Ze, { writable: true, value: void 0 }), Object.defineProperty(this, ze, { writable: true, value: void 0 }), Object.defineProperty(this, Xe, { writable: true, value: void 0 }), Object.defineProperty(this, en, { writable: true, value: void 0 }), Object.defineProperty(this, nn, { writable: true, value: void 0 }), Object.defineProperty(this, tn, { writable: true, value: void 0 }), Ke(this, Ze)[Ze] = e3, Ke(this, ze)[ze] = n2, Ke(this, Xe)[Xe] = Je, Ke(this, nn)[nn] = t3, Ke(this, tn)[tn] = a2, Ke(this, en)[en] = ["solana:signAndSendTransaction", "solana:signTransaction", "solana:signMessage"], new.target === _an && Object.freeze(this);
  }
};
function rn(e3, n2) {
  if (!Object.prototype.hasOwnProperty.call(e3, n2)) throw TypeError("attempted to use private field on non-instance");
  return e3;
}
var sn = 0;
function on(e3) {
  return "__private_" + sn++ + "_" + e3;
}
var cn = on("_listeners");
var ln = on("_version");
var dn = on("_name");
var un = on("_icon");
var pn = on("_injection");
var mn = on("_isPrivyWallet");
var fn = on("_accounts");
var gn = on("_on");
var hn = on("_emit");
var yn = on("_off");
var wn = on("_connected");
var vn = on("_connect");
var An = on("_disconnect");
var bn2 = on("_signMessage");
var In = on("_signAndSendTransaction");
var Tn = on("_signTransaction");
function Sn(e3, ...n2) {
  rn(this, cn)[cn][e3]?.forEach(((e4) => e4.apply(null, n2)));
}
function On(e3, n2) {
  rn(this, cn)[cn][e3] = rn(this, cn)[cn][e3]?.filter(((e4) => n2 !== e4));
}
var kn = dt.span.withConfig({ displayName: "CircleBackground", componentId: "sc-c9f33cd-0" })(["&&{width:82px;height:82px;border-width:4px;border-style:solid;border-color:", ";background-color:", ";border-radius:50%;display:inline-block;box-sizing:border-box;}"], ((e3) => e3.color ?? "var(--privy-color-accent)"), ((e3) => e3.color ?? "var(--privy-color-accent)"));
var Cn = ({ instruction: s2, fees: o9, transactionInfo: c, solPrice: l, chain: d }) => (0, import_jsx_runtime.jsxs)(mg, { children: [c?.action && (0, import_jsx_runtime.jsxs)(fg, { children: [(0, import_jsx_runtime.jsx)(yg, { children: "Action" }), (0, import_jsx_runtime.jsx)(vg, { children: c.action })] }), null != s2?.total && (0, import_jsx_runtime.jsxs)(fg, { children: [(0, import_jsx_runtime.jsx)(yg, { children: "Total" }), (0, import_jsx_runtime.jsx)(vg, { children: s2.total })] }), !s2?.total && null != s2?.amount && (0, import_jsx_runtime.jsxs)(fg, { children: [(0, import_jsx_runtime.jsx)(yg, { children: "Total" }), (0, import_jsx_runtime.jsx)(vg, { children: (0, import_jsx_runtime.jsx)(Bo, { quantities: [s2.amount, o9], tokenPrice: l }) })] }), (0, import_jsx_runtime.jsxs)(fg, { children: [(0, import_jsx_runtime.jsx)(yg, { children: "Fees" }), (0, import_jsx_runtime.jsx)(vg, { children: (0, import_jsx_runtime.jsx)(Bo, { quantities: [o9], tokenPrice: l }) })] }), s2?.to && (0, import_jsx_runtime.jsxs)(fg, { children: [(0, import_jsx_runtime.jsx)(yg, { children: "To" }), (0, import_jsx_runtime.jsx)(vg, { children: (0, import_jsx_runtime.jsx)(Cl, { walletAddress: s2.to, chainId: d, chainType: "solana" }) })] })] });
var En = ({ fees: e3, onClose: n2, receiptHeader: t3, receiptDescription: a2, transactionInfo: i2, solPrice: r4, signOnly: p3, instruction: m2, chain: f2 }) => (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(Di, { onClose: n2 }), (0, import_jsx_runtime.jsx)(Ml, { style: { marginBottom: "16px" }, children: (0, import_jsx_runtime.jsxs)("div", { children: [(0, import_jsx_runtime.jsx)(kn, { color: "var(--privy-color-success-light)" }), (0, import_jsx_runtime.jsx)(CheckCircleIcon_default, { height: 38, width: 38, strokeWidth: 2, stroke: "var(--privy-color-success)" })] }) }), (0, import_jsx_runtime.jsx)(Vl, { title: t3 ?? `Transaction ${p3 ? "signed" : "complete"}!`, description: a2 ?? "You're all set." }), (0, import_jsx_runtime.jsx)(Cn, { solPrice: r4, instruction: m2, fees: e3, transactionInfo: i2, chain: f2 }), (0, import_jsx_runtime.jsx)(Yr, {}), (0, import_jsx_runtime.jsx)(xn, { loading: false, onClick: n2, children: "Close" }), (0, import_jsx_runtime.jsx)(Xo, {}), (0, import_jsx_runtime.jsx)(ci, {})] });
var xn = dt(Ci).withConfig({ displayName: "SubmitButton", componentId: "sc-3cb7ee42-0" })(["&&{margin-top:24px;}transition:color 350ms ease,background-color 350ms ease;"]);
function Fn(e3) {
  return new Uint8Array(getTransactionDecoder().decode(e3).messageBytes);
}
async function _n(e3, n2) {
  try {
    return await e3;
  } catch {
    return n2;
  }
}
var Pn = (...e3) => {
  if ("undefined" == typeof import_buffer.Buffer) throw new _("Buffer is not defined.", void 0, p.BUFFER_NOT_DEFINED);
  return import_buffer.Buffer.from(...e3);
};
function Un(e3) {
  switch (e3) {
    case "solana:mainnet":
      return "mainnet-beta";
    case "solana:devnet":
      return "devnet";
    case "solana:testnet":
      return "testnet";
  }
}
async function Wn({ privyClient: e3, chain: n2, mint: t3 }) {
  let a2 = Fo[n2];
  if (!a2[t3]) {
    let i2 = await e3.getSplTokenMetadata({ mintAddress: t3, cluster: Un(n2) });
    i2 && (a2[t3] = { address: t3, symbol: i2.symbol, decimals: i2.decimals });
  }
  return a2[t3];
}
async function Mn({ solanaClient: e3, tx: n2 }) {
  let t3 = getBase64Decoder().decode(Fn(n2)), { value: a2 } = await e3.rpc.getFeeForMessage(t3).send();
  return a2 ?? 0n;
}
async function jn({ solanaClient: e3, tx: n2, replaceRecentBlockhash: t3 }) {
  let { value: a2 } = await e3.rpc.simulateTransaction(getBase64Decoder().decode(n2), { commitment: "confirmed", encoding: "base64", sigVerify: false, replaceRecentBlockhash: t3 }).send();
  if ("BlockhashNotFound" === a2.err && t3) throw Error("Simulation failed: Blockhash not found");
  return "BlockhashNotFound" === a2.err ? await jn({ solanaClient: e3, tx: n2, replaceRecentBlockhash: true }) : { logs: a2.logs ?? [], error: a2.err, hasError: !!a2.err, hasFunds: a2.logs?.every(((e4) => !/insufficient funds/gi.test(e4) && !/insufficient lamports/gi.test(e4))) ?? true };
}
async function Bn({ tx: e3, solanaClient: n2, privyClient: t3, checkFunds: a2 }) {
  let i2 = getCompiledTransactionMessageDecoder().decode(Fn(e3)), r4 = i2.staticAccounts[0] ?? "", s2 = await Mn({ solanaClient: n2, tx: e3 }), o9 = a2 ? await _n(jn({ solanaClient: n2, tx: e3 })) : void 0, c = o9?.hasFunds ?? true, l = {}, d = [], u2 = await (async function({ solanaClient: e4, message: n3 }) {
    if (!("addressTableLookups" in n3) || !n3.addressTableLookups) return [...n3.staticAccounts];
    let t4 = n3.addressTableLookups.map(((e5) => e5.lookupTableAddress)), a3 = await fetchAddressesForLookupTables(t4, e4.rpc), i3 = t4.map(((e5, t5) => [...n3.addressTableLookups[t5]?.writableIndexes.map(((n4) => {
      let i4 = a3[e5]?.[n4];
      if (i4) return { key: i4, isWritable: true, altIdx: t5 };
    })) ?? [], ...n3.addressTableLookups[t5]?.readonlyIndexes.map(((n4) => {
      let i4 = a3[e5]?.[n4];
      if (i4) return { key: i4, isWritable: false, altIdx: t5 };
    })) ?? []])).flat().filter(((e5) => !!e5)).sort(((e5, n4) => e5.isWritable !== n4.isWritable ? e5.isWritable ? -1 : 1 : e5.altIdx - n4.altIdx)).map((({ key: e5 }) => e5));
    return [...n3.staticAccounts, ...i3];
  })({ solanaClient: n2, message: i2 });
  for (let e4 of i2.instructions) {
    let a3 = i2.staticAccounts[e4.programAddressIndex] || "";
    if (a3 !== So && a3 !== Eo) if (a3 !== Io) {
      if (a3 === No) {
        let n3 = await _n((function(e5, n4, t4) {
          let [a4, i3, r5, s3] = e5.accountIndices?.map(((e6) => n4[e6])) ?? [];
          return { type: "ata-creation", program: t4, payer: a4, ata: i3, owner: r5, mint: s3 };
        })(e4, u2, a3));
        if (!n3) {
          d.push({ type: "unknown", program: a3, discriminator: e4.data?.[0] });
          continue;
        }
        if (d.push(n3), n3.ata && n3.owner && n3.mint) {
          l[n3.ata] = { owner: n3.owner, mint: n3.mint };
          continue;
        }
      }
      if (_o.includes(a3)) {
        let i3 = await _n($n(e4, u2, n2, t3, a3));
        if (!i3) {
          d.push({ type: "unknown", program: a3, discriminator: e4.data?.[0] });
          continue;
        }
        d.push(i3);
      } else if (Mo.includes(a3)) {
        let i3 = await _n(Rn(e4, u2, n2, t3, a3));
        if (!i3) {
          d.push({ type: "unknown", program: a3, discriminator: e4.data?.[0] });
          continue;
        }
        d.push(i3);
      } else d.push({ type: "unknown", program: a3, discriminator: e4.data?.[0] });
    } else {
      let n3 = await _n(Nn(e4, u2));
      if (!n3) {
        d.push({ type: "unknown", program: a3, discriminator: e4.data?.[0] });
        continue;
      }
      d.push(n3);
    }
    else {
      let i3 = await _n(Ln(e4, u2, n2, t3, l, a3));
      if (!i3) {
        d.push({ type: "unknown", program: a3, discriminator: e4.data?.[0] });
        continue;
      }
      d.push(i3), "spl-transfer" === i3.type && (i3.fromAta && i3.fromAccount && i3.token.address && (l[i3.fromAta] ??= { owner: i3.fromAccount, mint: i3.token.address }), i3.toAta && i3.toAccount && i3.token.address && (l[i3.toAta] ??= { owner: i3.toAccount, mint: i3.token.address }));
    }
  }
  return { spender: r4, fee: s2, instructions: d, hasFunds: !!c };
}
function Dn(e3, n2 = 0) {
  try {
    return (function(e4, n3 = 0) {
      let t4 = 0n;
      for (let a2 = 0; a2 < 8; a2++) t4 |= BigInt(e4[n3 + a2]) << BigInt(8 * a2);
      return t4;
    })(e3, n2);
  } catch {
  }
  try {
    return e3.readBigInt64LE(n2);
  } catch {
  }
  let t3 = Pn(e3);
  try {
    return ((e4, n3 = 0) => {
      let t4 = e4[n3], a2 = e4[n3 + 7];
      if (!t4 || !a2) throw Error(`Buffer offset out of range: first: ${t4}, last: ${a2}.`);
      return (BigInt(e4[n3 + 4] + 256 * e4[n3 + 5] + 65536 * e4[n3 + 6] + (a2 << 24)) << 32n) + BigInt(t4 + 256 * e4[++n3] + 65536 * e4[++n3] + 16777216 * e4[++n3]);
    })(t3);
  } catch {
  }
  try {
    return t3.subarray(n2).readBigInt64LE();
  } catch {
  }
  try {
    return t3.readBigInt64LE(n2);
  } catch {
  }
  return 0n;
}
async function Ln(e3, n2, t3, a2, i2, r4) {
  let s2 = e3.data?.[0], o9 = e3.accountIndices?.map(((e4) => n2[e4])) ?? [];
  if (1 === s2) {
    let [e4, n3, t4] = o9;
    return { type: "spl-init-account", program: r4, account: e4, mint: n3, owner: t4 };
  }
  if (3 === s2) {
    let n3, s3, [c, l, d] = o9, u2 = "", p3 = l ? i2[l] : void 0;
    if (p3) n3 = p3.owner, u2 = p3.mint;
    else if (l) {
      let e4 = await t3.rpc.getAccountInfo(l, { commitment: "confirmed", encoding: "jsonParsed" }).send(), a3 = e4.value?.data;
      n3 = a3?.parsed?.info?.owner, u2 = a3?.parsed?.info?.mint ?? "", s3 = a3?.parsed?.info?.tokenAmount?.decimals;
    }
    if (!u2 && c) {
      let e4 = await t3.rpc.getAccountInfo(c, { commitment: "confirmed", encoding: "jsonParsed" }).send(), n4 = e4.value?.data;
      u2 = n4?.parsed?.info?.mint ?? "";
    }
    let m2 = await Wn({ privyClient: a2, chain: t3.chain, mint: u2 }), f2 = m2?.symbol ?? "";
    return s3 ??= m2?.decimals ?? 9, { type: "spl-transfer", program: r4, fromAta: c, fromAccount: d, toAta: l, toAccount: n3, value: Dn(e3.data, 1), token: { symbol: f2, decimals: s3, address: u2 } };
  }
  if (9 === s2) {
    let [e4, n3, t4] = o9;
    return { type: "spl-close-account", program: r4, source: e4, destination: n3, owner: t4 };
  }
  if (17 === s2) return { type: "spl-sync-native", program: r4 };
  throw Error(`Token program instruction type ${s2} not supported`);
}
async function Nn(e3, n2) {
  let t3 = e3.data?.[0], a2 = e3.accountIndices?.map(((e4) => n2[e4])) ?? [];
  if (0 === t3) {
    let [, n3] = a2;
    return { type: "create-account", program: Io, account: n3?.toString(), value: Dn(e3.data, 4), withSeed: false };
  }
  if (2 === t3) {
    let [n3, t4] = a2;
    return { type: "sol-transfer", program: Io, fromAccount: n3, toAccount: t4, token: { symbol: "SOL", decimals: 9 }, value: Dn(e3.data, 4), withSeed: false };
  }
  if (3 === t3) {
    let [, n3] = a2;
    return { type: "create-account", program: Io, account: n3, withSeed: true, value: Dn(e3.data.slice(e3.data.length - 32 - 8 - 8)) };
  }
  if (11 === t3) {
    let [n3, t4] = a2;
    return { type: "sol-transfer", program: Io, fromAccount: n3, toAccount: t4, value: Dn(e3.data, 4), token: { symbol: "SOL", decimals: 9 }, withSeed: true };
  }
  throw Error(`System program instruction type ${t3} not supported`);
}
async function $n(e3, n2, t3, a2, i2) {
  let r4 = e3.accountIndices?.map(((e4) => n2[e4])) ?? [], s2 = e3.data?.[0];
  if (143 === s2) {
    let n3 = r4[10], s3 = r4[11];
    return { type: "raydium-swap-base-input", program: i2, mintIn: n3, mintOut: s3, tokenIn: n3 ? await Wn({ privyClient: a2, chain: t3.chain, mint: n3 }) : void 0, tokenOut: s3 ? await Wn({ privyClient: a2, chain: t3.chain, mint: s3 }) : void 0, amountIn: Dn(e3.data, 8), minimumAmountOut: Dn(e3.data, 16) };
  }
  if (55 === s2) {
    let n3 = r4[10], s3 = r4[11];
    return { type: "raydium-swap-base-output", program: i2, mintIn: n3, mintOut: s3, tokenIn: n3 ? await Wn({ privyClient: a2, chain: t3.chain, mint: n3 }) : void 0, tokenOut: s3 ? await Wn({ privyClient: a2, chain: t3.chain, mint: s3 }) : void 0, maxAmountIn: Dn(e3.data, 8), amountOut: Dn(e3.data, 16) };
  }
  throw Error(`Raydium swap program instruction type ${s2} not supported`);
}
async function Rn(e3, n2, t3, a2, i2) {
  let r4 = e3.data?.[0], s2 = e3.accountIndices?.map(((e4) => n2[e4])) ?? [];
  if ([208, 51, 239, 151, 123, 43, 237, 92].includes(r4)) {
    let n3 = s2[5], r5 = s2[6];
    return { type: "jupiter-swap-exact-out-route", program: i2, mintIn: n3, mintOut: r5, tokenIn: n3 ? await Wn({ privyClient: a2, chain: t3.chain, mint: n3 }) : void 0, tokenOut: r5 ? await Wn({ privyClient: a2, chain: t3.chain, mint: r5 }) : void 0, outAmount: Dn(e3.data, e3.data.length - 1 - 2 - 8 - 8), quotedInAmount: Dn(e3.data, e3.data.length - 1 - 2 - 8) };
  }
  if ([176, 209, 105, 168, 154, 125, 69, 62].includes(r4)) {
    let n3 = s2[7], r5 = s2[8];
    return { type: "jupiter-swap-exact-out-route", program: i2, mintIn: n3, mintOut: r5, tokenIn: n3 ? await Wn({ privyClient: a2, chain: t3.chain, mint: n3 }) : void 0, tokenOut: r5 ? await Wn({ privyClient: a2, chain: t3.chain, mint: r5 }) : void 0, outAmount: Dn(e3.data, e3.data.length - 1 - 2 - 8 - 8), quotedInAmount: Dn(e3.data, e3.data.length - 1 - 2 - 8) };
  }
  if ([193, 32, 155, 51, 65, 214, 156, 129].includes(r4)) {
    let n3 = s2[7], r5 = s2[8];
    return { type: "jupiter-swap-shared-accounts-route", program: i2, mintIn: n3, mintOut: r5, tokenIn: n3 ? await Wn({ privyClient: a2, chain: t3.chain, mint: n3 }) : void 0, tokenOut: r5 ? await Wn({ privyClient: a2, chain: t3.chain, mint: r5 }) : void 0, inAmount: Dn(e3.data, e3.data.length - 1 - 2 - 8 - 8), quotedOutAmount: Dn(e3.data, e3.data.length - 1 - 2 - 8) };
  }
  throw [62, 198, 214, 193, 213, 159, 108, 210].includes(r4) && console.warn("Jupiter swap program instruction 'claim' not implemented"), [116, 206, 27, 191, 166, 19, 0, 73].includes(r4) && console.warn("Jupiter swap program instruction 'claim_token' not implemented"), [26, 74, 236, 151, 104, 64, 183, 249].includes(r4) && console.warn("Jupiter swap program instruction 'close_token' not implemented"), [229, 194, 212, 172, 8, 10, 134, 147].includes(r4) && console.warn("Jupiter swap program instruction 'create_open_orders' not implemented"), [28, 226, 32, 148, 188, 136, 113, 171].includes(r4) && console.warn("Jupiter swap program instruction 'create_program_open_orders' not implemented"), [232, 242, 197, 253, 240, 143, 129, 52].includes(r4) && console.warn("Jupiter swap program instruction 'create_token_ledger' not implemented"), [147, 241, 123, 100, 244, 132, 174, 118].includes(r4) && console.warn("Jupiter swap program instruction 'create_token_account' not implemented"), [229, 23, 203, 151, 122, 227, 173, 42].includes(r4) && console.warn("Jupiter swap program instruction 'route' not implemented"), [150, 86, 71, 116, 167, 93, 14, 104].includes(r4) && console.warn("Jupiter swap program instruction 'route_with_token_ledger' not implemented"), [228, 85, 185, 112, 78, 79, 77, 2].includes(r4) && console.warn("Jupiter swap program instruction 'set_token_ledger' not implemented"), [230, 121, 143, 80, 119, 159, 106, 170].includes(r4) && console.warn("Jupiter swap program instruction 'shared_accounts_route_with_token_ledger' not implemented"), Error(`Jupiter swap program instruction type ${r4} not supported`);
}
async function Vn({ rpcSubscriptions: e3, signature: n2, timeout: t3 }) {
  let a2 = new AbortController(), i2 = await e3.signatureNotifications(n2, { commitment: "confirmed" }).subscribe({ abortSignal: a2.signal }), r4 = await Promise.race([new Promise(((e4) => {
    setTimeout((() => {
      a2.abort(), e4(Error("Transaction confirmation timed out"));
    }), t3);
  })), new Promise((async (e4) => {
    for await (let n3 of i2) {
      if (a2.abort(), n3.value.err) return e4(Error("Transaction confirmation failed"));
      e4(void 0);
    }
  }))]);
  if (r4 instanceof Error) throw r4;
}
function Jn({ rpc: e3, rpcSubscriptions: n2, chain: t3, blockExplorerUrl: a2 }) {
  let i2 = (function({ rpc: e4, rpcSubscriptions: n3 }) {
    return async (t4) => new Promise((async (a3, i3) => {
      try {
        let i4 = await e4.sendTransaction(Pn(t4).toString("base64"), { preflightCommitment: "confirmed", encoding: "base64" }).send();
        await Vn({ rpcSubscriptions: n3, signature: i4, timeout: 1e4 }), a3({ signature: new Uint8Array(getBase58Encoder().encode(i4)) });
      } catch (e5) {
        i3(e5);
      }
    }));
  })({ rpc: e3, rpcSubscriptions: n2 });
  return { rpc: e3, rpcSubscriptions: n2, chain: t3, blockExplorerUrl: a2, sendAndConfirmTransaction: i2 };
}
function Hn() {
  let e3 = Pr(), n2 = (0, import_react.useMemo)((() => Object.fromEntries(["solana:mainnet", "solana:devnet", "solana:testnet"].map(((n3) => [n3, e3.solanaRpcs[n3] ? Jn({ chain: n3, rpc: e3.solanaRpcs[n3].rpc, rpcSubscriptions: e3.solanaRpcs[n3].rpcSubscriptions, blockExplorerUrl: e3.solanaRpcs[n3].blockExplorerUrl ?? `https://explorer.solana.com?cluster=${n3.replace("solana:", "")}` }) : null])))), [e3.solanaRpcs]);
  return (0, import_react.useCallback)(((e4) => {
    if (!n2[e4]) throw Error(`No RPC configuration found for chain ${e4}`);
    return n2[e4];
  }), [n2]);
}
var Qn = { component: () => {
  let { data: e3, onUserCloseViaDialogOrKeybindRef: n2, setModalData: t3, navigate: a2 } = Or(), { client: i2, closePrivyModal: r4, walletProxy: s2, showFiatPrices: o9 } = s(), c = Pr(), { user: l } = v(), d = Hn()(e3?.standardSignAndSendTransaction?.chain ?? "solana:mainnet"), [u2, p3] = (0, import_react.useState)(e3?.standardSignAndSendTransaction?.transaction), [m2, f2] = (0, import_react.useState)(), [g, h] = (0, import_react.useState)(), [y2, w] = (0, import_react.useState)({ value: 0n, isLoading: false }), [v2, x] = (0, import_react.useState)(false), [F, _2] = (0, import_react.useState)({}), [P2, U2] = (0, import_react.useState)(), W = e3?.standardSignAndSendTransaction?.account, M3 = !!e3?.standardSignAndSendTransaction?.signOnly, j = W?.imported ? m(l) : y(l), { solPrice: B2, isSolPriceLoading: D3 } = Il({ enabled: o9 }), L3 = (0, import_react.useMemo)((() => {
    if (!m2) return;
    let e4 = m2.spender, n3 = Po(m2.fee), t4 = Po(y2.value, 3, true), a3 = m2.instructions.filter(((e5) => ["sol-transfer", "spl-transfer", "raydium-swap-base-input", "raydium-swap-base-output", "jupiter-swap-shared-accounts-route", "jupiter-swap-exact-out-route"].includes(e5.type))), i3 = a3.at(0);
    if (!i3 || a3.length > 1) return { fee: n3, spender: e4, balance: t4 };
    if ("sol-transfer" === i3.type) return { fee: n3, spender: e4, balance: t4, total: Po(i3.value) };
    if ("spl-transfer" === i3.type) return { fee: n3, spender: e4, balance: t4, total: `${i({ amount: i3.value, decimals: i3.token.decimals })} ${i3.token.symbol}` };
    if ("raydium-swap-base-input" === i3.type && i3.tokenIn && i3.tokenOut) {
      return { fee: n3, spender: e4, balance: t4, swap: `${`${i({ amount: i3.amountIn, decimals: i3.tokenIn.decimals })} ${i3.tokenIn.symbol}`}  ${`${i({ amount: i3.minimumAmountOut, decimals: i3.tokenOut.decimals })} ${i3.tokenOut.symbol}`}` };
    }
    if ("raydium-swap-base-output" === i3.type && i3.tokenIn && i3.tokenOut) {
      return { fee: n3, spender: e4, balance: t4, swap: `${`${i({ amount: i3.maxAmountIn, decimals: i3.tokenIn.decimals })} ${i3.tokenIn.symbol}`}  ${`${i({ amount: i3.amountOut, decimals: i3.tokenOut.decimals })} ${i3.tokenOut.symbol}`}` };
    }
    if ("jupiter-swap-shared-accounts-route" === i3.type && i3.tokenIn && i3.tokenOut) {
      return { fee: n3, spender: e4, balance: t4, swap: `${`${i({ amount: i3.inAmount, decimals: i3.tokenIn.decimals })} ${i3.tokenIn.symbol}`}  ${`${i({ amount: i3.quotedOutAmount, decimals: i3.tokenOut.decimals })} ${i3.tokenOut.symbol}`}` };
    }
    if ("jupiter-swap-exact-out-route" === i3.type && i3.tokenIn && i3.tokenOut) {
      return { fee: n3, spender: e4, balance: t4, swap: `${`${i({ amount: i3.quotedInAmount, decimals: i3.tokenIn.decimals })} ${i3.tokenIn.symbol}`}  ${`${i({ amount: i3.outAmount, decimals: i3.tokenOut.decimals })} ${i3.tokenOut.symbol}`}` };
    }
    return { fee: n3, spender: e4, balance: t4 };
  }), [m2, W?.address, y2]), N = (0, import_react.useMemo)((() => {
    let e4;
    if (!m2 || !o9 || !B2 || D3) return;
    function n3(...e5) {
      return Lo(e5.reduce(((e6, n4) => e6 + n4), 0n), B2 ?? 0);
    }
    W?.address === m2.spender && (e4 = n3(m2.fee));
    let t4 = n3(y2.value), a3 = m2.instructions.filter(((e5) => "sol-transfer" === e5.type || "spl-transfer" === e5.type)).at(0);
    return !a3 || m2.instructions.length > 1 ? { fee: e4, balance: t4 } : "sol-transfer" === a3.type ? { fee: e4, balance: t4, total: n3(a3.value, W?.address === m2.spender ? m2.fee : 0n) } : "spl-transfer" === a3.type ? { fee: e4, balance: t4, total: `${i({ amount: a3.value, decimals: a3.token.decimals })} ${a3.token.symbol}` } : { fee: e4, balance: t4 };
  }), [m2, o9, B2, D3, W?.address, y2]);
  if ((0, import_react.useEffect)((() => {
    !(async function() {
      if (u2 && i2) try {
        h(void 0);
        let e4 = await Bn({ tx: u2, solanaClient: d, privyClient: i2, checkFunds: !M3 });
        f2(e4);
      } catch (e4) {
        console.error("Failed to prepare transaction", e4), h(e4);
      }
    })();
  }), [u2, d, i2, M3]), (0, import_react.useEffect)((() => {
    (async function() {
      if (!W) return;
      w({ value: y2.value, isLoading: true });
      let { value: e4 } = await d.rpc.getBalance(W.address, { commitment: "confirmed" }).send();
      w({ value: e4 ?? 0n, isLoading: false });
    })().catch(console.error);
  }), [m2]), !u2 || !e3?.standardSignAndSendTransaction || !W) {
    let n3 = Error("Invalid transaction request");
    return (0, import_jsx_runtime.jsx)(Uc, { error: n3, allowlistConfig: c.allowlistConfig, onRetry: () => {
      e3?.standardSignAndSendTransaction?.onFailure(n3), r4({ shouldCallAuthOnSuccess: false });
    } });
  }
  let $ = () => {
    if (!v2) return F.signature || F.signedTransaction ? e3?.standardSignAndSendTransaction?.onSuccess({ signature: F.signature, signedTransaction: F.signedTransaction }) : e3?.standardSignAndSendTransaction?.onFailure(P2 ?? g ?? Error("User exited the modal before submitting the transaction")), r4({ shouldCallAuthOnSuccess: false });
  };
  n2.current = $;
  let R2 = e3.standardSignAndSendTransaction?.uiOptions?.transactionInfo?.contractInfo?.imgUrl ? (0, import_jsx_runtime.jsx)("img", { src: e3.standardSignAndSendTransaction.uiOptions.transactionInfo.contractInfo.imgUrl, alt: e3.standardSignAndSendTransaction.uiOptions.transactionInfo.contractInfo.imgAltText }) : null, V2 = !!(e3.funding && e3.funding.supportedOptions.length > 0), J2 = !m2?.hasFunds && V2;
  if (F.signature || F.signedTransaction) {
    let n3 = m2?.instructions.filter(((e4) => "sol-transfer" === e4.type || "spl-transfer" === e4.type)), t4 = 1 === n3?.length ? n3?.at(0) : void 0;
    return (0, import_jsx_runtime.jsx)(En, { fees: F.fees ?? 0n, onClose: $, transactionInfo: e3.standardSignAndSendTransaction?.uiOptions.transactionInfo, solPrice: B2, receiptHeader: e3.standardSignAndSendTransaction?.uiOptions.successHeader, receiptDescription: e3.standardSignAndSendTransaction?.uiOptions.successDescription, chain: d.chain, signOnly: M3, instruction: "sol-transfer" === t4?.type ? { to: t4.toAccount, amount: t4.value } : { to: t4?.toAccount || t4?.toAta, total: L3?.total } });
  }
  return P2 ? (0, import_jsx_runtime.jsx)(Km, { transactionError: P2, chainId: d.chain, onClose: $, chainType: "solana", onRetry: async () => {
    U2(void 0);
    let { value: e4 } = await d.rpc.getLatestBlockhash().send();
    p3((function(e5, n3) {
      return pipe(getCompiledTransactionMessageDecoder().decode(Fn(e5)), ((e6) => decompileTransactionMessage(e6)), ((e6) => setTransactionMessageLifetimeUsingBlockhash(n3, e6)), ((e6) => compileTransaction(e6)), ((e6) => new Uint8Array(getTransactionEncoder().encode(e6))));
    })(u2, e4));
  } }) : (0, import_jsx_runtime.jsx)($m, { img: R2, title: e3.standardSignAndSendTransaction?.uiOptions?.transactionInfo?.title || "Confirm transaction", subtitle: e3.standardSignAndSendTransaction?.uiOptions?.description || `${c.name} wants your permission to approve the following transaction.`, cta: J2 ? "Add funds" : e3.standardSignAndSendTransaction?.uiOptions?.buttonText || "Approve", instructions: m2?.instructions ?? [], network: "solana:mainnet" == d.chain ? "Solana" : d.chain.replace("solana:", ""), blockExplorerUrl: d.blockExplorerUrl, total: o9 ? N?.total : L3?.total, fee: o9 ? N?.fee : L3?.fee, balance: o9 ? N?.balance : L3?.balance, swap: L3?.swap, transactingWalletAddress: W.address, disabled: !m2?.hasFunds && !V2, isSubmitting: v2, isPreparing: !m2 || y2.isLoading, isTokenPriceLoading: o9 && D3, isMissingFunds: !m2?.hasFunds, submitError: P2 ?? void 0, parseError: g, onClick: J2 ? async () => {
    if (W) {
      if (!V2) throw Error("Funding wallet is not enabled");
      t3({ ...e3, funding: { ...e3.funding, methodScreen: vm }, solanaFundingData: e3?.solanaFundingData }), a2(vm);
    }
  } : async () => {
    try {
      if (x(true), v2 || !W || !s2 || !l || !j) return;
      let n3 = await e3.standardSignAndSendTransaction.onConfirm(u2);
      if ("signature" in n3) {
        let e4 = await (async function({ solanaClient: e5, signature: n4 }) {
          let t4 = getBase58Decoder().decode(n4), a3 = await e5.rpc.getTransaction(t4, { maxSupportedTransactionVersion: 0, commitment: "confirmed", encoding: "base64" }).send().catch((() => null));
          return a3 ? { fee: a3.meta?.fee ?? 0n } : null;
        })({ solanaClient: d, signature: n3.signature });
        return void _2({ ...n3, fees: e4?.fee });
      }
      _2(n3);
    } catch (e4) {
      console.warn({ transaction: u2, error: e4 }), U2(e4);
    } finally {
      x(false);
    }
  }, onClose: $ });
} };
function qn(e3, n2, t3) {
  let a2 = structuredClone(getTransactionDecoder().decode(e3)), i2 = address(n2);
  return i2 in a2.signatures && (a2.signatures[i2] = t3), new Uint8Array(getTransactionEncoder().encode(a2));
}
function Kn() {
  let { isHeadlessSigning: e3, walletProxy: n2, initializeWalletProxy: t3, recoverEmbeddedWallet: a2, openModal: i2, privy: r4, client: s2 } = s(), { user: o9 } = q(), { setModalData: c } = Or(), { signWithUserSigner: l } = r3();
  return { signMessage: ({ message: d, address: u2, options: p3 }) => new Promise((async (m2, f2) => {
    let g = f(o9, u2);
    if ("privy" !== g?.walletClientType) return void f2(new _("Wallet is not a Privy wallet", void 0, p.EMBEDDED_WALLET_NOT_FOUND));
    let { entropyId: h, entropyIdVerifier: y2 } = Ra(o9, g), w = b(g), v2 = Pn(d).toString("base64");
    if (v2.length < 1) return void f2(new _("Message must be a non-empty string", void 0, p.INVALID_MESSAGE));
    let A = async () => {
      let e4;
      if (!o9) throw Error("User must be authenticated before signing with a Privy wallet");
      let i3 = await s2.getAccessToken();
      if (!i3) throw Error("User must be authenticated to use their embedded wallet.");
      let c2 = n2 ?? await t3(15e3);
      if (!c2) throw Error("Failed to initialize embedded wallet proxy.");
      if (!await a2({ address: g.address })) throw Error("Unable to connect to wallet");
      if (w) {
        let n3 = await r(r4, l, { chain_type: "solana", method: "signMessage", params: { message: v2, encoding: "base64" }, wallet_id: g.id });
        if (!n3.data || !("signature" in n3.data)) throw Error("Failed to sign message");
        e4 = n3.data.signature;
      } else {
        let { response: n3 } = await c2.rpc({ accessToken: i3, entropyId: h, entropyIdVerifier: y2, chainType: "solana", hdWalletIndex: g.walletIndex ?? 0, requesterAppId: p3?.uiOptions?.requesterAppId, request: { method: "signMessage", params: { message: v2 } } });
        e4 = n3.data.signature;
      }
      return e4;
    };
    if (e3({ showWalletUIs: p3?.uiOptions?.showWalletUIs })) try {
      let e4 = await A(), n3 = new Uint8Array(Pn(e4, "base64"));
      m2({ signature: n3 });
    } catch (e4) {
      f2(e4);
    }
    else c({ signMessage: { method: "solana_signMessage", data: v2, confirmAndSign: A, onSuccess: (e4) => {
      m2({ signature: new Uint8Array(Pn(e4, "base64")) });
    }, onFailure: (e4) => {
      f2(e4);
    }, uiOptions: p3?.uiOptions ?? {} }, connectWallet: { recoveryMethod: g.recoveryMethod, connectingWalletAddress: g.address, entropyId: h, entropyIdVerifier: y2, isUnifiedWallet: w, onCompleteNavigateTo: ny, onFailure: (e4) => {
      f2(new _("Failed to connect to wallet", e4, p.UNKNOWN_CONNECT_WALLET_ERROR));
    } } }), i2(qf);
  })) };
}
function Yn() {
  let { isHeadlessSigning: e3, openModal: n2 } = s(), { setModalData: t3 } = Or(), { signMessage: a2 } = Kn(), { user: i2 } = q();
  return { signTransaction: async ({ transaction: r4, options: s2, chain: o9 = "solana:mainnet", address: c }) => {
    async function l(e4) {
      let { signature: n3 } = await a2({ message: Fn(e4), address: c, options: { ...s2, uiOptions: { ...s2?.uiOptions, showWalletUIs: false } } });
      return { signedTransaction: qn(e4, c, n3) };
    }
    return e3({ showWalletUIs: s2?.uiOptions?.showWalletUIs }) ? l(r4) : new Promise((async (e4, a3) => {
      let d = f(i2, c);
      if ("privy" !== d?.walletClientType) return void a3(new _("Wallet is not a Privy wallet", void 0, p.EMBEDDED_WALLET_NOT_FOUND));
      let { entropyId: u2, entropyIdVerifier: p3 } = Ra(i2, d), m2 = b(d);
      function f2(e5) {
        return (n3) => {
          a3(n3 instanceof _ ? n3 : new _("Failed to connect to wallet", n3, e5));
        };
      }
      let g = { account: d, transaction: r4, chain: o9, signOnly: true, uiOptions: s2?.uiOptions || {}, onConfirm: l, onSuccess: e4, onFailure: f2(p.TRANSACTION_FAILURE) };
      t3({ connectWallet: { recoveryMethod: d.recoveryMethod, connectingWalletAddress: d.address, entropyId: u2, entropyIdVerifier: p3, isUnifiedWallet: m2, onCompleteNavigateTo: Qn, onFailure: f2(p.UNKNOWN_CONNECT_WALLET_ERROR) }, standardSignAndSendTransaction: g }), n2(qf);
    }));
  } };
}
var Gn = new class extends eventemitter3_default {
  setImplementation(e3) {
    He(this, qe)[qe] = e3;
  }
  async signMessage(e3) {
    return He(this, qe)[qe].signMessage(e3);
  }
  async signAndSendTransaction(e3) {
    return He(this, qe)[qe].signAndSendTransaction(e3);
  }
  async signTransaction(e3) {
    return He(this, qe)[qe].signTransaction(e3);
  }
  constructor(e3) {
    super(), Object.defineProperty(this, qe, { writable: true, value: void 0 }), He(this, qe)[qe] = e3;
  }
}({ signTransaction: a("signTransaction was not injected"), signAndSendTransaction: a("signAndSendTransaction was not injected"), signMessage: a("signMessage was not injected") });
var Zn = new class {
  get version() {
    return rn(this, ln)[ln];
  }
  get name() {
    return rn(this, dn)[dn];
  }
  get icon() {
    return rn(this, un)[un];
  }
  get chains() {
    return Je.slice();
  }
  get features() {
    return { "standard:connect": { version: "1.0.0", connect: rn(this, vn)[vn] }, "standard:disconnect": { version: "1.0.0", disconnect: rn(this, An)[An] }, "standard:events": { version: "1.0.0", on: rn(this, gn)[gn] }, "solana:signAndSendTransaction": { version: "1.0.0", supportedTransactionVersions: ["legacy", 0], signAndSendTransaction: rn(this, In)[In] }, "solana:signTransaction": { version: "1.0.0", supportedTransactionVersions: ["legacy", 0], signTransaction: rn(this, Tn)[Tn] }, "solana:signMessage": { version: "1.0.0", signMessage: rn(this, bn2)[bn2] }, "privy:": { privy: { signMessage: rn(this, pn)[pn].signMessage, signTransaction: rn(this, pn)[pn].signTransaction, signAndSendTransaction: rn(this, pn)[pn].signAndSendTransaction } } };
  }
  get accounts() {
    return rn(this, fn)[fn].slice();
  }
  get isPrivyWallet() {
    return rn(this, mn)[mn];
  }
  constructor({ name: e3, icon: n2, version: t3, injection: a2, wallets: i2 }) {
    Object.defineProperty(this, hn, { value: Sn }), Object.defineProperty(this, yn, { value: On }), Object.defineProperty(this, cn, { writable: true, value: void 0 }), Object.defineProperty(this, ln, { writable: true, value: void 0 }), Object.defineProperty(this, dn, { writable: true, value: void 0 }), Object.defineProperty(this, un, { writable: true, value: void 0 }), Object.defineProperty(this, pn, { writable: true, value: void 0 }), Object.defineProperty(this, mn, { writable: true, value: void 0 }), Object.defineProperty(this, fn, { writable: true, value: void 0 }), Object.defineProperty(this, gn, { writable: true, value: void 0 }), Object.defineProperty(this, wn, { writable: true, value: void 0 }), Object.defineProperty(this, vn, { writable: true, value: void 0 }), Object.defineProperty(this, An, { writable: true, value: void 0 }), Object.defineProperty(this, bn2, { writable: true, value: void 0 }), Object.defineProperty(this, In, { writable: true, value: void 0 }), Object.defineProperty(this, Tn, { writable: true, value: void 0 }), rn(this, cn)[cn] = {}, rn(this, gn)[gn] = (e4, n3) => (rn(this, cn)[cn][e4]?.push(n3) || (rn(this, cn)[cn][e4] = [n3]), () => rn(this, yn)[yn](e4, n3)), rn(this, wn)[wn] = (e4) => {
      null != e4 && (rn(this, fn)[fn] = e4.map((({ address: e5 }) => new an({ address: e5, publicKey: base58.decode(e5) })))), rn(this, hn)[hn]("change", { accounts: this.accounts });
    }, rn(this, vn)[vn] = async () => (rn(this, hn)[hn]("change", { accounts: this.accounts }), { accounts: this.accounts }), rn(this, An)[An] = async () => {
      rn(this, hn)[hn]("change", { accounts: this.accounts });
    }, rn(this, bn2)[bn2] = async (...e4) => {
      let n3 = [];
      for (let { account: t4, ...a3 } of e4) {
        let { signature: e5 } = await rn(this, pn)[pn].signMessage({ ...a3, address: t4.address });
        n3.push({ signedMessage: a3.message, signature: e5 });
      }
      return n3;
    }, rn(this, In)[In] = async (...e4) => {
      let n3 = [];
      for (let { transaction: t4, account: a3, options: i3, chain: r4 } of e4) {
        let { signature: e5 } = await rn(this, pn)[pn].signAndSendTransaction({ transaction: t4, address: a3.address, chain: r4 || "solana:mainnet", options: i3 });
        n3.push({ signature: e5 });
      }
      return n3;
    }, rn(this, Tn)[Tn] = async (...e4) => {
      let n3 = [];
      for (let { transaction: t4, account: a3, options: i3, chain: r4 } of e4) {
        let { signedTransaction: e5 } = await rn(this, pn)[pn].signTransaction({ transaction: t4, address: a3.address, chain: r4 || "solana:mainnet", options: i3 });
        n3.push({ signedTransaction: e5 });
      }
      return n3;
    }, rn(this, dn)[dn] = e3, rn(this, un)[un] = n2, rn(this, ln)[ln] = t3, rn(this, pn)[pn] = a2, rn(this, fn)[fn] = [], rn(this, mn)[mn] = true, a2.on("accountChanged", rn(this, wn)[wn], this), rn(this, wn)[wn](i2);
  }
}({ name: "Privy", version: "1.0.0", icon: "data:image/png;base64,AAABAAEAFBQAAAAAIABlAQAAFgAAAIlQTkcNChoKAAAADUlIRFIAAAAUAAAAFAgGAAAAjYkdDQAAAAlwSFlzAAAOwwAADsMBx2+oZAAAAQVJREFUeJxiYMANZIC4E4ivAPFPIP4FxDeAuB+IlfDowwBMQFwJxF+B+D8O/AOI66Bq8QJGIF6ExyB0vAqImfEZmEeCYTDcgMswPiB+T4aB34FYApuBsWQYBsP52AycToGBK7EZuJECAw9jM3AVBQbuwWZgIwUGTsZmoDkFBnpiMxAEjpJh2FV8iVsbiD+TYBgoDVrgMgwGnID4HRGGgTKBGyHDYEAaiBdCSxh0g/5AU4Q8sYYhAzEgjoGmABBOgFo2eACowFABYn0oVgViAVINkQTiZUD8DIj/ATF6GILEXgLxCiCWIsZAbiAuBeKtQHwHiEHJ6C8UfwHie0C8E4jLoWpRAAAAAP//rcbhsQAAAAZJREFUAwBYFs3VKJ0cuQAAAABJRU5ErkJggg==", wallets: [], injection: Gn });
function zn() {
  let { ready: e3 } = Nl(), { user: n2 } = q(), { signMessage: t3 } = Kn(), { signTransaction: a2 } = Yn(), { signAndSendTransaction: i2 } = (function() {
    let e4 = Pr(), { isHeadlessSigning: n3, openModal: t4 } = s(), { setModalData: a3 } = Or(), { signTransaction: i3 } = Yn(), r5 = Hn(), { user: s3 } = q();
    return { signAndSendTransaction: async ({ transaction: o9, address: c, chain: l = "solana:mainnet", options: d }) => {
      async function u2(e5) {
        let { signedTransaction: n4 } = await i3({ transaction: e5, address: c, chain: l, options: { ...d, uiOptions: { ...d?.uiOptions, showWalletUIs: false } } }), { signature: t5 } = await r5(l).sendAndConfirmTransaction(n4);
        return { signature: t5 };
      }
      return n3({ showWalletUIs: d?.uiOptions?.showWalletUIs }) ? u2(o9) : new Promise((async (n4, i4) => {
        let r6, p3, m2 = f(s3, c);
        if ("privy" !== m2?.walletClientType) return void i4(new _("Wallet is not a Privy wallet", void 0, p.EMBEDDED_WALLET_NOT_FOUND));
        let { entropyId: f2, entropyIdVerifier: g } = Ra(s3, m2), h = b(m2);
        function y2(e5) {
          return (n5) => {
            i4(n5 instanceof _ ? n5 : new _("Failed to connect to wallet", n5, e5));
          };
        }
        let w = { account: m2, transaction: o9, chain: l, signOnly: false, uiOptions: d?.uiOptions || {}, onConfirm: u2, onSuccess: n4, onFailure: y2(p.TRANSACTION_FAILURE) }, v2 = { recoveryMethod: m2.recoveryMethod, connectingWalletAddress: m2.address, entropyId: f2, entropyIdVerifier: g, isUnifiedWallet: h, onCompleteNavigateTo: Qn, onFailure: y2(p.UNKNOWN_CONNECT_WALLET_ERROR) };
        e4.fundingConfig && (r6 = I({ address: c, appConfig: e4, methodScreen: vm, fundWalletConfig: { ...d, asset: "native-currency", chain: l }, externalSolanaFundingScreen: rt }), p3 = { amount: e4.fundingConfig.defaultRecommendedAmount, asset: "SOL", chain: l, destinationAddress: c, afterSuccessScreen: Qn, sourceWalletData: void 0 }), a3({ connectWallet: v2, standardSignAndSendTransaction: w, funding: r6, solanaFundingData: p3 }), t4(qf);
      }));
    } };
  })(), r4 = (0, import_react.useMemo)((() => {
    let e4 = [...u(n2).sort(((e5, n3) => (e5.walletIndex ?? 0) - (n3.walletIndex ?? 0)))], t4 = m(n2);
    return t4 ? [...e4, t4] : e4;
  }), [n2]), s2 = (0, import_react.useMemo)((() => ({ signMessage: async ({ message: e4, address: n3, options: a3 }) => await t3({ message: e4, address: n3, options: a3 }), signTransaction: async ({ transaction: e4, address: n3, chain: t4, options: i3 }) => await a2({ transaction: e4, address: n3, chain: t4, options: i3 }), async signAndSendTransaction({ transaction: e4, address: n3, chain: t4, options: a3 }) {
    let { signature: r5 } = await i2({ transaction: e4, address: n3, chain: t4, options: a3 });
    return { signature: r5 };
  } })), [t3, a2, i2]);
  return (0, import_react.useEffect)((() => {
    Gn?.setImplementation(s2);
  }), [s2]), (0, import_react.useEffect)((() => {
    var n3;
    !e3 || (n3 = Zn.accounts).length === r4.length && n3.every(((e4, n4) => e4.address === r4[n4]?.address)) || Gn?.emit("accountChanged", r4);
  }), [e3, r4]), { ready: e3, wallet: Zn };
}
function Xn() {
  let { ready: e3, wallets: n2 } = (function() {
    let { client: e4 } = s(), { ready: n3, wallet: t3 } = zn(), [a2, i2] = (0, import_react.useState)([]), [r4, s2] = (0, import_react.useState)([]);
    return (0, import_react.useEffect)((() => {
      let e5 = [t3, ...a2.filter(((e6) => "solana" === e6.chainType && !!e6.wallet.features)).map(((e6) => e6.wallet))];
      s2(e5);
      let n4 = e5.map(((n5) => n5.features["standard:events"]?.on("change", (() => {
        s2([...e5]);
      }))));
      return () => {
        n4.forEach(((e6) => e6?.()));
      };
    }), [a2]), (0, import_react.useEffect)((() => {
      if (!n3) return;
      i2(e4.connectors?.walletConnectors.filter(((e5) => "solana" === e5.chainType)) ?? []);
      let t4 = () => {
        i2(e4.connectors?.walletConnectors.filter(((e5) => "solana" === e5.chainType)) ?? []);
      };
      return e4.connectors?.on("connectorInitialized", t4), () => {
        e4.connectors?.off("connectorInitialized", t4);
      };
    }), [n3, e4.connectors]), { ready: n3, wallets: r4 };
  })();
  return { ready: e3, wallets: (0, import_react.useMemo)((() => n2.flatMap(((e4) => e4.accounts.map(((n3) => new r2({ wallet: e4, account: n3 })))))), [n2]) };
}
function et(e3) {
  return getBase58Decoder().decode(e3);
}
function nt(e3) {
  return BigInt(Math.floor(1e9 * parseFloat(e3)));
}
function tt(e3) {
  return +at.format(parseFloat(e3.toString()) / 1e9);
}
var at = Intl.NumberFormat(void 0, { maximumFractionDigits: 8 });
async function it({ tx: e3, solanaClient: n2, amount: t3, asset: a2, tokenPrice: i2 }) {
  if (!e3) return null;
  if ("SOL" === a2 && i2) {
    let a3 = nt(t3), r4 = Lo(a3, i2), s2 = await Mn({ solanaClient: n2, tx: e3 });
    return { amountInUsd: r4, feeInUsd: i2 ? Lo(s2, i2) : void 0, totalInUsd: Lo(a3 + s2, i2) };
  }
  if ("USDC" === a2 && i2) {
    let a3 = "$" + t3, r4 = await Mn({ solanaClient: n2, tx: e3 }), s2 = (function(e4, n3) {
      let t4 = parseFloat(e4.toString()) / Ao * n3;
      return t4 < 0.01 ? 0 : t4;
    })(r4, i2);
    return { amountInUsd: a3, feeInUsd: Lo(r4, i2), totalInUsd: "$" + (parseFloat(t3) + s2).toFixed(2) };
  }
  if ("SOL" === a2) {
    let a3 = nt(t3), i3 = await Mn({ solanaClient: n2, tx: e3 });
    return { amountInSol: t3 + " SOL", feeInSol: tt(i3) + " SOL", totalInSol: tt(a3 + i3) + " SOL" };
  }
  return { amountInUsdc: t3 + " USDC", feeInSol: tt(await Mn({ solanaClient: n2, tx: e3 })) + " SOL" };
}
var rt = { component: function() {
  let e3 = Pr(), { closePrivyModal: n2, createAnalyticsEvent: t3 } = s(), { data: a2, setModalData: i2, navigate: r4 } = Or(), { wallets: s2 } = Xn(), [o9, l] = (0, import_react.useState)("preparing"), [m2, g] = (0, import_react.useState)(), [h, y2] = (0, import_react.useState)(), [w, v2] = (0, import_react.useState)();
  if (!a2?.solanaFundingData) throw Error("Funding config is missing");
  if (!a2.solanaFundingData.sourceWalletData) throw Error("Funding config is missing source wallet data");
  let { amount: I2, asset: T, chain: S, sourceWalletData: O, destinationAddress: k, afterSuccessScreen: E } = a2.solanaFundingData, x = s2.find(((e4) => e4.address === O.address && dr(O.walletClientType) === dr(e4.standardWallet.name))), F = Hn()(S), { tokenPrice: _2, isTokenPriceLoading: P2 } = Sl("solana");
  return (0, import_react.useEffect)((() => {
    if ("preparing" !== o9 || P2 || !x) return;
    let e4 = "SOL" === T ? nt(I2) : (function(e5) {
      return BigInt(Math.floor(1e6 * parseFloat(e5)));
    })(I2);
    y2({ amount: ("SOL" === T && _2 ? Lo(e4, _2) : I2) ?? I2 }), ("SOL" === T ? (async function({ solanaClient: e5, source: n3, destination: t4, amountInLamports: a3 }) {
      let { value: i3 } = await e5.rpc.getLatestBlockhash().send(), r5 = { address: n3 }, s3 = pipe(createTransactionMessage({ version: 0 }), ((e6) => setTransactionMessageFeePayerSigner(r5, e6)), ((e6) => setTransactionMessageLifetimeUsingBlockhash(i3, e6)), ((e6) => appendTransactionMessageInstruction(getTransferSolInstruction({ amount: a3, source: r5, destination: t4 }), e6)), ((e6) => compileTransaction(e6)));
      return new Uint8Array(getTransactionEncoder().encode(s3));
    })({ solanaClient: F, source: x.address, destination: k, amountInLamports: e4 }) : (async function({ solanaClient: e5, source: n3, destination: t4, amountInBaseUnits: a3 }) {
      let i3 = eg(e5.chain), { value: r5 } = await e5.rpc.getLatestBlockhash().send(), s3 = { address: n3 }, [o10] = await findAssociatedTokenPda({ mint: i3, owner: n3, tokenProgram: So }), [c] = await findAssociatedTokenPda({ mint: i3, owner: t4, tokenProgram: So }), [l2, d] = await Promise.all([e5.rpc.getAccountInfo(o10, { commitment: "confirmed", encoding: "jsonParsed" }).send().catch((() => null)), e5.rpc.getAccountInfo(c, { commitment: "confirmed", encoding: "jsonParsed" }).send().catch((() => null))]);
      if (!l2?.value) throw Error(`Source token account does not exist for address: ${n3}`);
      let u2 = getCreateAssociatedTokenIdempotentInstruction({ payer: s3, ata: c, owner: t4, mint: i3 }), p3 = pipe(createTransactionMessage({ version: 0 }), ((e6) => setTransactionMessageFeePayerSigner(s3, e6)), ((e6) => setTransactionMessageLifetimeUsingBlockhash(r5, e6)), ((e6) => d?.value ? e6 : appendTransactionMessageInstruction(u2, e6)), ((e6) => appendTransactionMessageInstruction(getTransferInstruction({ source: o10, destination: c, authority: s3, amount: a3 }), e6)), ((e6) => compileTransaction(e6)));
      return new Uint8Array(getTransactionEncoder().encode(p3));
    })({ solanaClient: F, source: x.address, destination: k, amountInBaseUnits: e4 })).then(g).catch(((e5) => {
      l("error"), v2(e5);
    }));
  }), [o9, I2, T, S, x, k, P2, _2]), (0, import_react.useEffect)((() => {
    "preparing" === o9 && m2 && it({ tx: m2, solanaClient: F, amount: I2, asset: T, tokenPrice: _2 }).then(((e4) => {
      l("loaded"), y2({ amount: e4?.amountInUsd ?? e4?.amountInUsdc ?? e4?.amountInSol ?? I2, fee: e4?.feeInUsd ?? e4?.feeInSol, total: e4?.totalInUsd ?? e4?.totalInSol });
    })).catch(((e4) => {
      l("error"), v2(e4);
    }));
  }), [m2, I2, T, o9, _2]), (0, import_react.useEffect)((() => {
    "error" === o9 && w && (i2({ errorModalData: { error: w, previousScreen: rt }, solanaFundingData: a2.solanaFundingData }), r4(zc, false));
  }), [o9, r4]), (0, import_react.useEffect)((() => {
    if ("success" !== o9) return;
    let e4 = setTimeout(E ? () => r4(E) : n2, bn);
    return () => clearTimeout(e4);
  }), [o9]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, "success" === o9 ? { children: [(0, import_jsx_runtime.jsx)(Df, {}), (0, import_jsx_runtime.jsx)(Ko, {}), (0, import_jsx_runtime.jsxs)(Go, { children: [(0, import_jsx_runtime.jsx)(CheckCircleIcon_default, { color: "var(--privy-color-success)", width: "64px", height: "64px" }), (0, import_jsx_runtime.jsx)(Vl, { title: "Success!", description: `Youve successfully added ${I2} ${T} to your ${e3.name} wallet. It may take a minute before the funds are available to use.` })] }), (0, import_jsx_runtime.jsx)(Xo, {}), (0, import_jsx_runtime.jsx)(ci, {})] } : "preparing" === o9 || "loaded" === o9 || "sending" === o9 ? { children: [(0, import_jsx_runtime.jsx)(Df, {}), (0, import_jsx_runtime.jsx)(Vo, { style: { marginTop: "16px" }, children: (0, import_jsx_runtime.jsx)(Ku, { icon: x?.standardWallet.icon, name: x?.standardWallet.name }) }), (0, import_jsx_runtime.jsx)(Vl, { style: { marginTop: "8px", marginBottom: "12px" }, title: "sending" === o9 && x ? `Confirming with ${x.standardWallet.name}` : "Confirm transaction" }), (0, import_jsx_runtime.jsx)(Ve, { rows: [{ label: "Source", value: n(O.address) }, { label: "Destination", value: n(k) }, { label: "Network", value: Jh(S) }, { label: "Amount", value: h?.amount, isLoading: "preparing" === o9 }, { label: "Estimated fee", value: h?.fee, isLoading: "preparing" === o9 }, { label: "Total", value: h?.total, isLoading: "preparing" === o9 }] }), (0, import_jsx_runtime.jsx)(Ci, { style: { marginTop: "1rem" }, loading: "preparing" === o9 || "sending" === o9, onClick: function() {
    "loaded" === o9 && m2 && x && (l("sending"), (async function({ transaction: e4, chain: n3, sourceWallet: t4, solanaClient: a3 }) {
      let { hasFunds: i3 } = await jn({ solanaClient: a3, tx: e4 });
      if (!i3) throw new _(`Wallet ${n(t4.address)} does not have enough funds.`, void 0, p.INSUFFICIENT_BALANCE);
      let r5 = et((await t4.signAndSendTransaction({ transaction: e4, chain: n3 }).catch(((e5) => {
        throw new _("Transaction was rejected by the user", e5, p.TRANSACTION_FAILURE);
      }))).signature);
      return await Vn({ rpcSubscriptions: a3.rpcSubscriptions, signature: r5, timeout: 2e4 }), r5;
    })({ solanaClient: F, transaction: m2, chain: S, sourceWallet: x }).then(((e4) => {
      l("success"), t3({ eventName: Kh, payload: { provider: "external", status: "success", txHash: e4, address: x.address, value: I2, chainType: "solana", clusterName: S, token: T, destinationAddress: k, destinationValue: I2, destinationChainType: "solana", destinationClusterName: S, destinationToken: T } });
    })).catch(((e4) => {
      l("error"), v2(e4);
    })));
  }, children: "Confirm" }), (0, import_jsx_runtime.jsx)(ci, {})] } : { children: [(0, import_jsx_runtime.jsx)(Df, {}), (0, import_jsx_runtime.jsx)(zi, {}), (0, import_jsx_runtime.jsx)("div", { style: { marginTop: "1rem" } }), (0, import_jsx_runtime.jsx)(ci, {})] });
} };
function st() {
  let e3 = Pr(), { openModal: n2 } = s(), { setModalData: t3 } = Or();
  return { fundWallet: async ({ address: a2, options: i2 }) => {
    let r4 = i2?.amount || e3.fundingConfig?.defaultRecommendedAmount || "1", s2 = i2?.asset || e3.fundingConfig?.defaultRecommendedCurrency.asset || "native-currency", o9 = i2?.chain || "solana:mainnet";
    t3({ funding: I({ address: a2, appConfig: e3, methodScreen: vm, fundWalletConfig: { ...i2, amount: r4, asset: s2, chain: o9 }, externalSolanaFundingScreen: rt }), solanaFundingData: { amount: r4, asset: "native-currency" === s2 ? "SOL" : "USDC", chain: o9, destinationAddress: a2, sourceWalletData: void 0 } }), n2(vm);
  } };
}
function ot() {
  let { user: e3, getAccessToken: n2 } = v(), { walletProxy: t3, openModal: a2, client: i2 } = s(), { setModalData: r4 } = Or(), s2 = Pr();
  return (0, import_react.useMemo)((() => ({ exportWallet: (o9) => new Promise((async (c, l) => {
    if (!e3) return void l(new _("User must be authenticated before exporting their Privy wallet"));
    let d = o9?.address ? f(e3, o9.address) : p2(e3);
    if (!d) return void l(new _("User must have an embedded wallet."));
    if (!M(d)) return void l(Error(`Export is not supported for ${d.chainType} wallets`));
    let u2 = b(d), { entropyId: p3, entropyIdVerifier: m2 } = Ra(e3, d);
    await n2() ? t3 ? (r4({ connectWallet: { recoveryMethod: d.recoveryMethod, connectingWalletAddress: d.address, isUnifiedWallet: u2, entropyId: p3, entropyIdVerifier: m2, onCompleteNavigateTo: Hf, onFailure: l, shouldForceMFA: true }, keyExport: { appId: s2.id, appClientId: s2.appClientId, origin: i2.apiUrl, address: d.address, entropyId: p3, entropyIdVerifier: m2, hdWalletIndex: d.walletIndex, chainType: d.chainType, walletId: d.id, isUnifiedWallet: u2, imported: d.imported, onSuccess: c, onFailure: l } }), a2(qf)) : l(new _("Wallet not ready for export")) : l(new _("Must have valid access token."));
  })) })), [e3, n2, t3, a2, i2, r4, s2]);
}

// node_modules/@solana-program/memo/dist/src/index.mjs
init_shim();
var MEMO_PROGRAM_ADDRESS = "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr";
var MemoInstruction = ((MemoInstruction2) => {
  MemoInstruction2[MemoInstruction2["AddMemo"] = 0] = "AddMemo";
  return MemoInstruction2;
})(MemoInstruction || {});
function getAddMemoInstructionDataEncoder() {
  return getStructEncoder([["memo", getUtf8Encoder()]]);
}
function getAddMemoInstruction(input, config) {
  const programAddress = config?.programAddress ?? MEMO_PROGRAM_ADDRESS;
  const args = { ...input };
  const remainingAccounts = (args.signers ?? []).map(
    (signer) => ({
      address: signer.address,
      role: AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const instruction = {
    accounts: remainingAccounts,
    programAddress,
    data: getAddMemoInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}

// node_modules/@wallet-standard/app/lib/esm/index.js
init_shim();

// node_modules/@wallet-standard/app/lib/esm/wallets.js
init_shim();
var __classPrivateFieldGet = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var _AppReadyEvent_detail;
var wallets = void 0;
var registeredWalletsSet = /* @__PURE__ */ new Set();
function addRegisteredWallet(wallet) {
  cachedWalletsArray = void 0;
  registeredWalletsSet.add(wallet);
}
function removeRegisteredWallet(wallet) {
  cachedWalletsArray = void 0;
  registeredWalletsSet.delete(wallet);
}
var listeners = {};
function getWallets() {
  if (wallets)
    return wallets;
  wallets = Object.freeze({ register, get, on: on2 });
  if (typeof window === "undefined")
    return wallets;
  const api = Object.freeze({ register });
  try {
    window.addEventListener("wallet-standard:register-wallet", ({ detail: callback }) => callback(api));
  } catch (error) {
    console.error("wallet-standard:register-wallet event listener could not be added\n", error);
  }
  try {
    window.dispatchEvent(new AppReadyEvent(api));
  } catch (error) {
    console.error("wallet-standard:app-ready event could not be dispatched\n", error);
  }
  return wallets;
}
function register(...wallets2) {
  wallets2 = wallets2.filter((wallet) => !registeredWalletsSet.has(wallet));
  if (!wallets2.length)
    return () => {
    };
  wallets2.forEach((wallet) => addRegisteredWallet(wallet));
  listeners["register"]?.forEach((listener) => guard(() => listener(...wallets2)));
  return function unregister() {
    wallets2.forEach((wallet) => removeRegisteredWallet(wallet));
    listeners["unregister"]?.forEach((listener) => guard(() => listener(...wallets2)));
  };
}
var cachedWalletsArray;
function get() {
  if (!cachedWalletsArray) {
    cachedWalletsArray = [...registeredWalletsSet];
  }
  return cachedWalletsArray;
}
function on2(event, listener) {
  listeners[event]?.push(listener) || (listeners[event] = [listener]);
  return function off() {
    listeners[event] = listeners[event]?.filter((existingListener) => listener !== existingListener);
  };
}
function guard(callback) {
  try {
    callback();
  } catch (error) {
    console.error(error);
  }
}
var AppReadyEvent = class extends Event {
  get detail() {
    return __classPrivateFieldGet(this, _AppReadyEvent_detail, "f");
  }
  get type() {
    return "wallet-standard:app-ready";
  }
  constructor(api) {
    super("wallet-standard:app-ready", {
      bubbles: false,
      cancelable: false,
      composed: false
    });
    _AppReadyEvent_detail.set(this, void 0);
    __classPrivateFieldSet(this, _AppReadyEvent_detail, api, "f");
  }
  /** @deprecated */
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  /** @deprecated */
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  /** @deprecated */
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
};
_AppReadyEvent_detail = /* @__PURE__ */ new WeakMap();

// node_modules/@privy-io/react-auth/dist/esm/solana.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react_device_detect = __toESM(require_lib(), 1);
var import_fast_password_entropy = __toESM(require_es5(), 1);
var import_qrcode = __toESM(require_browser(), 1);
var M2 = (o9) => {
  let e3, { get: r4, on: n2 } = getWallets(), i2 = o9?.shouldAutoConnect ?? true, a2 = /* @__PURE__ */ new Map(), s2 = [];
  function c(...o10) {
    o10.forEach(((o11) => !(o11.features["privy:"] && "isPrivyWallet" in o11 && o11.isPrivyWallet) && !a2.has(o11.name) && a2.set(o11.name, o11))), s2 = Array.from(a2.values()).map(((o11) => new pr(o11, i2))), e3?.(s2);
  }
  function l(...o10) {
    Array.from(a2.values()).forEach(((e4) => !o10.includes(e4) && a2.delete(e4.name))), s2 = Array.from(a2.values()).map(((o11) => new pr(o11, i2))), e3?.(s2);
  }
  let m2 = [n2("register", c), n2("unregister", l)];
  return c(...r4()), { _setOnConnectorsUpdated: (o10) => {
    e3 = o10;
  }, onMount: () => {
    m2[0] || (m2[0] = n2("register", c)), m2[1] || (m2[1] = n2("unregister", l));
  }, onUnmount: () => {
    let o10 = m2.pop();
    for (; o10; ) o10(), o10 = m2.pop();
  }, get: () => s2 };
};
var U = () => {
  let { user: r4 } = v(), { client: t3, refreshSessionAndUser: a2, initializeWalletProxy: s2 } = s(), c = Zr(), l = Pr();
  return { importWallet: (0, import_react2.useCallback)((({ privateKey: o9 }) => z({ getAccessToken: () => t3.getAccessToken(), user: r4, initializeWalletProxy: s2, refreshSessionAndUser: a2, emitPrivyEvent: c, appConfig: l }, { privateKey: o9, chainType: "solana" })), [r4, t3, a2, s2, c]) };
};
var D2 = { id: Zg, getSolanaRpcClient: Jn, createTransactionFromRelayQuote: async function({ solanaClient: o9, quote: e3, source: r4 }) {
  let t3 = e3.steps[0]?.items?.[0];
  if (!t3) throw Error("Invalid quote");
  let n2 = t3.data.instructions.map((({ keys: o10, programId: e4, data: r5 }) => ({ accounts: o10.map((({ pubkey: o11, isSigner: e5, isWritable: r6 }) => ({ address: o11, role: e5 && r6 ? 3 : e5 && !r6 ? 2 : !e5 && r6 ? 1 : 0 }))), programAddress: e4, data: new Uint8Array(import_buffer.Buffer.from(r5, "hex")) }))), { value: i2 } = await o9.rpc.getLatestBlockhash().send(), a2 = pipe(createTransactionMessage({ version: 0 }), ((o10) => setTransactionMessageFeePayerSigner({ address: r4 }, o10)), ((o10) => setTransactionMessageLifetimeUsingBlockhash(i2, o10)), ((o10) => appendTransactionMessageInstructions(n2, o10)), ((o10) => compileTransaction(o10)));
  return new Uint8Array(getTransactionEncoder().encode(a2));
}, simulateTransaction: jn, getAddressFromBuffer: et, fetchTransactionEstimatedFees: Mn };
var R = () => cp(D2);
var q2 = { id: pp, createSiwsMemoTransaction: ({ address: o9, nonce: e3 }) => {
  let r4 = getAddMemoInstruction({ memo: la({ address: address(o9), nonce: e3 }) });
  return pipe(createTransactionMessage({ version: "legacy" }), ((e4) => setTransactionMessageFeePayer(address(o9), e4)), ((o10) => setTransactionMessageLifetimeUsingBlockhash({ blockhash: blockhash("GfVcyD5fWFJ6hRm8bsy7CoVPsLSoJhtJKRJYk8T2VVFN"), lastValidBlockHeight: 0n }, o10)), ((o10) => appendTransactionMessageInstructions([r4], o10)), ((o10) => compileTransaction(o10)), ((o10) => base64.encode(Uint8Array.from(getTransactionEncoder().encode(o10)))));
}, getSignatureFromTransaction: (o9, e3) => {
  let r4 = getTransactionDecoder().decode(o9).signatures[e3];
  if (!r4) throw Error(`Missing transaction signature for address: ${e3}`);
  return base64.encode(r4);
} };
var z3 = () => cp(q2);
function L2() {
  let { create: o9 } = L();
  return { createWallet: async (e3) => {
    e3 && "target" in e3 && e3 && (e3 = void 0);
    let { account: r4 } = await o9({ chainType: "solana", options: e3 });
    return { wallet: r4 };
  } };
}
function V() {
  return { signMessage: async ({ message: o9, wallet: e3, options: r4 }) => await e3.signMessage({ message: o9, options: r4 }) };
}
function B() {
  return { signTransaction: async ({ transaction: o9, wallet: e3, chain: r4 = "solana:mainnet", options: t3 }) => await e3.signTransaction({ transaction: o9, chain: r4, options: t3 }) };
}
function J() {
  return { signAndSendTransaction: async ({ transaction: o9, wallet: e3, chain: r4 = "solana:mainnet", options: t3 }) => await e3.signAndSendTransaction({ transaction: o9, chain: r4, options: t3 }) };
}
export {
  pr as SolanaAdapterConnector,
  M2 as toSolanaWalletConnectors,
  L2 as useCreateWallet,
  ot as useExportWallet,
  st as useFundWallet,
  U as useImportWallet,
  J as useSignAndSendTransaction,
  V as useSignMessage,
  B as useSignTransaction,
  R as useSolanaFundingPlugin,
  z3 as useSolanaLedgerPlugin,
  Xn as useWallets
};
//# sourceMappingURL=@privy-io_react-auth_solana.js.map
