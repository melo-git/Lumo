{
  "version": 3,
  "sources": ["../../gill/node_modules/@solana/errors/src/codes.ts", "../../gill/node_modules/@solana/errors/src/context.ts", "../../gill/node_modules/@solana/errors/src/messages.ts", "../../gill/node_modules/@solana/errors/src/message-formatter.ts", "../../gill/node_modules/@solana/errors/src/error.ts", "../../gill/node_modules/@solana/errors/src/stack-trace.ts", "../../gill/node_modules/@solana/errors/src/rpc-enum-errors.ts", "../../gill/node_modules/@solana/errors/src/instruction-error.ts", "../../gill/node_modules/@solana/errors/src/transaction-error.ts", "../../gill/node_modules/@solana/errors/src/json-rpc-error.ts", "../../gill/node_modules/@solana/codecs-core/src/bytes.ts", "../../gill/node_modules/@solana/codecs-core/src/codec.ts", "../../gill/node_modules/@solana/codecs-core/src/combine-codec.ts", "../../gill/node_modules/@solana/codecs-core/src/add-codec-sentinel.ts", "../../gill/node_modules/@solana/codecs-core/src/assertions.ts", "../../gill/node_modules/@solana/codecs-core/src/add-codec-size-prefix.ts", "../../gill/node_modules/@solana/codecs-core/src/fix-codec-size.ts", "../../gill/node_modules/@solana/codecs-core/src/offset-codec.ts", "../../gill/node_modules/@solana/codecs-core/src/resize-codec.ts", "../../gill/node_modules/@solana/codecs-core/src/pad-codec.ts", "../../gill/node_modules/@solana/codecs-core/src/reverse-codec.ts", "../../gill/node_modules/@solana/codecs-core/src/transform-codec.ts", "../../gill/node_modules/@solana/codecs-strings/src/assertions.ts", "../../gill/node_modules/@solana/codecs-strings/src/baseX.ts", "../../gill/node_modules/@solana/codecs-strings/src/base10.ts", "../../gill/node_modules/@solana/codecs-strings/src/base16.ts", "../../gill/node_modules/@solana/codecs-strings/src/base58.ts", "../../gill/node_modules/@solana/codecs-strings/src/baseX-reslice.ts", "../../gill/node_modules/@solana/codecs-strings/src/base64.ts", "../../gill/node_modules/@solana/codecs-strings/src/null-characters.ts", "../../gill/node_modules/@solana/text-encoding-impl/src/index.browser.ts", "../../gill/node_modules/@solana/codecs-strings/src/utf8.ts", "../../gill/node_modules/@solana/accounts/src/account.ts", "../../gill/node_modules/@solana/accounts/src/decode-account.ts", "../../gill/node_modules/@solana/accounts/src/parse-account.ts", "../../gill/node_modules/@solana/accounts/src/fetch-account.ts", "../../gill/node_modules/@solana/accounts/src/maybe-account.ts", "../../gill/node_modules/@solana/assertions/src/crypto.ts", "../../gill/node_modules/@solana/assertions/src/subtle-crypto.ts", "../../gill/node_modules/@solana/addresses/src/address.ts", "../../gill/node_modules/@solana/addresses/src/vendor/noble/ed25519.ts", "../../gill/node_modules/@solana/addresses/src/curve-internal.ts", "../../gill/node_modules/@solana/addresses/src/curve.ts", "../../gill/node_modules/@solana/addresses/src/program-derived-address.ts", "../../gill/node_modules/@solana/addresses/src/public-key.ts", "../../gill/node_modules/@solana/codecs/dist/index.browser.mjs", "../../gill/node_modules/@solana/codecs-numbers/src/assertions.ts", "../../gill/node_modules/@solana/codecs-numbers/src/common.ts", "../../gill/node_modules/@solana/codecs-numbers/src/utils.ts", "../../gill/node_modules/@solana/codecs-numbers/src/f32.ts", "../../gill/node_modules/@solana/codecs-numbers/src/f64.ts", "../../gill/node_modules/@solana/codecs-numbers/src/i128.ts", "../../gill/node_modules/@solana/codecs-numbers/src/i16.ts", "../../gill/node_modules/@solana/codecs-numbers/src/i32.ts", "../../gill/node_modules/@solana/codecs-numbers/src/i64.ts", "../../gill/node_modules/@solana/codecs-numbers/src/i8.ts", "../../gill/node_modules/@solana/codecs-numbers/src/short-u16.ts", "../../gill/node_modules/@solana/codecs-numbers/src/u128.ts", "../../gill/node_modules/@solana/codecs-numbers/src/u16.ts", "../../gill/node_modules/@solana/codecs-numbers/src/u32.ts", "../../gill/node_modules/@solana/codecs-numbers/src/u64.ts", "../../gill/node_modules/@solana/codecs-numbers/src/u8.ts", "../../gill/node_modules/@solana/codecs-data-structures/src/assertions.ts", "../../gill/node_modules/@solana/codecs-data-structures/src/utils.ts", "../../gill/node_modules/@solana/codecs-data-structures/src/array.ts", "../../gill/node_modules/@solana/codecs-data-structures/src/bit-array.ts", "../../gill/node_modules/@solana/codecs-data-structures/src/boolean.ts", "../../gill/node_modules/@solana/codecs-data-structures/src/bytes.ts", "../../gill/node_modules/@solana/codecs-strings/src/base16.ts", "../../gill/node_modules/@solana/codecs-data-structures/src/constant.ts", "../../gill/node_modules/@solana/codecs-data-structures/src/tuple.ts", "../../gill/node_modules/@solana/codecs-data-structures/src/union.ts", "../../gill/node_modules/@solana/codecs-data-structures/src/discriminated-union.ts", "../../gill/node_modules/@solana/codecs-data-structures/src/enum-helpers.ts", "../../gill/node_modules/@solana/codecs-data-structures/src/enum.ts", "../../gill/node_modules/@solana/codecs-data-structures/src/hidden-prefix.ts", "../../gill/node_modules/@solana/codecs-data-structures/src/hidden-suffix.ts", "../../gill/node_modules/@solana/codecs-data-structures/src/literal-union.ts", "../../gill/node_modules/@solana/codecs-data-structures/src/map.ts", "../../gill/node_modules/@solana/codecs-data-structures/src/unit.ts", "../../gill/node_modules/@solana/codecs-data-structures/src/nullable.ts", "../../gill/node_modules/@solana/codecs-data-structures/src/set.ts", "../../gill/node_modules/@solana/codecs-data-structures/src/struct.ts", "../../gill/node_modules/@solana/options/src/option.ts", "../../gill/node_modules/@solana/options/src/unwrap-option.ts", "../../gill/node_modules/@solana/options/src/option-codec.ts", "../../gill/node_modules/@solana/options/src/unwrap-option-recursively.ts", "../../gill/node_modules/@solana/functional/src/pipe.ts", "../../gill/node_modules/@solana/instructions/src/instruction.ts", "../../gill/node_modules/@solana/instructions/src/roles.ts", "../../gill/node_modules/@solana/keys/src/algorithm.ts", "../../gill/node_modules/@solana/keys/src/private-key.ts", "../../gill/node_modules/@solana/keys/src/public-key.ts", "../../gill/node_modules/@solana/keys/src/signatures.ts", "../../gill/node_modules/@solana/keys/src/key-pair.ts", "../../gill/node_modules/@solana/programs/src/program-error.ts", "../../gill/node_modules/@solana/rpc-spec-types/src/parse-json-with-bigints.ts", "../../gill/node_modules/@solana/rpc-spec-types/src/rpc-message.ts", "../../gill/node_modules/@solana/rpc-spec-types/src/stringify-json-with-bigints.ts", "../../gill/node_modules/@solana/rpc-spec/src/rpc.ts", "../../gill/node_modules/@solana/rpc-spec/src/rpc-api.ts", "../../gill/node_modules/@solana/rpc-spec/src/rpc-transport.ts", "../../gill/node_modules/@solana/rpc-transformers/src/request-transformer-bigint-downcast-internal.ts", "../../gill/node_modules/@solana/rpc-transformers/src/tree-traversal.ts", "../../gill/node_modules/@solana/rpc-transformers/src/request-transformer-bigint-downcast.ts", "../../gill/node_modules/@solana/rpc-transformers/src/request-transformer-default-commitment-internal.ts", "../../gill/node_modules/@solana/rpc-transformers/src/request-transformer-default-commitment.ts", "../../gill/node_modules/@solana/rpc-transformers/src/request-transformer-integer-overflow-internal.ts", "../../gill/node_modules/@solana/rpc-transformers/src/request-transformer-integer-overflow.ts", "../../gill/node_modules/@solana/rpc-transformers/src/request-transformer-options-object-position-config.ts", "../../gill/node_modules/@solana/rpc-transformers/src/request-transformer.ts", "../../gill/node_modules/@solana/rpc-transformers/src/response-transformer-bigint-upcast-internal.ts", "../../gill/node_modules/@solana/rpc-transformers/src/response-transformer-bigint-upcast.ts", "../../gill/node_modules/@solana/rpc-transformers/src/response-transformer-result.ts", "../../gill/node_modules/@solana/rpc-transformers/src/response-transformer-throw-solana-error.ts", "../../gill/node_modules/@solana/rpc-transformers/src/response-transformer.ts", "../../gill/node_modules/@solana/rpc-transformers/src/response-transformer-allowed-numeric-values.ts", "../../gill/node_modules/@solana/rpc-api/src/index.ts", "../../gill/node_modules/@solana/rpc-transport-http/src/http-transport-headers.ts", "../../gill/node_modules/@solana/rpc-transport-http/src/http-transport.ts", "../../gill/node_modules/@solana/rpc-transport-http/src/is-solana-request.ts", "../../gill/node_modules/@solana/rpc-transport-http/src/http-transport-for-solana-rpc.ts", "../../gill/node_modules/@solana/fast-stable-stringify/src/index.ts", "../../gill/node_modules/@solana/rpc/src/rpc-integer-overflow-error.ts", "../../gill/node_modules/@solana/rpc/src/rpc-default-config.ts", "../../gill/node_modules/@solana/event-target-impl/src/index.browser.ts", "../../gill/node_modules/@solana/rpc/src/rpc-request-coalescer.ts", "../../gill/node_modules/@solana/rpc/src/rpc-request-deduplication.ts", "../../gill/node_modules/@solana/rpc/src/rpc-transport.ts", "../../gill/node_modules/@solana/rpc/src/rpc.ts", "../../gill/node_modules/@solana/rpc-parsed-types/dist/index.browser.mjs", "../../gill/node_modules/@solana/event-target-impl/src/index.browser.ts", "../../gill/node_modules/@solana/subscribable/src/async-iterable.ts", "../../gill/node_modules/@solana/subscribable/src/data-publisher.ts", "../../gill/node_modules/@solana/subscribable/src/demultiplex.ts", "../../gill/node_modules/@solana/promises/src/race.ts", "../../gill/node_modules/@solana/promises/src/abortable.ts", "../../gill/node_modules/@solana/rpc-subscriptions-spec/src/rpc-subscriptions.ts", "../../gill/node_modules/@solana/rpc-subscriptions-spec/src/rpc-subscriptions-api.ts", "../../gill/node_modules/@solana/rpc-subscriptions-spec/src/rpc-subscriptions-channel.ts", "../../gill/node_modules/@solana/event-target-impl/src/index.browser.ts", "../../gill/node_modules/@solana/rpc-subscriptions-spec/src/rpc-subscriptions-pubsub-plan.ts", "../../gill/node_modules/@solana/rpc-subscriptions-api/src/index.ts", "../../gill/node_modules/@solana/event-target-impl/src/index.browser.ts", "../../gill/node_modules/@solana/ws-impl/src/index.browser.ts", "../../gill/node_modules/@solana/rpc-subscriptions-channel-websocket/src/websocket-channel.ts", "../../gill/node_modules/@solana/rpc-subscriptions/src/rpc-integer-overflow-error.ts", "../../gill/node_modules/@solana/rpc-subscriptions/src/rpc-default-config.ts", "../../gill/node_modules/@solana/event-target-impl/src/index.browser.ts", "../../gill/node_modules/@solana/rpc-subscriptions/src/rpc-subscriptions-autopinger.ts", "../../gill/node_modules/@solana/rpc-subscriptions/src/rpc-subscriptions-channel-pool-internal.ts", "../../gill/node_modules/@solana/rpc-subscriptions/src/rpc-subscriptions-channel-pool.ts", "../../gill/node_modules/@solana/rpc-subscriptions/src/rpc-subscriptions-json.ts", "../../gill/node_modules/@solana/rpc-subscriptions/src/rpc-subscriptions-json-bigint.ts", "../../gill/node_modules/@solana/rpc-subscriptions/src/rpc-subscriptions-channel.ts", "../../gill/node_modules/@solana/rpc-subscriptions/src/rpc-subscriptions-coalescer.ts", "../../gill/node_modules/@solana/rpc-subscriptions/src/rpc-subscriptions-transport.ts", "../../gill/node_modules/@solana/rpc-subscriptions/src/rpc-subscriptions.ts", "../../gill/node_modules/@solana/rpc-types/src/blockhash.ts", "../../gill/node_modules/@solana/rpc-types/src/cluster-url.ts", "../../gill/node_modules/@solana/rpc-types/src/commitment.ts", "../../gill/node_modules/@solana/rpc-types/src/lamports.ts", "../../gill/node_modules/@solana/rpc-types/src/stringified-bigint.ts", "../../gill/node_modules/@solana/rpc-types/src/stringified-number.ts", "../../gill/node_modules/@solana/rpc-types/src/unix-timestamp.ts", "../../gill/node_modules/@solana/transaction-messages/src/blockhash.ts", "../../gill/node_modules/@solana/codecs-strings/src/assertions.ts", "../../gill/node_modules/@solana/codecs-strings/src/baseX.ts", "../../gill/node_modules/@solana/codecs-strings/src/base58.ts", "../../gill/node_modules/@solana/transaction-messages/src/codecs/address-table-lookup.ts", "../../gill/node_modules/@solana/transaction-messages/src/codecs/header.ts", "../../gill/node_modules/@solana/transaction-messages/src/codecs/instruction.ts", "../../gill/node_modules/@solana/transaction-messages/src/codecs/transaction-version.ts", "../../gill/node_modules/@solana/transaction-messages/src/codecs/message.ts", "../../gill/node_modules/@solana/transaction-messages/src/compile/accounts.ts", "../../gill/node_modules/@solana/transaction-messages/src/compile/address-table-lookups.ts", "../../gill/node_modules/@solana/transaction-messages/src/compile/header.ts", "../../gill/node_modules/@solana/transaction-messages/src/compile/instructions.ts", "../../gill/node_modules/@solana/transaction-messages/src/compile/lifetime-token.ts", "../../gill/node_modules/@solana/transaction-messages/src/compile/static-accounts.ts", "../../gill/node_modules/@solana/transaction-messages/src/compile/message.ts", "../../gill/node_modules/@solana/transaction-messages/src/compress-transaction-message.ts", "../../gill/node_modules/@solana/transaction-messages/src/create-transaction-message.ts", "../../gill/node_modules/@solana/transaction-messages/src/durable-nonce-instruction.ts", "../../gill/node_modules/@solana/transaction-messages/src/durable-nonce.ts", "../../gill/node_modules/@solana/transaction-messages/src/fee-payer.ts", "../../gill/node_modules/@solana/transaction-messages/src/instructions.ts", "../../gill/node_modules/@solana/transaction-messages/src/decompile-message.ts", "../../gill/node_modules/@solana/transaction-messages/src/deprecated.ts", "../../gill/node_modules/@solana/transactions/src/codecs/signatures-encoder.ts", "../../gill/node_modules/@solana/transactions/src/codecs/transaction-codec.ts", "../../gill/node_modules/@solana/transactions/src/compile-transaction.ts", "../../gill/node_modules/@solana/transactions/src/signatures.ts", "../../gill/node_modules/@solana/transactions/src/wire-transaction.ts", "../../gill/node_modules/@solana/transactions/src/transaction-size.ts", "../../gill/node_modules/@solana/transactions/src/transaction-message-size.ts", "../../gill/node_modules/@solana/transactions/src/deprecated.ts", "../../gill/node_modules/@solana/signers/src/deduplicate-signers.ts", "../../gill/node_modules/@solana/signers/src/transaction-modifying-signer.ts", "../../gill/node_modules/@solana/signers/src/transaction-partial-signer.ts", "../../gill/node_modules/@solana/signers/src/transaction-sending-signer.ts", "../../gill/node_modules/@solana/signers/src/transaction-signer.ts", "../../gill/node_modules/@solana/signers/src/account-signer-meta.ts", "../../gill/node_modules/@solana/signers/src/add-signers.ts", "../../gill/node_modules/@solana/signers/src/fee-payer-signer.ts", "../../gill/node_modules/@solana/signers/src/message-partial-signer.ts", "../../gill/node_modules/@solana/signers/src/keypair-signer.ts", "../../gill/node_modules/@solana/signers/src/message-modifying-signer.ts", "../../gill/node_modules/@solana/signers/src/message-signer.ts", "../../gill/node_modules/@solana/signers/src/noop-signer.ts", "../../gill/node_modules/@solana/signers/src/transaction-with-single-sending-signer.ts", "../../gill/node_modules/@solana/signers/src/sign-transaction.ts", "../../gill/node_modules/@solana/text-encoding-impl/src/index.browser.ts", "../../gill/node_modules/@solana/signers/src/signable-message.ts", "../../gill/node_modules/@solana/event-target-impl/src/index.browser.ts", "../../gill/node_modules/@solana/transaction-confirmation/src/confirmation-strategy-blockheight.ts", "../../gill/node_modules/@solana/transaction-confirmation/src/confirmation-strategy-nonce.ts", "../../gill/node_modules/@solana/transaction-confirmation/src/confirmation-strategy-recent-signature.ts", "../../gill/node_modules/@solana/transaction-confirmation/src/confirmation-strategy-timeout.ts", "../../gill/node_modules/@solana/transaction-confirmation/src/confirmation-strategy-racer.ts", "../../gill/node_modules/@solana/transaction-confirmation/src/waiters.ts", "../../gill/node_modules/@solana/kit/src/airdrop-internal.ts", "../../gill/node_modules/@solana/kit/src/airdrop.ts", "../../gill/node_modules/@solana/kit/src/compute-limit-internal.ts", "../../gill/node_modules/@solana/kit/src/compute-limit.ts", "../../gill/node_modules/@solana/kit/src/fetch-lookup-tables.ts", "../../gill/node_modules/@solana/kit/src/decompile-transaction-message-fetching-lookup-tables.ts", "../../gill/node_modules/@solana/kit/src/send-transaction-internal.ts", "../../gill/node_modules/@solana/kit/src/send-and-confirm-durable-nonce-transaction.ts", "../../gill/node_modules/@solana/kit/src/send-and-confirm-transaction.ts", "../../gill/node_modules/@solana/kit/src/send-transaction-without-confirming.ts", "../../gill/node_modules/@solana-program/compute-budget/src/generated/programs/computeBudget.ts", "../../gill/node_modules/@solana-program/compute-budget/src/generated/instructions/requestHeapFrame.ts", "../../gill/node_modules/@solana-program/compute-budget/src/generated/instructions/requestUnits.ts", "../../gill/node_modules/@solana-program/compute-budget/src/generated/instructions/setComputeUnitLimit.ts", "../../gill/node_modules/@solana-program/compute-budget/src/generated/instructions/setComputeUnitPrice.ts", "../../gill/node_modules/@solana-program/compute-budget/src/generated/instructions/setLoadedAccountsDataSizeLimit.ts", "../../gill/node_modules/@solana-program/compute-budget/src/constants.ts", "../../gill/node_modules/@solana-program/compute-budget/src/internal.ts", "../../gill/node_modules/@solana-program/compute-budget/src/setComputeLimit.ts", "../../gill/node_modules/@solana-program/compute-budget/src/estimateAndSetComputeLimit.ts", "../../gill/node_modules/@solana-program/compute-budget/src/internalMoveToKit.ts", "../../gill/node_modules/@solana-program/compute-budget/src/estimateComputeLimitInternal.ts", "../../gill/node_modules/@solana-program/compute-budget/src/estimateComputeLimit.ts", "../../gill/node_modules/@solana-program/compute-budget/src/setComputePrice.ts", "../../gill/src/core/debug.ts", "../../gill/src/core/const.ts", "../../gill/src/core/utils.ts", "../../gill/src/core/rpc.ts", "../../gill/src/core/explorer.ts", "../../gill/src/core/create-transaction.ts", "../../gill/src/core/send-and-confirm-transaction-with-signers.ts", "../../gill/src/programs/compute-budget/utils.ts", "../../gill/src/core/base64-to-transaction.ts", "../../gill/src/core/prepare-transaction.ts", "../../gill/src/core/simulate-transaction.ts", "../../gill/src/core/create-solana-client.ts", "../../gill/src/core/accounts.ts", "../../gill/src/core/keypairs-extractable.ts", "../../gill/src/core/keypairs-base58.ts", "../../gill/src/core/base64-from-transaction.ts", "../../gill/src/core/get-oldest-signature.ts", "../../gill/src/core/insert-reference-key.ts", "../../gill/src/core/create-codama-config.ts"],
  "sourcesContent": ["/**\n * To add a new error, follow the instructions at\n * https://github.com/anza-xyz/kit/tree/main/packages/errors/#adding-a-new-error\n *\n * @module\n * @privateRemarks\n * WARNING:\n *   - Don't remove error codes\n *   - Don't change or reorder error codes.\n *\n * Good naming conventions:\n *   - Prefixing common errors — e.g. under the same package — can be a good way to namespace them. E.g. All codec-related errors start with `SOLANA_ERROR__CODECS__`.\n *   - Use consistent names — e.g. choose `PDA` or `PROGRAM_DERIVED_ADDRESS` and stick with it. Ensure your names are consistent with existing error codes. The decision might have been made for you.\n *   - Recommended prefixes and suffixes:\n *     - `MALFORMED_`: Some input was not constructed properly. E.g. `MALFORMED_BASE58_ENCODED_ADDRESS`.\n *     - `INVALID_`: Some input is invalid (other than because it was MALFORMED). E.g. `INVALID_NUMBER_OF_BYTES`.\n *     - `EXPECTED_`: Some input was different than expected, no need to specify the \"GOT\" part unless necessary. E.g. `EXPECTED_DECODED_ACCOUNT`.\n *     - `_CANNOT_`: Some operation cannot be performed or some input cannot be used due to some condition. E.g. `CANNOT_DECODE_EMPTY_BYTE_ARRAY` or `PDA_CANNOT_END_WITH_PDA_MARKER`.\n *     - `_MUST_BE_`: Some condition must be true. E.g. `NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE`.\n *     - `_FAILED_TO_`: Tried to perform some operation and failed. E.g. `FAILED_TO_DECODE_ACCOUNT`.\n *     - `_NOT_FOUND`: Some operation lead to not finding something. E.g. `ACCOUNT_NOT_FOUND`.\n *     - `_OUT_OF_RANGE`: Some value is out of range. E.g. `ENUM_DISCRIMINATOR_OUT_OF_RANGE`.\n *     - `_EXCEEDED`: Some limit was exceeded. E.g. `PDA_MAX_SEED_LENGTH_EXCEEDED`.\n *     - `_MISMATCH`: Some elements do not match. E.g. `ENCODER_DECODER_FIXED_SIZE_MISMATCH`.\n *     - `_MISSING`: Some required input is missing. E.g. `TRANSACTION_FEE_PAYER_MISSING`.\n *     - `_UNIMPLEMENTED`: Some required component is not available in the environment. E.g. `SUBTLE_CRYPTO_VERIFY_FUNCTION_UNIMPLEMENTED`.\n */\nexport const SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;\nexport const SOLANA_ERROR__INVALID_NONCE = 2;\nexport const SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;\nexport const SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;\nexport const SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;\nexport const SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;\nexport const SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;\nexport const SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;\nexport const SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;\nexport const SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;\n\n// JSON-RPC-related errors.\n// Reserve error codes in the range [-32768, -32000]\n// Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-api/src/custom_error.rs\nexport const SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;\nexport const SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;\nexport const SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;\nexport const SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;\n\n// Addresses-related errors.\n// Reserve error codes in the range [2800000-2800999].\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 2800000;\nexport const SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;\nexport const SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;\nexport const SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;\nexport const SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;\nexport const SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;\nexport const SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;\nexport const SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;\n\n// Account-related errors.\n// Reserve error codes in the range [3230000-3230999].\nexport const SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 3230000;\nexport const SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;\nexport const SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;\n\n// Subtle-Crypto-related errors.\n// Reserve error codes in the range [3610000-3610999].\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 3610000;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;\n\n// Crypto-related errors.\n// Reserve error codes in the range [3611000-3611050].\nexport const SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611000;\n\n// Key-related errors.\n// Reserve error codes in the range [3704000-3704999].\nexport const SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704000;\nexport const SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;\nexport const SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;\nexport const SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;\nexport const SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;\n\n// Instruction-related errors.\n// Reserve error codes in the range [4128000-4128999].\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128000;\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;\nexport const SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;\n\n// Instruction errors.\n// Reserve error codes starting with [4615000-4615999] for the Rust enum `InstructionError`.\n// Error names here are dictated by the RPC (see ./instruction-error.ts).\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615000;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;\n\n// Signer-related errors.\n// Reserve error codes in the range [5508000-5508999].\nexport const SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508000;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;\nexport const SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;\n\n// Transaction-related errors.\n// Reserve error codes in the range [5663000-5663999].\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663000;\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;\nexport const SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;\nexport const SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;\nexport const SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;\nexport const SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;\nexport const SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;\n\n// Transaction errors.\n// Reserve error codes starting with [7050000-7050999] for the Rust enum `TransactionError`.\n// Error names here are dictated by the RPC (see ./transaction-error.ts).\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 7050000;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;\n// `InstructionError` intentionally omitted.\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;\n\n// Codec-related errors.\n// Reserve error codes in the range [8078000-8078999].\nexport const SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078000;\nexport const SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;\nexport const SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;\nexport const SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;\nexport const SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;\nexport const SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;\nexport const SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;\nexport const SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;\nexport const SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;\nexport const SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;\nexport const SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;\nexport const SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;\nexport const SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;\nexport const SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;\nexport const SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;\nexport const SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;\nexport const SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;\nexport const SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;\nexport const SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;\nexport const SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;\n\n// RPC-related errors.\n// Reserve error codes in the range [8100000-8100999].\nexport const SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 8100000;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;\nexport const SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;\n\n// RPC-Subscriptions-related errors.\n// Reserve error codes in the range [8190000-8190999].\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 8190000;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;\n\n// Invariant violation errors.\n// Reserve error codes in the range [9900000-9900999].\n// These errors should only be thrown when there is a bug with the\n// library itself and should, in theory, never reach the end user.\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 9900000;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;\n\n/**\n * A union of every Solana error code\n *\n * @privateRemarks\n * You might be wondering why this is not a TypeScript enum or const enum.\n *\n * One of the goals of this library is to enable people to use some or none of it without having to\n * bundle all of it.\n *\n * If we made the set of error codes an enum then anyone who imported it (even if to only use a\n * single error code) would be forced to bundle every code and its label.\n *\n * Const enums appear to solve this problem by letting the compiler inline only the codes that are\n * actually used. Unfortunately exporting ambient (const) enums from a library like `@solana/errors`\n * is not safe, for a variety of reasons covered here: https://stackoverflow.com/a/28818850\n */\nexport type SolanaErrorCode =\n    | typeof SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND\n    | typeof SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE\n    | typeof SOLANA_ERROR__ADDRESSES__MALFORMED_PDA\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER\n    | typeof SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED\n    | typeof SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY\n    | typeof SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS\n    | typeof SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE\n    | typeof SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__INVALID_CONSTANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS\n    | typeof SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE\n    | typeof SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES\n    | typeof SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR\n    | typeof SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH\n    | typeof SOLANA_ERROR__INVALID_NONCE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE\n    | typeof SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_PARAMS\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_REQUEST\n    | typeof SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND\n    | typeof SOLANA_ERROR__JSON_RPC__PARSE_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SCAN_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION\n    | typeof SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY\n    | typeof SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__MALFORMED_BIGINT_STRING\n    | typeof SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR\n    | typeof SOLANA_ERROR__MALFORMED_NUMBER_STRING\n    | typeof SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD\n    | typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID\n    | typeof SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING\n    | typeof SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES\n    | typeof SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE\n    | typeof SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH\n    | typeof SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT;\n\n/**\n * Errors of this type are understood to have an optional {@link SolanaError} nested inside as\n * `cause`.\n */\nexport type SolanaErrorCodeWithCause = typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE;\n", "/**\n * To add a new error, follow the instructions at\n * https://github.com/anza-xyz/kit/tree/main/packages/errors/#adding-a-new-error\n *\n * @privateRemarks\n * WARNING:\n *   - Don't change or remove members of an error's context.\n */\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_CONSTANT,\n    SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,\n    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__MALFORMED_BIGINT_STRING,\n    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,\n    SOLANA_ERROR__MALFORMED_NUMBER_STRING,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD,\n    SOLANA_ERROR__RPC__INTEGER_OVERFLOW,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,\n    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,\n    SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY,\n    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n    SolanaErrorCode,\n} from './codes';\nimport { RpcSimulateTransactionResult } from './json-rpc-error';\n\ntype BasicInstructionErrorContext<T extends SolanaErrorCode> = Readonly<{ [P in T]: { index: number } }>;\n\ntype DefaultUnspecifiedErrorContextToUndefined<T> = {\n    [P in SolanaErrorCode]: P extends keyof T ? T[P] : undefined;\n};\n\ntype TypedArrayMutableProperties = 'copyWithin' | 'fill' | 'reverse' | 'set' | 'sort';\ninterface ReadonlyUint8Array extends Omit<Uint8Array, TypedArrayMutableProperties> {\n    readonly [n: number]: number;\n}\n\n/** A amount of bytes. */\ntype Bytes = number;\n\n/**\n * A map of every {@link SolanaError} code to the type of its `context` property.\n */\nexport type SolanaErrorContext = DefaultUnspecifiedErrorContextToUndefined<\n    BasicInstructionErrorContext<\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR\n    > & {\n        [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: {\n            putativeAddress: string;\n        };\n        [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: {\n            actual: number;\n            maxSeeds: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: {\n            actual: number;\n            index: number;\n            maxSeedLength: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: {\n            bump: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: {\n            currentBlockHeight: bigint;\n            lastValidBlockHeight: bigint;\n        };\n        [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: {\n            codecDescription: string;\n        };\n        [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: {\n            stringValues: string[];\n        };\n        [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: {\n            encodedBytes: ReadonlyUint8Array;\n            hexEncodedBytes: string;\n            hexSentinel: string;\n            sentinel: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: {\n            decoderFixedSize: number;\n            encoderFixedSize: number;\n        };\n        [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: {\n            decoderMaxSize: number | undefined;\n            encoderMaxSize: number | undefined;\n        };\n        [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: {\n            discriminator: bigint | number;\n            formattedValidDiscriminators: string;\n            validDiscriminators: number[];\n        };\n        [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: {\n            bytesLength: number;\n            codecDescription: string;\n        };\n        [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: {\n            codecDescription: string;\n            expectedSize: number;\n            hexZeroValue: string;\n            zeroValue: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: {\n            bytesLength: number;\n            codecDescription: string;\n            expected: number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: {\n            constant: ReadonlyUint8Array;\n            data: ReadonlyUint8Array;\n            hexConstant: string;\n            hexData: string;\n            offset: number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: {\n            value: bigint | boolean | number | string | null | undefined;\n            variants: readonly (bigint | boolean | number | string | null | undefined)[];\n        };\n        [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: {\n            formattedNumericalValues: string;\n            numericalValues: number[];\n            stringValues: string[];\n            variant: number | string | symbol;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: {\n            value: bigint | boolean | number | string | null | undefined;\n            variants: readonly (bigint | boolean | number | string | null | undefined)[];\n        };\n        [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: {\n            actual: bigint | number;\n            codecDescription: string;\n            expected: bigint | number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: {\n            alphabet: string;\n            base: number;\n            value: string;\n        };\n        [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: {\n            discriminator: bigint | number;\n            maxRange: number;\n            minRange: number;\n        };\n        [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: {\n            codecDescription: string;\n            max: bigint | number;\n            min: bigint | number;\n            value: bigint | number;\n        };\n        [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: {\n            bytesLength: number;\n            codecDescription: string;\n            offset: number;\n        };\n        [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: {\n            decodedBytes: ReadonlyUint8Array;\n            hexDecodedBytes: string;\n            hexSentinel: string;\n            sentinel: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: {\n            maxRange: number;\n            minRange: number;\n            variant: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: {\n            encodedData: string;\n            index: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: {\n            code: number;\n            index: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: {\n            errorName: string;\n            index: number;\n            instructionErrorContext?: unknown;\n        };\n        [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: {\n            data?: ReadonlyUint8Array;\n            programAddress: string;\n        };\n        [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: {\n            accountAddresses?: string[];\n            programAddress: string;\n        };\n        [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: {\n            actualProgramAddress: string;\n            expectedProgramAddress: string;\n        };\n        [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__INVALID_NONCE]: {\n            actualNonceValue: string;\n            expectedNonceValue: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: {\n            cacheKey: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: {\n            channelName: string;\n            supportedChannelNames: string[];\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: {\n            unexpectedValue: unknown;\n        };\n        [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: {\n            contextSlot: bigint;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: {\n            numSlotsBehind?: number;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: Omit<\n            RpcSimulateTransactionResult,\n            'err'\n        >;\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: {\n            byteLength: number;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: {\n            value: string;\n        };\n        [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: {\n            error: unknown;\n            message: string;\n        };\n        [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: {\n            value: string;\n        };\n        [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: {\n            nonceAccountAddress: string;\n        };\n        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: {\n            notificationName: string;\n        };\n        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: {\n            errorEvent: Event;\n        };\n        [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: {\n            method: string;\n            params: unknown[];\n        };\n        [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: {\n            argumentLabel: string;\n            keyPath: readonly (number | string | symbol)[];\n            methodName: string;\n            optionalPathLabel: string;\n            path?: string;\n            value: bigint;\n        };\n        [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: {\n            headers: Headers;\n            message: string;\n            statusCode: number;\n        };\n        [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: {\n            headers: string[];\n        };\n        [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: {\n            key: CryptoKey;\n        };\n        [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: {\n            value: bigint;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: {\n            accountIndex: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: {\n            accountIndex: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: {\n            errorName: string;\n            transactionErrorContext?: unknown;\n        };\n        [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: {\n            expectedAddresses: string[];\n            unexpectedAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: {\n            transactionSize: Bytes;\n            transactionSizeLimit: Bytes;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: {\n            lookupTableAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: {\n            highestKnownIndex: number;\n            highestRequestedIndex: number;\n            lookupTableAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: {\n            unitsConsumed: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: {\n            programAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: {\n            programAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: {\n            numRequiredSignatures: number;\n            signaturesLength: number;\n            signerAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: {\n            actualVersion: number;\n        };\n    }\n>;\n\nexport function decodeEncodedContext(encodedContext: string): object {\n    const decodedUrlString = __NODEJS__ ? Buffer.from(encodedContext, 'base64').toString('utf8') : atob(encodedContext);\n    return Object.fromEntries(new URLSearchParams(decodedUrlString).entries());\n}\n\nfunction encodeValue(value: unknown): string {\n    if (Array.isArray(value)) {\n        const commaSeparatedValues = value.map(encodeValue).join('%2C%20' /* \", \" */);\n        return '%5B' /* \"[\" */ + commaSeparatedValues + /* \"]\" */ '%5D';\n    } else if (typeof value === 'bigint') {\n        return `${value}n`;\n    } else {\n        return encodeURIComponent(\n            String(\n                value != null && Object.getPrototypeOf(value) === null\n                    ? // Plain objects with no prototype don't have a `toString` method.\n                      // Convert them before stringifying them.\n                      { ...(value as object) }\n                    : value,\n            ),\n        );\n    }\n}\n\nfunction encodeObjectContextEntry([key, value]: [string, unknown]): `${typeof key}=${string}` {\n    return `${key}=${encodeValue(value)}`;\n}\n\nexport function encodeContextObject(context: object): string {\n    const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join('&');\n    return __NODEJS__ ? Buffer.from(searchParamsString, 'utf8').toString('base64') : btoa(searchParamsString);\n}\n", "/**\n * To add a new error, follow the instructions at\n * https://github.com/anza-xyz/kit/tree/main/packages/errors#adding-a-new-error\n *\n * WARNING:\n *   - Don't change the meaning of an error message.\n */\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY,\n    SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_CONSTANT,\n    SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE,\n    SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,\n    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE,\n    SOLANA_ERROR__MALFORMED_BIGINT_STRING,\n    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,\n    SOLANA_ERROR__MALFORMED_NUMBER_STRING,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD,\n    SOLANA_ERROR__RPC__INTEGER_OVERFLOW,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID,\n    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,\n    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,\n    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES,\n    SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED,\n    SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP,\n    SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE,\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT,\n    SolanaErrorCode,\n} from './codes';\n\n/**\n * A map of every {@link SolanaError} code to the error message shown to developers in development\n * mode.\n */\nexport const SolanaErrorMessages: Readonly<{\n    // This type makes this data structure exhaustive with respect to `SolanaErrorCode`.\n    // TypeScript will fail to build this project if add an error code without a message.\n    [P in SolanaErrorCode]: string;\n}> = {\n    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: 'Account not found at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]:\n        'Not all accounts were decoded. Encoded accounts found at addresses: $addresses.',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: 'Expected decoded account at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: 'Failed to decode account data at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: 'Accounts not found at addresses: $addresses',\n    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]:\n        'Unable to find a viable program address bump seed.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: '$putativeAddress is not a base58-encoded address.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]:\n        'Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: 'The `CryptoKey` must be an `Ed25519` public key.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]:\n        '$putativeOffCurveAddress is not a base58-encoded off-curve address.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: 'Invalid seeds; point must fall off the Ed25519 curve.',\n    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]:\n        'Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].',\n    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]:\n        'A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.',\n    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]:\n        'The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.',\n    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]:\n        'Expected program derived address bump to be in the range [0, 255], got: $bump.',\n    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: 'Program address cannot end with PDA marker.',\n    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]:\n        'The network has progressed past the last block for which this transaction could have been committed.',\n    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]:\n        'Codec [$codecDescription] cannot decode empty byte arrays.',\n    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]:\n        'Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.',\n    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]:\n        'Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]:\n        'Encoder and decoder must either both be fixed-size or variable-size.',\n    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.',\n    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: 'Expected a fixed-size codec, got a variable-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected a positive byte length, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: 'Expected a variable-size codec, got a fixed-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]:\n        'Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].',\n    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected $expected bytes, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__INVALID_CONSTANT]:\n        'Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].',\n    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]:\n        'Invalid discriminated union variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]:\n        'Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.',\n    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]:\n        'Invalid literal union variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]:\n        'Expected [$codecDescription] to have $expected items, got $actual.',\n    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: 'Invalid value $value for base $base with alphabet $alphabet.',\n    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.',\n    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.',\n    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.',\n    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]:\n        'Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].',\n    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]:\n        'Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.',\n    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: 'No random values implementation could be found.',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: 'instruction requires an uninitialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]:\n        'instruction tries to borrow reference for an account which is already borrowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'instruction left account with an outstanding borrowed reference',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]:\n        \"program other than the account's owner changed the size of the account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: 'account data too small for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: 'instruction expected an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]:\n        'An account does not have enough lamports to be rent-exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: 'Program arithmetic overflowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: 'Failed to serialize or deserialize account data: $encodedData',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]:\n        'Builtin programs must consume compute units',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: 'Cross-program invocation call depth too deep',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: 'Computational budget exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: 'custom program error: #$code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: 'instruction contains duplicate accounts',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]:\n        'instruction modifications of multiply-passed account differ',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: 'executable accounts must be rent exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: 'instruction changed executable accounts data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]:\n        'instruction changed the balance of an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: 'instruction changed executable bit of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]:\n        'instruction modified data of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]:\n        'instruction spent from the balance of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: 'generic instruction error',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: 'Provided owner is not allowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: 'Account is immutable',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: 'Incorrect authority provided',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: 'incorrect program id for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: 'insufficient funds for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: 'invalid account data for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: 'Invalid account owner',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: 'invalid program argument',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: 'program returned invalid error code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: 'invalid instruction data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: 'Failed to reallocate account data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: 'Provided seeds do not result in a valid address',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]:\n        'Accounts data allocations exceeded the maximum allowed per transaction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: 'Max accounts exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: 'Max instruction trace length exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]:\n        'Length of the seed is too long for address generation',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: 'An account required by the instruction is missing',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: 'missing required signature for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]:\n        'instruction illegally modified the program id of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: 'insufficient account keys for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]:\n        'Cross-program invocation with unauthorized signer or writable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]:\n        'Failed to create program execution environment',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: 'Program failed to compile',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: 'Program failed to complete',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: 'instruction modified data of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]:\n        'instruction changed the balance of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]:\n        'Cross-program invocation reentrancy not allowed for this instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: 'instruction modified rent epoch of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]:\n        'sum of account balances before and after instruction do not match',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: 'instruction requires an initialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: '',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: 'Unsupported program id',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: 'Unsupported sysvar',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: 'The instruction does not have any accounts.',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: 'The instruction does not have any data.',\n    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]:\n        'Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.',\n    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]:\n        'Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__INVALID_NONCE]:\n        'The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]:\n        'Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It ' +\n        'should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]:\n        'Invariant violation: This data publisher does not publish to the channel named ' +\n        '`$channelName`. Supported channels include $supportedChannelNames.',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]:\n        'Invariant violation: WebSocket message iterator state is corrupt; iterated without first ' +\n        'resolving existing message promise. It should be impossible to hit this error; please ' +\n        'file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]:\n        'Invariant violation: WebSocket message iterator is missing state storage. It should be ' +\n        'impossible to hit this error; please file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]:\n        'Invariant violation: Switch statement non-exhaustive. Received unexpected value ' +\n        '`$unexpectedValue`. It should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: 'JSON-RPC error: Internal JSON-RPC error ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: 'JSON-RPC error: Invalid method parameter(s) ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]:\n        'JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]:\n        'JSON-RPC error: The method does not exist / is not available ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]:\n        'JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: 'Minimum context slot has not been reached',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: 'Node is unhealthy; behind by $numSlotsBehind slots',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: 'No snapshot',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: 'Transaction simulation failed',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]:\n        'Transaction history is not available from this node',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: 'Transaction signature length mismatch',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]:\n        'Transaction signature verification failure',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: '$__serverMessage',\n    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: 'Key pair bytes must be of length 64, got $byteLength.',\n    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]:\n        'Expected private key bytes with length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]:\n        'Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]:\n        'The provided private key does not match the provided public key.',\n    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.',\n    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: 'Lamports value must be in the range [0, 2e64-1]',\n    [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: '`$value` cannot be parsed as a `BigInt`',\n    [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: '$message',\n    [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: '`$value` cannot be parsed as a `Number`',\n    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: 'No nonce account could be found at address `$nonceAccountAddress`',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]:\n        \"The notification name must end in 'Notifications' and the API must supply a \" +\n        \"subscription plan creator function for the notification '$notificationName'.\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]:\n        'WebSocket was closed before payload could be added to the send buffer',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: 'WebSocket connection closed',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: 'WebSocket failed to connect',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]:\n        'Failed to obtain a subscription id from the server',\n    [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: 'Could not find an API plan for RPC method: `$method`',\n    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]:\n        'The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was ' +\n        '`$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds ' +\n        '`Number.MAX_SAFE_INTEGER`.',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: 'HTTP error ($statusCode): $message',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]:\n        'HTTP header(s) forbidden: $headers. Learn more at ' +\n        'https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.',\n    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]:\n        'Multiple distinct signers were identified for address `$address`. Please ensure that ' +\n        'you are using the same signer instance for each address.',\n    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]:\n        'The provided value does not implement the `KeyPairSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]:\n        'The provided value does not implement the `MessageModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]:\n        'The provided value does not implement the `MessagePartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]:\n        'The provided value does not implement any of the `MessageSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]:\n        'The provided value does not implement the `TransactionModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]:\n        'The provided value does not implement the `TransactionPartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]:\n        'The provided value does not implement the `TransactionSendingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]:\n        'The provided value does not implement any of the `TransactionSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]:\n        'More than one `TransactionSendingSigner` was identified.',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]:\n        'No `TransactionSendingSigner` was identified. Please provide a valid ' +\n        '`TransactionWithSingleSendingSigner` transaction.',\n    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]:\n        'Wallet account signers do not support signing multiple messages/transactions in a single operation',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: 'Cannot export a non-extractable key.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: 'No digest implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]:\n        'Cryptographic operations are only allowed in secure browser contexts. Read more ' +\n        'here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]:\n        'This runtime does not support the generation of Ed25519 key pairs.\\n\\nInstall ' +\n        '@solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in ' +\n        'environments that do not support Ed25519.\\n\\nFor a list of runtimes that ' +\n        'currently support Ed25519 operations, visit ' +\n        'https://github.com/WICG/webcrypto-secure-curves/issues/20.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]:\n        'No signature verification implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: 'No key generation implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: 'No signing implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: 'No key export implementation could be found.',\n    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]:\n        'Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'Transaction processing left an account with an outstanding borrowed reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: 'Account in use',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: 'Account loaded twice',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]:\n        'Attempt to debit an account but found no record of a prior credit.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]:\n        \"Transaction loads an address table account that doesn't exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: 'This transaction has already been processed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: 'Blockhash not found',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: 'Loader call chain is too deep',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]:\n        'Transactions are currently disabled due to cluster maintenance',\n    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]:\n        'Transaction contains a duplicate instruction ($index) that is not allowed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: 'Insufficient funds for fee',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]:\n        'Transaction results in an account ($accountIndex) with insufficient funds for rent',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: 'This account may not be used to pay transaction fees',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: 'Transaction contains an invalid account reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]:\n        'Transaction loads an address table account with invalid data',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]:\n        'Transaction address table lookup uses an invalid index',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]:\n        'Transaction loads an address table account with an invalid owner',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]:\n        'LoadedAccountsDataSizeLimit set for transaction must be greater than 0.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]:\n        'This program may not be used for executing instructions',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]:\n        'Transaction leaves an account with a lower balance than rent-exempt minimum',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]:\n        'Transaction loads a writable account that cannot be written',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]:\n        'Transaction exceeded max loaded accounts data size cap',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]:\n        'Transaction requires a fee but has no signature present',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: 'Attempt to load a program that does not exist',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]:\n        'Execution of the program referenced by account at index $accountIndex is temporarily restricted.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: 'ResanitizationNeeded',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: 'Transaction failed to sanitize accounts offsets correctly',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: 'Transaction did not pass signature verification',\n    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: 'Transaction locked too many accounts',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]:\n        'Sum of account balances before and after transaction do not match',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: 'The transaction failed with the error `$errorName`',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: 'Transaction version is unsupported',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]:\n        'Transaction would exceed account data limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]:\n        'Transaction would exceed total account data limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]:\n        'Transaction would exceed max account limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]:\n        'Transaction would exceed max Block Cost Limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: 'Transaction would exceed max Vote Cost Limit',\n    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]:\n        'Attempted to sign a transaction with an address that is not a signer for it',\n    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: 'Transaction is missing an address at index: $index.',\n    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]:\n        'Transaction has no expected signers therefore it cannot be encoded',\n    [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]:\n        'Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: 'Transaction does not have a blockhash lifetime',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: 'Transaction is not a durable nonce transaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]:\n        'Contents of these address lookup tables unknown: $lookupTableAddresses',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]:\n        'Lookup of address at index $highestRequestedIndex failed for lookup table ' +\n        '`$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table ' +\n        'may have been extended since its contents were retrieved',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: 'No fee payer set in CompiledTransaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]:\n        'Could not find program address at index $index',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]:\n        'Failed to estimate the compute unit consumption for this transaction message. This is ' +\n        'likely because simulating the transaction failed. Inspect the `cause` property of this ' +\n        'error to learn more',\n    [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]:\n        'Transaction failed when it was simulated in order to estimate the compute unit consumption. ' +\n        'The compute unit estimate provided is for a transaction that failed when simulated and may not ' +\n        'be representative of the compute units this transaction would consume if successful. Inspect the ' +\n        '`cause` property of this error to learn more',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: 'Transaction is missing a fee payer.',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]:\n        \"Could not determine this transaction's signature. Make sure that the transaction has \" +\n        'been signed by its fee payer.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]:\n        'Transaction first instruction is not advance nonce account instruction.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]:\n        'Transaction with no instructions cannot be durable nonce transaction.',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]:\n        'This transaction includes an address (`$programAddress`) which is both ' +\n        'invoked and set as the fee payer. Program addresses may not pay fees',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]:\n        'This transaction includes an address (`$programAddress`) which is both invoked and ' +\n        'marked writable. Program addresses may not be writable',\n    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]:\n        'The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.',\n    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: 'Transaction is missing signatures for addresses: $addresses.',\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]:\n        'Transaction version must be in the range [0, 127]. `$actualVersion` given',\n};\n", "import { SolanaErrorCode } from './codes';\nimport { encodeContextObject } from './context';\nimport { SolanaErrorMessages } from './messages';\n\nconst enum StateType {\n    EscapeSequence,\n    Text,\n    Variable,\n}\ntype State = Readonly<{\n    [START_INDEX]: number;\n    [TYPE]: StateType;\n}>;\nconst START_INDEX = 'i';\nconst TYPE = 't';\n\nexport function getHumanReadableErrorMessage<TErrorCode extends SolanaErrorCode>(\n    code: TErrorCode,\n    context: object = {},\n): string {\n    const messageFormatString = SolanaErrorMessages[code];\n    if (messageFormatString.length === 0) {\n        return '';\n    }\n    let state: State;\n    function commitStateUpTo(endIndex?: number) {\n        if (state[TYPE] === StateType.Variable) {\n            const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n\n            fragments.push(\n                variableName in context\n                    ? // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                      `${context[variableName as keyof typeof context]}`\n                    : `$${variableName}`,\n            );\n        } else if (state[TYPE] === StateType.Text) {\n            fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n        }\n    }\n    const fragments: string[] = [];\n    messageFormatString.split('').forEach((char, ii) => {\n        if (ii === 0) {\n            state = {\n                [START_INDEX]: 0,\n                [TYPE]:\n                    messageFormatString[0] === '\\\\'\n                        ? StateType.EscapeSequence\n                        : messageFormatString[0] === '$'\n                          ? StateType.Variable\n                          : StateType.Text,\n            };\n            return;\n        }\n        let nextState;\n        switch (state[TYPE]) {\n            case StateType.EscapeSequence:\n                nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                break;\n            case StateType.Text:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                }\n                break;\n            case StateType.Variable:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                } else if (!char.match(/\\w/)) {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                }\n                break;\n        }\n        if (nextState) {\n            if (state !== nextState) {\n                commitStateUpTo(ii);\n            }\n            state = nextState;\n        }\n    });\n    commitStateUpTo();\n    return fragments.join('');\n}\n\nexport function getErrorMessage<TErrorCode extends SolanaErrorCode>(\n    code: TErrorCode,\n    context: Record<string, unknown> = {},\n): string {\n    if (process.env.NODE_ENV !== \"production\") {\n        return getHumanReadableErrorMessage(code, context);\n    } else {\n        let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \\`npx @solana/errors decode -- ${code}`;\n        if (Object.keys(context).length) {\n            /**\n             * DANGER: Be sure that the shell command is escaped in such a way that makes it\n             *         impossible for someone to craft malicious context values that would result in\n             *         an exploit against anyone who bindly copy/pastes it into their terminal.\n             */\n            decodingAdviceMessage += ` '${encodeContextObject(context)}'`;\n        }\n        return `${decodingAdviceMessage}\\``;\n    }\n}\n", "import { SolanaErrorCode, SolanaErrorCodeWithCause } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { getErrorMessage } from './message-formatter';\n\n/**\n * A type guard that returns `true` if the input is a {@link SolanaError}, optionally with a\n * particular error code.\n *\n * When the `code` argument is supplied and the input is a {@link SolanaError}, TypeScript will\n * refine the error's {@link SolanaError#context | `context`} property to the type associated with\n * that error code. You can use that context to render useful error messages, or to make\n * context-aware decisions that help your application to recover from the error.\n *\n * @example\n * ```ts\n * import {\n *     SOLANA_ERROR__TRANSACTION__MISSING_SIGNATURE,\n *     SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n *     isSolanaError,\n * } from '@solana/errors';\n * import { assertIsFullySignedTransaction, getSignatureFromTransaction } from '@solana/transactions';\n *\n * try {\n *     const transactionSignature = getSignatureFromTransaction(tx);\n *     assertIsFullySignedTransaction(tx);\n *     /* ... *\\/\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         displayError(\n *             \"We can't send this transaction without signatures for these addresses:\\n- %s\",\n *             // The type of the `context` object is now refined to contain `addresses`.\n *             e.context.addresses.join('\\n- '),\n *         );\n *         return;\n *     } else if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING)) {\n *         if (!tx.feePayer) {\n *             displayError('Choose a fee payer for this transaction before sending it');\n *         } else {\n *             displayError('The fee payer still needs to sign for this transaction');\n *         }\n *         return;\n *     }\n *     throw e;\n * }\n * ```\n */\nexport function isSolanaError<TErrorCode extends SolanaErrorCode>(\n    e: unknown,\n    /**\n     * When supplied, this function will require that the input is a {@link SolanaError} _and_ that\n     * its error code is exactly this value.\n     */\n    code?: TErrorCode,\n): e is SolanaError<TErrorCode> {\n    const isSolanaError = e instanceof Error && e.name === 'SolanaError';\n    if (isSolanaError) {\n        if (code !== undefined) {\n            return (e as SolanaError<TErrorCode>).context.__code === code;\n        }\n        return true;\n    }\n    return false;\n}\n\ntype SolanaErrorCodedContext = Readonly<{\n    [P in SolanaErrorCode]: (SolanaErrorContext[P] extends undefined ? object : SolanaErrorContext[P]) & {\n        __code: P;\n    };\n}>;\n\n/**\n * Encapsulates an error's stacktrace, a Solana-specific numeric code that indicates what went\n * wrong, and optional context if the type of error indicated by the code supports it.\n */\nexport class SolanaError<TErrorCode extends SolanaErrorCode = SolanaErrorCode> extends Error {\n    /**\n     * Indicates the root cause of this {@link SolanaError}, if any.\n     *\n     * For example, a transaction error might have an instruction error as its root cause. In this\n     * case, you will be able to access the instruction error on the transaction error as `cause`.\n     */\n    readonly cause?: TErrorCode extends SolanaErrorCodeWithCause ? SolanaError : unknown = this.cause;\n    /**\n     * Contains context that can assist in understanding or recovering from a {@link SolanaError}.\n     */\n    readonly context: SolanaErrorCodedContext[TErrorCode];\n    constructor(\n        ...[code, contextAndErrorOptions]: SolanaErrorContext[TErrorCode] extends undefined\n            ? [code: TErrorCode, errorOptions?: ErrorOptions | undefined]\n            : [code: TErrorCode, contextAndErrorOptions: SolanaErrorContext[TErrorCode] & (ErrorOptions | undefined)]\n    ) {\n        let context: SolanaErrorContext[TErrorCode] | undefined;\n        let errorOptions: ErrorOptions | undefined;\n        if (contextAndErrorOptions) {\n            // If the `ErrorOptions` type ever changes, update this code.\n            const { cause, ...contextRest } = contextAndErrorOptions;\n            if (cause) {\n                errorOptions = { cause };\n            }\n            if (Object.keys(contextRest).length > 0) {\n                context = contextRest as SolanaErrorContext[TErrorCode];\n            }\n        }\n        const message = getErrorMessage(code, context);\n        super(message, errorOptions);\n        this.context = {\n            __code: code,\n            ...context,\n        } as SolanaErrorCodedContext[TErrorCode];\n        // This is necessary so that `isSolanaError()` can identify a `SolanaError` without having\n        // to import the class for use in an `instanceof` check.\n        this.name = 'SolanaError';\n    }\n}\n", "export function safeCaptureStackTrace(...args: Parameters<typeof Error.captureStackTrace>): void {\n    if ('captureStackTrace' in Error && typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(...args);\n    }\n}\n", "import { SolanaErrorCode } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\n\ntype Config = Readonly<{\n    /**\n     * Oh, hello. You might wonder what in tarnation is going on here. Allow us to explain.\n     *\n     * One of the goals of `@solana/errors` is to allow errors that are not interesting to your\n     * application to shake out of your app bundle in production. This means that we must never\n     * export large hardcoded maps of error codes/messages.\n     *\n     * Unfortunately, where instruction and transaction errors from the RPC are concerned, we have\n     * no choice but to keep a map between the RPC `rpcEnumError` enum name and its corresponding\n     * `SolanaError` code. In the interest of implementing that map in as few bytes of source code\n     * as possible, we do the following:\n     *\n     *   1. Reserve a block of sequential error codes for the enum in question\n     *   2. Hardcode the list of enum names in that same order\n     *   3. Match the enum error name from the RPC with its index in that list, and reconstruct the\n     *      `SolanaError` code by adding the `errorCodeBaseOffset` to that index\n     */\n    errorCodeBaseOffset: number;\n    getErrorContext: (\n        errorCode: SolanaErrorCode,\n        rpcErrorName: string,\n        rpcErrorContext?: unknown,\n    ) => SolanaErrorContext[SolanaErrorCode];\n    orderedErrorNames: string[];\n    rpcEnumError: string | { [key: string]: unknown };\n}>;\n\nexport function getSolanaErrorFromRpcError(\n    { errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }: Config,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    constructorOpt: Function,\n): SolanaError {\n    let rpcErrorName;\n    let rpcErrorContext;\n    if (typeof rpcEnumError === 'string') {\n        rpcErrorName = rpcEnumError;\n    } else {\n        rpcErrorName = Object.keys(rpcEnumError)[0];\n        rpcErrorContext = rpcEnumError[rpcErrorName];\n    }\n    const codeOffset = orderedErrorNames.indexOf(rpcErrorName);\n    const errorCode = (errorCodeBaseOffset + codeOffset) as SolanaErrorCode;\n    const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);\n    const err = new SolanaError(errorCode, errorContext);\n    safeCaptureStackTrace(err, constructorOpt);\n    return err;\n}\n", "import {\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n} from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/program/src/instruction.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'GenericError',\n    'InvalidArgument',\n    'InvalidInstructionData',\n    'InvalidAccountData',\n    'AccountDataTooSmall',\n    'InsufficientFunds',\n    'IncorrectProgramId',\n    'MissingRequiredSignature',\n    'AccountAlreadyInitialized',\n    'UninitializedAccount',\n    'UnbalancedInstruction',\n    'ModifiedProgramId',\n    'ExternalAccountLamportSpend',\n    'ExternalAccountDataModified',\n    'ReadonlyLamportChange',\n    'ReadonlyDataModified',\n    'DuplicateAccountIndex',\n    'ExecutableModified',\n    'RentEpochModified',\n    'NotEnoughAccountKeys',\n    'AccountDataSizeChanged',\n    'AccountNotExecutable',\n    'AccountBorrowFailed',\n    'AccountBorrowOutstanding',\n    'DuplicateAccountOutOfSync',\n    'Custom',\n    'InvalidError',\n    'ExecutableDataModified',\n    'ExecutableLamportChange',\n    'ExecutableAccountNotRentExempt',\n    'UnsupportedProgramId',\n    'CallDepth',\n    'MissingAccount',\n    'ReentrancyNotAllowed',\n    'MaxSeedLengthExceeded',\n    'InvalidSeeds',\n    'InvalidRealloc',\n    'ComputationalBudgetExceeded',\n    'PrivilegeEscalation',\n    'ProgramEnvironmentSetupFailure',\n    'ProgramFailedToComplete',\n    'ProgramFailedToCompile',\n    'Immutable',\n    'IncorrectAuthority',\n    'BorshIoError',\n    'AccountNotRentExempt',\n    'InvalidAccountOwner',\n    'ArithmeticOverflow',\n    'UnsupportedSysvar',\n    'IllegalOwner',\n    'MaxAccountsDataAllocationsExceeded',\n    'MaxAccountsExceeded',\n    'MaxInstructionTraceLengthExceeded',\n    'BuiltinProgramsMustConsumeComputeUnits',\n];\n\nexport function getSolanaErrorFromInstructionError(\n    /**\n     * The index of the instruction inside the transaction.\n     */\n    index: bigint | number,\n    instructionError: string | { [key: string]: unknown },\n): SolanaError {\n    const numberIndex = Number(index);\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 4615001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        index: numberIndex,\n                        ...(rpcErrorContext !== undefined ? { instructionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {\n                    return {\n                        code: Number(rpcErrorContext as bigint | number),\n                        index: numberIndex,\n                    };\n                } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR) {\n                    return {\n                        encodedData: rpcErrorContext as string,\n                        index: numberIndex,\n                    };\n                }\n                return { index: numberIndex };\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: instructionError,\n        },\n        getSolanaErrorFromInstructionError,\n    );\n}\n", "import {\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n} from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromInstructionError } from './instruction-error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\n/**\n * How to add an error when an entry is added to the RPC `TransactionError` enum:\n *\n *   1. Follow the instructions in `./codes.ts` to add a corresponding Solana error code\n *   2. Add the `TransactionError` enum name in the same order as it appears in `./codes.ts`\n *   3. Add the new error name/code mapping to `./__tests__/transaction-error-test.ts`\n */\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'AccountInUse',\n    'AccountLoadedTwice',\n    'AccountNotFound',\n    'ProgramAccountNotFound',\n    'InsufficientFundsForFee',\n    'InvalidAccountForFee',\n    'AlreadyProcessed',\n    'BlockhashNotFound',\n    // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`\n    'CallChainTooDeep',\n    'MissingSignatureForFee',\n    'InvalidAccountIndex',\n    'SignatureFailure',\n    'InvalidProgramForExecution',\n    'SanitizeFailure',\n    'ClusterMaintenance',\n    'AccountBorrowOutstanding',\n    'WouldExceedMaxBlockCostLimit',\n    'UnsupportedVersion',\n    'InvalidWritableAccount',\n    'WouldExceedMaxAccountCostLimit',\n    'WouldExceedAccountDataBlockLimit',\n    'TooManyAccountLocks',\n    'AddressLookupTableNotFound',\n    'InvalidAddressLookupTableOwner',\n    'InvalidAddressLookupTableData',\n    'InvalidAddressLookupTableIndex',\n    'InvalidRentPayingAccount',\n    'WouldExceedMaxVoteCostLimit',\n    'WouldExceedAccountDataTotalLimit',\n    'DuplicateInstruction',\n    'InsufficientFundsForRent',\n    'MaxLoadedAccountsDataSizeExceeded',\n    'InvalidLoadedAccountsDataSizeLimit',\n    'ResanitizationNeeded',\n    'ProgramExecutionTemporarilyRestricted',\n    'UnbalancedTransaction',\n];\n\nexport function getSolanaErrorFromTransactionError(transactionError: string | { [key: string]: unknown }): SolanaError {\n    if (typeof transactionError === 'object' && 'InstructionError' in transactionError) {\n        return getSolanaErrorFromInstructionError(\n            ...(transactionError.InstructionError as Parameters<typeof getSolanaErrorFromInstructionError>),\n        );\n    }\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 7050001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        ...(rpcErrorContext !== undefined ? { transactionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {\n                    return {\n                        index: Number(rpcErrorContext as bigint | number),\n                    };\n                } else if (\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT ||\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n                ) {\n                    return {\n                        accountIndex: Number((rpcErrorContext as { account_index: bigint | number }).account_index),\n                    };\n                }\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: transactionError,\n        },\n        getSolanaErrorFromTransactionError,\n    );\n}\n", "import {\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,\n    SolanaErrorCode,\n} from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\nimport { getSolanaErrorFromTransactionError } from './transaction-error';\n\ninterface RpcErrorResponse {\n    code: bigint | number;\n    data?: unknown;\n    message: string;\n}\n\ntype TransactionError = string | { [key: string]: unknown };\n\n/**\n * Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-types/src/response.rs\n * @hidden\n */\nexport interface RpcSimulateTransactionResult {\n    accounts:\n        | ({\n              data:\n                  | string // LegacyBinary\n                  | {\n                        // Json\n                        parsed: unknown;\n                        program: string;\n                        space: number;\n                    }\n                  // Binary\n                  | [encodedBytes: string, encoding: 'base58' | 'base64' | 'base64+zstd' | 'binary' | 'jsonParsed'];\n              executable: boolean;\n              lamports: number;\n              owner: string;\n              rentEpoch: number;\n              space?: number;\n          } | null)[]\n        | null;\n    err: TransactionError | null;\n    // Enabled by `enable_cpi_recording`\n    innerInstructions?:\n        | {\n              index: number;\n              instructions: (\n                  | {\n                        // Compiled\n                        accounts: number[];\n                        data: string;\n                        programIdIndex: number;\n                        stackHeight?: number;\n                    }\n                  | {\n                        // Parsed\n                        parsed: unknown;\n                        program: string;\n                        programId: string;\n                        stackHeight?: number;\n                    }\n                  | {\n                        // PartiallyDecoded\n                        accounts: string[];\n                        data: string;\n                        programId: string;\n                        stackHeight?: number;\n                    }\n              )[];\n          }[]\n        | null;\n    logs: string[] | null;\n    replacementBlockhash: string | null;\n    returnData: {\n        data: [string, 'base64'];\n        programId: string;\n    } | null;\n    unitsConsumed: bigint | null;\n}\n\nexport function getSolanaErrorFromJsonRpcError(putativeErrorResponse: unknown): SolanaError {\n    let out: SolanaError;\n    if (isRpcErrorResponse(putativeErrorResponse)) {\n        const { code: rawCode, data, message } = putativeErrorResponse;\n        const code = Number(rawCode);\n        if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {\n            const { err, ...preflightErrorContext } = data as RpcSimulateTransactionResult;\n            const causeObject = err ? { cause: getSolanaErrorFromTransactionError(err) } : null;\n            out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {\n                ...preflightErrorContext,\n                ...causeObject,\n            });\n        } else {\n            let errorContext;\n            switch (code) {\n                case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:\n                case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:\n                case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:\n                case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:\n                case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:\n                    // The server supplies no structured data, but rather a pre-formatted message. Put\n                    // the server message in `context` so as not to completely lose the data. The long\n                    // term fix for this is to add data to the server responses and modify the\n                    // messages in `@solana/errors` to be actual format strings.\n                    errorContext = { __serverMessage: message };\n                    break;\n                default:\n                    if (typeof data === 'object' && !Array.isArray(data)) {\n                        errorContext = data;\n                    }\n            }\n            out = new SolanaError(code as SolanaErrorCode, errorContext as SolanaErrorContext[SolanaErrorCode]);\n        }\n    } else {\n        const message =\n            typeof putativeErrorResponse === 'object' &&\n            putativeErrorResponse !== null &&\n            'message' in putativeErrorResponse &&\n            typeof putativeErrorResponse.message === 'string'\n                ? putativeErrorResponse.message\n                : 'Malformed JSON-RPC error with no message attribute';\n        out = new SolanaError(SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR, { error: putativeErrorResponse, message });\n    }\n    safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);\n    return out;\n}\n\nfunction isRpcErrorResponse(value: unknown): value is RpcErrorResponse {\n    return (\n        typeof value === 'object' &&\n        value !== null &&\n        'code' in value &&\n        'message' in value &&\n        (typeof value.code === 'number' || typeof value.code === 'bigint') &&\n        typeof value.message === 'string'\n    );\n}\n", "import { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n *\n * @param byteArrays - The array of byte arrays to concatenate.\n *\n * @example\n * ```ts\n * const bytes1 = new Uint8Array([0x01, 0x02]);\n * const bytes2 = new Uint8Array([]);\n * const bytes3 = new Uint8Array([0x03, 0x04]);\n * const bytes = mergeBytes([bytes1, bytes2, bytes3]);\n * //    ^ [0x01, 0x02, 0x03, 0x04]\n * ```\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n *\n * @param bytes - The byte array to pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 2);\n * // bytes === paddedBytes\n * ```\n */\nexport const padBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array => {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n *\n * @param bytes - The byte array to truncate or pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Truncates the byte array to the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const fixedBytes = fixBytes(bytes, 2);\n * //    ^ [0x01, 0x02]\n * ```\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 2);\n * // bytes === fixedBytes\n * ```\n */\nexport const fixBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n\n/**\n * Returns true if and only if the provided `data` byte array contains\n * the provided `bytes` byte array at the specified `offset`.\n *\n * @param data - The byte sequence to search for.\n * @param bytes - The byte array in which to search for `data`.\n * @param offset - The position in `bytes` where the search begins.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const data = new Uint8Array([0x02, 0x03]);\n * containsBytes(bytes, data, 1); // true\n * containsBytes(bytes, data, 2); // false\n * ```\n */\nexport function containsBytes(\n    data: ReadonlyUint8Array | Uint8Array,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset: number,\n): boolean {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i) => b === slice[i]);\n}\n", "import {\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Defines an offset in bytes.\n */\nexport type Offset = number;\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * This is a common interface for {@link FixedSizeEncoder} and {@link VariableSizeEncoder}.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n */\ntype BaseEncoder<TFrom> = {\n    /** Encode the provided value and return the encoded bytes directly. */\n    readonly encode: (value: TFrom) => ReadonlyUint8Array;\n    /**\n     * Writes the encoded value into the provided byte array at the given offset.\n     * Returns the offset of the next byte after the encoded value.\n     */\n    readonly write: (value: TFrom, bytes: Uint8Array, offset: Offset) => Offset;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a fixed-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const encoder: FixedSizeEncoder<number, 4>;\n * const bytes = encoder.encode(42);\n * const size = encoder.fixedSize; // 4\n * ```\n *\n * @see {@link Encoder}\n * @see {@link VariableSizeEncoder}\n */\nexport type FixedSizeEncoder<TFrom, TSize extends number = number> = BaseEncoder<TFrom> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a variable-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * ```ts\n * const encoder: VariableSizeEncoder<string>;\n * const bytes = encoder.encode('hello');\n * const size = encoder.getSizeFromValue('hello');\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n */\nexport type VariableSizeEncoder<TFrom> = BaseEncoder<TFrom> & {\n    /** Returns the size of the encoded value in bytes for a given input. */\n    readonly getSizeFromValue: (value: TFrom) => number;\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * An `Encoder` can be either:\n * - A {@link FixedSizeEncoder}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeEncoder}, where encoded values can vary in size.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * Encoding a value into a new byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = encoder.encode('hello');\n * ```\n *\n * @example\n * Writing the encoded value into an existing byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = new Uint8Array(100);\n * const nextOffset = encoder.write('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Encoders` manually using the {@link createEncoder} function but it is more common\n * to compose multiple `Encoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Encoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructEncoder, addEncoderSizePrefix, getUtf8Encoder, getU32Encoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonEncoder = (): Encoder<Person> =>\n *     getStructEncoder([\n *         ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *         ['age', getU32Encoder()],\n *     ]);\n * ```\n *\n * Note that composed `Encoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Encoder()` is\n * a fixed-size encoder, while `addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())`\n * is a variable-size encoder. This makes the final `Person` encoder a variable-size encoder.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link createEncoder}\n */\nexport type Encoder<TFrom> = FixedSizeEncoder<TFrom> | VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * This is a common interface for {@link FixedSizeDecoder} and {@link VariableSizeDecoder}.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n */\ntype BaseDecoder<TTo> = {\n    /** Decodes the provided byte array at the given offset (or zero) and returns the value directly. */\n    readonly decode: (bytes: ReadonlyUint8Array | Uint8Array, offset?: Offset) => TTo;\n    /**\n     * Reads the encoded value from the provided byte array at the given offset.\n     * Returns the decoded value and the offset of the next byte after the encoded value.\n     */\n    readonly read: (bytes: ReadonlyUint8Array | Uint8Array, offset: Offset) => [TTo, Offset];\n};\n\n/**\n * An object that can decode a fixed-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const decoder: FixedSizeDecoder<number, 4>;\n * const value = decoder.decode(bytes);\n * const size = decoder.fixedSize; // 4\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type FixedSizeDecoder<TTo, TSize extends number = number> = BaseDecoder<TTo> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can decode a variable-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const decoder: VariableSizeDecoder<number>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type VariableSizeDecoder<TTo> = BaseDecoder<TTo> & {\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * An `Decoder` can be either:\n * - A {@link FixedSizeDecoder}, where all byte arrays have the same fixed size.\n * - A {@link VariableSizeDecoder}, where byte arrays can vary in size.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * Getting the decoded value from a byte array.\n * ```ts\n * const decoder: Decoder<string>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @example\n * Reading the decoded value from a byte array at a specific offset\n * and getting the offset of the next byte to read.\n * ```ts\n * const decoder: Decoder<string>;\n * const [value, nextOffset] = decoder.read('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Decoders` manually using the {@link createDecoder} function but it is more common\n * to compose multiple `Decoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Decoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructDecoder, addDecoderSizePrefix, getUtf8Decoder, getU32Decoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonDecoder = (): Decoder<Person> =>\n *     getStructDecoder([\n *         ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *         ['age', getU32Decoder()],\n *     ]);\n * ```\n *\n * Note that composed `Decoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Decoder()` is\n * a fixed-size decoder, while `addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())`\n * is a variable-size decoder. This makes the final `Person` decoder a variable-size decoder.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link createDecoder}\n */\nexport type Decoder<TTo> = FixedSizeDecoder<TTo> | VariableSizeDecoder<TTo>;\n\n/**\n * An object that can encode and decode a value to and from a fixed-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const codec: FixedSizeCodec<number | bigint, bigint, 8>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.fixedSize; // 8\n * ```\n *\n * @see {@link Codec}\n * @see {@link VariableSizeCodec}\n */\nexport type FixedSizeCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number> = FixedSizeDecoder<\n    TTo,\n    TSize\n> &\n    FixedSizeEncoder<TFrom, TSize>;\n\n/**\n * An object that can encode and decode a value to and from a variable-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec: VariableSizeCodec<number | bigint, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.getSizeFromValue(42);\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n */\nexport type VariableSizeCodec<TFrom, TTo extends TFrom = TFrom> = VariableSizeDecoder<TTo> & VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can encode and decode a value to and from a byte array.\n *\n * A `Codec` can be either:\n * - A {@link FixedSizeCodec}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeCodec}, where encoded values can vary in size.\n *\n * @example\n * ```ts\n * const codec: Codec<string>;\n * const bytes = codec.encode('hello');\n * const value = codec.decode(bytes); // 'hello'\n * ```\n *\n * @remarks\n * For convenience, codecs can encode looser types than they decode.\n * That is, type {@link TFrom} can be a superset of type {@link TTo}.\n * For instance, a `Codec<bigint | number, bigint>` can encode both\n * `bigint` and `number` values, but will always decode to a `bigint`.\n *\n * ```ts\n * const codec: Codec<bigint | number, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * It is worth noting that codecs are the union of encoders and decoders.\n * This means that a `Codec<TFrom, TTo>` can be combined from an `Encoder<TFrom>`\n * and a `Decoder<TTo>` using the {@link combineCodec} function. This is particularly\n * useful for library authors who want to expose all three types of objects to their users.\n *\n * ```ts\n * const encoder: Encoder<bigint | number>;\n * const decoder: Decoder<bigint>;\n * const codec: Codec<bigint | number, bigint> = combineCodec(encoder, decoder);\n * ```\n *\n * Aside from combining encoders and decoders, codecs can also be created from scratch using\n * the {@link createCodec} function but it is more common to compose multiple codecs together\n * using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create a `Codec` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructCodec, addCodecSizePrefix, getUtf8Codec, getU32Codec } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonCodec = (): Codec<Person> =>\n *     getStructCodec([\n *         ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *         ['age', getU32Codec()],\n *     ]);\n * ```\n *\n * Note that composed `Codec` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Codec()` is\n * a fixed-size codec, while `addCodecSizePrefix(getUtf8Codec(), getU32Codec())`\n * is a variable-size codec. This makes the final `Person` codec a variable-size codec.\n *\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link combineCodec}\n * @see {@link createCodec}\n */\nexport type Codec<TFrom, TTo extends TFrom = TFrom> = FixedSizeCodec<TFrom, TTo> | VariableSizeCodec<TFrom, TTo>;\n\n/**\n * Gets the encoded size of a given value in bytes using the provided encoder.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @param value - The value to be encoded.\n * @param encoder - The encoder used to determine the encoded size.\n * @returns The size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const fixedSizeEncoder = { fixedSize: 4 };\n * getEncodedSize(123, fixedSizeEncoder); // Returns 4.\n *\n * const variableSizeEncoder = { getSizeFromValue: (value: string) => value.length };\n * getEncodedSize(\"hello\", variableSizeEncoder); // Returns 5.\n * ```\n *\n * @see {@link Encoder}\n */\nexport function getEncodedSize<TFrom>(\n    value: TFrom,\n    encoder: { fixedSize: number } | { getSizeFromValue: (value: TFrom) => number },\n): number {\n    return 'fixedSize' in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\n\n/**\n * Creates an `Encoder` by filling in the missing `encode` function using the provided `write` function and\n * either the `fixedSize` property (for {@link FixedSizeEncoder | FixedSizeEncoders}) or\n * the `getSizeFromValue` function (for {@link VariableSizeEncoder | VariableSizeEncoders}).\n *\n * Instead of manually implementing `encode`, this utility leverages the existing `write` function\n * and the size helpers to generate a complete encoder. The provided `encode` method will allocate\n * a new `Uint8Array` of the correct size and use `write` to populate it.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size encoders).\n *\n * @param encoder - An encoder object that implements `write`, but not `encode`.\n * - If the encoder has a `fixedSize` property, it is treated as a {@link FixedSizeEncoder}.\n * - Otherwise, it is treated as a {@link VariableSizeEncoder}.\n *\n * @returns A fully functional `Encoder` with both `write` and `encode` methods.\n *\n * @example\n * Creating a custom fixed-size encoder.\n * ```ts\n * const encoder = createEncoder({\n *     fixedSize: 4,\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n * ```\n *\n * @example\n * Creating a custom variable-size encoder:\n * ```ts\n * const encoder = createEncoder({\n *     getSizeFromValue: (value: string) => value.length,\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = encoder.encode(\"hello\");\n * // 0x68656c6c6f\n * ```\n *\n * @remarks\n * Note that, while `createEncoder` is useful for defining more complex encoders, it is more common to compose\n * encoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createEncoder`.\n *\n * ```ts\n * // Fixed-size encoder for unsigned 32-bit integers.\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n *\n * // Variable-size encoder for 32-bytes prefixed UTF-8 strings.\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const bytes = encoder.encode(\"hello\");\n * // 0x0500000068656c6c6f\n *\n * // Variable-size encoder for custom objects.\n * type Person = { name: string; age: number };\n * const encoder: Encoder<Person> = getStructEncoder([\n *     ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *     ['age', getU32Encoder()],\n * ]);\n * const bytes = encoder.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link getStructEncoder}\n * @see {@link getU32Encoder}\n * @see {@link getUtf8Encoder}\n * @see {@link addEncoderSizePrefix}\n */\nexport function createEncoder<TFrom, TSize extends number>(\n    encoder: Omit<FixedSizeEncoder<TFrom, TSize>, 'encode'>,\n): FixedSizeEncoder<TFrom, TSize>;\nexport function createEncoder<TFrom>(encoder: Omit<VariableSizeEncoder<TFrom>, 'encode'>): VariableSizeEncoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom> {\n    return Object.freeze({\n        ...encoder,\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Creates a `Decoder` by filling in the missing `decode` function using the provided `read` function.\n *\n * Instead of manually implementing `decode`, this utility leverages the existing `read` function\n * and the size properties to generate a complete decoder. The provided `decode` method will read\n * from a `Uint8Array` at the given offset and return the decoded value.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeDecoder} will be created, otherwise\n * a {@link VariableSizeDecoder} will be created.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size decoders).\n *\n * @param decoder - A decoder object that implements `read`, but not `decode`.\n * - If the decoder has a `fixedSize` property, it is treated as a {@link FixedSizeDecoder}.\n * - Otherwise, it is treated as a {@link VariableSizeDecoder}.\n *\n * @returns A fully functional `Decoder` with both `read` and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size decoder.\n * ```ts\n * const decoder = createDecoder({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size decoder:\n * ```ts\n * const decoder = createDecoder({\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([104, 101, 108, 108, 111]));\n * // \"hello\"\n * ```\n *\n * @remarks\n * Note that, while `createDecoder` is useful for defining more complex decoders, it is more common to compose\n * decoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createDecoder`.\n *\n * ```ts\n * // Fixed-size decoder for unsigned 32-bit integers.\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n *\n * // Variable-size decoder for 32-bytes prefixed UTF-8 strings.\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const value = decoder.decode(new Uint8Array([5, 0, 0, 0, 104, 101, 108, 108, 111]));\n * // \"hello\"\n *\n * // Variable-size decoder for custom objects.\n * type Person = { name: string; age: number };\n * const decoder: Decoder<Person> = getStructDecoder([\n *     ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *     ['age', getU32Decoder()],\n * ]);\n * const value = decoder.decode(new Uint8Array([3, 0, 0, 0, 66, 111, 98, 42, 0, 0, 0]));\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Decoder}\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link getStructDecoder}\n * @see {@link getU32Decoder}\n * @see {@link getUtf8Decoder}\n * @see {@link addDecoderSizePrefix}\n */\nexport function createDecoder<TTo, TSize extends number>(\n    decoder: Omit<FixedSizeDecoder<TTo, TSize>, 'decode'>,\n): FixedSizeDecoder<TTo, TSize>;\nexport function createDecoder<TTo>(decoder: Omit<VariableSizeDecoder<TTo>, 'decode'>): VariableSizeDecoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo> {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0],\n    });\n}\n\n/**\n * Creates a `Codec` by filling in the missing `encode` and `decode` functions using the provided `write` and `read` functions.\n *\n * This utility combines the behavior of {@link createEncoder} and {@link createDecoder} to produce a fully functional `Codec`.\n * The `encode` method is derived from the `write` function, while the `decode` method is derived from the `read` function.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeCodec} will be created, otherwise\n * a {@link VariableSizeCodec} will be created.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param codec - A codec object that implements `write` and `read`, but not `encode` or `decode`.\n * - If the codec has a `fixedSize` property, it is treated as a {@link FixedSizeCodec}.\n * - Otherwise, it is treated as a {@link VariableSizeCodec}.\n *\n * @returns A fully functional `Codec` with `write`, `read`, `encode`, and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size codec.\n * ```ts\n * const codec = createCodec({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size codec:\n * ```ts\n * const codec = createCodec({\n *     getSizeFromValue: (value: string) => value.length,\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = codec.encode(\"hello\");\n * // 0x68656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n * ```\n *\n * @remarks\n * This function effectively combines the behavior of {@link createEncoder} and {@link createDecoder}.\n * If you only need to encode or decode (but not both), consider using those functions instead.\n *\n * Here are some alternative examples using codec primitives instead of `createCodec`.\n *\n * ```ts\n * // Fixed-size codec for unsigned 32-bit integers.\n * const codec = getU32Codec();\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n *\n * // Variable-size codec for 32-bytes prefixed UTF-8 strings.\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const bytes = codec.encode(\"hello\");\n * // 0x0500000068656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n *\n * // Variable-size codec for custom objects.\n * type Person = { name: string; age: number };\n * const codec: Codec<PersonInput, Person> = getStructCodec([\n *     ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *     ['age', getU32Codec()],\n * ]);\n * const bytes = codec.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * const value = codec.decode(bytes);\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link createEncoder}\n * @see {@link createDecoder}\n * @see {@link getStructCodec}\n * @see {@link getU32Codec}\n * @see {@link getUtf8Codec}\n * @see {@link addCodecSizePrefix}\n */\nexport function createCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number>(\n    codec: Omit<FixedSizeCodec<TFrom, TTo, TSize>, 'decode' | 'encode'>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec: Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo> {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is fixed-size.\n *\n * A fixed-size object is identified by the presence of a `fixedSize` property.\n * If this property exists, the object is considered a {@link FixedSizeCodec},\n * {@link FixedSizeEncoder}, or {@link FixedSizeDecoder}.\n * Otherwise, it is assumed to be a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is fixed-size, `false` otherwise.\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isFixedSize(encoder); // true\n * ```\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isFixedSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is commonly used to distinguish between fixed-size and variable-size objects at runtime.\n * If you need to enforce this distinction with type assertions, consider using {@link assertIsFixedSize}.\n *\n * @see {@link assertIsFixedSize}\n */\nexport function isFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function isFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): decoder is FixedSizeDecoder<TTo, TSize>;\nexport function isFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function isFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): codec is { fixedSize: TSize };\nexport function isFixedSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { fixedSize: number } {\n    return 'fixedSize' in codec && typeof codec.fixedSize === 'number';\n}\n\n/**\n * Asserts that the given codec, encoder, or decoder is fixed-size.\n *\n * If the object is not fixed-size (i.e., it lacks a `fixedSize` property),\n * this function throws a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @throws {SolanaError} If the object is not fixed-size.\n *\n * @example\n * Asserting a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * assertIsFixedSize(encoder); // Passes\n * ```\n *\n * @example\n * Attempting to assert a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * assertIsFixedSize(encoder); // Throws SolanaError\n * ```\n *\n * @remarks\n * This function is the assertion-based counterpart of {@link isFixedSize}.\n * If you only need to check whether an object is fixed-size without throwing an error, use {@link isFixedSize} instead.\n *\n * @see {@link isFixedSize}\n */\nexport function assertIsFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): asserts encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function assertIsFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): asserts decoder is FixedSizeDecoder<TTo, TSize>;\nexport function assertIsFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): asserts codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function assertIsFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): asserts codec is { fixedSize: TSize };\nexport function assertIsFixedSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { fixedSize: number } {\n    if (!isFixedSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is variable-size.\n *\n * A variable-size object is identified by the absence of a `fixedSize` property.\n * If this property is missing, the object is considered a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is variable-size, `false` otherwise.\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isVariableSize(encoder); // true\n * ```\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isVariableSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is the inverse of {@link isFixedSize}.\n *\n * @see {@link isFixedSize}\n * @see {@link assertIsVariableSize}\n */\nexport function isVariableSize<TFrom>(encoder: Encoder<TFrom>): encoder is VariableSizeEncoder<TFrom>;\nexport function isVariableSize<TTo>(decoder: Decoder<TTo>): decoder is VariableSizeDecoder<TTo>;\nexport function isVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): codec is VariableSizeCodec<TFrom, TTo>;\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number };\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number } {\n    return !isFixedSize(codec);\n}\n\n/**\n * Asserts that the given codec, encoder, or decoder is variable-size.\n *\n * If the object is not variable-size (i.e., it has a `fixedSize` property),\n * this function throws a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @throws {SolanaError} If the object is not variable-size.\n *\n * @example\n * Asserting a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * assertIsVariableSize(encoder); // Passes\n * ```\n *\n * @example\n * Attempting to assert a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * assertIsVariableSize(encoder); // Throws SolanaError\n * ```\n *\n * @remarks\n * This function is the assertion-based counterpart of {@link isVariableSize}.\n * If you only need to check whether an object is variable-size without throwing an error, use {@link isVariableSize} instead.\n *\n * Also note that this function is the inverse of {@link assertIsFixedSize}.\n *\n * @see {@link isVariableSize}\n * @see {@link assertIsFixedSize}\n */\nexport function assertIsVariableSize<TFrom>(encoder: Encoder<TFrom>): asserts encoder is VariableSizeEncoder<TFrom>;\nexport function assertIsVariableSize<TTo>(decoder: Decoder<TTo>): asserts decoder is VariableSizeDecoder<TTo>;\nexport function assertIsVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): asserts codec is VariableSizeCodec<TFrom, TTo>;\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number };\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number } {\n    if (!isVariableSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\n", "import {\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    Codec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Combines an `Encoder` and a `Decoder` into a `Codec`.\n *\n * That is, given a `Encoder<TFrom>` and a `Decoder<TTo>`, this function returns a `Codec<TFrom, TTo>`.\n *\n * This allows for modular composition by keeping encoding and decoding logic separate\n * while still offering a convenient way to bundle them into a single `Codec`.\n * This is particularly useful for library maintainers who want to expose `Encoders`,\n * `Decoders`, and `Codecs` separately, enabling tree-shaking of unused logic.\n *\n * The provided `Encoder` and `Decoder` must be compatible in terms of:\n * - **Fixed Size:** If both are fixed-size, they must have the same `fixedSize` value.\n * - **Variable Size:** If either has a `maxSize` attribute, it must match the other.\n *\n * If these conditions are not met, a {@link SolanaError} will be thrown.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param encoder - The `Encoder` to combine.\n * @param decoder - The `Decoder` to combine.\n * @returns A `Codec` that provides both `encode` and `decode` methods.\n *\n * @throws {SolanaError}\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH`\n *   Thrown if the encoder and decoder have mismatched size types (fixed vs. variable).\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH`\n *   Thrown if both are fixed-size but have different `fixedSize` values.\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH`\n *   Thrown if the `maxSize` attributes do not match.\n *\n * @example\n * Creating a fixed-size `Codec` from an encoder and a decoder.\n * ```ts\n * const encoder = getU32Encoder();\n * const decoder = getU32Decoder();\n * const codec = combineCodec(encoder, decoder);\n *\n * const bytes = codec.encode(42); // 0x2a000000\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Creating a variable-size `Codec` from an encoder and a decoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const codec = combineCodec(encoder, decoder);\n *\n * const bytes = codec.encode(\"hello\"); // 0x0500000068656c6c6f\n * const value = codec.decode(bytes); // \"hello\"\n * ```\n *\n * @remarks\n * The recommended pattern for defining codecs in libraries is to expose separate functions for the encoder, decoder, and codec.\n * This allows users to import only what they need, improving tree-shaking efficiency.\n *\n * ```ts\n * type MyType = \\/* ... *\\/;\n * const getMyTypeEncoder = (): Encoder<MyType> => { \\/* ... *\\/ };\n * const getMyTypeDecoder = (): Decoder<MyType> => { \\/* ... *\\/ };\n * const getMyTypeCodec = (): Codec<MyType> =>\n *     combineCodec(getMyTypeEncoder(), getMyTypeDecoder());\n * ```\n *\n * @see {@link Codec}\n * @see {@link Encoder}\n * @see {@link Decoder}\n */\nexport function combineCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: VariableSizeEncoder<TFrom>,\n    decoder: VariableSizeDecoder<TTo>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo> {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize,\n        });\n    }\n\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize,\n        });\n    }\n\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write,\n    };\n}\n", "import {\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SolanaError,\n} from '@solana/errors';\n\nimport { containsBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Creates an encoder that writes a `Uint8Array` sentinel after the encoded value.\n * This is useful to delimit the encoded value when being read by a decoder.\n *\n * See {@link addCodecSentinel} for more information.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link addCodecSentinel}\n */\nexport function addEncoderSentinel<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(\n    encoder: Encoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(encoder: Encoder<TFrom>, sentinel: ReadonlyUint8Array): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds\n        // and to avoid writing the sentinel as part of the encoded value.\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });\n    }\n\n    return createEncoder({\n        ...encoder,\n        ...(encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {}),\n        getSizeFromValue: value => encoder.getSizeFromValue(value) + sentinel.length,\n        write,\n    });\n}\n\n/**\n * Creates a decoder that continues reading until\n * a given `Uint8Array` sentinel is found.\n *\n * See {@link addCodecSentinel} for more information.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link addCodecSentinel}\n */\nexport function addDecoderSentinel<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): VariableSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds\n        // and ensure that the sentinel is not part of the decoded value.\n        return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });\n    }\n\n    return createDecoder({\n        ...decoder,\n        ...(decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {}),\n        read,\n    });\n}\n\n/**\n * Creates a Codec that writes a given `Uint8Array` sentinel after the encoded\n * value and, when decoding, continues reading until the sentinel is found.\n *\n * This sets a limit on variable-size codecs and tells us when to stop decoding.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec = addCodecSentinel(getUtf8Codec(), new Uint8Array([255, 255]));\n * codec.encode('hello');\n * // 0x68656c6c6fffff\n * //   |        └-- Our sentinel.\n * //   └-- Our encoded string.\n * ```\n *\n * @remarks\n * Note that the sentinel _must not_ be present in the encoded data and\n * _must_ be present in the decoded data for this to work.\n * If this is not the case, dedicated errors will be thrown.\n *\n * ```ts\n * const sentinel = new Uint8Array([108, 108]); // 'll'\n * const codec = addCodecSentinel(getUtf8Codec(), sentinel);\n *\n * codec.encode('hello'); // Throws: sentinel is in encoded data.\n * codec.decode(new Uint8Array([1, 2, 3])); // Throws: sentinel missing in decoded data.\n * ```\n *\n * Separate {@link addEncoderSentinel} and {@link addDecoderSentinel} functions are also available.\n *\n * ```ts\n * const bytes = addEncoderSentinel(getUtf8Encoder(), sentinel).encode('hello');\n * const value = addDecoderSentinel(getUtf8Decoder(), sentinel).decode(bytes);\n * ```\n *\n * @see {@link addEncoderSentinel}\n * @see {@link addDecoderSentinel}\n */\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\n\nfunction findSentinelIndex(bytes: ReadonlyUint8Array, sentinel: ReadonlyUint8Array) {\n    return bytes.findIndex((byte, index, arr) => {\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\n\nfunction hexBytes(bytes: ReadonlyUint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n", "import {\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Asserts that a given byte array is not empty (after the optional provided offset).\n *\n * Returns void if the byte array is not empty but throws a {@link SolanaError} otherwise.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param bytes - The byte array to check.\n * @param offset - The offset from which to start checking the byte array.\n * If provided, the byte array is considered empty if it has no bytes after the offset.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes); // OK\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes, 1); // OK\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes, 3); // Throws\n * ```\n */\nexport function assertByteArrayIsNotEmptyForCodec(\n    codecDescription: string,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    if (bytes.length - offset <= 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription,\n        });\n    }\n}\n\n/**\n * Asserts that a given byte array has enough bytes to decode\n * (after the optional provided offset).\n *\n * Returns void if the byte array has at least the expected number\n * of bytes but throws a {@link SolanaError} otherwise.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param expected - The minimum number of bytes expected in the byte array.\n * @param bytes - The byte array to check.\n * @param offset - The offset from which to start checking the byte array.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 3, bytes); // OK\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 4, bytes); // Throws\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 2, bytes, 1); // OK\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 3, bytes, 1); // Throws\n * ```\n */\nexport function assertByteArrayHasEnoughBytesForCodec(\n    codecDescription: string,\n    expected: number,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected,\n        });\n    }\n}\n\n/**\n * Asserts that a given offset is within the byte array bounds.\n * This range is between 0 and the byte array length and is inclusive.\n * An offset equals to the byte array length is considered a valid offset\n * as it allows the post-offset of codecs to signal the end of the byte array.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param offset - The offset to check.\n * @param bytesLength - The length of the byte array from which the offset should be within bounds.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 0, bytes.length); // OK\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 3, bytes.length); // OK\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 4, bytes.length); // Throws\n * ```\n */\nexport function assertByteArrayOffsetIsNotOutOfRange(codecDescription: string, offset: number, bytesLength: number) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset,\n        });\n    }\n}\n", "import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\ntype NumberEncoder = Encoder<bigint | number> | Encoder<number>;\ntype FixedSizeNumberEncoder<TSize extends number = number> =\n    | FixedSizeEncoder<bigint | number, TSize>\n    | FixedSizeEncoder<number, TSize>;\ntype NumberDecoder = Decoder<bigint> | Decoder<number>;\ntype FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\ntype NumberCodec = Codec<bigint | number, bigint> | Codec<number>;\ntype FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<number, number, TSize>;\n\n/**\n * Stores the size of the `encoder` in bytes as a prefix using the `prefix` encoder.\n *\n * See {@link addCodecSizePrefix} for more information.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link addCodecSizePrefix}\n */\nexport function addEncoderSizePrefix<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefix: FixedSizeNumberEncoder,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): VariableSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds.\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : (encoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n\n    return createEncoder({\n        ...encoder,\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: value => {\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write,\n    });\n}\n\n/**\n * Bounds the size of the nested `decoder` by reading its encoded `prefix`.\n *\n * See {@link addCodecSizePrefix} for more information.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link addCodecSizePrefix}\n */\nexport function addDecoderSizePrefix<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefix: FixedSizeNumberDecoder,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): VariableSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        // Slice the byte array to the contained size if necessary.\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec('addDecoderSizePrefix', size, bytes);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds.\n        return [decoder.decode(bytes), offset + size];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : (decoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({ ...decoder, ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Stores the byte size of any given codec as an encoded number prefix.\n *\n * This sets a limit on variable-size codecs and tells us when to stop decoding.\n * When encoding, the size of the encoded data is stored before the encoded data itself.\n * When decoding, the size is read first to know how many bytes to read next.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * For example, say we want to bound a variable-size base-58 string using a `u32` size prefix.\n * Here’s how you can use the `addCodecSizePrefix` function to achieve that.\n *\n * ```ts\n * const getU32Base58Codec = () => addCodecSizePrefix(getBase58Codec(), getU32Codec());\n *\n * getU32Base58Codec().encode('hello world');\n * // 0x0b00000068656c6c6f20776f726c64\n * //   |       └-- Our encoded base-58 string.\n * //   └-- Our encoded u32 size prefix.\n * ```\n *\n * @remarks\n * Separate {@link addEncoderSizePrefix} and {@link addDecoderSizePrefix} functions are also available.\n *\n * ```ts\n * const bytes = addEncoderSizePrefix(getBase58Encoder(), getU32Encoder()).encode('hello');\n * const value = addDecoderSizePrefix(getBase58Decoder(), getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link addEncoderSizePrefix}\n * @see {@link addDecoderSizePrefix}\n */\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefix: FixedSizeNumberCodec,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n", "import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport { fixBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    Offset,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Creates a fixed-size encoder from a given encoder.\n *\n * The resulting encoder ensures that encoded values always have the specified number of bytes.\n * If the original encoded value is larger than `fixedBytes`, it is truncated.\n * If it is smaller, it is padded with trailing zeroes.\n *\n * For more details, see {@link fixCodecSize}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param encoder - The encoder to wrap into a fixed-size encoder.\n * @param fixedBytes - The fixed number of bytes to write.\n * @returns A `FixedSizeEncoder` that ensures a consistent output size.\n *\n * @example\n * ```ts\n * const encoder = fixEncoderSize(getUtf8Encoder(), 4);\n * encoder.encode(\"Hello\"); // 0x48656c6c (truncated)\n * encoder.encode(\"Hi\");    // 0x48690000 (padded)\n * encoder.encode(\"Hiya\");  // 0x48697961 (same length)\n * ```\n *\n * @remarks\n * If you need a full codec with both encoding and decoding, use {@link fixCodecSize}.\n *\n * @see {@link fixCodecSize}\n * @see {@link fixDecoderSize}\n */\nexport function fixEncoderSize<TFrom, TSize extends number>(\n    encoder: Encoder<TFrom>,\n    fixedBytes: TSize,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value: TFrom, bytes: Uint8Array, offset: Offset) => {\n            // Here we exceptionally use the `encode` function instead of the `write`\n            // function as using the nested `write` function on a fixed-sized byte\n            // array may result in a out-of-bounds error on the nested encoder.\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray =\n                variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        },\n    });\n}\n\n/**\n * Creates a fixed-size decoder from a given decoder.\n *\n * The resulting decoder always reads exactly `fixedBytes` bytes from the input.\n * If the nested decoder is also fixed-size, the bytes are truncated or padded as needed.\n *\n * For more details, see {@link fixCodecSize}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param decoder - The decoder to wrap into a fixed-size decoder.\n * @param fixedBytes - The fixed number of bytes to read.\n * @returns A `FixedSizeDecoder` that ensures a consistent input size.\n *\n * @example\n * ```ts\n * const decoder = fixDecoderSize(getUtf8Decoder(), 4);\n * decoder.decode(new Uint8Array([72, 101, 108, 108, 111])); // \"Hell\" (truncated)\n * decoder.decode(new Uint8Array([72, 105, 0, 0]));          // \"Hi\" (zeroes ignored)\n * decoder.decode(new Uint8Array([72, 105, 121, 97]));       // \"Hiya\" (same length)\n * ```\n *\n * @remarks\n * If you need a full codec with both encoding and decoding, use {@link fixCodecSize}.\n *\n * @see {@link fixCodecSize}\n * @see {@link fixEncoderSize}\n */\nexport function fixDecoderSize<TTo, TSize extends number>(\n    decoder: Decoder<TTo>,\n    fixedBytes: TSize,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset) => {\n            assertByteArrayHasEnoughBytesForCodec('fixCodecSize', fixedBytes, bytes, offset);\n            // Slice the byte array to the fixed size if necessary.\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            // If the nested decoder is fixed-size, pad and truncate the byte array accordingly.\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            // Decode the value using the nested decoder.\n            const [value] = decoder.read(bytes, 0);\n            return [value, offset + fixedBytes];\n        },\n    });\n}\n\n/**\n * Creates a fixed-size codec from a given codec.\n *\n * The resulting codec ensures that both encoding and decoding operate on a fixed number of bytes.\n * When encoding:\n * - If the encoded value is larger than `fixedBytes`, it is truncated.\n * - If it is smaller, it is padded with trailing zeroes.\n * - If it is exactly `fixedBytes`, it remains unchanged.\n *\n * When decoding:\n * - Exactly `fixedBytes` bytes are read from the input.\n * - If the nested decoder has a smaller fixed size, bytes are truncated or padded as necessary.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param codec - The codec to wrap into a fixed-size codec.\n * @param fixedBytes - The fixed number of bytes to read/write.\n * @returns A `FixedSizeCodec` that ensures both encoding and decoding conform to a fixed size.\n *\n * @example\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 4);\n *\n * const bytes1 = codec.encode(\"Hello\"); // 0x48656c6c (truncated)\n * const value1 = codec.decode(bytes1);  // \"Hell\"\n *\n * const bytes2 = codec.encode(\"Hi\");    // 0x48690000 (padded)\n * const value2 = codec.decode(bytes2);  // \"Hi\"\n *\n * const bytes3 = codec.encode(\"Hiya\");  // 0x48697961 (same length)\n * const value3 = codec.decode(bytes3);  // \"Hiya\"\n * ```\n *\n * @remarks\n * If you only need to enforce a fixed size for encoding, use {@link fixEncoderSize}.\n * If you only need to enforce a fixed size for decoding, use {@link fixDecoderSize}.\n *\n * ```ts\n * const bytes = fixEncoderSize(getUtf8Encoder(), 4).encode(\"Hiya\");\n * const value = fixDecoderSize(getUtf8Decoder(), 4).decode(bytes);\n * ```\n *\n * @see {@link fixEncoderSize}\n * @see {@link fixDecoderSize}\n */\nexport function fixCodecSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: Codec<TFrom, TTo>,\n    fixedBytes: TSize,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n", "import { assertByteArrayOffsetIsNotOutOfRange } from './assertions';\nimport { Codec, createDecoder, createEncoder, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Configuration object for modifying the offset of an encoder, decoder, or codec.\n *\n * This type defines optional functions for adjusting the **pre-offset** (before encoding/decoding)\n * and the **post-offset** (after encoding/decoding). These functions allow precise control\n * over where data is written or read within a byte array.\n *\n * @property preOffset - A function that modifies the offset before encoding or decoding.\n * @property postOffset - A function that modifies the offset after encoding or decoding.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * };\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const config: OffsetConfig = {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * };\n * ```\n *\n * @example\n * Using both pre-offset and post-offset together.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n *     postOffset: ({ postOffset }) => postOffset + 4,\n * };\n * ```\n *\n * @see {@link offsetEncoder}\n * @see {@link offsetDecoder}\n * @see {@link offsetCodec}\n */\ntype OffsetConfig = {\n    postOffset?: PostOffsetFunction;\n    preOffset?: PreOffsetFunction;\n};\n\n/**\n * Scope provided to the `preOffset` and `postOffset` functions,\n * containing contextual information about the current encoding or decoding process.\n *\n * The pre-offset function modifies where encoding or decoding begins,\n * while the post-offset function modifies where the next operation continues.\n *\n * @property bytes - The entire byte array being encoded or decoded.\n * @property preOffset - The original offset before encoding or decoding starts.\n * @property wrapBytes - A helper function that wraps offsets around the byte array length.\n *\n * @example\n * Using `wrapBytes` to wrap a negative offset to the end of the byte array.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves to last 4 bytes\n * };\n * ```\n *\n * @example\n * Adjusting the offset dynamically based on the byte array size.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ bytes }) => bytes.length > 10 ? 4 : 2,\n * };\n * ```\n *\n * @see {@link PreOffsetFunction}\n * @see {@link PostOffsetFunction}\n */\ntype PreOffsetFunctionScope = {\n    /** The entire byte array. */\n    bytes: ReadonlyUint8Array | Uint8Array;\n    /** The original offset prior to encode or decode. */\n    preOffset: Offset;\n    /** Wraps the offset to the byte array length. */\n    wrapBytes: (offset: Offset) => Offset;\n};\n\n/**\n * A function that modifies the pre-offset before encoding or decoding.\n *\n * This function is used to adjust the starting position before writing\n * or reading data in a byte array.\n *\n * @param scope - The current encoding or decoding context.\n * @returns The new offset at which encoding or decoding should start.\n *\n * @example\n * Skipping the first 2 bytes before writing or reading.\n * ```ts\n * const preOffset: PreOffsetFunction = ({ preOffset }) => preOffset + 2;\n * ```\n *\n * @example\n * Wrapping the offset to ensure it stays within bounds.\n * ```ts\n * const preOffset: PreOffsetFunction = ({ wrapBytes, preOffset }) => wrapBytes(preOffset + 10);\n * ```\n *\n * @see {@link OffsetConfig}\n * @see {@link PreOffsetFunctionScope}\n */\ntype PreOffsetFunction = (scope: PreOffsetFunctionScope) => Offset;\n\n/**\n * A function that modifies the post-offset after encoding or decoding.\n *\n * This function adjusts where the next encoder or decoder should start\n * after the current operation has completed.\n *\n * @param scope - The current encoding or decoding context, including the modified pre-offset\n * and the original post-offset.\n * @returns The new offset at which the next operation should begin.\n *\n * @example\n * Moving the post-offset forward by 4 bytes.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ postOffset }) => postOffset + 4;\n * ```\n *\n * @example\n * Wrapping the post-offset within the byte array length.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ wrapBytes, postOffset }) => wrapBytes(postOffset);\n * ```\n *\n * @example\n * Ensuring a minimum spacing of 8 bytes between values.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ postOffset, newPreOffset }) =>\n *     Math.max(postOffset, newPreOffset + 8);\n * ```\n *\n * @see {@link OffsetConfig}\n * @see {@link PreOffsetFunctionScope}\n */\ntype PostOffsetFunction = (\n    scope: PreOffsetFunctionScope & {\n        /** The modified offset used to encode or decode. */\n        newPreOffset: Offset;\n        /** The original offset returned by the encoder or decoder. */\n        postOffset: Offset;\n    },\n) => Offset;\n\n/**\n * Moves the offset of a given encoder before and/or after encoding.\n *\n * This function allows an encoder to write its encoded value at a different offset\n * than the one originally provided. It supports both pre-offset adjustments\n * (before encoding) and post-offset adjustments (after encoding).\n *\n * The pre-offset function determines where encoding should start, while the\n * post-offset function adjusts where the next encoder should continue writing.\n *\n * For more details, see {@link offsetCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new encoder with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * encoder.write(42, bytes, 0); // Actually written at offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * const nextOffset = encoder.write(42, bytes, 0); // Next encoder starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to ensure an offset wraps around the byte array length.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes of the array\n * });\n * const bytes = new Uint8Array(10);\n * encoder.write(42, bytes, 0); // Writes at bytes.length - 4\n * ```\n *\n * @remarks\n * If you need both encoding and decoding offsets to be adjusted, use {@link offsetCodec}.\n *\n * @see {@link offsetCodec}\n * @see {@link offsetDecoder}\n */\nexport function offsetEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, config: OffsetConfig): TEncoder {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPostOffset, bytes.length);\n            return newPostOffset;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Moves the offset of a given decoder before and/or after decoding.\n *\n * This function allows a decoder to read its input from a different offset\n * than the one originally provided. It supports both pre-offset adjustments\n * (before decoding) and post-offset adjustments (after decoding).\n *\n * The pre-offset function determines where decoding should start, while the\n * post-offset function adjusts where the next decoder should continue reading.\n *\n * For more details, see {@link offsetCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new decoder with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array([0, 0, 42, 0]); // Value starts at offset 2\n * decoder.read(bytes, 0); // Actually reads from offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array([42, 0, 0, 0]);\n * const [value, nextOffset] = decoder.read(bytes, 0); // Next decoder starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to read from the last 4 bytes of an array.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes of the array\n * });\n * const bytes = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 42]); // Value stored at the last 4 bytes\n * decoder.read(bytes, 0); // Reads from bytes.length - 4\n * ```\n *\n * @remarks\n * If you need both encoding and decoding offsets to be adjusted, use {@link offsetCodec}.\n *\n * @see {@link offsetCodec}\n * @see {@link offsetEncoder}\n */\nexport function offsetDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, config: OffsetConfig): TDecoder {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPostOffset, bytes.length);\n            return [value, newPostOffset];\n        },\n    }) as TDecoder;\n}\n\n/**\n * Moves the offset of a given codec before and/or after encoding and decoding.\n *\n * This function allows a codec to encode and decode values at custom offsets\n * within a byte array. It modifies both the **pre-offset** (where encoding/decoding starts)\n * and the **post-offset** (where the next operation should continue).\n *\n * This is particularly useful when working with structured binary formats\n * that require skipping reserved bytes, inserting padding, or aligning fields at\n * specific locations.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new codec with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes when encoding and decoding.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0); // Actually written at offset 2\n * codec.read(bytes, 0);      // Actually read from offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes when encoding and decoding.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0);\n * // Next encoding starts at offset 6 instead of 4\n * codec.read(bytes, 0);\n * // Next decoding starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to loop around negative offsets.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0); // Writes at bytes.length - 4\n * codec.read(bytes, 0); // Reads from bytes.length - 4\n * ```\n *\n * @remarks\n * If you only need to adjust offsets for encoding, use {@link offsetEncoder}.\n * If you only need to adjust offsets for decoding, use {@link offsetDecoder}.\n *\n * ```ts\n * const bytes = new Uint8Array(10);\n * offsetEncoder(getU32Encoder(), { preOffset: ({ preOffset }) => preOffset + 2 }).write(42, bytes, 0);\n * const [value] = offsetDecoder(getU32Decoder(), { preOffset: ({ preOffset }) => preOffset + 2 }).read(bytes, 0);\n * ```\n *\n * @see {@link offsetEncoder}\n * @see {@link offsetDecoder}\n */\nexport function offsetCodec<TCodec extends AnyCodec>(codec: TCodec, config: OffsetConfig): TCodec {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config)) as TCodec;\n}\n\n/** A modulo function that handles negative dividends and zero divisors. */\nfunction modulo(dividend: number, divisor: number) {\n    if (divisor === 0) return 0;\n    return ((dividend % divisor) + divisor) % divisor;\n}\n", "import { SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Updates the size of a given encoder.\n *\n * This function modifies the size of an encoder using a provided transformation function.\n * For fixed-size encoders, it updates the `fixedSize` property, and for variable-size\n * encoders, it adjusts the size calculation based on the encoded value.\n *\n * If the new size is negative, an error will be thrown.\n *\n * For more details, see {@link resizeCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The original fixed size of the encoded value.\n * @typeParam TNewSize - The new fixed size after resizing.\n *\n * @param encoder - The encoder whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new encoder with the updated size.\n *\n * @example\n * Increasing the size of a `u16` encoder by 2 bytes.\n * ```ts\n * const encoder = resizeEncoder(getU16Encoder(), size => size + 2);\n * encoder.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * ```\n *\n * @example\n * Shrinking a `u32` encoder to only use 2 bytes.\n * ```ts\n * const encoder = resizeEncoder(getU32Encoder(), () => 2);\n * encoder.fixedSize; // 2\n * ```\n *\n * @see {@link resizeCodec}\n * @see {@link resizeDecoder}\n */\nexport function resizeEncoder<TFrom, TSize extends number, TNewSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeEncoder<TFrom, TNewSize>;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeEncoder',\n            });\n        }\n        return createEncoder({ ...encoder, fixedSize }) as TEncoder;\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: value => {\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: 'resizeEncoder',\n                });\n            }\n            return newSize;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Updates the size of a given decoder.\n *\n * This function modifies the size of a decoder using a provided transformation function.\n * For fixed-size decoders, it updates the `fixedSize` property to reflect the new size.\n * Variable-size decoders remain unchanged, as their size is determined dynamically.\n *\n * If the new size is negative, an error will be thrown.\n *\n * For more details, see {@link resizeCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The original fixed size of the decoded value.\n * @typeParam TNewSize - The new fixed size after resizing.\n *\n * @param decoder - The decoder whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new decoder with the updated size.\n *\n * @example\n * Expanding a `u16` decoder to read 4 bytes instead of 2.\n * ```ts\n * const decoder = resizeDecoder(getU16Decoder(), size => size + 2);\n * decoder.fixedSize; // 4\n * ```\n *\n * @example\n * Shrinking a `u32` decoder to only read 2 bytes.\n * ```ts\n * const decoder = resizeDecoder(getU32Decoder(), () => 2);\n * decoder.fixedSize; // 2\n * ```\n *\n * @see {@link resizeCodec}\n * @see {@link resizeEncoder}\n */\nexport function resizeDecoder<TFrom, TSize extends number, TNewSize extends number>(\n    decoder: FixedSizeDecoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeDecoder<TFrom, TNewSize>;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeDecoder',\n            });\n        }\n        return createDecoder({ ...decoder, fixedSize }) as TDecoder;\n    }\n    return decoder;\n}\n\n/**\n * Updates the size of a given codec.\n *\n * This function modifies the size of both the codec using a provided\n * transformation function. It is useful for adjusting the allocated byte size for\n * encoding and decoding without altering the underlying data structure.\n *\n * If the new size is negative, an error will be thrown.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The original fixed size of the encoded/decoded value (for fixed-size codecs).\n * @typeParam TNewSize - The new fixed size after resizing (for fixed-size codecs).\n *\n * @param codec - The codec whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new codec with the updated size.\n *\n * @example\n * Expanding a `u16` codec from 2 to 4 bytes.\n * ```ts\n * const codec = resizeCodec(getU16Codec(), size => size + 2);\n * const bytes = codec.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * const value = codec.decode(bytes);  // 0xffff (reads original two bytes)\n * ```\n *\n * @example\n * Shrinking a `u32` codec to only use 2 bytes.\n * ```ts\n * const codec = resizeCodec(getU32Codec(), () => 2);\n * codec.fixedSize; // 2\n * ```\n *\n * @remarks\n * If you only need to resize an encoder, use {@link resizeEncoder}.\n * If you only need to resize a decoder, use {@link resizeDecoder}.\n *\n * ```ts\n * const bytes = resizeEncoder(getU32Encoder(), (size) => size + 2).encode(0xffff);\n * const value = resizeDecoder(getU32Decoder(), (size) => size + 2).decode(bytes);\n * ```\n *\n * @see {@link resizeEncoder}\n * @see {@link resizeDecoder}\n */\nexport function resizeCodec<TFrom, TTo extends TFrom, TSize extends number, TNewSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeCodec<TFrom, TTo, TNewSize>;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize)) as TCodec;\n}\n", "import { Codec, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { offsetDecoder, offsetEncoder } from './offset-codec';\nimport { resizeDecoder, resizeEncoder } from './resize-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Adds left padding to the given encoder, shifting the encoded value forward\n * by `offset` bytes whilst increasing the size of the encoder accordingly.\n *\n * For more details, see {@link padLeftCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to pad.\n * @param offset - The number of padding bytes to add before encoding.\n * @returns A new encoder with left padding applied.\n *\n * @example\n * ```ts\n * const encoder = padLeftEncoder(getU16Encoder(), 2);\n * const bytes = encoder.encode(0xffff); // 0x0000ffff (0xffff written at offset 2)\n * ```\n *\n * @see {@link padLeftCodec}\n * @see {@link padLeftDecoder}\n */\nexport function padLeftEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given encoder, extending the encoded value by `offset`\n * bytes whilst increasing the size of the encoder accordingly.\n *\n * For more details, see {@link padRightCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to pad.\n * @param offset - The number of padding bytes to add after encoding.\n * @returns A new encoder with right padding applied.\n *\n * @example\n * ```ts\n * const encoder = padRightEncoder(getU16Encoder(), 2);\n * const bytes = encoder.encode(0xffff); // 0xffff0000 (two extra bytes added at the end)\n * ```\n *\n * @see {@link padRightCodec}\n * @see {@link padRightDecoder}\n */\nexport function padRightEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given decoder, shifting the decoding position forward\n * by `offset` bytes whilst increasing the size of the decoder accordingly.\n *\n * For more details, see {@link padLeftCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to pad.\n * @param offset - The number of padding bytes to skip before decoding.\n * @returns A new decoder with left padding applied.\n *\n * @example\n * ```ts\n * const decoder = padLeftDecoder(getU16Decoder(), 2);\n * const value = decoder.decode(new Uint8Array([0, 0, 0x12, 0x34])); // 0xffff (reads from offset 2)\n * ```\n *\n * @see {@link padLeftCodec}\n * @see {@link padLeftEncoder}\n */\nexport function padLeftDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given decoder, extending the post-offset by `offset`\n * bytes whilst increasing the size of the decoder accordingly.\n *\n * For more details, see {@link padRightCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to pad.\n * @param offset - The number of padding bytes to skip after decoding.\n * @returns A new decoder with right padding applied.\n *\n * @example\n * ```ts\n * const decoder = padRightDecoder(getU16Decoder(), 2);\n * const value = decoder.decode(new Uint8Array([0x12, 0x34, 0, 0])); // 0xffff (ignores trailing bytes)\n * ```\n *\n * @see {@link padRightCodec}\n * @see {@link padRightEncoder}\n */\nexport function padRightDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given codec, shifting the encoding and decoding positions\n * forward by `offset` bytes whilst increasing the size of the codec accordingly.\n *\n * This ensures that values are read and written at a later position in the byte array,\n * while the padding bytes remain unused.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to pad.\n * @param offset - The number of padding bytes to add before encoding and decoding.\n * @returns A new codec with left padding applied.\n *\n * @example\n * ```ts\n * const codec = padLeftCodec(getU16Codec(), 2);\n * const bytes = codec.encode(0xffff); // 0x0000ffff (0xffff written at offset 2)\n * const value = codec.decode(bytes);  // 0xffff (reads from offset 2)\n * ```\n *\n * @remarks\n * If you only need to apply padding for encoding, use {@link padLeftEncoder}.\n * If you only need to apply padding for decoding, use {@link padLeftDecoder}.\n *\n * ```ts\n * const bytes = padLeftEncoder(getU16Encoder(), 2).encode(0xffff);\n * const value = padLeftDecoder(getU16Decoder(), 2).decode(bytes);\n * ```\n *\n * @see {@link padLeftEncoder}\n * @see {@link padLeftDecoder}\n */\nexport function padLeftCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset)) as TCodec;\n}\n\n/**\n * Adds right padding to the given codec, extending the encoded and decoded value\n * by `offset` bytes whilst increasing the size of the codec accordingly.\n *\n * The extra bytes remain unused, ensuring that the next operation starts further\n * along the byte array.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to pad.\n * @param offset - The number of padding bytes to add after encoding and decoding.\n * @returns A new codec with right padding applied.\n *\n * @example\n * ```ts\n * const codec = padRightCodec(getU16Codec(), 2);\n * const bytes = codec.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * const value = codec.decode(bytes);  // 0xffff (ignores padding bytes)\n * ```\n *\n * @remarks\n * If you only need to apply padding for encoding, use {@link padRightEncoder}.\n * If you only need to apply padding for decoding, use {@link padRightDecoder}.\n *\n * ```ts\n * const bytes = padRightEncoder(getU16Encoder(), 2).encode(0xffff);\n * const value = padRightDecoder(getU16Decoder(), 2).decode(bytes);\n * ```\n *\n * @see {@link padRightEncoder}\n * @see {@link padRightDecoder}\n */\nexport function padRightCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset)) as TCodec;\n}\n", "import {\n    assertIsFixedSize,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\nfunction copySourceToTargetInReverse(\n    source: ReadonlyUint8Array,\n    target_WILL_MUTATE: Uint8Array,\n    sourceOffset: number,\n    sourceLength: number,\n    targetOffset: number = 0,\n) {\n    while (sourceOffset < --sourceLength) {\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\n\n/**\n * Reverses the bytes of a fixed-size encoder.\n *\n * Given a `FixedSizeEncoder`, this function returns a new `FixedSizeEncoder` that\n * reverses the bytes within the fixed-size byte array when encoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * For more details, see {@link reverseCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param encoder - The fixed-size encoder to reverse.\n * @returns A new encoder that writes bytes in reverse order.\n *\n * @example\n * Encoding a `u16` value in reverse order.\n * ```ts\n * const encoder = reverseEncoder(getU16Encoder({ endian: Endian.Big }));\n * const bytes = encoder.encode(0x1234); // 0x3412 (bytes are flipped)\n * ```\n *\n * @see {@link reverseCodec}\n * @see {@link reverseDecoder}\n */\nexport function reverseEncoder<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value: TFrom, bytes, offset) => {\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                bytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + encoder.fixedSize /* sourceLength */,\n            );\n            return newOffset;\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size decoder.\n *\n * Given a `FixedSizeDecoder`, this function returns a new `FixedSizeDecoder` that\n * reverses the bytes within the fixed-size byte array before decoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * For more details, see {@link reverseCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the decoded value in bytes.\n *\n * @param decoder - The fixed-size decoder to reverse.\n * @returns A new decoder that reads bytes in reverse order.\n *\n * @example\n * Decoding a reversed `u16` value.\n * ```ts\n * const decoder = reverseDecoder(getU16Decoder({ endian: Endian.Big }));\n * const value = decoder.decode(new Uint8Array([0x34, 0x12])); // 0x1234 (bytes are flipped back)\n * ```\n *\n * @see {@link reverseCodec}\n * @see {@link reverseEncoder}\n */\nexport function reverseDecoder<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset) => {\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                reversedBytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + decoder.fixedSize /* sourceLength */,\n            );\n            return decoder.read(reversedBytes, offset);\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size codec.\n *\n * Given a `FixedSizeCodec`, this function returns a new `FixedSizeCodec` that\n * reverses the bytes within the fixed-size byte array during encoding and decoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded/decoded value in bytes.\n *\n * @param codec - The fixed-size codec to reverse.\n * @returns A new codec that encodes and decodes bytes in reverse order.\n *\n * @example\n * Reversing a `u16` codec.\n * ```ts\n * const codec = reverseCodec(getU16Codec({ endian: Endian.Big }));\n * const bytes = codec.encode(0x1234); // 0x3412 (bytes are flipped)\n * const value = codec.decode(bytes);  // 0x1234 (bytes are flipped back)\n * ```\n *\n * @remarks\n * If you only need to reverse an encoder, use {@link reverseEncoder}.\n * If you only need to reverse a decoder, use {@link reverseDecoder}.\n *\n * ```ts\n * const bytes = reverseEncoder(getU16Encoder()).encode(0x1234);\n * const value = reverseDecoder(getU16Decoder()).decode(bytes);\n * ```\n *\n * @see {@link reverseEncoder}\n * @see {@link reverseDecoder}\n */\nexport function reverseCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n", "import {\n    Codec,\n    createCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isVariableSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Transforms an encoder by mapping its input values.\n *\n * This function takes an existing `Encoder<A>` and returns an `Encoder<B>`, allowing values of type `B`\n * to be converted into values of type `A` before encoding. The transformation is applied via the `unmap` function.\n *\n * This is useful for handling type conversions, applying default values, or structuring data before encoding.\n *\n * For more details, see {@link transformCodec}.\n *\n * @typeParam TOldFrom - The original type expected by the encoder.\n * @typeParam TNewFrom - The new type that will be transformed before encoding.\n *\n * @param encoder - The encoder to transform.\n * @param unmap - A function that converts values of `TNewFrom` into `TOldFrom` before encoding.\n * @returns A new encoder that accepts `TNewFrom` values and transforms them before encoding.\n *\n * @example\n * Encoding a string by counting its characters and storing the length as a `u32`.\n * ```ts\n * const encoder = transformEncoder(getU32Encoder(), (value: string) => value.length);\n * encoder.encode(\"hello\"); // 0x05000000 (stores length 5)\n * ```\n *\n * @see {@link transformCodec}\n * @see {@link transformDecoder}\n */\nexport function transformEncoder<TOldFrom, TNewFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TOldFrom, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeEncoder<TNewFrom, TSize>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: VariableSizeEncoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeEncoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom> {\n    return createEncoder({\n        ...(isVariableSize(encoder)\n            ? { ...encoder, getSizeFromValue: (value: TNewFrom) => encoder.getSizeFromValue(unmap(value)) }\n            : encoder),\n        write: (value: TNewFrom, bytes, offset) => encoder.write(unmap(value), bytes, offset),\n    });\n}\n\n/**\n * Transforms a decoder by mapping its output values.\n *\n * This function takes an existing `Decoder<A>` and returns a `Decoder<B>`, allowing values of type `A`\n * to be converted into values of type `B` after decoding. The transformation is applied via the `map` function.\n *\n * This is useful for post-processing, type conversions, or enriching decoded data.\n *\n * For more details, see {@link transformCodec}.\n *\n * @typeParam TOldTo - The original type returned by the decoder.\n * @typeParam TNewTo - The new type that will be transformed after decoding.\n *\n * @param decoder - The decoder to transform.\n * @param map - A function that converts values of `TOldTo` into `TNewTo` after decoding.\n * @returns A new decoder that decodes into `TNewTo`.\n *\n * @example\n * Decoding a stored `u32` length into a string of `'x'` characters.\n * ```ts\n * const decoder = transformDecoder(getU32Decoder(), (length) => 'x'.repeat(length));\n * decoder.decode(new Uint8Array([0x05, 0x00, 0x00, 0x00])); // \"xxxxx\"\n * ```\n *\n * @see {@link transformCodec}\n * @see {@link transformEncoder}\n */\nexport function transformDecoder<TOldTo, TNewTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TOldTo, TSize>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeDecoder<TNewTo, TSize>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: VariableSizeDecoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeDecoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo> {\n    return createDecoder({\n        ...decoder,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [map(value, bytes, offset), newOffset];\n        },\n    });\n}\n\n/**\n * Transforms a codec by mapping its input and output values.\n *\n * This function takes an existing `Codec<A, B>` and returns a `Codec<C, D>`, allowing:\n * - Values of type `C` to be transformed into `A` before encoding.\n * - Values of type `B` to be transformed into `D` after decoding.\n *\n * This is useful for adapting codecs to work with different representations, handling default values, or\n * converting between primitive and structured types.\n *\n * @typeParam TOldFrom - The original type expected by the codec.\n * @typeParam TNewFrom - The new type that will be transformed before encoding.\n * @typeParam TOldTo - The original type returned by the codec.\n * @typeParam TNewTo - The new type that will be transformed after decoding.\n *\n * @param codec - The codec to transform.\n * @param unmap - A function that converts values of `TNewFrom` into `TOldFrom` before encoding.\n * @param map - A function that converts values of `TOldTo` into `TNewTo` after decoding (optional).\n * @returns A new codec that encodes `TNewFrom` and decodes into `TNewTo`.\n *\n * @example\n * Mapping a `u32` codec to encode string lengths and decode them into `'x'` characters.\n * ```ts\n * const codec = transformCodec(\n *     getU32Codec(),\n *     (value: string) => value.length, // Encode string length\n *     (length) => 'x'.repeat(length)  // Decode length into a string of 'x's\n * );\n *\n * const bytes = codec.encode(\"hello\"); // 0x05000000 (stores length 5)\n * const value = codec.decode(bytes);   // \"xxxxx\"\n * ```\n *\n * @remarks\n * If only input transformation is needed, use {@link transformEncoder}.\n * If only output transformation is needed, use {@link transformDecoder}.\n *\n * ```ts\n * const bytes = transformEncoder(getU32Encoder(), (value: string) => value.length).encode(\"hello\");\n * const value = transformDecoder(getU32Decoder(), (length) => 'x'.repeat(length)).decode(bytes);\n * ```\n *\n * @see {@link transformEncoder}\n * @see {@link transformDecoder}\n */\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom, TSize extends number>(\n    codec: FixedSizeCodec<TOldFrom, TTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeCodec<TNewFrom, TTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: VariableSizeCodec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeCodec<TNewFrom, TTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: Codec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Codec<TNewFrom, TTo>;\nexport function transformCodec<\n    TOldFrom,\n    TNewFrom,\n    TOldTo extends TOldFrom,\n    TNewTo extends TNewFrom,\n    TSize extends number,\n>(\n    codec: FixedSizeCodec<TOldFrom, TOldTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeCodec<TNewFrom, TNewTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: VariableSizeCodec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeCodec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map?: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo> {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : (codec.read as unknown as Decoder<TNewTo>['read']),\n    });\n}\n", "import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n", "import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n", "import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/**\n * Returns an encoder for base-10 strings.\n *\n * This encoder serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-10 strings.\n *\n * @example\n * Encoding a base-10 string.\n * ```ts\n * const encoder = getBase10Encoder();\n * const bytes = encoder.encode('1024'); // 0x0400\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-10 strings.\n *\n * This decoder deserializes base-10 encoded strings from a byte array.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-10 strings.\n *\n * @example\n * Decoding a base-10 string.\n * ```ts\n * const decoder = getBase10Decoder();\n * const value = decoder.decode(new Uint8Array([0x04, 0x00])); // \"1024\"\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-10 strings.\n *\n * This codec serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-10 strings.\n *\n * @example\n * Encoding and decoding a base-10 string.\n * ```ts\n * const codec = getBase10Codec();\n * const bytes = codec.encode('1024'); // 0x0400\n * const value = codec.decode(bytes);  // \"1024\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-10 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase10Codec(), 5);\n * ```\n *\n * If you need a size-prefixed base-10 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase10Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase10Encoder} and {@link getBase10Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase10Encoder().encode('1024');\n * const value = getBase10Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase10Encoder}\n * @see {@link getBase10Decoder}\n */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n", "import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/**\n * Returns an encoder for base-16 (hexadecimal) strings.\n *\n * This encoder serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-16 strings.\n *\n * @example\n * Encoding a base-16 string.\n * ```ts\n * const encoder = getBase16Encoder();\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-16 (hexadecimal) strings.\n *\n * This decoder deserializes base-16 encoded strings from a byte array.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-16 strings.\n *\n * @example\n * Decoding a base-16 string.\n * ```ts\n * const decoder = getBase16Decoder();\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-16 (hexadecimal) strings.\n *\n * This codec serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-16 strings.\n *\n * @example\n * Encoding and decoding a base-16 string.\n * ```ts\n * const codec = getBase16Codec();\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-16 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase16Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-16 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase16Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase16Encoder} and {@link getBase16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase16Encoder().encode('deadface');\n * const value = getBase16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase16Encoder}\n * @see {@link getBase16Decoder}\n */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n", "import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n", "import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings using bit re-slicing.\n *\n * This encoder serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to an alphabet, and encoding the result into a byte array.\n * This approach is commonly used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding a base-X string using bit re-slicing.\n * ```ts\n * const encoder = getBaseXResliceEncoder('elho', 2);\n * const bytes = encoder.encode('hellolol'); // 0x4aee\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-X encoded strings using bit re-slicing.\n *\n * This decoder deserializes base-X encoded strings by re-slicing the bits of a byte array into\n * custom-sized chunks and mapping them to a specified alphabet.\n * This is typically used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings using bit re-slicing.\n *\n * @example\n * Decoding a base-X string using bit re-slicing.\n * ```ts\n * const decoder = getBaseXResliceDecoder('elho', 2);\n * const value = decoder.decode(new Uint8Array([0x4a, 0xee])); // \"hellolol\"\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-X strings using bit re-slicing.\n *\n * This codec serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to a given alphabet, and encoding the result into bytes.\n * It is particularly suited for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding and decoding a base-X string using bit re-slicing.\n * ```ts\n * const codec = getBaseXResliceCodec('elho', 2);\n * const bytes = codec.encode('hellolol'); // 0x4aee\n * const value = codec.decode(bytes);      // \"hellolol\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXResliceCodec('elho', 2), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXResliceCodec('elho', 2), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXResliceEncoder} and {@link getBaseXResliceDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXResliceEncoder('elho', 2).encode('hellolol');\n * const value = getBaseXResliceDecoder('elho', 2).decode(bytes);\n * ```\n *\n * @see {@link getBaseXResliceEncoder}\n * @see {@link getBaseXResliceDecoder}\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n", "import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/**\n * Returns an encoder for base-64 strings.\n *\n * This encoder serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-64 strings.\n *\n * @example\n * Encoding a base-64 string.\n * ```ts\n * const encoder = getBase64Encoder();\n * const bytes = encoder.encode('hello+world'); // 0x85e965a3ec28ae57\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/**\n * Returns a decoder for base-64 strings.\n *\n * This decoder deserializes base-64 encoded strings from a byte array.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-64 strings.\n *\n * @example\n * Decoding a base-64 string.\n * ```ts\n * const decoder = getBase64Decoder();\n * const value = decoder.decode(new Uint8Array([0x85, 0xe9, 0x65, 0xa3, 0xec, 0x28, 0xae, 0x57])); // \"hello+world\"\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/**\n * Returns a codec for encoding and decoding base-64 strings.\n *\n * This codec serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-64 strings.\n *\n * @example\n * Encoding and decoding a base-64 string.\n * ```ts\n * const codec = getBase64Codec();\n * const bytes = codec.encode('hello+world'); // 0x85e965a3ec28ae57\n * const value = codec.decode(bytes);         // \"hello+world\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-64 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase64Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-64 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase64Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase64Encoder} and {@link getBase64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase64Encoder().encode('hello+world');\n * const value = getBase64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase64Encoder}\n * @see {@link getBase64Decoder}\n */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n", "/**\n * Removes all null characters (`\\u0000`) from a string.\n *\n * This function cleans a string by stripping out any null characters,\n * which are often used as padding in fixed-size string encodings.\n *\n * @param value - The string to process.\n * @returns The input string with all null characters removed.\n *\n * @example\n * Removing null characters from a string.\n * ```ts\n * removeNullCharacters('hello\\u0000\\u0000'); // \"hello\"\n * ```\n */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/**\n * Pads a string with null characters (`\\u0000`) at the end to reach a fixed length.\n *\n * If the input string is shorter than the specified length, it is padded with null characters\n * until it reaches the desired size. If it is already long enough, it remains unchanged.\n *\n * @param value - The string to pad.\n * @param chars - The total length of the resulting string, including padding.\n * @returns The input string padded with null characters up to the specified length.\n *\n * @example\n * Padding a string with null characters.\n * ```ts\n * padNullCharacters('hello', 8); // \"hello\\u0000\\u0000\\u0000\"\n * ```\n */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n", "export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n", "import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/**\n * Returns an encoder for UTF-8 strings.\n *\n * This encoder serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding UTF-8 strings.\n *\n * @example\n * Encoding a UTF-8 string.\n * ```ts\n * const encoder = getUtf8Encoder();\n * const bytes = encoder.encode('hello'); // 0x68656c6c6f\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for UTF-8 strings.\n *\n * This decoder deserializes UTF-8 encoded strings from a byte array.\n * It reads all available bytes starting from the given offset.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding UTF-8 strings.\n *\n * @example\n * Decoding a UTF-8 string.\n * ```ts\n * const decoder = getUtf8Decoder();\n * const value = decoder.decode(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f])); // \"hello\"\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding UTF-8 strings.\n *\n * This codec serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding UTF-8 strings.\n *\n * @example\n * Encoding and decoding a UTF-8 string.\n * ```ts\n * const codec = getUtf8Codec();\n * const bytes = codec.encode('hello'); // 0x68656c6c6f\n * const value = codec.decode(bytes);   // \"hello\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size UTF-8 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 5);\n * ```\n *\n * If you need a size-prefixed UTF-8 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getUtf8Encoder} and {@link getUtf8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getUtf8Encoder().encode('hello');\n * const value = getUtf8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getUtf8Encoder}\n * @see {@link getUtf8Decoder}\n */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n", "import type { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport type { Lamports } from '@solana/rpc-types';\n\n/**\n * The number of bytes required to store the {@link BaseAccount} information without its data.\n *\n * @example\n * ```ts\n * const myTotalAccountSize = myAccountDataSize + BASE_ACCOUNT_SIZE;\n * ```\n */\nexport const BASE_ACCOUNT_SIZE = 128;\n\n/**\n * Defines the attributes common to all Solana accounts. Namely, it contains everything stored\n * on-chain except the account data itself.\n *\n * @interface\n *\n * @example\n * ```ts\n * const BaseAccount: BaseAccount = {\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * };\n * ```\n */\nexport type BaseAccount = {\n    readonly executable: boolean;\n    readonly lamports: Lamports;\n    readonly programAddress: Address;\n    readonly space: bigint;\n};\n\n/**\n * Contains all the information relevant to a Solana account. It includes the account's address and\n * data, as well as the properties of {@link BaseAccount}.\n *\n * @interface\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * // Encoded\n * const myEncodedAccount: Account<Uint8Array, '1234..5678'> = {\n *     address: address('1234..5678'),\n *     data: new Uint8Array([1, 2, 3]),\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * };\n *\n * // Decoded\n * type MyAccountData = { name: string; age: number };\n * const myDecodedAccount: Account<MyAccountData, '1234..5678'> = {\n *     address: address('1234..5678'),\n *     data: { name: 'Alice', age: 30 },\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * };\n * ```\n */\nexport type Account<TData extends Uint8Array | object, TAddress extends string = string> = BaseAccount & {\n    readonly address: Address<TAddress>;\n    readonly data: TData;\n};\n\n/**\n * Represents an encoded account and is equivalent to an {@link Account} with `Uint8Array` account\n * data.\n *\n * @interface\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * {\n *     address: address('1234..5678'),\n *     data: new Uint8Array([1, 2, 3]),\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * } satisfies EncodedAccount<'1234..5678'>;\n * ```\n */\nexport type EncodedAccount<TAddress extends string = string> = Account<ReadonlyUint8Array, TAddress>;\n", "import type { Decoder, ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SolanaError,\n} from '@solana/errors';\n\nimport type { Account, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\n\n/**\n * Transforms an {@link EncodedAccount} into an {@link Account} (or a {@link MaybeEncodedAccount}\n * into a {@link MaybeAccount}) by decoding the account data using the provided {@link Decoder}\n * instance.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The type of this account's data.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccount: EncodedAccount<'1234..5678'>;\n * const myDecoder: Decoder<MyAccountData> = getStructDecoder([\n *     ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *     ['age', getU32Decoder()],\n * ]);\n *\n * const myDecodedAccount = decodeAccount(myAccount, myDecoder);\n * myDecodedAccount satisfies Account<MyAccountData, '1234..5678'>;\n * ```\n */\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): MaybeAccount<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    try {\n        if ('exists' in encodedAccount && !encodedAccount.exists) {\n            return encodedAccount;\n        }\n        return Object.freeze({ ...encodedAccount, data: decoder.decode(encodedAccount.data) });\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, {\n            address: encodedAccount.address,\n        });\n    }\n}\n\nfunction accountExists<TData extends object>(account: Account<TData> | MaybeAccount<TData>): account is Account<TData> {\n    return !('exists' in account) || ('exists' in account && account.exists);\n}\n\n/**\n * Asserts that an account stores decoded data, ie. not a `Uint8Array`.\n *\n * Note that it does not check the shape of the data matches the decoded type, only that it is not a\n * `Uint8Array`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The type of this account's data.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccount: Account<MyAccountData | Uint8Array, '1234..5678'>;\n * assertAccountDecoded(myAccount);\n *\n * // now the account data can be used as MyAccountData\n * account.data satisfies MyAccountData;\n * ```\n *\n * This is particularly useful for narrowing the result of fetching a JSON parsed account.\n *\n * ```ts\n * const account: MaybeAccount<MockData | Uint8Array> = await fetchJsonParsedAccount<MockData>(\n *     rpc,\n *     '1234..5678' as Address,\n * );\n *\n * assertAccountDecoded(account);\n * // now we have a MaybeAccount<MockData>\n * account satisfies MaybeAccount<MockData>;\n * ```\n */\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is MaybeAccount<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress> | MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (accountExists(account) && account.data instanceof Uint8Array) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT, {\n            address: account.address,\n        });\n    }\n}\n\n/**\n * Asserts that all input accounts store decoded data, ie. not a `Uint8Array`.\n *\n * As with {@link assertAccountDecoded} it does not check the shape of the data matches the decoded\n * type, only that it is not a `Uint8Array`.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccounts: Account<MyAccountData | Uint8Array, Address>[];\n * assertAccountsDecoded(myAccounts);\n *\n * // now the account data can be used as MyAccountData\n * for (const a of account) {\n *     account.data satisfies MyAccountData;\n * }\n * ```\n */\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: Account<ReadonlyUint8Array | TData, TAddress>[],\n): asserts accounts is Account<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: MaybeAccount<ReadonlyUint8Array | TData, TAddress>[],\n): asserts accounts is MaybeAccount<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: (Account<ReadonlyUint8Array | TData, TAddress> | MaybeAccount<ReadonlyUint8Array | TData, TAddress>)[],\n): asserts accounts is (Account<TData, TAddress> | MaybeAccount<TData, TAddress>)[] {\n    const encoded = accounts.filter(a => accountExists(a) && a.data instanceof Uint8Array);\n    if (encoded.length > 0) {\n        const encodedAddresses = encoded.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, {\n            addresses: encodedAddresses,\n        });\n    }\n}\n", "import type { Address } from '@solana/addresses';\nimport { getBase58Encoder, getBase64Encoder } from '@solana/codecs-strings';\nimport type {\n    AccountInfoBase,\n    AccountInfoWithBase58Bytes,\n    AccountInfoWithBase58EncodedData,\n    AccountInfoWithBase64EncodedData,\n} from '@solana/rpc-types';\n\nimport type { Account, BaseAccount, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport type { JsonParsedDataResponse } from './rpc-api';\n\ntype Base64EncodedRpcAccount = AccountInfoBase & AccountInfoWithBase64EncodedData;\n\n/**\n * Parses a base64-encoded account provided by the RPC client into an {@link EncodedAccount} type or\n * a {@link MaybeEncodedAccount} type if the raw data can be set to `null`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myRpcAccount = await rpc.getAccountInfo(myAddress, { encoding: 'base64' }).send();\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = parseBase64RpcAccount(myRpcAccount);\n * ```\n */\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase64Encoder().encode(rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype Base58EncodedRpcAccount = AccountInfoBase & (AccountInfoWithBase58Bytes | AccountInfoWithBase58EncodedData);\n\n/**\n * Parses a base58-encoded account provided by the RPC client into an {@link EncodedAccount} type or\n * a {@link MaybeEncodedAccount} type if the raw data can be set to `null`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myRpcAccount = await rpc.getAccountInfo(myAddress, { encoding: 'base58' }).send();\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = parseBase58RpcAccount(myRpcAccount);\n * ```\n */\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase58Encoder().encode(typeof rpcAccount.data === 'string' ? rpcAccount.data : rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype JsonParsedRpcAccount = AccountInfoBase & { readonly data: JsonParsedDataResponse<unknown> };\n\n/**\n * Parses an arbitrary `jsonParsed` account provided by the RPC client into an {@link Account} type\n * or a {@link MaybeAccount} type if the raw data can be set to `null`.\n *\n * The expected data type should be explicitly provided as the first type parameter.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The expected type of this account's data.\n *\n * @example\n * ```ts\n * const myAccount: Account<MyData> = parseJsonRpcAccount<MyData>(myJsonRpcAccount);\n * ```\n */\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount,\n): Account<TData, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): MaybeAccount<TData, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = rpcAccount.data.parsed.info as TData;\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\nfunction parseBaseAccount(rpcAccount: AccountInfoBase): BaseAccount {\n    return Object.freeze({\n        executable: rpcAccount.executable,\n        lamports: rpcAccount.lamports,\n        programAddress: rpcAccount.owner,\n        space: rpcAccount.space,\n    });\n}\n", "import type { Address } from '@solana/addresses';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Commitment, Slot } from '@solana/rpc-types';\n\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport { parseBase64RpcAccount, parseJsonRpcAccount } from './parse-account';\nimport type { GetAccountInfoApi, GetMultipleAccountsApi } from './rpc-api';\n\n/**\n * Optional configuration for fetching a singular account.\n *\n * @interface\n */\nexport type FetchAccountConfig = {\n    abortSignal?: AbortSignal;\n    /**\n     * Fetch the details of the account as of the highest slot that has reached this level of\n     * commitment.\n     *\n     * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n     * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n     * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n     * default commitment applied by the server is `\"finalized\"`.\n     */\n    commitment?: Commitment;\n    /**\n     * Prevents accessing stale data by enforcing that the RPC node has processed transactions up to\n     * this slot\n     */\n    minContextSlot?: Slot;\n};\n\n/**\n * Fetches a {@link MaybeEncodedAccount} from the provided RPC client and address.\n *\n * It uses the {@link GetAccountInfoApi.getAccountInfo | getAccountInfo} RPC method under the hood\n * with base64 encoding and an additional configuration object can be provided to customize the\n * behavior of the RPC call.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = await fetchEncodedAccount(rpc, myAddress);\n *\n * // With custom configuration.\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = await fetchEncodedAccount(rpc, myAddress, {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchEncodedAccount<TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc.getAccountInfo(address, { ...rpcConfig, encoding: 'base64' }).send({ abortSignal });\n    return parseBase64RpcAccount(address, response.value);\n}\n\n/**\n * Fetches a {@link MaybeAccount} from the provided RPC client and address by using\n * {@link GetAccountInfoApi.getAccountInfo | getAccountInfo} under the hood with the `jsonParsed`\n * encoding.\n *\n * It may also return a {@link MaybeEncodedAccount} if the RPC client does not know how to parse the\n * account at the requested address. In any case, the expected data type should be explicitly\n * provided as the first type parameter.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The expected type of this account's data.\n *\n * @example\n * ```ts\n * type TokenData = { mint: Address; owner: Address };\n * const myAccount = await fetchJsonParsedAccount<TokenData>(rpc, myAddress);\n * myAccount satisfies MaybeAccount<TokenData> | MaybeEncodedAccount;\n *\n * // With custom configuration.\n * const myAccount = await fetchJsonParsedAccount<TokenData>(rpc, myAddress, {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchJsonParsedAccount<TData extends object, TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeAccount<TData, TAddress> | MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const { value: account } = await rpc\n        .getAccountInfo(address, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return !!account && typeof account === 'object' && 'parsed' in account.data\n        ? parseJsonRpcAccount<TData, TAddress>(address, account as Parameters<typeof parseJsonRpcAccount>[1])\n        : parseBase64RpcAccount<TAddress>(address, account as Parameters<typeof parseBase64RpcAccount>[1]);\n}\n\n/**\n * Optional configuration for fetching multiple accounts.\n *\n * @interface\n */\nexport type FetchAccountsConfig = {\n    abortSignal?: AbortSignal;\n    /**\n     * Fetch the details of the accounts as of the highest slot that has reached this level of\n     * commitment.\n     *\n     * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n     * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n     * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n     * default commitment applied by the server is `\"finalized\"`.\n     */\n    commitment?: Commitment;\n    /**\n     * Prevents accessing stale data by enforcing that the RPC node has processed transactions up to\n     * this slot\n     */\n    minContextSlot?: Slot;\n};\n\n/**\n * Fetches an array of {@link MaybeEncodedAccount | MaybeEncodedAccounts} from the provided RPC\n * client and an array of addresses.\n *\n * It uses the {@link GetMultipleAccountsApi#getMultipleAccounts | getMultipleAccounts} RPC method\n * under the hood with base64 encodings and an additional configuration object can be provided to\n * customize the behavior of the RPC call.\n *\n * @typeParam TAddresses - Supply an array of string literals to define accounts having particular\n * addresses.\n *\n * @example\n * ```ts\n * const myAddressA = address('1234..5678');\n * const myAddressB = address('8765..4321');\n * const [myAccountA, myAccountB] = await fetchEncodedAccounts(rpc, [myAddressA, myAddressB]);\n * myAccountA satisfies MaybeEncodedAccount<'1234..5678'>;\n * myAccountB satisfies MaybeEncodedAccount<'8765..4321'>;\n *\n * // With custom configuration.\n * const [myAccountA, myAccountB] = await fetchEncodedAccounts(rpc, [myAddressA, myAddressB], {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchEncodedAccounts<\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'base64' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => parseBase64RpcAccount(addresses[index], account)) as {\n        [P in keyof TAddresses]: MaybeEncodedAccount<TAddresses[P]>;\n    };\n}\n\n/**\n * Fetches an array of {@link MaybeAccount | MaybeAccounts} from a provided RPC client and an array\n * of addresses.\n *\n * It uses the {@link GetMultipleAccountsApi#getMultipleAccounts | getMultipleAccounts} RPC method\n * under the hood with the `jsonParsed` encoding. It may also return a\n * {@link MaybeEncodedAccount} instead of the expected {@link MaybeAccount} if the RPC client does\n * not know how to parse some of the requested accounts. In any case, the array of expected data\n * types should be explicitly provided as the first type parameter.\n *\n * @typeParam TAddresses - Supply an array of string literals to define accounts having particular\n * addresses.\n * @typeParam TData - The expected types of these accounts' data.\n \n * @example\n * ```ts\n * type TokenData = { mint: Address; owner: Address };\n * type MintData = { supply: bigint };\n * const [myAccountA, myAccountB] = await fetchJsonParsedAccounts<[TokenData, MintData]>(rpc, [myAddressA, myAddressB]);\n * myAccountA satisfies MaybeAccount<TokenData> | MaybeEncodedAccount;\n * myAccountB satisfies MaybeAccount<MintData> | MaybeEncodedAccount;\n * ```\n */\nexport async function fetchJsonParsedAccounts<\n    TData extends object[],\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => {\n        return !!account && typeof account === 'object' && 'parsed' in account.data\n            ? parseJsonRpcAccount(addresses[index], account as Parameters<typeof parseJsonRpcAccount>[1])\n            : parseBase64RpcAccount(addresses[index], account as Parameters<typeof parseBase64RpcAccount>[1]);\n    }) as {\n        [P in keyof TAddresses]:\n            | MaybeAccount<TData[P & keyof TData], TAddresses[P]>\n            | MaybeEncodedAccount<TAddresses[P]>;\n    } & {\n        [P in keyof TData]:\n            | MaybeAccount<TData[P], TAddresses[P & keyof TAddresses]>\n            | MaybeEncodedAccount<TAddresses[P & keyof TAddresses]>;\n    };\n}\n", "import { Address } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\n\nimport { Account } from './account';\n\n/**\n * Represents an account that may or may not exist on-chain.\n *\n * When the account exists, it is represented as an {@link Account} type with an additional `exists`\n * attribute set to `true`. When it does not exist, it is represented by an object containing only\n * the address of the account and an `exists` attribute set to `false`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * // Account exists\n * const myExistingAccount: MaybeAccount<MyAccountData, '1234..5678'> = {\n *     exists: true,\n *     address: address('1234..5678'),\n *     data: { name: 'Alice', age: 30 },\n *     // ...\n * };\n *\n * // Account does not exist\n * const myMissingAccount: MaybeAccount<MyAccountData, '8765..4321'> = {\n *     exists: false,\n *     address: address('8765..4321'),\n * };\n * ```\n */\nexport type MaybeAccount<TData extends Uint8Array | object, TAddress extends string = string> =\n    | { readonly address: Address<TAddress>; readonly exists: false }\n    | (Account<TData, TAddress> & { readonly exists: true });\n\n/**\n * Represents an encoded account that may or may not exist on-chain.\n *\n * When the account exists, it is represented as an {@link Account} type having its `TData` type\n * parameter set to `Uint8Array` with an additional `exists` attribute set to `true`. When it does\n * not exist, it is represented by an object containing only the address of the account and an\n * `exists` attribute set to `false`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * // Encoded account exists\n * const myExistingAccount: MaybeEncodedAccount<'1234..5678'> = {\n *     exists: true,\n *     address: address('1234..5678'),\n *     data: new Uint8Array([1, 2, 3]),\n *     // ...\n * };\n *\n * // Encoded account does not exist\n * const myMissingAccount: MaybeEncodedAccount<'8765..4321'> = {\n *     exists: false,\n *     address: address('8765..4321'),\n * };\n * ```\n */\nexport type MaybeEncodedAccount<TAddress extends string = string> = MaybeAccount<Uint8Array, TAddress>;\n\n/**\n * Given a {@link MaybeAccount}, asserts that the account exists and allows it to be used as an\n * {@link Account} type going forward.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * const myAccount: MaybeEncodedAccount<'1234..5678'>;\n * assertAccountExists(myAccount);\n *\n * // Now we can use myAccount as an `EncodedAccount`\n * myAccount satisfies EncodedAccount<'1234..5678'>;\n * ```\n */\nexport function assertAccountExists<TData extends Uint8Array | object, TAddress extends string = string>(\n    account: MaybeAccount<TData, TAddress>,\n): asserts account is Account<TData, TAddress> & { exists: true } {\n    if (!account.exists) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, { address: account.address });\n    }\n}\n\n/**\n * Given an array of {@link MaybeAccount | MaybeAccounts}, asserts that all the accounts exist and\n * allows them to be used as an array of {@link Account | Accounts} going forward.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * const myAccounts: MaybeEncodedAccount<Address>[];\n * assertAccountsExist(myAccounts);\n *\n * // Now we can use them as an array of `EncodedAccounts`\n * for (const a of myAccounts) {\n *     a satisfies EncodedAccount<Address>;\n * }\n * ```\n */\nexport function assertAccountsExist<TData extends Uint8Array | object, TAddress extends string = string>(\n    accounts: MaybeAccount<TData, TAddress>[],\n): asserts accounts is (Account<TData, TAddress> & { exists: true })[] {\n    const missingAccounts = accounts.filter(a => !a.exists);\n    if (missingAccounts.length > 0) {\n        const missingAddresses = missingAccounts.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND, { addresses: missingAddresses });\n    }\n}\n", "import { SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED, SolanaError } from '@solana/errors';\n\n/**\n * Throws an exception unless {@link Crypto#getRandomValues | `crypto.getRandomValues()`} is\n * available in the current JavaScript environment.\n */\nexport function assertPRNGIsAvailable() {\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.getRandomValues !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED);\n    }\n}\n", "import {\n    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,\n    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,\n    SolanaError,\n} from '@solana/errors';\n\nfunction assertIsSecureContext() {\n    if (__BROWSER__ && !globalThis.isSecureContext) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT);\n    }\n}\n\nlet cachedEd25519Decision: PromiseLike<boolean> | boolean | undefined;\nasync function isEd25519CurveSupported(subtle: SubtleCrypto): Promise<boolean> {\n    if (cachedEd25519Decision === undefined) {\n        cachedEd25519Decision = new Promise(resolve => {\n            subtle\n                .generateKey('Ed25519', /* extractable */ false, ['sign', 'verify'])\n                .then(() => {\n                    resolve((cachedEd25519Decision = true));\n                })\n                .catch(() => {\n                    resolve((cachedEd25519Decision = false));\n                });\n        });\n    }\n    if (typeof cachedEd25519Decision === 'boolean') {\n        return cachedEd25519Decision;\n    } else {\n        return await cachedEd25519Decision;\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#digest | `crypto.subtle.digest()`} is available in\n * the current JavaScript environment.\n */\nexport function assertDigestCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.digest !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#generateKey | `crypto.subtle.generateKey()`} is\n * available in the current JavaScript environment and has support for the Ed25519 curve.\n */\nexport async function assertKeyGenerationIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.generateKey !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED);\n    }\n    if (!(await isEd25519CurveSupported(globalThis.crypto.subtle))) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#exportKey | `crypto.subtle.exportKey()`} is\n * available in the current JavaScript environment.\n */\nexport function assertKeyExporterIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.exportKey !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#sign | `crypto.subtle.sign()`} is available in the\n * current JavaScript environment.\n */\nexport function assertSigningCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.sign !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED);\n    }\n}\n/**\n * Throws an exception unless {@link SubtleCrypto#verify | `crypto.subtle.verify()`} is available in\n * the current JavaScript environment.\n */\nexport function assertVerificationCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.verify !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED);\n    }\n}\n", "import {\n    combineCodec,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\n/**\n * Represents a string that validates as a Solana address. Functions that require well-formed\n * addresses should specify their inputs in terms of this type.\n *\n * Whenever you need to validate an arbitrary string as a base58-encoded address, use the\n * {@link address}, {@link assertIsAddress}, or {@link isAddress} functions in this package.\n */\nexport type Address<TAddress extends string = string> = Brand<EncodedString<TAddress, 'base58'>, 'Address'>;\n\nlet memoizedBase58Encoder: Encoder<string> | undefined;\nlet memoizedBase58Decoder: Decoder<string> | undefined;\n\nfunction getMemoizedBase58Encoder(): Encoder<string> {\n    if (!memoizedBase58Encoder) memoizedBase58Encoder = getBase58Encoder();\n    return memoizedBase58Encoder;\n}\n\nfunction getMemoizedBase58Decoder(): Decoder<string> {\n    if (!memoizedBase58Decoder) memoizedBase58Decoder = getBase58Decoder();\n    return memoizedBase58Decoder;\n}\n\n/**\n * A type guard that returns `true` if the input string conforms to the {@link Address} type, and\n * refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isAddress } from '@solana/addresses';\n *\n * if (isAddress(ownerAddress)) {\n *     // At this point, `ownerAddress` has been refined to a\n *     // `Address` that can be used with the RPC.\n *     const { value: lamports } = await rpc.getBalance(ownerAddress).send();\n *     setBalanceLamports(lamports);\n * } else {\n *     setError(`${ownerAddress} is not an address`);\n * }\n * ```\n */\nexport function isAddress(putativeAddress: string): putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    try {\n        return base58Encoder.encode(putativeAddress).byteLength === 32;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * From time to time you might acquire a string, that you expect to validate as an address or public\n * key, from an untrusted network API or user input. Use this function to assert that such an\n * arbitrary string is a base58-encoded address.\n *\n * @example\n * ```ts\n * import { assertIsAddress } from '@solana/addresses';\n *\n * // Imagine a function that fetches an account's balance when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const address: string = accountAddressInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `Address`.\n *         assertIsAddress(address);\n *         // At this point, `address` is an `Address` that can be used with the RPC.\n *         const balanceInLamports = await rpc.getBalance(address).send();\n *     } catch (e) {\n *         // `address` turned out not to be a base58-encoded address\n *     }\n * }\n * ```\n */\nexport function assertIsAddress(putativeAddress: string): asserts putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeAddress.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeAddress);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\n/**\n * Combines _asserting_ that a string is an address with _coercing_ it to the {@link Address} type.\n * It's most useful with untrusted input.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n *\n * await transfer(address(fromAddress), address(toAddress), lamports(100000n));\n * ```\n *\n * > [!TIP]\n * > When starting from a known-good address as a string, it's more efficient to typecast it rather\n * than to use the {@link address} helper, because the helper unconditionally performs validation on\n * its input.\n * >\n * > ```ts\n * > import { Address } from '@solana/addresses';\n * >\n * > const MEMO_PROGRAM_ADDRESS =\n * >     'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr' as Address<'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'>;\n * > ```\n */\nexport function address<TAddress extends string = string>(putativeAddress: TAddress): Address<TAddress> {\n    assertIsAddress(putativeAddress);\n    return putativeAddress as Address<TAddress>;\n}\n\n/**\n * Returns an encoder that you can use to encode a base58-encoded address to a byte array.\n *\n * @example\n * ```ts\n * import { getAddressEncoder } from '@solana/addresses';\n *\n * const address = 'B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka' as Address;\n * const addressEncoder = getAddressEncoder();\n * const addressBytes = addressEncoder.encode(address);\n * // Uint8Array(32) [\n * //   150, 183, 190,  48, 171,   8, 39, 156,\n * //   122, 213, 172, 108, 193,  95, 26, 158,\n * //   149, 243, 115, 254,  20, 200, 36,  30,\n * //   248, 179, 178, 232, 220,  89, 53, 127\n * // ]\n * ```\n */\nexport function getAddressEncoder(): FixedSizeEncoder<Address, 32> {\n    return transformEncoder(fixEncoderSize(getMemoizedBase58Encoder(), 32), putativeAddress =>\n        address(putativeAddress),\n    );\n}\n\n/**\n * Returns a decoder that you can use to convert an array of 32 bytes representing an address to the\n * base58-encoded representation of that address.\n *\n * @example\n * ```ts\n * import { getAddressDecoder } from '@solana/addresses';\n *\n * const addressBytes = new Uint8Array([\n *     150, 183, 190,  48, 171,   8, 39, 156,\n *     122, 213, 172, 108, 193,  95, 26, 158,\n *     149, 243, 115, 254,  20, 200, 36,  30,\n *     248, 179, 178, 232, 220,  89, 53, 127\n * ]);\n * const addressDecoder = getAddressDecoder();\n * const address = addressDecoder.decode(addressBytes); // B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka\n * ```\n */\nexport function getAddressDecoder(): FixedSizeDecoder<Address, 32> {\n    return fixDecoderSize(getMemoizedBase58Decoder(), 32) as FixedSizeDecoder<Address, 32>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a base-58 encoded address.\n *\n * @see {@link getAddressDecoder}\n * @see {@link getAddressEncoder}\n */\nexport function getAddressCodec(): FixedSizeCodec<Address, Address, 32> {\n    return combineCodec(getAddressEncoder(), getAddressDecoder());\n}\n\nexport function getAddressComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n", "/**!\n * noble-ed25519\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2019 Paul Miller (https://paulmillr.com)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the “Software”), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nconst D = 37095705934669439343138083508754565189542113879843219016388785533085940283555n;\nconst P = 57896044618658097711785492504343953926634992332820282019728792003956564819949n; // 2n ** 255n - 19n;  ed25519 is twisted edwards curve\nconst RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n; // √-1\n\n// mod division\nfunction mod(a: bigint): bigint {\n    const r = a % P;\n    return r >= 0n ? r : P + r;\n}\nfunction pow2(x: bigint, power: bigint): bigint {\n    // pow2(x, 4) == x^(2^4)\n    let r = x;\n    while (power-- > 0n) {\n        r *= r;\n        r %= P;\n    }\n    return r;\n}\nfunction pow_2_252_3(x: bigint): bigint {\n    // x^(2^252-3) unrolled util for square root\n    const x2 = (x * x) % P; // x^2,       bits 1\n    const b2 = (x2 * x) % P; // x^3,       bits 11\n    const b4 = (pow2(b2, 2n) * b2) % P; // x^(2^4-1), bits 1111\n    const b5 = (pow2(b4, 1n) * x) % P; // x^(2^5-1), bits 11111\n    const b10 = (pow2(b5, 5n) * b5) % P; // x^(2^10)\n    const b20 = (pow2(b10, 10n) * b10) % P; // x^(2^20)\n    const b40 = (pow2(b20, 20n) * b20) % P; // x^(2^40)\n    const b80 = (pow2(b40, 40n) * b40) % P; // x^(2^80)\n    const b160 = (pow2(b80, 80n) * b80) % P; // x^(2^160)\n    const b240 = (pow2(b160, 80n) * b80) % P; // x^(2^240)\n    const b250 = (pow2(b240, 10n) * b10) % P; // x^(2^250)\n    const pow_p_5_8 = (pow2(b250, 2n) * x) % P; // < To pow to (p+3)/8, multiply it by x.\n    return pow_p_5_8;\n}\nfunction uvRatio(u: bigint, v: bigint): bigint | null {\n    // for sqrt comp\n    const v3 = mod(v * v * v); // v³\n    const v7 = mod(v3 * v3 * v); // v⁷\n    const pow = pow_2_252_3(u * v7); // (uv⁷)^(p-5)/8\n    let x = mod(u * v3 * pow); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = mod(v * x * x); // vx²\n    const root1 = x; // First root candidate\n    const root2 = mod(x * RM1); // Second root candidate; RM1 is √-1\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * RM1); // There is no valid root, vx² = -u√-1\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n    if ((mod(x) & 1n) === 1n) x = mod(-x); // edIsNegative\n    if (!useRoot1 && !useRoot2) {\n        return null;\n    }\n    return x;\n}\n// https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.3\nexport function pointIsOnCurve(y: bigint, lastByte: number): boolean {\n    const y2 = mod(y * y); // y²\n    const u = mod(y2 - 1n); // u=y²-1\n    const v = mod(D * y2 + 1n);\n    const x = uvRatio(u, v); // (uv³)(uv⁷)^(p-5)/8; square root\n    if (x === null) {\n        return false;\n    }\n    const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n    if (x === 0n && isLastByteOdd) {\n        return false;\n    }\n    return true;\n}\n", "import { ReadonlyUint8Array } from '@solana/codecs-core';\n\nimport { pointIsOnCurve } from './vendor/noble/ed25519';\n\nfunction byteToHex(byte: number): string {\n    const hexString = byte.toString(16);\n    if (hexString.length === 1) {\n        return `0${hexString}`;\n    } else {\n        return hexString;\n    }\n}\n\nfunction decompressPointBytes(bytes: ReadonlyUint8Array): bigint {\n    const hexString = bytes.reduce((acc, byte, ii) => `${byteToHex(ii === 31 ? byte & ~0x80 : byte)}${acc}`, '');\n    const integerLiteralString = `0x${hexString}`;\n    return BigInt(integerLiteralString);\n}\n\nexport function compressedPointBytesAreOnCurve(bytes: ReadonlyUint8Array): boolean {\n    if (bytes.byteLength !== 32) {\n        return false;\n    }\n    const y = decompressPointBytes(bytes);\n    return pointIsOnCurve(y, bytes[31]);\n}\n", "import { SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS, SolanaError } from '@solana/errors';\nimport type { AffinePoint } from '@solana/nominal-types';\n\nimport { type Address, getAddressCodec } from './address';\nimport { compressedPointBytesAreOnCurve } from './curve-internal';\n\n/**\n * Represents an {@link Address} that validates as being off-curve. Functions that require off-curve\n * addresses should specify their inputs in terms of this type.\n *\n * Whenever you need to validate an address as being off-curve, use the {@link offCurveAddress},\n * {@link assertIsOffCurveAddress}, or {@link isOffCurveAddress} functions in this package.\n */\nexport type OffCurveAddress<TAddress extends string = string> = AffinePoint<Address<TAddress>, 'invalid'>;\n\n/**\n * A type guard that returns `true` if the input address conforms to the {@link OffCurveAddress}\n * type, and refines its type for use in your application.\n *\n * @example\n * ```ts\n * import { isOffCurveAddress } from '@solana/addresses';\n *\n * if (isOffCurveAddress(accountAddress)) {\n *     // At this point, `accountAddress` has been refined to a\n *     // `OffCurveAddress` that can be used within your business logic.\n *     const { value: account } = await rpc.getAccountInfo(accountAddress).send();\n * } else {\n *     setError(`${accountAddress} is not off-curve`);\n * }\n * ```\n */\nexport function isOffCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): putativeOffCurveAddress is OffCurveAddress<TAddress> {\n    const addressBytes = getAddressCodec().encode(putativeOffCurveAddress);\n    return compressedPointBytesAreOnCurve(addressBytes) === false;\n}\n\n/**\n * From time to time you might acquire an {@link Address}, that you expect to validate as an\n * off-curve address, from an untrusted source. Use this function to assert that such an address is\n * off-curve.\n *\n * @example\n * ```ts\n * import { assertIsOffCurveAddress } from '@solana/addresses';\n *\n * // Imagine a function that fetches an account's balance when a user submits a form.\n * function handleSubmit() {\n *     // We know only that the input conforms to the `string` type.\n *     const address: string = accountAddressInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `Address`.\n *         assertIsAddress(address);\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `OffCurveAddress`.\n *         assertIsOffCurveAddress(address);\n *         // At this point, `address` is an `OffCurveAddress` that can be used with the RPC.\n *         const balanceInLamports = await rpc.getBalance(address).send();\n *     } catch (e) {\n *         // `address` turned out to NOT be a base58-encoded off-curve address\n *     }\n * }\n * ```\n */\nexport function assertIsOffCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): asserts putativeOffCurveAddress is OffCurveAddress<TAddress> {\n    if (!isOffCurveAddress(putativeOffCurveAddress)) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS);\n    }\n}\n\n/**\n * Combines _asserting_ that an {@link Address} is off-curve with _coercing_ it to the\n * {@link OffCurveAddress} type. It's most useful with untrusted input.\n */\nexport function offCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): OffCurveAddress<TAddress> {\n    assertIsOffCurveAddress(putativeOffCurveAddress);\n    return putativeOffCurveAddress;\n}\n", "import { assertDigestCapabilityIsAvailable } from '@solana/assertions';\nimport type { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\nimport { Address, assertIsAddress, getAddressCodec, isAddress } from './address';\nimport { compressedPointBytesAreOnCurve } from './curve-internal';\n\n/**\n * A tuple representing a program derived address (derived from the address of some program and a\n * set of seeds) and the associated bump seed used to ensure that the address, as derived, does not\n * fall on the Ed25519 curve.\n *\n * Whenever you need to validate an arbitrary tuple as one that represents a program derived\n * address, use the {@link assertIsProgramDerivedAddress} or {@link isProgramDerivedAddress}\n * functions in this package.\n */\nexport type ProgramDerivedAddress<TAddress extends string = string> = Readonly<\n    [Address<TAddress>, ProgramDerivedAddressBump]\n>;\n\n/**\n * Represents an integer in the range [0,255] used in the derivation of a program derived address to\n * ensure that it does not fall on the Ed25519 curve.\n */\nexport type ProgramDerivedAddressBump = Brand<number, 'ProgramDerivedAddressBump'>;\n\n/**\n * A type guard that returns `true` if the input tuple conforms to the {@link ProgramDerivedAddress}\n * type, and refines its type for use in your program.\n *\n * @see The {@link isAddress} function for an example of how to use a type guard.\n */\nexport function isProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): value is ProgramDerivedAddress<TAddress> {\n    return (\n        Array.isArray(value) &&\n        value.length === 2 &&\n        typeof value[0] === 'string' &&\n        typeof value[1] === 'number' &&\n        value[1] >= 0 &&\n        value[1] <= 255 &&\n        isAddress(value[0])\n    );\n}\n\n/**\n * In the event that you receive an address/bump-seed tuple from some untrusted source, use this\n * function to assert that it conforms to the {@link ProgramDerivedAddress} interface.\n *\n * @see The {@link assertIsAddress} function for an example of how to use an assertion function.\n */\nexport function assertIsProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): asserts value is ProgramDerivedAddress<TAddress> {\n    const validFormat =\n        Array.isArray(value) && value.length === 2 && typeof value[0] === 'string' && typeof value[1] === 'number';\n    if (!validFormat) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MALFORMED_PDA);\n    }\n    if (value[1] < 0 || value[1] > 255) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE, {\n            bump: value[1],\n        });\n    }\n    assertIsAddress(value[0]);\n}\n\ntype ProgramDerivedAddressInput = Readonly<{\n    programAddress: Address;\n    seeds: Seed[];\n}>;\n\ntype SeedInput = Readonly<{\n    baseAddress: Address;\n    programAddress: Address;\n    seed: Seed;\n}>;\n\ntype Seed = ReadonlyUint8Array | string;\n\nconst MAX_SEED_LENGTH = 32;\nconst MAX_SEEDS = 16;\nconst PDA_MARKER_BYTES = [\n    // The string 'ProgramDerivedAddress'\n    80, 114, 111, 103, 114, 97, 109, 68, 101, 114, 105, 118, 101, 100, 65, 100, 100, 114, 101, 115, 115,\n] as const;\n\nasync function createProgramDerivedAddress({ programAddress, seeds }: ProgramDerivedAddressInput): Promise<Address> {\n    assertDigestCapabilityIsAvailable();\n    if (seeds.length > MAX_SEEDS) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED, {\n            actual: seeds.length,\n            maxSeeds: MAX_SEEDS,\n        });\n    }\n    let textEncoder: TextEncoder;\n    const seedBytes = seeds.reduce((acc, seed, ii) => {\n        const bytes = typeof seed === 'string' ? (textEncoder ||= new TextEncoder()).encode(seed) : seed;\n        if (bytes.byteLength > MAX_SEED_LENGTH) {\n            throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n                actual: bytes.byteLength,\n                index: ii,\n                maxSeedLength: MAX_SEED_LENGTH,\n            });\n        }\n        acc.push(...bytes);\n        return acc;\n    }, [] as number[]);\n    const base58EncodedAddressCodec = getAddressCodec();\n    const programAddressBytes = base58EncodedAddressCodec.encode(programAddress);\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...seedBytes, ...programAddressBytes, ...PDA_MARKER_BYTES]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n    if (compressedPointBytesAreOnCurve(addressBytes)) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE);\n    }\n    return base58EncodedAddressCodec.decode(addressBytes);\n}\n\n/**\n * Given a program's {@link Address} and up to 16 {@link Seed | Seeds}, this method will return the\n * program derived address (PDA) associated with each.\n *\n * @example\n * ```ts\n * import { getAddressEncoder, getProgramDerivedAddress } from '@solana/addresses';\n *\n * const addressEncoder = getAddressEncoder();\n * const [pda, bumpSeed] = await getProgramDerivedAddress({\n *     programAddress: 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address,\n *     seeds: [\n *         // Owner\n *         addressEncoder.encode('9fYLFVoVqwH37C3dyPi6cpeobfbQ2jtLpN5HgAYDDdkm' as Address),\n *         // Token program\n *         addressEncoder.encode('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address),\n *         // Mint\n *         addressEncoder.encode('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v' as Address),\n *     ],\n * });\n * ```\n */\nexport async function getProgramDerivedAddress({\n    programAddress,\n    seeds,\n}: ProgramDerivedAddressInput): Promise<ProgramDerivedAddress> {\n    let bumpSeed = 255;\n    while (bumpSeed > 0) {\n        try {\n            const address = await createProgramDerivedAddress({\n                programAddress,\n                seeds: [...seeds, new Uint8Array([bumpSeed])],\n            });\n            return [address, bumpSeed as ProgramDerivedAddressBump];\n        } catch (e) {\n            if (isSolanaError(e, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE)) {\n                bumpSeed--;\n            } else {\n                throw e;\n            }\n        }\n    }\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED);\n}\n\n/**\n * Returns a base58-encoded address derived from some base address, some program address, and a seed\n * string or byte array.\n *\n * @example\n * ```ts\n * import { createAddressWithSeed } from '@solana/addresses';\n *\n * const derivedAddress = await createAddressWithSeed({\n *     // The private key associated with this address will be able to sign for `derivedAddress`.\n *     baseAddress: 'B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka' as Address,\n *     // Only this program will be able to write data to this account.\n *     programAddress: '445erYq578p2aERrGW9mn9KiYe3fuG6uHdcJ2LPPShGw' as Address,\n *     seed: 'data-account',\n * });\n * ```\n */\nexport async function createAddressWithSeed({ baseAddress, programAddress, seed }: SeedInput): Promise<Address> {\n    const { encode, decode } = getAddressCodec();\n\n    const seedBytes = typeof seed === 'string' ? new TextEncoder().encode(seed) : seed;\n    if (seedBytes.byteLength > MAX_SEED_LENGTH) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n            actual: seedBytes.byteLength,\n            index: 0,\n            maxSeedLength: MAX_SEED_LENGTH,\n        });\n    }\n\n    const programAddressBytes = encode(programAddress);\n    if (\n        programAddressBytes.length >= PDA_MARKER_BYTES.length &&\n        programAddressBytes.slice(-PDA_MARKER_BYTES.length).every((byte, index) => byte === PDA_MARKER_BYTES[index])\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER);\n    }\n\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...encode(baseAddress), ...seedBytes, ...programAddressBytes]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n\n    return decode(addressBytes);\n}\n", "import { assertKeyExporterIsAvailable } from '@solana/assertions';\nimport { SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY, SolanaError } from '@solana/errors';\n\nimport { Address, getAddressDecoder, getAddressEncoder } from './address';\n\n/**\n * Given a public {@link CryptoKey}, this method will return its associated {@link Address}.\n *\n * @example\n * ```ts\n * import { getAddressFromPublicKey } from '@solana/addresses';\n *\n * const address = await getAddressFromPublicKey(publicKey);\n * ```\n */\nexport async function getAddressFromPublicKey(publicKey: CryptoKey): Promise<Address> {\n    assertKeyExporterIsAvailable();\n    if (publicKey.type !== 'public' || publicKey.algorithm.name !== 'Ed25519') {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY);\n    }\n    const publicKeyBytes = await crypto.subtle.exportKey('raw', publicKey);\n    return getAddressDecoder().decode(new Uint8Array(publicKeyBytes));\n}\n\n/**\n * Given an {@link Address}, return a {@link CryptoKey} that can be used to verify signatures.\n *\n * @example\n * ```ts\n * import { getAddressFromPublicKey } from '@solana/addresses';\n *\n * const publicKey = await getPublicKeyFromAddress(address);\n * ```\n */\nexport async function getPublicKeyFromAddress(address: Address) {\n    const addressBytes = getAddressEncoder().encode(address);\n    return await crypto.subtle.importKey('raw', addressBytes, { name: 'Ed25519' }, true /* extractable */, ['verify']);\n}\n", "export * from '@solana/codecs-core';\nexport * from '@solana/codecs-data-structures';\nexport * from '@solana/codecs-numbers';\nexport * from '@solana/codecs-strings';\nexport * from '@solana/options';\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map", "import { SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\n/**\n * Ensures that a given number falls within a specified range.\n *\n * If the number is outside the allowed range, an error is thrown.\n * This function is primarily used to validate values before encoding them in a codec.\n *\n * @param codecDescription - A string describing the codec that is performing the validation.\n * @param min - The minimum allowed value (inclusive).\n * @param max - The maximum allowed value (inclusive).\n * @param value - The number to validate.\n *\n * @throws {@link SolanaError} if the value is out of range.\n *\n * @example\n * Validating a number within range.\n * ```ts\n * assertNumberIsBetweenForCodec('u8', 0, 255, 42); // Passes\n * ```\n *\n * @example\n * Throwing an error for an out-of-range value.\n * ```ts\n * assertNumberIsBetweenForCodec('u8', 0, 255, 300); // Throws\n * ```\n */\nexport function assertNumberIsBetweenForCodec(\n    codecDescription: string,\n    min: bigint | number,\n    max: bigint | number,\n    value: bigint | number,\n) {\n    if (value < min || value > max) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value,\n        });\n    }\n}\n", "import { Codec, Decoder, Encoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n/**\n * Represents an encoder for numbers and bigints.\n *\n * This type allows encoding values that are either `number` or `bigint`.\n * Depending on the specific implementation, the encoded output may have a fixed or variable size.\n *\n * @see {@link FixedSizeNumberEncoder}\n */\nexport type NumberEncoder = Encoder<bigint | number>;\n\n/**\n * Represents a fixed-size encoder for numbers and bigints.\n *\n * This encoder serializes values using an exact number of bytes, defined by `TSize`.\n *\n * @typeParam TSize - The number of bytes used for encoding.\n *\n * @see {@link NumberEncoder}\n */\nexport type FixedSizeNumberEncoder<TSize extends number = number> = FixedSizeEncoder<bigint | number, TSize>;\n\n/**\n * Represents a decoder for numbers and bigints.\n *\n * This type supports decoding values as either `number` or `bigint`, depending on the implementation.\n *\n * @see {@link FixedSizeNumberDecoder}\n */\nexport type NumberDecoder = Decoder<bigint> | Decoder<number>;\n\n/**\n * Represents a fixed-size decoder for numbers and bigints.\n *\n * This decoder reads a fixed number of bytes (`TSize`) and converts them into a `number` or `bigint`.\n *\n * @typeParam TSize - The number of bytes expected for decoding.\n *\n * @see {@link NumberDecoder}\n */\nexport type FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\n\n/**\n * Represents a codec for encoding and decoding numbers and bigints.\n *\n * - The encoded value can be either a `number` or a `bigint`.\n * - The decoded value will always be either a `number` or `bigint`, depending on the implementation.\n *\n * @see {@link FixedSizeNumberCodec}\n */\nexport type NumberCodec = Codec<bigint | number, bigint> | Codec<bigint | number, number>;\n\n/**\n * Represents a fixed-size codec for encoding and decoding numbers and bigints.\n *\n * This codec uses a specific number of bytes (`TSize`) for serialization.\n * The encoded value can be either a `number` or `bigint`, but the decoded value will always be a `number` or `bigint`,\n * depending on the implementation.\n *\n * @typeParam TSize - The number of bytes used for encoding and decoding.\n *\n * @see {@link NumberCodec}\n */\nexport type FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<bigint | number, number, TSize>;\n\n/**\n * Configuration options for number codecs that use more than one byte.\n *\n * This configuration applies to all number codecs except `u8` and `i8`,\n * allowing the user to specify the endianness of serialization.\n */\nexport type NumberCodecConfig = {\n    /**\n     * Specifies whether numbers should be encoded in little-endian or big-endian format.\n     *\n     * @defaultValue `Endian.Little`\n     */\n    endian?: Endian;\n};\n\n/**\n * Defines the byte order used for number serialization.\n *\n * - `Little`: The least significant byte is stored first.\n * - `Big`: The most significant byte is stored first.\n */\nexport enum Endian {\n    Little,\n    Big,\n}\n", "import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\nimport { Endian, NumberCodecConfig } from './common';\n\ntype NumberFactorySharedInput<TSize extends number> = {\n    config?: NumberCodecConfig;\n    name: string;\n    size: TSize;\n};\n\ntype NumberFactoryEncoderInput<TFrom, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    range?: [bigint | number, bigint | number];\n    set: (view: DataView, value: TFrom, littleEndian?: boolean) => void;\n};\n\ntype NumberFactoryDecoderInput<TTo, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    get: (view: DataView, littleEndian?: boolean) => TTo;\n};\n\nfunction isLittleEndian(config?: NumberCodecConfig): boolean {\n    return config?.endian === Endian.Big ? false : true;\n}\n\nexport function numberEncoderFactory<TFrom extends bigint | number, TSize extends number>(\n    input: NumberFactoryEncoderInput<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: input.size,\n        write(value: TFrom, bytes: Uint8Array, offset: Offset): Offset {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        },\n    });\n}\n\nexport function numberDecoderFactory<TTo extends bigint | number, TSize extends number>(\n    input: NumberFactoryDecoderInput<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: input.size,\n        read(bytes, offset = 0): [TTo, number] {\n            assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n            assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n        },\n    });\n}\n\n/**\n * Helper function to ensure that the ArrayBuffer is converted properly from a Uint8Array\n * Source: https://stackoverflow.com/questions/37228285/uint8array-to-arraybuffer\n */\nfunction toArrayBuffer(bytes: ReadonlyUint8Array | Uint8Array, offset?: number, length?: number): ArrayBuffer {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit floating-point numbers (`f32`).\n *\n * This encoder serializes `f32` values using 4 bytes.\n * Floating-point values may lose precision when encoded.\n *\n * For more details, see {@link getF32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number, 4>` for encoding `f32` values.\n *\n * @example\n * Encoding an `f32` value.\n * ```ts\n * const encoder = getF32Encoder();\n * const bytes = encoder.encode(-1.5); // 0x0000c0bf\n * ```\n *\n * @see {@link getF32Codec}\n */\nexport const getF32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'f32',\n        set: (view, value, le) => view.setFloat32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit floating-point numbers (`f32`).\n *\n * This decoder deserializes `f32` values from 4 bytes.\n * Some precision may be lost during decoding due to floating-point representation.\n *\n * For more details, see {@link getF32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `f32` values.\n *\n * @example\n * Decoding an `f32` value.\n * ```ts\n * const decoder = getF32Decoder();\n * const value = decoder.decode(new Uint8Array([0x00, 0x00, 0xc0, 0xbf])); // -1.5\n * ```\n *\n * @see {@link getF32Codec}\n */\nexport const getF32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat32(0, le),\n        name: 'f32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit floating-point numbers (`f32`).\n *\n * This codec serializes `f32` values using 4 bytes.\n * Due to the IEEE 754 floating-point representation, some precision loss may occur.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number, number, 4>` for encoding and decoding `f32` values.\n *\n * @example\n * Encoding and decoding an `f32` value.\n * ```ts\n * const codec = getF32Codec();\n * const bytes = codec.encode(-1.5); // 0x0000c0bf\n * const value = codec.decode(bytes); // -1.5\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getF32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-1.5); // 0xbfc00000\n * ```\n *\n * @remarks\n * `f32` values follow the IEEE 754 single-precision floating-point standard.\n * Precision loss may occur for certain values.\n *\n * - If you need higher precision, consider using {@link getF64Codec}.\n * - If you need integer values, consider using {@link getI32Codec} or {@link getU32Codec}.\n *\n * Separate {@link getF32Encoder} and {@link getF32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getF32Encoder().encode(-1.5);\n * const value = getF32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getF32Encoder}\n * @see {@link getF32Decoder}\n */\nexport const getF32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getF32Encoder(config), getF32Decoder(config));\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit floating-point numbers (`f64`).\n *\n * This encoder serializes `f64` values using 8 bytes.\n * Floating-point values may lose precision when encoded.\n *\n * For more details, see {@link getF64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number, 8>` for encoding `f64` values.\n *\n * @example\n * Encoding an `f64` value.\n * ```ts\n * const encoder = getF64Encoder();\n * const bytes = encoder.encode(-1.5); // 0x000000000000f8bf\n * ```\n *\n * @see {@link getF64Codec}\n */\nexport const getF64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'f64',\n        set: (view, value, le) => view.setFloat64(0, Number(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit floating-point numbers (`f64`).\n *\n * This decoder deserializes `f64` values from 8 bytes.\n * Some precision may be lost during decoding due to floating-point representation.\n *\n * For more details, see {@link getF64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 8>` for decoding `f64` values.\n *\n * @example\n * Decoding an `f64` value.\n * ```ts\n * const decoder = getF64Decoder();\n * const value = decoder.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xbf])); // -1.5\n * ```\n *\n * @see {@link getF64Codec}\n */\nexport const getF64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat64(0, le),\n        name: 'f64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit floating-point numbers (`f64`).\n *\n * This codec serializes `f64` values using 8 bytes.\n * Due to the IEEE 754 floating-point representation, some precision loss may occur.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number, number, 8>` for encoding and decoding `f64` values.\n *\n * @example\n * Encoding and decoding an `f64` value.\n * ```ts\n * const codec = getF64Codec();\n * const bytes = codec.encode(-1.5); // 0x000000000000f8bf\n * const value = codec.decode(bytes); // -1.5\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getF64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-1.5); // 0xbff8000000000000\n * ```\n *\n * @remarks\n * `f64` values follow the IEEE 754 double-precision floating-point standard.\n * Precision loss may still occur but is significantly lower than `f32`.\n *\n * - If you need smaller floating-point values, consider using {@link getF32Codec}.\n * - If you need integer values, consider using {@link getI64Codec} or {@link getU64Codec}.\n *\n * Separate {@link getF64Encoder} and {@link getF64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getF64Encoder().encode(-1.5);\n * const value = getF64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getF64Encoder}\n * @see {@link getF64Decoder}\n */\nexport const getF64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 8> =>\n    combineCodec(getF64Encoder(config), getF64Decoder(config));\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 128-bit signed integers (`i128`).\n *\n * This encoder serializes `i128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI128Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 16>` for encoding `i128` values.\n *\n * @example\n * Encoding an `i128` value.\n * ```ts\n * const encoder = getI128Encoder();\n * const bytes = encoder.encode(-42n); // 0xd6ffffffffffffffffffffffffffffff\n * ```\n *\n * @see {@link getI128Codec}\n */\nexport const getI128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'i128',\n        range: [-BigInt('0x7fffffffffffffffffffffffffffffff') - 1n, BigInt('0x7fffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\n/**\n * Returns a decoder for 128-bit signed integers (`i128`).\n *\n * This decoder deserializes `i128` values from 16 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getI128Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 16>` for decoding `i128` values.\n *\n * @example\n * Decoding an `i128` value.\n * ```ts\n * const decoder = getI128Decoder();\n * const value = decoder.decode(new Uint8Array([\n *   0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n *   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n * ])); // -42n\n * ```\n *\n * @see {@link getI128Codec}\n */\nexport const getI128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'i128',\n        size: 16,\n    });\n\n/**\n * Returns a codec for encoding and decoding 128-bit signed integers (`i128`).\n *\n * This codec serializes `i128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 16>` for encoding and decoding `i128` values.\n *\n * @example\n * Encoding and decoding an `i128` value.\n * ```ts\n * const codec = getI128Codec();\n * const bytes = codec.encode(-42n); // 0xd6ffffffffffffffffffffffffffffff\n * const value = codec.decode(bytes); // -42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI128Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42n); // 0xffffffffffffffffffffffffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^127` and `2^127 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller signed integer, consider using {@link getI64Codec} or {@link getI32Codec}.\n * - If you need a larger signed integer, consider using a custom codec.\n * - If you need unsigned integers, consider using {@link getU128Codec}.\n *\n * Separate {@link getI128Encoder} and {@link getI128Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI128Encoder().encode(-42);\n * const value = getI128Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI128Encoder}\n * @see {@link getI128Decoder}\n */\nexport const getI128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getI128Encoder(config), getI128Decoder(config));\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 16-bit signed integers (`i16`).\n *\n * This encoder serializes `i16` values using 2 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI16Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 2>` for encoding `i16` values.\n *\n * @example\n * Encoding an `i16` value.\n * ```ts\n * const encoder = getI16Encoder();\n * const bytes = encoder.encode(-42); // 0xd6ff\n * ```\n *\n * @see {@link getI16Codec}\n */\nexport const getI16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'i16',\n        range: [-Number('0x7fff') - 1, Number('0x7fff')],\n        set: (view, value, le) => view.setInt16(0, Number(value), le),\n        size: 2,\n    });\n\n/**\n * Returns a decoder for 16-bit signed integers (`i16`).\n *\n * This decoder deserializes `i16` values from 2 bytes.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI16Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 2>` for decoding `i16` values.\n *\n * @example\n * Decoding an `i16` value.\n * ```ts\n * const decoder = getI16Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6, 0xff])); // -42\n * ```\n *\n * @see {@link getI16Codec}\n */\nexport const getI16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt16(0, le),\n        name: 'i16',\n        size: 2,\n    });\n\n/**\n * Returns a codec for encoding and decoding 16-bit signed integers (`i16`).\n *\n * This codec serializes `i16` values using 2 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, number, 2>` for encoding and decoding `i16` values.\n *\n * @example\n * Encoding and decoding an `i16` value.\n * ```ts\n * const codec = getI16Codec();\n * const bytes = codec.encode(-42); // 0xd6ff\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI16Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42); // 0xffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^15` (`-32,768`) and `2^15 - 1` (`32,767`).\n *\n * - If you need a smaller signed integer, consider using {@link getI8Codec}.\n * - If you need a larger signed integer, consider using {@link getI32Codec}.\n * - If you need unsigned integers, consider using {@link getU16Codec}.\n *\n * Separate {@link getI16Encoder} and {@link getI16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI16Encoder().encode(-42);\n * const value = getI16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI16Encoder}\n * @see {@link getI16Decoder}\n */\nexport const getI16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getI16Encoder(config), getI16Decoder(config));\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit signed integers (`i32`).\n *\n * This encoder serializes `i32` values using 4 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 4>` for encoding `i32` values.\n *\n * @example\n * Encoding an `i32` value.\n * ```ts\n * const encoder = getI32Encoder();\n * const bytes = encoder.encode(-42); // 0xd6ffffff\n * ```\n *\n * @see {@link getI32Codec}\n */\nexport const getI32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'i32',\n        range: [-Number('0x7fffffff') - 1, Number('0x7fffffff')],\n        set: (view, value, le) => view.setInt32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit signed integers (`i32`).\n *\n * This decoder deserializes `i32` values from 4 bytes.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `i32` values.\n *\n * @example\n * Decoding an `i32` value.\n * ```ts\n * const decoder = getI32Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6, 0xff, 0xff, 0xff])); // -42\n * ```\n *\n * @see {@link getI32Codec}\n */\nexport const getI32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt32(0, le),\n        name: 'i32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit signed integers (`i32`).\n *\n * This codec serializes `i32` values using 4 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, number, 4>` for encoding and decoding `i32` values.\n *\n * @example\n * Encoding and decoding an `i32` value.\n * ```ts\n * const codec = getI32Codec();\n * const bytes = codec.encode(-42); // 0xd6ffffff\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42); // 0xffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^31` (`-2,147,483,648`) and `2^31 - 1` (`2,147,483,647`).\n *\n * - If you need a smaller signed integer, consider using {@link getI16Codec} or {@link getI8Codec}.\n * - If you need a larger signed integer, consider using {@link getI64Codec}.\n * - If you need unsigned integers, consider using {@link getU32Codec}.\n *\n * Separate {@link getI32Encoder} and {@link getI32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI32Encoder().encode(-42);\n * const value = getI32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI32Encoder}\n * @see {@link getI32Decoder}\n */\nexport const getI32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getI32Encoder(config), getI32Decoder(config));\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit signed integers (`i64`).\n *\n * This encoder serializes `i64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 8>` for encoding `i64` values.\n *\n * @example\n * Encoding an `i64` value.\n * ```ts\n * const encoder = getI64Encoder();\n * const bytes = encoder.encode(-42n); // 0xd6ffffffffffffff\n * ```\n *\n * @see {@link getI64Codec}\n */\nexport const getI64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'i64',\n        range: [-BigInt('0x7fffffffffffffff') - 1n, BigInt('0x7fffffffffffffff')],\n        set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit signed integers (`i64`).\n *\n * This decoder deserializes `i64` values from 8 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getI64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 8>` for decoding `i64` values.\n *\n * @example\n * Decoding an `i64` value.\n * ```ts\n * const decoder = getI64Decoder();\n * const value = decoder.decode(new Uint8Array([\n *   0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n * ])); // -42n\n * ```\n *\n * @see {@link getI64Codec}\n */\nexport const getI64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigInt64(0, le),\n        name: 'i64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit signed integers (`i64`).\n *\n * This codec serializes `i64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 8>` for encoding and decoding `i64` values.\n *\n * @example\n * Encoding and decoding an `i64` value.\n * ```ts\n * const codec = getI64Codec();\n * const bytes = codec.encode(-42n); // 0xd6ffffffffffffff\n * const value = codec.decode(bytes); // -42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42n); // 0xffffffffffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^63` and `2^63 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller signed integer, consider using {@link getI32Codec} or {@link getI16Codec}.\n * - If you need a larger signed integer, consider using {@link getI128Codec}.\n * - If you need unsigned integers, consider using {@link getU64Codec}.\n *\n * Separate {@link getI64Encoder} and {@link getI64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI64Encoder().encode(-42);\n * const value = getI64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI64Encoder}\n * @see {@link getI64Decoder}\n */\nexport const getI64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getI64Encoder(config), getI64Decoder(config));\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 8-bit signed integers (`i8`).\n *\n * This encoder serializes `i8` values using 1 byte.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI8Codec}.\n *\n * @returns A `FixedSizeEncoder<number | bigint, 1>` for encoding `i8` values.\n *\n * @example\n * Encoding an `i8` value.\n * ```ts\n * const encoder = getI8Encoder();\n * const bytes = encoder.encode(-42); // 0xd6\n * ```\n *\n * @see {@link getI8Codec}\n */\nexport const getI8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'i8',\n        range: [-Number('0x7f') - 1, Number('0x7f')],\n        set: (view, value) => view.setInt8(0, Number(value)),\n        size: 1,\n    });\n\n/**\n * Returns a decoder for 8-bit signed integers (`i8`).\n *\n * This decoder deserializes `i8` values from 1 byte.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI8Codec}.\n *\n * @returns A `FixedSizeDecoder<number, 1>` for decoding `i8` values.\n *\n * @example\n * Decoding an `i8` value.\n * ```ts\n * const decoder = getI8Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6])); // -42\n * ```\n *\n * @see {@link getI8Codec}\n */\nexport const getI8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getInt8(0),\n        name: 'i8',\n        size: 1,\n    });\n\n/**\n * Returns a codec for encoding and decoding 8-bit signed integers (`i8`).\n *\n * This codec serializes `i8` values using 1 byte.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @returns A `FixedSizeCodec<number | bigint, number, 1>` for encoding and decoding `i8` values.\n *\n * @example\n * Encoding and decoding an `i8` value.\n * ```ts\n * const codec = getI8Codec();\n * const bytes = codec.encode(-42); // 0xd6\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @remarks\n * This codec supports values between `-2^7` (`-128`) and `2^7 - 1` (`127`).\n *\n * - If you need a larger signed integer, consider using {@link getI16Codec}.\n * - If you need an unsigned integer, consider using {@link getU8Codec}.\n *\n * Separate {@link getI8Encoder} and {@link getI8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI8Encoder().encode(-42);\n * const value = getI8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI8Encoder}\n * @see {@link getI8Decoder}\n */\nexport const getI8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getI8Encoder(), getI8Decoder());\n", "import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Offset,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\n\n/**\n * Returns an encoder for `shortU16` values.\n *\n * This encoder serializes `shortU16` values using **1 to 3 bytes**.\n * Smaller values use fewer bytes, while larger values take up more space.\n *\n * For more details, see {@link getShortU16Codec}.\n *\n * @returns A `VariableSizeEncoder<number | bigint>` for encoding `shortU16` values.\n *\n * @example\n * Encoding a `shortU16` value.\n * ```ts\n * const encoder = getShortU16Encoder();\n * encoder.encode(42);    // 0x2a\n * encoder.encode(128);   // 0x8001\n * encoder.encode(16384); // 0x808001\n * ```\n *\n * @see {@link getShortU16Codec}\n */\nexport const getShortU16Encoder = (): VariableSizeEncoder<bigint | number> =>\n    createEncoder({\n        getSizeFromValue: (value: bigint | number): number => {\n            if (value <= 0b01111111) return 1;\n            if (value <= 0b0011111111111111) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value: bigint | number, bytes: Uint8Array, offset: Offset): Offset => {\n            assertNumberIsBetweenForCodec('shortU16', 0, 65535, value);\n            const shortU16Bytes = [0];\n            for (let ii = 0; ; ii += 1) {\n                // Shift the bits of the value over such that the next 7 bits are at the right edge.\n                const alignedValue = Number(value) >> (ii * 7);\n                if (alignedValue === 0) {\n                    // No more bits to consume.\n                    break;\n                }\n                // Extract those 7 bits using a mask.\n                const nextSevenBits = 0b1111111 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    // Set the continuation bit of the previous slice.\n                    shortU16Bytes[ii - 1] |= 0b10000000;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        },\n    });\n\n/**\n * Returns a decoder for `shortU16` values.\n *\n * This decoder deserializes `shortU16` values from **1 to 3 bytes**.\n * The number of bytes used depends on the encoded value.\n *\n * For more details, see {@link getShortU16Codec}.\n *\n * @returns A `VariableSizeDecoder<number>` for decoding `shortU16` values.\n *\n * @example\n * Decoding a `shortU16` value.\n * ```ts\n * const decoder = getShortU16Decoder();\n * decoder.decode(new Uint8Array([0x2a]));             // 42\n * decoder.decode(new Uint8Array([0x80, 0x01]));       // 128\n * decoder.decode(new Uint8Array([0x80, 0x80, 0x01])); // 16384\n * ```\n *\n * @see {@link getShortU16Codec}\n */\nexport const getShortU16Decoder = (): VariableSizeDecoder<number> =>\n    createDecoder({\n        maxSize: 3,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset): [number, Offset] => {\n            let value = 0;\n            let byteCount = 0;\n            while (++byteCount) {\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 0b1111111 & currentByte;\n                // Insert the next group of seven bits into the correct slot of the output value.\n                value |= nextSevenBits << (byteIndex * 7);\n                if ((currentByte & 0b10000000) === 0) {\n                    // This byte does not have its continuation bit set. We're done.\n                    break;\n                }\n            }\n            return [value, offset + byteCount];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding `shortU16` values.\n *\n * It serializes unsigned integers using **1 to 3 bytes** based on the encoded value.\n * The larger the value, the more bytes it uses.\n *\n * - If the value is `<= 0x7f` (127), it is stored in a **single byte**\n *   and the first bit is set to `0` to indicate the end of the value.\n * - Otherwise, the first bit is set to `1` to indicate that the value continues in the next byte, which follows the same pattern.\n * - This process repeats until the value is fully encoded in up to 3 bytes. The third and last byte, if needed, uses all 8 bits to store the remaining value.\n *\n * In other words, the encoding scheme follows this structure:\n *\n * ```txt\n * 0XXXXXXX                   <- Values 0 to 127 (1 byte)\n * 1XXXXXXX 0XXXXXXX          <- Values 128 to 16,383 (2 bytes)\n * 1XXXXXXX 1XXXXXXX XXXXXXXX <- Values 16,384 to 4,194,303 (3 bytes)\n * ```\n *\n * @returns A `VariableSizeCodec<number | bigint, number>` for encoding and decoding `shortU16` values.\n *\n * @example\n * Encoding and decoding `shortU16` values.\n * ```ts\n * const codec = getShortU16Codec();\n * const bytes1 = codec.encode(42);    // 0x2a\n * const bytes2 = codec.encode(128);   // 0x8001\n * const bytes3 = codec.encode(16384); // 0x808001\n *\n * codec.decode(bytes1); // 42\n * codec.decode(bytes2); // 128\n * codec.decode(bytes3); // 16384\n * ```\n *\n * @remarks\n * This codec efficiently stores small numbers, making it useful for transactions and compact representations.\n *\n * If you need a fixed-size `u16` codec, consider using {@link getU16Codec}.\n *\n * Separate {@link getShortU16Encoder} and {@link getShortU16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getShortU16Encoder().encode(42);\n * const value = getShortU16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getShortU16Encoder}\n * @see {@link getShortU16Decoder}\n */\nexport const getShortU16Codec = (): VariableSizeCodec<bigint | number, number> =>\n    combineCodec(getShortU16Encoder(), getShortU16Decoder());\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 128-bit unsigned integers (`u128`).\n *\n * This encoder serializes `u128` values using sixteen bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU128Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<number | bigint, 16>` for encoding `u128` values.\n *\n * @example\n * Encoding a `u128` value.\n * ```ts\n * const encoder = getU128Encoder();\n * const bytes = encoder.encode(42n); // 0x2a000000000000000000000000000000\n * ```\n *\n * @see {@link getU128Codec}\n */\nexport const getU128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'u128',\n        range: [0n, BigInt('0xffffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\n/**\n * Returns a decoder for 128-bit unsigned integers (`u128`).\n *\n * This decoder deserializes `u128` values from sixteen bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU128Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<bigint, 16>` for decoding `u128` values.\n *\n * @example\n * Decoding a `u128` value.\n * ```ts\n * const decoder = getU128Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])); // 42n\n * ```\n *\n * @see {@link getU128Codec}\n */\nexport const getU128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'u128',\n        size: 16,\n    });\n\n/**\n * Returns a codec for encoding and decoding 128-bit unsigned integers (`u128`).\n *\n * This codec serializes `u128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 16>` for encoding and decoding `u128` values.\n *\n * @example\n * Encoding and decoding a `u128` value.\n * ```ts\n * const codec = getU128Codec();\n * const bytes = codec.encode(42); // 0x2a000000000000000000000000000000\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getU128Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x0000000000000000000000000000002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^128 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller unsigned integer, consider using {@link getU64Codec} or {@link getU32Codec}.\n * - If you need signed integers, consider using {@link getI128Codec}.\n *\n * Separate {@link getU128Encoder} and {@link getU128Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU128Encoder().encode(42);\n * const value = getU128Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU128Encoder}\n * @see {@link getU128Decoder}\n */\nexport const getU128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getU128Encoder(config), getU128Decoder(config));\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 16-bit unsigned integers (`u16`).\n *\n * This encoder serializes `u16` values using two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU16Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<number | bigint, 2>` for encoding `u16` values.\n *\n * @example\n * Encoding a `u16` value.\n * ```ts\n * const encoder = getU16Encoder();\n * const bytes = encoder.encode(42); // 0x2a00\n * ```\n *\n * @see {@link getU16Codec}\n */\nexport const getU16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'u16',\n        range: [0, Number('0xffff')],\n        set: (view, value, le) => view.setUint16(0, Number(value), le),\n        size: 2,\n    });\n\n/**\n * Returns a decoder for 16-bit unsigned integers (`u16`).\n *\n * This decoder deserializes `u16` values from two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU16Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<number, 2>` for decoding `u16` values.\n *\n * @example\n * Decoding a `u16` value.\n * ```ts\n * const decoder = getU16Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @see {@link getU16Codec}\n */\nexport const getU16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint16(0, le),\n        name: 'u16',\n        size: 2,\n    });\n\n/**\n * Returns a codec for encoding and decoding 16-bit unsigned integers (`u16`).\n *\n * This codec serializes `u16` values using two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeCodec<number | bigint, number, 2>` for encoding and decoding `u16` values.\n *\n * @example\n * Encoding and decoding a `u16` value.\n * ```ts\n * const codec = getU16Codec();\n * const bytes = codec.encode(42); // 0x2a00 (little-endian)\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Storing values in big-endian format.\n * ```ts\n * const codec = getU16Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^16 - 1`.\n * If you need a larger range, consider using {@link getU32Codec} or {@link getU64Codec}.\n * For signed integers, use {@link getI16Codec}.\n *\n * Separate {@link getU16Encoder} and {@link getU16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU16Encoder().encode(42);\n * const value = getU16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU16Encoder}\n * @see {@link getU16Decoder}\n */\nexport const getU16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getU16Encoder(config), getU16Decoder(config));\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit unsigned integers (`u32`).\n *\n * This encoder serializes `u32` values using four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU32Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<bigint | number, 4>` for encoding `u32` values.\n *\n * @example\n * Encoding a `u32` value.\n * ```ts\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42); // 0x2a000000\n * ```\n *\n * @see {@link getU32Codec}\n */\nexport const getU32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'u32',\n        range: [0, Number('0xffffffff')],\n        set: (view, value, le) => view.setUint32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit unsigned integers (`u32`).\n *\n * This decoder deserializes `u32` values from four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU32Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `u32` values.\n *\n * @example\n * Decoding a `u32` value.\n * ```ts\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @see {@link getU32Codec}\n */\nexport const getU32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint32(0, le),\n        name: 'u32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit unsigned integers (`u32`).\n *\n * This codec serializes `u32` values using four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeCodec<bigint | number, number, 4>` for encoding and decoding `u32` values.\n *\n * @example\n * Encoding and decoding a `u32` value.\n * ```ts\n * const codec = getU32Codec();\n * const bytes = codec.encode(42); // 0x2a000000 (little-endian)\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Storing values in big-endian format.\n * ```ts\n * const codec = getU32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x0000002a\n * ```\n *\n * @remarks\n * This codec only supports values between `0` and `2^32 - 1`.\n * If you need a larger range, consider using {@link getU64Codec} or {@link getU128Codec}.\n * For signed integers, use {@link getI32Codec}.\n *\n * Separate {@link getU32Encoder} and {@link getU32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU32Encoder().encode(42);\n * const value = getU32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU32Encoder}\n * @see {@link getU32Decoder}\n */\nexport const getU32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getU32Encoder(config), getU32Decoder(config));\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit unsigned integers (`u64`).\n *\n * This encoder serializes `u64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getU64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 8>` for encoding `u64` values.\n *\n * @example\n * Encoding a `u64` value.\n * ```ts\n * const encoder = getU64Encoder();\n * const bytes = encoder.encode(42); // 0x2a00000000000000\n * ```\n *\n * @see {@link getU64Codec}\n */\nexport const getU64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'u64',\n        range: [0n, BigInt('0xffffffffffffffff')],\n        set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit unsigned integers (`u64`).\n *\n * This decoder deserializes `u64` values from 8 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getU64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 8>` for decoding `u64` values.\n *\n * @example\n * Decoding a `u64` value.\n * ```ts\n * const decoder = getU64Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])); // 42n\n * ```\n *\n * @see {@link getU64Codec}\n */\nexport const getU64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigUint64(0, le),\n        name: 'u64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit unsigned integers (`u64`).\n *\n * This codec serializes `u64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 8>` for encoding and decoding `u64` values.\n *\n * @example\n * Encoding and decoding a `u64` value.\n * ```ts\n * const codec = getU64Codec();\n * const bytes = codec.encode(42); // 0x2a00000000000000\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getU64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x000000000000002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^64 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller unsigned integer, consider using {@link getU32Codec} or {@link getU16Codec}.\n * - If you need a larger unsigned integer, consider using {@link getU128Codec}.\n * - If you need signed integers, consider using {@link getI64Codec}.\n *\n * Separate {@link getU64Encoder} and {@link getU64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU64Encoder().encode(42);\n * const value = getU64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU64Encoder}\n * @see {@link getU64Decoder}\n */\nexport const getU64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getU64Encoder(config), getU64Decoder(config));\n", "import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 8-bit unsigned integers (`u8`).\n *\n * This encoder serializes `u8` values using a single byte.\n *\n * For more details, see {@link getU8Codec}.\n *\n * @returns A `FixedSizeEncoder<number | bigint, 1>` for encoding `u8` values.\n *\n * @example\n * Encoding a `u8` value.\n * ```ts\n * const encoder = getU8Encoder();\n * const bytes = encoder.encode(42); // 0x2a\n * ```\n *\n * @see {@link getU8Codec}\n */\nexport const getU8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'u8',\n        range: [0, Number('0xff')],\n        set: (view, value) => view.setUint8(0, Number(value)),\n        size: 1,\n    });\n\n/**\n * Returns a decoder for 8-bit unsigned integers (`u8`).\n *\n * This decoder deserializes `u8` values from a single byte.\n *\n * For more details, see {@link getU8Codec}.\n *\n * @returns A `FixedSizeDecoder<number, 1>` for decoding `u8` values.\n *\n * @example\n * Decoding a `u8` value.\n * ```ts\n * const decoder = getU8Decoder();\n * const value = decoder.decode(new Uint8Array([0xff])); // 255\n * ```\n *\n * @see {@link getU8Codec}\n */\nexport const getU8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getUint8(0),\n        name: 'u8',\n        size: 1,\n    });\n\n/**\n * Returns a codec for encoding and decoding 8-bit unsigned integers (`u8`).\n *\n * This codec serializes `u8` values using a single byte.\n *\n * @returns A `FixedSizeCodec<number | bigint, number, 1>` for encoding and decoding `u8` values.\n *\n * @example\n * Encoding and decoding a `u8` value.\n * ```ts\n * const codec = getU8Codec();\n * const bytes = codec.encode(255); // 0xff\n * const value = codec.decode(bytes); // 255\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^8 - 1` (0 to 255).\n * If you need larger integers, consider using {@link getU16Codec}, {@link getU32Codec}, or {@link getU64Codec}.\n * For signed integers, use {@link getI8Codec}.\n *\n * Separate {@link getU8Encoder} and {@link getU8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU8Encoder().encode(42);\n * const value = getU8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU8Encoder}\n * @see {@link getU8Decoder}\n */\nexport const getU8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getU8Encoder(), getU8Decoder());\n", "import { SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SolanaError } from '@solana/errors';\n\n/** Checks the number of items in an array-like structure is expected. */\nexport function assertValidNumberOfItemsForCodec(\n    codecDescription: string,\n    expected: bigint | number,\n    actual: bigint | number,\n) {\n    if (expected !== actual) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n            actual,\n            codecDescription,\n            expected,\n        });\n    }\n}\n", "import { isFixedSize } from '@solana/codecs-core';\n\n/**\n * Functionally, this type helper is equivalent to the identity type — i.e. `type Identity<T> = T`.\n * However, wrapping generic object mappings in this type significantly reduces the number\n * of instantiation expressions processed, which increases TypeScript performance and\n * prevents \"Type instantiation is excessively deep and possibly infinite\" errors.\n *\n * This works because TypeScript doesn't create a new level of nesting when encountering conditional generic types.\n * @see https://github.com/microsoft/TypeScript/issues/34933\n * @see https://github.com/kysely-org/kysely/pull/483\n */\nexport type DrainOuterGeneric<T> = [T] extends [unknown] ? T : never;\n\nexport function maxCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce(\n        (all, size) => (all === null || size === null ? null : Math.max(all, size)),\n        0 as number | null,\n    );\n}\n\nexport function sumCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce((all, size) => (all === null || size === null ? null : all + size), 0 as number | null);\n}\n\nexport function getFixedSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : null;\n}\n\nexport function getMaxSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : (codec.maxSize ?? null);\n}\n", "import {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getU32Decoder, getU32Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { getFixedSize, getMaxSize } from './utils';\n\n/**\n * Defines the possible size strategies for array-like codecs (`array`, `map`, and `set`).\n *\n * The size of the collection can be determined using one of the following approaches:\n * - A {@link NumberCodec}, {@link NumberDecoder}, or {@link NumberEncoder} to store a size prefix.\n * - A fixed `number` of items, enforcing an exact length.\n * - The string `\"remainder\"`, which infers the number of items by consuming the rest of the available bytes.\n *   This option is only available when encoding fixed-size items.\n *\n * @typeParam TPrefix - A number codec, decoder, or encoder used for size prefixing.\n */\nexport type ArrayLikeCodecSize<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> =\n    | TPrefix\n    | number\n    | 'remainder';\n\n/**\n * Defines the configuration options for array codecs.\n *\n * @typeParam TPrefix - A number codec, decoder, or encoder used for size prefixing.\n */\nexport type ArrayCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how the size of the array is determined.\n     *\n     * - A {@link NumberCodec}, {@link NumberDecoder}, or {@link NumberEncoder} stores a size prefix before encoding the array.\n     * - A `number` enforces a fixed number of elements.\n     * - `\"remainder\"` uses all remaining bytes to infer the array length (only for fixed-size items).\n     *\n     * @defaultValue A `u32` size prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for arrays of values.\n *\n * This encoder serializes arrays by encoding each element using the provided item encoder.\n * By default, a `u32` size prefix is included to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * For more details, see {@link getArrayCodec}.\n *\n * @typeParam TFrom - The type of the elements in the array.\n *\n * @param item - The encoder for each item in the array.\n * @param config - Optional configuration for the size encoding strategy.\n * @returns A `VariableSizeEncoder<TFrom[]>` for encoding arrays.\n *\n * @example\n * Encoding an array of `u8` numbers.\n * ```ts\n * const encoder = getArrayEncoder(getU8Encoder());\n * const bytes = encoder.encode([1, 2, 3]);\n * // 0x03000000010203\n * //   |       └-- 3 items of 1 byte each.\n * //   └-- 4-byte prefix telling us to read 3 items.\n * ```\n *\n * @see {@link getArrayCodec}\n */\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<TFrom[], 0>;\nexport function getArrayEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: ArrayCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom[]> {\n    const size = config.size ?? getU32Encoder();\n    const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize !== null\n            ? { fixedSize }\n            : {\n                  getSizeFromValue: (array: TFrom[]) => {\n                      const prefixSize = typeof size === 'object' ? getEncodedSize(array.length, size) : 0;\n                      return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);\n                  },\n                  maxSize,\n              }),\n        write: (array: TFrom[], bytes, offset) => {\n            if (typeof size === 'number') {\n                assertValidNumberOfItemsForCodec('array', size, array.length);\n            }\n            if (typeof size === 'object') {\n                offset = size.write(array.length, bytes, offset);\n            }\n            array.forEach(value => {\n                offset = item.write(value, bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for arrays of values.\n *\n * This decoder deserializes arrays by decoding each element using the provided item decoder.\n * By default, a `u32` size prefix is expected to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * For more details, see {@link getArrayCodec}.\n *\n * @typeParam TTo - The type of the decoded elements in the array.\n *\n * @param item - The decoder for each item in the array.\n * @param config - Optional configuration for the size decoding strategy.\n * @returns A `VariableSizeDecoder<TTo[]>` for decoding arrays.\n *\n * @example\n * Decoding an array of `u8` numbers.\n * ```ts\n * const decoder = getArrayDecoder(getU8Decoder());\n * const array = decoder.decode(new Uint8Array([0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03]));\n * // [1, 2, 3]\n * // 0x03000000010203\n * //   |       └-- 3 items of 1 byte each.\n * //   └-- 4-byte prefix telling us to read 3 items.\n * ```\n *\n * @see {@link getArrayCodec}\n */\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<TTo[], 0>;\nexport function getArrayDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: ArrayCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(item: Decoder<TTo>, config: ArrayCodecConfig<NumberDecoder> = {}): Decoder<TTo[]> {\n    const size = config.size ?? getU32Decoder();\n    const itemSize = getFixedSize(item);\n    const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize !== null ? { fixedSize } : { maxSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const array: TTo[] = [];\n            if (typeof size === 'object' && bytes.slice(offset).length === 0) {\n                return [array, offset];\n            }\n\n            if (size === 'remainder') {\n                while (offset < bytes.length) {\n                    const [value, newOffset] = item.read(bytes, offset);\n                    offset = newOffset;\n                    array.push(value);\n                }\n                return [array, offset];\n            }\n\n            const [resolvedSize, newOffset] = typeof size === 'number' ? [size, offset] : size.read(bytes, offset);\n            offset = newOffset;\n            for (let i = 0; i < resolvedSize; i += 1) {\n                const [value, newOffset] = item.read(bytes, offset);\n                offset = newOffset;\n                array.push(value);\n            }\n            return [array, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding arrays of values.\n *\n * This codec serializes arrays by encoding each element using the provided item codec.\n * By default, a `u32` size prefix is included to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * @typeParam TFrom - The type of the elements to encode.\n * @typeParam TTo - The type of the decoded elements.\n *\n * @param item - The codec for each item in the array.\n * @param config - Optional configuration for the size encoding/decoding strategy.\n * @returns A `VariableSizeCodec<TFrom[], TTo[]>` for encoding and decoding arrays.\n *\n * @example\n * Encoding and decoding an array of `u8` numbers.\n * ```ts\n * const codec = getArrayCodec(getU8Codec());\n * const bytes = codec.encode([1, 2, 3]);\n * // 0x03000000010203\n * //   |       └-- 3 items of 1 byte each.\n * //   └-- 4-byte prefix telling us to read 3 items.\n *\n * const array = codec.decode(bytes);\n * // [1, 2, 3]\n * ```\n *\n * @example\n * Using a `u16` size prefix instead of `u32`.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode([1, 2, 3]);\n * // 0x0300010203\n * //   |   └-- 3 items of 1 byte each.\n * //   └-- 2-byte prefix telling us to read 3 items.\n * ```\n *\n * @example\n * Using a fixed-size array of 3 items.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: 3 });\n * codec.encode([1, 2, 3]);\n * // 0x010203\n * //   └-- 3 items of 1 byte each. There must always be 3 items in the array.\n * ```\n *\n * @example\n * Using the `\"remainder\"` size strategy.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: 'remainder' });\n * codec.encode([1, 2, 3]);\n * // 0x010203\n * //   └-- 3 items of 1 byte each. The size is inferred from the remainder of the bytes.\n * ```\n *\n * @remarks\n * The size of the array can be controlled using the `size` option:\n * - A `Codec<number>` (e.g. `getU16Codec()`) stores a size prefix before the array.\n * - A `number` enforces a fixed number of elements.\n * - `\"remainder\"` uses all remaining bytes to infer the array length.\n *\n * Separate {@link getArrayEncoder} and {@link getArrayDecoder} functions are available.\n *\n * ```ts\n * const bytes = getArrayEncoder(getU8Encoder()).encode([1, 2, 3]);\n * const array = getArrayDecoder(getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getArrayEncoder}\n * @see {@link getArrayDecoder}\n */\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<TFrom[], TTo[], 0>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: ArrayCodecConfig<NumberCodec>,\n): VariableSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> = {},\n): Codec<TFrom[], TTo[]> {\n    return combineCodec(getArrayEncoder(item, config as object), getArrayDecoder(item, config as object));\n}\n\nfunction computeArrayLikeCodecSize(size: number | object | 'remainder', itemSize: number | null): number | null {\n    if (typeof size !== 'number') return null;\n    if (size === 0) return 0;\n    return itemSize === null ? null : itemSize * size;\n}\n", "import {\n    assertByteArrayHasEnoughBytesForCodec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Defines the configuration options for bit array codecs.\n *\n * A bit array codec encodes an array of booleans into bits, packing them into bytes.\n * This configuration allows adjusting the bit ordering.\n *\n * @see {@link getBitArrayEncoder}\n * @see {@link getBitArrayDecoder}\n * @see {@link getBitArrayCodec}\n */\nexport type BitArrayCodecConfig = {\n    /**\n     * Determines whether the bits should be read in reverse order.\n     *\n     * - `false` (default): The first boolean is stored in the most significant bit (MSB-first).\n     * - `true`: The first boolean is stored in the least significant bit (LSB-first).\n     *\n     * @defaultValue `false`\n     */\n    backward?: boolean;\n};\n\n/**\n * Returns an encoder that packs an array of booleans into bits.\n *\n * This encoder converts a list of `boolean` values into a compact bit representation,\n * storing 8 booleans per byte.\n *\n * The `backward` config option determines whether the bits are stored in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * For more details, see {@link getBitArrayCodec}.\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for encoding the bit array.\n * @returns A `FixedSizeEncoder<boolean[], TSize>` for encoding bit arrays.\n *\n * @example\n * Encoding a bit array.\n * ```ts\n * const encoder = getBitArrayEncoder(1);\n *\n * encoder.encode([true, false, true, false, false, false, false, false]);\n * // 0xa0 (0b10100000)\n * ```\n *\n * @see {@link getBitArrayCodec}\n */\nexport function getBitArrayEncoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeEncoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createEncoder({\n        fixedSize: size,\n        write(value: boolean[], bytes, offset) {\n            const bytesToAdd: number[] = [];\n\n            for (let i = 0; i < size; i += 1) {\n                let byte = 0;\n                for (let j = 0; j < 8; j += 1) {\n                    const feature = Number(value[i * 8 + j] ?? 0);\n                    byte |= feature << (backward ? j : 7 - j);\n                }\n                if (backward) {\n                    bytesToAdd.unshift(byte);\n                } else {\n                    bytesToAdd.push(byte);\n                }\n            }\n\n            bytes.set(bytesToAdd, offset);\n            return size;\n        },\n    });\n}\n\n/**\n * Returns a decoder that unpacks bits into an array of booleans.\n *\n * This decoder converts a compact bit representation back into a list of `boolean` values.\n * Each byte is expanded into 8 booleans.\n *\n * The `backward` config option determines whether the bits are read in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * For more details, see {@link getBitArrayCodec}.\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for decoding the bit array.\n * @returns A `FixedSizeDecoder<boolean[], TSize>` for decoding bit arrays.\n *\n * @example\n * Decoding a bit array.\n * ```ts\n * const decoder = getBitArrayDecoder(1);\n *\n * decoder.decode(new Uint8Array([0xa0]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @see {@link getBitArrayCodec}\n */\nexport function getBitArrayDecoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeDecoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createDecoder({\n        fixedSize: size,\n        read(bytes, offset) {\n            assertByteArrayHasEnoughBytesForCodec('bitArray', size, bytes, offset);\n            const booleans: boolean[] = [];\n            let slice = bytes.slice(offset, offset + size);\n            slice = backward ? slice.reverse() : slice;\n\n            slice.forEach(byte => {\n                for (let i = 0; i < 8; i += 1) {\n                    if (backward) {\n                        booleans.push(Boolean(byte & 1));\n                        byte >>= 1;\n                    } else {\n                        booleans.push(Boolean(byte & 0b1000_0000));\n                        byte <<= 1;\n                    }\n                }\n            });\n\n            return [booleans, offset + size];\n        },\n    });\n}\n\n/**\n * Returns a codec that encodes and decodes boolean arrays as compact bit representations.\n *\n * This codec efficiently stores boolean arrays as bits, packing 8 values per byte.\n * The `backward` config option determines whether bits are stored in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for encoding and decoding the bit array.\n * @returns A `FixedSizeCodec<boolean[], boolean[], TSize>` for encoding and decoding bit arrays.\n *\n * @example\n * Encoding and decoding a bit array.\n * ```ts\n * const codec = getBitArrayCodec(1);\n *\n * codec.encode([true, false, true, false, false, false, false, false]);\n * // 0xa0 (0b10100000)\n *\n * codec.decode(new Uint8Array([0xa0]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @example\n * Encoding and decoding a bit array backwards.\n * ```ts\n * const codec = getBitArrayCodec(1, { backward: true });\n *\n * codec.encode([true, false, true, false, false, false, false, false]);\n * // 0x05 (0b00000101)\n *\n * codec.decode(new Uint8Array([0x05]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @remarks\n * Separate {@link getBitArrayEncoder} and {@link getBitArrayDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBitArrayEncoder(1).encode([true, false, true, false]);\n * const value = getBitArrayDecoder(1).decode(bytes);\n * ```\n *\n * @see {@link getBitArrayEncoder}\n * @see {@link getBitArrayDecoder}\n */\nexport function getBitArrayCodec<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeCodec<boolean[], boolean[], TSize> {\n    return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\n", "import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\n/**\n * Defines the configuration options for boolean codecs.\n *\n * A boolean codec encodes `true` as `1` and `false` as `0`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * @typeParam TSize - A number codec, encoder, or decoder used for boolean representation.\n *\n * @see {@link getBooleanEncoder}\n * @see {@link getBooleanDecoder}\n * @see {@link getBooleanCodec}\n */\nexport type BooleanCodecConfig<TSize extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The number codec used to store boolean values.\n     *\n     * - By default, booleans are stored as a `u8` (`1` for `true`, `0` for `false`).\n     * - A custom number codec can be provided to change the storage size.\n     *\n     * @defaultValue `u8`\n     */\n    size?: TSize;\n};\n\n/**\n * Returns an encoder for boolean values.\n *\n * This encoder converts `true` into `1` and `false` into `0`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * For more details, see {@link getBooleanCodec}.\n *\n * @param config - Configuration options for encoding booleans.\n * @returns A `FixedSizeEncoder<boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Encoding booleans.\n * ```ts\n * const encoder = getBooleanEncoder();\n *\n * encoder.encode(false); // 0x00\n * encoder.encode(true);  // 0x01\n * ```\n *\n * @see {@link getBooleanCodec}\n */\nexport function getBooleanEncoder(): FixedSizeEncoder<boolean, 1>;\nexport function getBooleanEncoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<boolean, TSize>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder>): VariableSizeEncoder<boolean>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder> = {}): Encoder<boolean> {\n    return transformEncoder(config.size ?? getU8Encoder(), (value: boolean) => (value ? 1 : 0));\n}\n\n/**\n * Returns a decoder for boolean values.\n *\n * This decoder reads a number and interprets `1` as `true` and `0` as `false`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * For more details, see {@link getBooleanCodec}.\n *\n * @param config - Configuration options for decoding booleans.\n * @returns A `FixedSizeDecoder<boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Decoding booleans.\n * ```ts\n * const decoder = getBooleanDecoder();\n *\n * decoder.decode(new Uint8Array([0x00])); // false\n * decoder.decode(new Uint8Array([0x01])); // true\n * ```\n *\n * @see {@link getBooleanCodec}\n */\nexport function getBooleanDecoder(): FixedSizeDecoder<boolean, 1>;\nexport function getBooleanDecoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<boolean, TSize>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder>): VariableSizeDecoder<boolean>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder> = {}): Decoder<boolean> {\n    return transformDecoder(config.size ?? getU8Decoder(), (value: bigint | number): boolean => Number(value) === 1);\n}\n\n/**\n * Returns a codec for encoding and decoding boolean values.\n *\n * By default, booleans are stored as a `u8` (`1` for `true`, `0` for `false`).\n * The `size` option allows customizing the number codec used for storage.\n *\n * @param config - Configuration options for encoding and decoding booleans.\n * @returns A `FixedSizeCodec<boolean, boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Encoding and decoding booleans using a `u8` (default).\n * ```ts\n * const codec = getBooleanCodec();\n *\n * codec.encode(false); // 0x00\n * codec.encode(true);  // 0x01\n *\n * codec.decode(new Uint8Array([0x00])); // false\n * codec.decode(new Uint8Array([0x01])); // true\n * ```\n *\n * @example\n * Encoding and decoding booleans using a custom number codec.\n * ```ts\n * const codec = getBooleanCodec({ size: getU16Codec() });\n *\n * codec.encode(false); // 0x0000\n * codec.encode(true);  // 0x0100\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // false\n * codec.decode(new Uint8Array([0x01, 0x00])); // true\n * ```\n *\n * @remarks\n * Separate {@link getBooleanEncoder} and {@link getBooleanDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBooleanEncoder().encode(true);\n * const value = getBooleanDecoder().decode(bytes);\n * ```\n *\n * @see {@link getBooleanEncoder}\n * @see {@link getBooleanDecoder}\n */\nexport function getBooleanCodec(): FixedSizeCodec<boolean, boolean, 1>;\nexport function getBooleanCodec<TSize extends number>(\n    config: BooleanCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<boolean, boolean, TSize>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec>): VariableSizeCodec<boolean>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec> = {}): Codec<boolean> {\n    return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\n", "import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Returns an encoder for raw byte arrays.\n *\n * This encoder writes byte arrays exactly as provided without modification.\n *\n * The size of the encoded byte array is determined by the length of the input.\n * - To enforce a fixed size, consider using {@link fixEncoderSize}.\n * - To add a size prefix, use {@link addEncoderSizePrefix}.\n * - To add a sentinel value, use {@link addEncoderSentinel}.\n *\n * For more details, see {@link getBytesCodec}.\n *\n * @returns A `VariableSizeEncoder<ReadonlyUint8Array | Uint8Array>`.\n *\n * @example\n * Encoding a byte array as-is.\n * ```ts\n * const encoder = getBytesEncoder();\n *\n * encoder.encode(new Uint8Array([1, 2, 3])); // 0x010203\n * encoder.encode(new Uint8Array([255, 0, 127])); // 0xff007f\n * ```\n *\n * @see {@link getBytesCodec}\n */\nexport function getBytesEncoder(): VariableSizeEncoder<ReadonlyUint8Array | Uint8Array> {\n    return createEncoder({\n        getSizeFromValue: value => value.length,\n        write: (value, bytes, offset) => {\n            bytes.set(value, offset);\n            return offset + value.length;\n        },\n    });\n}\n\n/**\n * Returns a decoder for raw byte arrays.\n *\n * This decoder reads byte arrays exactly as provided without modification.\n *\n * The decoded byte array extends from the provided offset to the end of the input.\n * - To enforce a fixed size, consider using {@link fixDecoderSize}.\n * - To add a size prefix, use {@link addDecoderSizePrefix}.\n * - To add a sentinel value, use {@link addDecoderSentinel}.\n *\n * For more details, see {@link getBytesCodec}.\n *\n * @returns A `VariableSizeDecoder<ReadonlyUint8Array>`.\n *\n * @example\n * Decoding a byte array as-is.\n * ```ts\n * const decoder = getBytesDecoder();\n *\n * decoder.decode(new Uint8Array([1, 2, 3])); // Uint8Array([1, 2, 3])\n * decoder.decode(new Uint8Array([255, 0, 127])); // Uint8Array([255, 0, 127])\n * ```\n *\n * @see {@link getBytesCodec}\n */\nexport function getBytesDecoder(): VariableSizeDecoder<ReadonlyUint8Array> {\n    return createDecoder({\n        read: (bytes, offset) => {\n            const slice = bytes.slice(offset);\n            return [slice, offset + slice.length];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding raw byte arrays.\n *\n * This codec serializes and deserializes byte arrays without modification.\n *\n * The size of the encoded and decoded byte array is determined dynamically.\n * This means, when reading, the codec will consume all remaining bytes in the input.\n * - To enforce a fixed size, consider using {@link fixCodecSize}.\n * - To add a size prefix, use {@link addCodecSizePrefix}.\n * - To add a sentinel value, use {@link addCodecSentinel}.\n *\n * @returns A `VariableSizeCodec<ReadonlyUint8Array | Uint8Array, ReadonlyUint8Array>`.\n *\n * @example\n * Encoding and decoding a byte array.\n * ```ts\n * const codec = getBytesCodec();\n *\n * codec.encode(new Uint8Array([1, 2, 3])); // 0x010203\n * codec.decode(new Uint8Array([255, 0, 127])); // Uint8Array([255, 0, 127])\n * ```\n *\n * @remarks\n * Separate {@link getBytesEncoder} and {@link getBytesDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBytesEncoder().encode(new Uint8Array([1, 2, 3]));\n * const value = getBytesDecoder().decode(bytes);\n * ```\n *\n * @see {@link getBytesEncoder}\n * @see {@link getBytesDecoder}\n */\nexport function getBytesCodec(): VariableSizeCodec<ReadonlyUint8Array | Uint8Array, ReadonlyUint8Array> {\n    return combineCodec(getBytesEncoder(), getBytesDecoder());\n}\n", "import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/**\n * Returns an encoder for base-16 (hexadecimal) strings.\n *\n * This encoder serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-16 strings.\n *\n * @example\n * Encoding a base-16 string.\n * ```ts\n * const encoder = getBase16Encoder();\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-16 (hexadecimal) strings.\n *\n * This decoder deserializes base-16 encoded strings from a byte array.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-16 strings.\n *\n * @example\n * Decoding a base-16 string.\n * ```ts\n * const decoder = getBase16Decoder();\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-16 (hexadecimal) strings.\n *\n * This codec serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-16 strings.\n *\n * @example\n * Encoding and decoding a base-16 string.\n * ```ts\n * const codec = getBase16Codec();\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-16 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase16Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-16 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase16Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase16Encoder} and {@link getBase16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase16Encoder().encode('deadface');\n * const value = getBase16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase16Encoder}\n * @see {@link getBase16Decoder}\n */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n", "import {\n    combineCodec,\n    containsBytes,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { getBase16Decoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__CODECS__INVALID_CONSTANT, SolanaError } from '@solana/errors';\n\n/**\n * Returns an encoder that always writes a predefined constant byte sequence.\n *\n * This encoder ensures that encoding always produces the specified byte array,\n * ignoring any input values.\n *\n * For more details, see {@link getConstantCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence that will be written during encoding.\n *\n * @param constant - The predefined byte array to encode.\n * @returns A `FixedSizeEncoder<void, N>` where `N` is the length of the constant.\n *\n * @example\n * Encoding a constant magic number.\n * ```ts\n * const encoder = getConstantEncoder(new Uint8Array([1, 2, 3, 4]));\n *\n * const bytes = encoder.encode();\n * // 0x01020304\n * //   └──────┘ The predefined 4-byte constant.\n * ```\n *\n * @see {@link getConstantCodec}\n */\nexport function getConstantEncoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeEncoder<void, TConstant['length']> {\n    return createEncoder({\n        fixedSize: constant.length,\n        write: (_, bytes, offset) => {\n            bytes.set(constant, offset);\n            return offset + constant.length;\n        },\n    });\n}\n\n/**\n * Returns a decoder that verifies a predefined constant byte sequence.\n *\n * This decoder reads the next bytes and checks that they match the provided constant.\n * If the bytes differ, it throws an error.\n *\n * For more details, see {@link getConstantCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence expected during decoding.\n *\n * @param constant - The predefined byte array to verify.\n * @returns A `FixedSizeDecoder<void, N>` where `N` is the length of the constant.\n *\n * @example\n * Decoding a constant magic number.\n * ```ts\n * const decoder = getConstantDecoder(new Uint8Array([1, 2, 3]));\n *\n * decoder.decode(new Uint8Array([1, 2, 3])); // Passes\n * decoder.decode(new Uint8Array([1, 2, 4])); // Throws an error\n * ```\n *\n * @see {@link getConstantCodec}\n */\nexport function getConstantDecoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeDecoder<void, TConstant['length']> {\n    return createDecoder({\n        fixedSize: constant.length,\n        read: (bytes, offset) => {\n            const base16 = getBase16Decoder();\n            if (!containsBytes(bytes, constant, offset)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_CONSTANT, {\n                    constant,\n                    data: bytes,\n                    hexConstant: base16.decode(constant),\n                    hexData: base16.decode(bytes),\n                    offset,\n                });\n            }\n            return [undefined, offset + constant.length];\n        },\n    });\n}\n\n/**\n * Returns a codec that encodes and decodes a predefined constant byte sequence.\n *\n * - **Encoding:** Always writes the specified byte array.\n * - **Decoding:** Asserts that the next bytes match the constant, throwing an error if they do not.\n *\n * This is useful for encoding fixed byte patterns required in a binary format or to use in\n * conjunction with other codecs such as {@link getHiddenPrefixCodec} or {@link getHiddenSuffixCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence to encode and verify during decoding.\n *\n * @param constant - The predefined byte array to encode and assert during decoding.\n * @returns A `FixedSizeCodec<void, void, N>` where `N` is the length of the constant.\n *\n * @example\n * Encoding and decoding a constant magic number.\n * ```ts\n * const codec = getConstantCodec(new Uint8Array([1, 2, 3]));\n *\n * codec.encode(); // 0x010203\n * codec.decode(new Uint8Array([1, 2, 3])); // Passes\n * codec.decode(new Uint8Array([1, 2, 4])); // Throws an error\n * ```\n *\n * @remarks\n * Separate {@link getConstantEncoder} and {@link getConstantDecoder} functions are available.\n *\n * ```ts\n * const bytes = getConstantEncoder(new Uint8Array([1, 2, 3])).encode();\n * getConstantDecoder(new Uint8Array([1, 2, 3])).decode(bytes);\n * ```\n *\n * @see {@link getConstantEncoder}\n * @see {@link getConstantDecoder}\n */\nexport function getConstantCodec<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeCodec<void, void, TConstant['length']> {\n    return combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\n/**\n * Infers the TypeScript type for a tuple that can be encoded using a tuple codec.\n *\n * This type maps each provided item encoder to its corresponding value type.\n *\n * @typeParam TItems - An array of encoders, each corresponding to a tuple element.\n */\ntype GetEncoderTypeFromItems<TItems extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\n/**\n * Infers the TypeScript type for a tuple that can be decoded using a tuple codec.\n *\n * This type maps each provided item decoder to its corresponding value type.\n *\n * @typeParam TItems - An array of decoders, each corresponding to a tuple element.\n */\ntype GetDecoderTypeFromItems<TItems extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Returns an encoder for tuples.\n *\n * This encoder serializes a fixed-size array (tuple) by encoding its items\n * sequentially using the provided item encoders.\n *\n * For more details, see {@link getTupleCodec}.\n *\n * @typeParam TItems - An array of encoders, each corresponding to a tuple element.\n *\n * @param items - The encoders for each item in the tuple.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding tuples.\n *\n * @example\n * Encoding a tuple with 2 items.\n * ```ts\n * const encoder = getTupleEncoder([fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()]);\n *\n * const bytes = encoder.encode(['Alice', 42]);\n * // 0x416c6963652a\n * //   |         └── Second item (42)\n * //   └── First item (\"Alice\")\n * ```\n *\n * @see {@link getTupleCodec}\n */\nexport function getTupleEncoder<const TItems extends readonly FixedSizeEncoder<any>[]>(\n    items: TItems,\n): FixedSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): VariableSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): Encoder<GetEncoderTypeFromItems<TItems>> {\n    type TFrom = GetEncoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (value: TFrom, bytes, offset) => {\n            assertValidNumberOfItemsForCodec('tuple', items.length, value.length);\n            items.forEach((item, index) => {\n                offset = item.write(value[index], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for tuples.\n *\n * This decoder deserializes a fixed-size array (tuple) by decoding its items\n * sequentially using the provided item decoders.\n *\n * For more details, see {@link getTupleCodec}.\n *\n * @typeParam TItems - An array of decoders, each corresponding to a tuple element.\n *\n * @param items - The decoders for each item in the tuple.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding tuples.\n *\n * @example\n * Decoding a tuple with 2 items.\n * ```ts\n * const decoder = getTupleDecoder([fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()]);\n *\n * const tuple = decoder.decode(new Uint8Array([\n *   0x41,0x6c,0x69,0x63,0x65,0x2a\n * ]));\n * // ['Alice', 42]\n * ```\n *\n * @see {@link getTupleCodec}\n */\nexport function getTupleDecoder<const TItems extends readonly FixedSizeDecoder<any>[]>(\n    items: TItems,\n): FixedSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): VariableSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): Decoder<GetDecoderTypeFromItems<TItems>> {\n    type TTo = GetDecoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const values = [] as Array<any> & TTo;\n            items.forEach(item => {\n                const [newValue, newOffset] = item.read(bytes, offset);\n                values.push(newValue);\n                offset = newOffset;\n            });\n            return [values, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding tuples.\n *\n * This codec serializes tuples by encoding and decoding each item sequentially.\n *\n * Unlike the {@link getArrayCodec} codec, each item in the tuple has its own codec\n * and, therefore, can be of a different type.\n *\n * @typeParam TItems - An array of codecs, each corresponding to a tuple element.\n *\n * @param items - The codecs for each item in the tuple.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding tuples.\n *\n * @example\n * Encoding and decoding a tuple with 2 items.\n * ```ts\n * const codec = getTupleCodec([fixCodecSize(getUtf8Codec(), 5), getU8Codec()]);\n *\n * const bytes = codec.encode(['Alice', 42]);\n * // 0x416c6963652a\n * //   |         └── Second item (42)\n * //   └── First item (\"Alice\")\n *\n * const tuple = codec.decode(bytes);\n * // ['Alice', 42]\n * ```\n *\n * @remarks\n * Separate {@link getTupleEncoder} and {@link getTupleDecoder} functions are available.\n *\n * ```ts\n * const bytes = getTupleEncoder([fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()])\n *   .encode(['Alice', 42]);\n *\n * const tuple = getTupleDecoder([fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()])\n *   .decode(bytes);\n * ```\n *\n * @see {@link getTupleEncoder}\n * @see {@link getTupleDecoder}\n */\nexport function getTupleCodec<const TItems extends readonly FixedSizeCodec<any>[]>(\n    items: TItems,\n): FixedSizeCodec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): VariableSizeCodec<\n    GetEncoderTypeFromItems<TItems>,\n    GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>\n>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): Codec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>> {\n    return combineCodec(\n        getTupleEncoder(items),\n        getTupleDecoder(items) as Decoder<GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>,\n    );\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    getEncodedSize,\n    isFixedSize,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { DrainOuterGeneric, getMaxSize, maxCodecSizes } from './utils';\n\n/**\n * Infers the TypeScript type for values that can be encoded using a union codec.\n *\n * This type maps the provided variant encoders to their corresponding value types.\n *\n * @typeParam TVariants - An array of encoders, each corresponding to a union variant.\n */\ntype GetEncoderTypeFromVariants<TVariants extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>[number];\n\n/**\n * Infers the TypeScript type for values that can be decoded using a union codec.\n *\n * This type maps the provided variant decoders to their corresponding value types.\n *\n * @typeParam TVariants - An array of decoders, each corresponding to a union variant.\n */\ntype GetDecoderTypeFromVariants<TVariants extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Decoder<infer TFrom> ? TFrom : never;\n}>[number];\n\n/**\n * Returns an encoder for union types.\n *\n * This encoder serializes values by selecting the correct variant encoder\n * based on the `getIndexFromValue` function.\n *\n * Unlike other codecs, this encoder does not store the variant index.\n * It is the user's responsibility to manage discriminators separately.\n *\n * For more details, see {@link getUnionCodec}.\n *\n * @typeParam TVariants - An array of encoders, each corresponding to a union variant.\n *\n * @param variants - The encoders for each variant of the union.\n * @param getIndexFromValue - A function that determines the variant index from the provided value.\n * @returns An `Encoder` for encoding union values.\n *\n * @example\n * Encoding a union of numbers and booleans.\n * ```ts\n * const encoder = getUnionEncoder(\n *   [getU16Encoder(), getBooleanEncoder()],\n *   value => (typeof value === 'number' ? 0 : 1)\n * );\n *\n * encoder.encode(42);\n * // 0x2a00\n * //   └── Encoded number (42) as `u16`\n *\n * encoder.encode(true);\n * // 0x01\n * //   └── Encoded boolean (`true`) as `u8`\n * ```\n *\n * @see {@link getUnionCodec}\n */\nexport function getUnionEncoder<const TVariants extends readonly Encoder<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n): Encoder<GetEncoderTypeFromVariants<TVariants>> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const write: Encoder<TFrom>['write'] = (variant, bytes, offset) => {\n        const index = getIndexFromValue(variant);\n        assertValidVariantIndex(variants, index);\n        return variants[index].write(variant, bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createEncoder({ fixedSize, write });\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createEncoder({\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: variant => {\n            const index = getIndexFromValue(variant);\n            assertValidVariantIndex(variants, index);\n            return getEncodedSize(variant, variants[index]);\n        },\n        write,\n    });\n}\n\n/**\n * Returns a decoder for union types.\n *\n * This decoder deserializes values by selecting the correct variant decoder\n * based on the `getIndexFromBytes` function.\n *\n * Unlike other codecs, this decoder does not assume a stored discriminator.\n * It is the user's responsibility to manage discriminators separately.\n *\n * For more details, see {@link getUnionCodec}.\n *\n * @typeParam TVariants - An array of decoders, each corresponding to a union variant.\n *\n * @param variants - The decoders for each variant of the union.\n * @param getIndexFromBytes - A function that determines the variant index from the byte array.\n * @returns A `Decoder` for decoding union values.\n *\n * @example\n * Decoding a union of numbers and booleans.\n * ```ts\n * const decoder = getUnionDecoder(\n *   [getU16Decoder(), getBooleanDecoder()],\n *   (bytes, offset) => (bytes.length - offset > 1 ? 0 : 1)\n * );\n *\n * decoder.decode(new Uint8Array([0x2a, 0x00])); // 42\n * decoder.decode(new Uint8Array([0x01]));       // true\n * // Type is inferred as `number | boolean`\n * ```\n *\n * @see {@link getUnionCodec}\n */\nexport function getUnionDecoder<const TVariants extends readonly Decoder<any>[]>(\n    variants: TVariants,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): Decoder<GetDecoderTypeFromVariants<TVariants>> {\n    type TTo = GetDecoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const read: Decoder<TTo>['read'] = (bytes, offset) => {\n        const index = getIndexFromBytes(bytes, offset);\n        assertValidVariantIndex(variants, index);\n        return variants[index].read(bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createDecoder({ fixedSize, read });\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createDecoder({ ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Returns a codec for encoding and decoding union types.\n *\n * This codec serializes and deserializes union values by selecting the correct variant\n * based on the provided index functions.\n *\n * Unlike the {@link getDiscriminatedUnionCodec}, this codec does not assume a stored\n * discriminator and must be used with an explicit mechanism for managing discriminators.\n *\n * @typeParam TVariants - An array of codecs, each corresponding to a union variant.\n *\n * @param variants - The codecs for each variant of the union.\n * @param getIndexFromValue - A function that determines the variant index from the provided value.\n * @param getIndexFromBytes - A function that determines the variant index from the byte array.\n * @returns A `Codec` for encoding and decoding union values.\n *\n * @example\n * Encoding and decoding a union of numbers and booleans.\n * ```ts\n * const codec = getUnionCodec(\n *   [getU16Codec(), getBooleanCodec()],\n *   value => (typeof value === 'number' ? 0 : 1),\n *   (bytes, offset) => (bytes.length - offset > 1 ? 0 : 1)\n * );\n *\n * const bytes1 = codec.encode(42); // 0x2a00\n * const value1: number | boolean = codec.decode(bytes1); // 42\n *\n * const bytes2 = codec.encode(true); // 0x01\n * const value2: number | boolean = codec.decode(bytes2); // true\n * ```\n *\n * @remarks\n * If you need a codec that includes a stored discriminator,\n * consider using {@link getDiscriminatedUnionCodec}.\n *\n * Separate {@link getUnionEncoder} and {@link getUnionDecoder} functions are also available.\n *\n * ```ts\n * const bytes = getUnionEncoder(variantEncoders, getIndexFromValue).encode(42);\n * const value = getUnionDecoder(variantDecoders, getIndexFromBytes).decode(bytes);\n * ```\n *\n * @see {@link getUnionEncoder}\n * @see {@link getUnionDecoder}\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getUnionCodec<const TVariants extends readonly Codec<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): Codec<\n    GetEncoderTypeFromVariants<TVariants>,\n    GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n> {\n    return combineCodec(\n        getUnionEncoder(variants, getIndexFromValue),\n        getUnionDecoder(variants, getIndexFromBytes) as Decoder<\n            GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n        >,\n    );\n}\n\nfunction assertValidVariantIndex(variants: readonly unknown[], index: number) {\n    if (typeof variants[index] === 'undefined') {\n        throw new SolanaError(SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {\n            maxRange: variants.length - 1,\n            minRange: 0,\n            variant: index,\n        });\n    }\n}\n\nfunction getUnionFixedSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    if (variants.length === 0) return 0;\n    if (!isFixedSize(variants[0])) return null;\n    const variantSize = variants[0].fixedSize;\n    const sameSizedVariants = variants.every(variant => isFixedSize(variant) && variant.fixedSize === variantSize);\n    return sameSizedVariants ? variantSize : null;\n}\n\nfunction getUnionMaxSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    return maxCodecSizes(variants.map(variant => getMaxSize(variant)));\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Codec, combineCodec, Decoder, Encoder, transformDecoder, transformEncoder } from '@solana/codecs-core';\nimport { getU8Decoder, getU8Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SolanaError } from '@solana/errors';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { DrainOuterGeneric } from './utils';\n\n/**\n * Represents a discriminated union using a specific discriminator property.\n *\n * A discriminated union is a TypeScript-friendly way to represent Rust-like enums.\n * Each variant in the union is distinguished by a shared discriminator property.\n *\n * @typeParam TDiscriminatorProperty - The name of the discriminator property.\n * @typeParam TDiscriminatorValue - The type of the discriminator value.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant\n * ```\n */\nexport type DiscriminatedUnion<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorValue extends string = string,\n> = {\n    [P in TDiscriminatorProperty]: TDiscriminatorValue;\n};\n\n/**\n * Extracts a variant from a discriminated union based on its discriminator value.\n *\n * @typeParam TUnion - The discriminated union type.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n * @typeParam TDiscriminatorValue - The specific variant to extract.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' }\n *   | { __kind: 'Write'; fields: [string] }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * type ClickEvent = GetDiscriminatedUnionVariant<Message, '__kind', 'Move'>;\n * // -> { __kind: 'Move'; x: number; y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariant<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Extract<TUnion, DiscriminatedUnion<TDiscriminatorProperty, TDiscriminatorValue>>;\n\n/**\n * Extracts a variant from a discriminated union without its discriminator property.\n *\n * @typeParam TUnion - The discriminated union type.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n * @typeParam TDiscriminatorValue - The specific variant to extract.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' }\n *   | { __kind: 'Write'; fields: [string] }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * type MoveContent = GetDiscriminatedUnionVariantContent<Message, '__kind', 'Move'>;\n * // -> { x: number; y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariantContent<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Omit<GetDiscriminatedUnionVariant<TUnion, TDiscriminatorProperty, TDiscriminatorValue>, TDiscriminatorProperty>;\n\n/**\n * Defines the configuration for discriminated union codecs.\n *\n * This configuration controls how the discriminator is stored and named.\n *\n * @typeParam TDiscriminatorProperty - The property name of the discriminator.\n * @typeParam TDiscriminatorSize - The codec used for the discriminator prefix.\n */\nexport type DiscriminatedUnionCodecConfig<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorSize = NumberCodec | NumberDecoder | NumberEncoder,\n> = {\n    /**\n     * The property name of the discriminator.\n     * @defaultValue `__kind`\n     */\n    discriminator?: TDiscriminatorProperty;\n    /**\n     * The codec used to encode/decode the discriminator prefix.\n     * @defaultValue `u8` prefix\n     */\n    size?: TDiscriminatorSize;\n};\n\ntype DiscriminatorValue = bigint | boolean | number | string | null | undefined;\ntype Variants<T> = readonly (readonly [DiscriminatorValue, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromVariants<\n    TVariants extends Variants<Encoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Encoder<infer TFrom>\n        ? TFrom extends object\n            ? TFrom\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\ntype GetDecoderTypeFromVariants<\n    TVariants extends Variants<Decoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Decoder<infer TTo>\n        ? TTo extends object\n            ? TTo\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\n/**\n * Returns an encoder for discriminated unions.\n *\n * This encoder serializes objects that follow the discriminated union pattern\n * by prefixing them with a numerical discriminator that represents their variant.\n *\n * Unlike {@link getUnionEncoder}, this encoder automatically extracts and processes\n * the discriminator property (default: `__kind`) from each variant.\n *\n * For more details, see {@link getDiscriminatedUnionCodec}.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant encoders as `[discriminator, encoder]` pairs.\n * @param config - Configuration options for encoding.\n * @returns An `Encoder` for encoding discriminated union objects.\n *\n * @example\n * Encoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageEncoder = getDiscriminatedUnionEncoder([\n *   ['Quit', getUnitEncoder()],\n *   ['Write', getStructEncoder([['fields', getTupleEncoder([addCodecSizePrefix(getUtf8Encoder(), getU32Encoder())])]])],\n *   ['Move', getStructEncoder([['x', getI32Encoder()], ['y', getI32Encoder()]])]\n * ]);\n *\n * messageEncoder.encode({ __kind: 'Move', x: 5, y: 6 });\n * // 0x020500000006000000\n * //   | |       └── Field y (6)\n * //   | └── Field x (5)\n * //   └── 1-byte discriminator (Index 2 — the \"Move\" variant)\n * ```\n *\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getDiscriminatedUnionEncoder<\n    const TVariants extends Variants<Encoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberEncoder> = {},\n): Encoder<GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>;\n    const discriminatorProperty = (config.discriminator ?? '__kind') as TDiscriminatorProperty;\n    const prefix = config.size ?? getU8Encoder();\n    return getUnionEncoder(\n        variants.map(([, variant], index) =>\n            transformEncoder(getTupleEncoder([prefix, variant]), (value: TFrom): [number, TFrom] => [index, value]),\n        ),\n        value => getVariantDiscriminator(variants, value[discriminatorProperty]),\n    );\n}\n\n/**\n * Returns a decoder for discriminated unions.\n *\n * This decoder deserializes objects that follow the discriminated union pattern\n * by **reading a numerical discriminator** and mapping it to the corresponding variant.\n *\n * Unlike {@link getUnionDecoder}, this decoder automatically inserts the discriminator\n * property (default: `__kind`) into the decoded object.\n *\n * For more details, see {@link getDiscriminatedUnionCodec}.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant decoders as `[discriminator, decoder]` pairs.\n * @param config - Configuration options for decoding.\n * @returns A `Decoder` for decoding discriminated union objects.\n *\n * @example\n * Decoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageDecoder = getDiscriminatedUnionDecoder([\n *   ['Quit', getUnitDecoder()],\n *   ['Write', getStructDecoder([['fields', getTupleDecoder([addCodecSizePrefix(getUtf8Decoder(), getU32Decoder())])]])],\n *   ['Move', getStructDecoder([['x', getI32Decoder()], ['y', getI32Decoder()]])]\n * ]);\n *\n * messageDecoder.decode(new Uint8Array([0x02,0x05,0x00,0x00,0x00,0x06,0x00,0x00,0x00]));\n * // { __kind: 'Move', x: 5, y: 6 }\n * ```\n *\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getDiscriminatedUnionDecoder<\n    const TVariants extends Variants<Decoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberDecoder> = {},\n): Decoder<GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty>> {\n    const discriminatorProperty = config.discriminator ?? '__kind';\n    const prefix = config.size ?? getU8Decoder();\n    return getUnionDecoder(\n        variants.map(([discriminator, variant]) =>\n            transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({\n                [discriminatorProperty]: discriminator,\n                ...value,\n            })),\n        ),\n        (bytes, offset) => Number(prefix.read(bytes, offset)[0]),\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding {@link DiscriminatedUnion}.\n *\n * A {@link DiscriminatedUnion} is a TypeScript representation of Rust-like enums, where\n * each variant is distinguished by a discriminator field (default: `__kind`).\n *\n * This codec inserts a numerical prefix to represent the variant index.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant codecs as `[discriminator, codec]` pairs.\n * @param config - Configuration options for encoding/decoding.\n * @returns A `Codec` for encoding and decoding discriminated union objects.\n *\n * @example\n * Encoding and decoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageCodec = getDiscriminatedUnionCodec([\n *   ['Quit', getUnitCodec()],\n *   ['Write', getStructCodec([['fields', getTupleCodec([addCodecSizePrefix(getUtf8Codec(), getU32Codec())])]])],\n *   ['Move', getStructCodec([['x', getI32Codec()], ['y', getI32Codec()]])]\n * ]);\n *\n * messageCodec.encode({ __kind: 'Move', x: 5, y: 6 });\n * // 0x020500000006000000\n * //   | |       └── Field y (6)\n * //   | └── Field x (5)\n * //   └── 1-byte discriminator (Index 2 — the \"Move\" variant)\n *\n * const value = messageCodec.decode(bytes);\n * // { __kind: 'Move', x: 5, y: 6 }\n * ```\n *\n * @example\n * Using a `u32` discriminator instead of `u8`.\n * ```ts\n * const codec = getDiscriminatedUnionCodec([...], { size: getU32Codec() });\n *\n * codec.encode({ __kind: 'Quit' });\n * // 0x00000000\n * //   └------┘ 4-byte discriminator (Index 0)\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00]));\n * // { __kind: 'Quit' }\n * ```\n *\n * @example\n * Customizing the discriminator property.\n * ```ts\n * const codec = getDiscriminatedUnionCodec([...], { discriminator: 'message' });\n *\n * codec.encode({ message: 'Quit' }); // 0x00\n * codec.decode(new Uint8Array([0x00])); // { message: 'Quit' }\n * ```\n *\n * @remarks\n * Separate `getDiscriminatedUnionEncoder` and `getDiscriminatedUnionDecoder` functions are available.\n *\n * ```ts\n * const bytes = getDiscriminatedUnionEncoder(variantEncoders).encode({ __kind: 'Quit' });\n * const message = getDiscriminatedUnionDecoder(variantDecoders).decode(bytes);\n * ```\n *\n * @see {@link getDiscriminatedUnionEncoder}\n * @see {@link getDiscriminatedUnionDecoder}\n */\nexport function getDiscriminatedUnionCodec<\n    const TVariants extends Variants<Codec<any, any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberCodec> = {},\n): Codec<\n    GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>,\n    GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n        GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n> {\n    return combineCodec(\n        getDiscriminatedUnionEncoder(variants, config),\n        getDiscriminatedUnionDecoder(variants, config) as Decoder<\n            GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n        >,\n    );\n}\n\nfunction getVariantDiscriminator<const TVariants extends Variants<Decoder<any> | Encoder<any>>>(\n    variants: TVariants,\n    discriminatorValue: DiscriminatorValue,\n) {\n    const discriminator = variants.findIndex(([key]) => discriminatorValue === key);\n    if (discriminator < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {\n            value: discriminatorValue,\n            variants: variants.map(([key]) => key),\n        });\n    }\n    return discriminator;\n}\n\n/** @deprecated Use `getDiscriminatedUnionEncoder` instead. */\nexport const getDataEnumEncoder = getDiscriminatedUnionEncoder;\n\n/** @deprecated Use `getDiscriminatedUnionDecoder` instead. */\nexport const getDataEnumDecoder = getDiscriminatedUnionDecoder;\n\n/** @deprecated Use `getDiscriminatedUnionCodec` instead. */\nexport const getDataEnumCodec = getDiscriminatedUnionCodec;\n", "/**\n * Defines the \"lookup object\" of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * ```\n */\nexport type EnumLookupObject = { [key: string]: number | string };\n\n/**\n * Returns the allowed input for an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionInput = GetEnumFrom<Direction>; // \"Left\" | \"Right\" | 0 | 1\n * ```\n */\nexport type GetEnumFrom<TEnum extends EnumLookupObject> = TEnum[keyof TEnum] | keyof TEnum;\n\n/**\n * Returns all the available variants of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionOutput = GetEnumTo<Direction>; // 0 | 1\n * ```\n */\nexport type GetEnumTo<TEnum extends EnumLookupObject> = TEnum[keyof TEnum];\n\nexport function getEnumStats(constructor: EnumLookupObject) {\n    const numericalValues = [...new Set(Object.values(constructor).filter(v => typeof v === 'number'))].sort();\n    const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length)) as Record<\n        string,\n        number | string\n    >;\n    const enumKeys = Object.keys(enumRecord);\n    const enumValues = Object.values(enumRecord);\n    const stringValues: string[] = [\n        ...new Set([...enumKeys, ...enumValues.filter((v): v is string => typeof v === 'string')]),\n    ];\n\n    return { enumKeys, enumRecord, enumValues, numericalValues, stringValues };\n}\n\nexport function getEnumIndexFromVariant({\n    enumKeys,\n    enumValues,\n    variant,\n}: {\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    variant: number | string | symbol;\n}): number {\n    const valueIndex = findLastIndex(enumValues, value => value === variant);\n    if (valueIndex >= 0) return valueIndex;\n    return enumKeys.findIndex(key => key === variant);\n}\n\nexport function getEnumIndexFromDiscriminator({\n    discriminator,\n    enumKeys,\n    enumValues,\n    useValuesAsDiscriminators,\n}: {\n    discriminator: number;\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    useValuesAsDiscriminators: boolean;\n}): number {\n    if (!useValuesAsDiscriminators) {\n        return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;\n    }\n    return findLastIndex(enumValues, value => value === discriminator);\n}\n\nfunction findLastIndex<T>(array: Array<T>, predicate: (value: T, index: number, obj: T[]) => boolean): number {\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) return l;\n    }\n    return -1;\n}\n\nexport function formatNumericalValues(values: number[]): string {\n    if (values.length === 0) return '';\n    let range: [number, number] = [values[0], values[0]];\n    const ranges: string[] = [];\n    for (let index = 1; index < values.length; index++) {\n        const value = values[index];\n        if (range[1] + 1 === value) {\n            range[1] = value;\n        } else {\n            ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n            range = [value, value];\n        }\n    }\n    ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n    return ranges.join(', ');\n}\n", "import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    EnumLookupObject,\n    formatNumericalValues,\n    GetEnumFrom,\n    getEnumIndexFromDiscriminator,\n    getEnumIndexFromVariant,\n    getEnumStats,\n    GetEnumTo,\n} from './enum-helpers';\n\n/**\n * Defines the configuration options for enum codecs.\n *\n * The `size` option determines the numerical encoding used for the enum's discriminant.\n * By default, enums are stored as a `u8` (1 byte).\n *\n * The `useValuesAsDiscriminators` option allows mapping the actual enum values\n * as discriminators instead of using their positional index.\n *\n * @typeParam TDiscriminator - A number codec, encoder, or decoder used for the discriminant.\n */\nexport type EnumCodecConfig<TDiscriminator extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec used to encode/decode the enum discriminator.\n     * @defaultValue `u8` discriminator.\n     */\n    size?: TDiscriminator;\n\n    /**\n     * If set to `true`, the enum values themselves will be used as discriminators.\n     * This is only valid for numerical enum values.\n     *\n     * @defaultValue `false`\n     */\n    useValuesAsDiscriminators?: boolean;\n};\n\n/**\n * Returns an encoder for enums.\n *\n * This encoder serializes enums as a numerical discriminator.\n * By default, the discriminator is based on the positional index of the enum variants.\n *\n * For more details, see {@link getEnumCodec}.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for encoding the enum.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding enums.\n *\n * @example\n * Encoding enum values.\n * ```ts\n * enum Direction { Up,  Down, Left, Right }\n * const encoder = getEnumEncoder(Direction);\n *\n * encoder.encode(Direction.Up);    // 0x00\n * encoder.encode(Direction.Down);  // 0x01\n * encoder.encode(Direction.Left);  // 0x02\n * encoder.encode(Direction.Right); // 0x03\n * ```\n *\n * @see {@link getEnumCodec}\n */\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberEncoder>, 'size'>,\n): FixedSizeEncoder<GetEnumFrom<TEnum>, 1>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<GetEnumFrom<TEnum>, TSize>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<GetEnumFrom<TEnum>>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> = {},\n): Encoder<GetEnumFrom<TEnum>> {\n    const prefix = config.size ?? getU8Encoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformEncoder(prefix, (variant: GetEnumFrom<TEnum>): number => {\n        const index = getEnumIndexFromVariant({ enumKeys, enumValues, variant });\n        if (index < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {\n                formattedNumericalValues: formatNumericalValues(numericalValues),\n                numericalValues,\n                stringValues,\n                variant,\n            });\n        }\n        return useValuesAsDiscriminators ? (enumValues[index] as number) : index;\n    });\n}\n\n/**\n * Returns a decoder for enums.\n *\n * This decoder deserializes enums from a numerical discriminator.\n * By default, the discriminator is based on the positional index of the enum variants.\n *\n * For more details, see {@link getEnumCodec}.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for decoding the enum.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding enums.\n *\n * @example\n * Decoding enum values.\n * ```ts\n * enum Direction { Up,  Down, Left, Right }\n * const decoder = getEnumDecoder(Direction);\n *\n * decoder.decode(new Uint8Array([0x00])); // Direction.Up\n * decoder.decode(new Uint8Array([0x01])); // Direction.Down\n * decoder.decode(new Uint8Array([0x02])); // Direction.Left\n * decoder.decode(new Uint8Array([0x03])); // Direction.Right\n * ```\n *\n * @see {@link getEnumCodec}\n */\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberDecoder>, 'size'>,\n): FixedSizeDecoder<GetEnumTo<TEnum>, 1>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<GetEnumTo<TEnum>, TSize>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<GetEnumTo<TEnum>>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> = {},\n): Decoder<GetEnumTo<TEnum>> {\n    const prefix = config.size ?? getU8Decoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformDecoder(prefix, (value: bigint | number): GetEnumTo<TEnum> => {\n        const discriminator = Number(value);\n        const index = getEnumIndexFromDiscriminator({\n            discriminator,\n            enumKeys,\n            enumValues,\n            useValuesAsDiscriminators,\n        });\n        if (index < 0) {\n            const validDiscriminators = useValuesAsDiscriminators\n                ? numericalValues\n                : [...Array(enumKeys.length).keys()];\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator,\n                formattedValidDiscriminators: formatNumericalValues(validDiscriminators),\n                validDiscriminators,\n            });\n        }\n        return enumValues[index] as GetEnumTo<TEnum>;\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding enums.\n *\n * This codec serializes enums as a numerical discriminator, allowing them\n * to be efficiently stored and reconstructed from binary data.\n *\n * By default, the discriminator is derived from the positional index\n * of the enum variant, but it can be configured to use the enum's numeric values instead.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for encoding and decoding the enum.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding enums.\n *\n * @example\n * Encoding and decoding enums using positional indexes.\n * ```ts\n * enum Direction { Up, Down, Left, Right }\n * const codec = getEnumCodec(Direction);\n *\n * codec.encode(Direction.Up);    // 0x00\n * codec.encode(Direction.Down);  // 0x01\n * codec.encode(Direction.Left);  // 0x02\n * codec.encode(Direction.Right); // 0x03\n *\n * codec.decode(new Uint8Array([0x00])); // Direction.Up\n * codec.decode(new Uint8Array([0x01])); // Direction.Down\n * codec.decode(new Uint8Array([0x02])); // Direction.Left\n * codec.decode(new Uint8Array([0x03])); // Direction.Right\n * ```\n *\n * @example\n * Encoding and decoding enums using their numeric values.\n * ```ts\n * enum GameDifficulty { Easy = 1, Normal = 4, Hard = 7, Expert = 9 }\n * const codec = getEnumCodec(GameDifficulty, { useValuesAsDiscriminators: true });\n *\n * codec.encode(GameDifficulty.Easy);   // 0x01\n * codec.encode(GameDifficulty.Normal); // 0x04\n * codec.encode(GameDifficulty.Hard);   // 0x07\n * codec.encode(GameDifficulty.Expert); // 0x09\n *\n * codec.decode(new Uint8Array([0x01])); // GameDifficulty.Easy\n * codec.decode(new Uint8Array([0x04])); // GameDifficulty.Normal\n * codec.decode(new Uint8Array([0x07])); // GameDifficulty.Hard\n * codec.decode(new Uint8Array([0x09])); // GameDifficulty.Expert\n * ```\n *\n * Note that, when using values as discriminators, the enum values must be numerical.\n * Otherwise, an error will be thrown.\n *\n * ```ts\n * enum GameDifficulty { Easy = 'EASY', Normal = 'NORMAL', Hard = 'HARD' }\n * getEnumCodec(GameDifficulty, { useValuesAsDiscriminators: true }); // Throws an error.\n * ```\n *\n * @example\n * Using a custom discriminator size.\n * ```ts\n * enum Status { Pending, Approved, Rejected }\n * const codec = getEnumCodec(Status, { size: getU16Codec() });\n *\n * codec.encode(Status.Pending);  // 0x0000\n * codec.encode(Status.Approved); // 0x0100\n * codec.encode(Status.Rejected); // 0x0200\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // Status.Pending\n * codec.decode(new Uint8Array([0x01, 0x00])); // Status.Approved\n * codec.decode(new Uint8Array([0x02, 0x00])); // Status.Rejected\n * ```\n *\n * @remarks\n * Separate {@link getEnumEncoder} and {@link getEnumDecoder} functions are available.\n *\n * ```ts\n * const bytes = getEnumEncoder(Direction).encode(Direction.Up);\n * const value = getEnumDecoder(Direction).decode(bytes);\n * ```\n *\n * @see {@link getEnumEncoder}\n * @see {@link getEnumDecoder}\n */\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberCodec>, 'size'>,\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, 1>;\nexport function getEnumCodec<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, TSize>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberCodec>,\n): VariableSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> = {},\n): Codec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>> {\n    return combineCodec(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));\n}\n\n/** @deprecated Use `getEnumEncoder` instead. */\nexport const getScalarEnumEncoder = getEnumEncoder;\n\n/** @deprecated Use `getEnumDecoder` instead. */\nexport const getScalarEnumDecoder = getEnumDecoder;\n\n/** @deprecated Use `getEnumCodec` instead. */\nexport const getScalarEnumCodec = getEnumCodec;\n", "import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Returns an encoder that prefixes encoded values with hidden data.\n *\n * This encoder applies a list of void encoders before encoding the main value.\n * The prefixed data is encoded before the main value without being exposed to the user.\n *\n * For more details, see {@link getHiddenPrefixCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param encoder - The encoder for the main value.\n * @param prefixedEncoders - A list of void encoders that produce the hidden prefix.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` that encodes the value with a hidden prefix.\n *\n * @example\n * Prefixing a value with constants.\n * ```ts\n * const encoder = getHiddenPrefixEncoder(getUtf8Encoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * encoder.encode('Hello');\n * // 0x01020304050648656c6c6f\n * //   |     |     └-- Our encoded value (\"Hello\").\n * //   |     └-- Our second hidden prefix.\n * //   └-- Our first hidden prefix.\n * ```\n *\n * @see {@link getHiddenPrefixCodec}\n */\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([...prefixedEncoders, encoder]) as Encoder<readonly [...void[], TFrom]>,\n        (value: TFrom) => [...prefixedEncoders.map(() => undefined), value] as const,\n    );\n}\n\n/**\n * Returns a decoder that skips hidden prefixed data before decoding the main value.\n *\n * This decoder applies a list of void decoders before decoding the main value.\n * The prefixed data is skipped during decoding without being exposed to the user.\n *\n * For more details, see {@link getHiddenPrefixCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param decoder - The decoder for the main value.\n * @param prefixedDecoders - A list of void decoders that produce the hidden prefix.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` that decodes values while ignoring the hidden prefix.\n *\n * @example\n * Decoding a value with prefixed constants.\n * ```ts\n * const decoder = getHiddenPrefixDecoder(getUtf8Decoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * decoder.decode(new Uint8Array([1, 2, 3, 4, 5, 6, 0x48, 0x65, 0x6C, 0x6C, 0x6F]));\n * // 'Hello'\n * ```\n *\n * @see {@link getHiddenPrefixCodec}\n */\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([...prefixedDecoders, decoder]) as Decoder<readonly [...void[], TTo]>,\n        tuple => tuple[tuple.length - 1] as TTo,\n    );\n}\n\n/**\n * Returns a codec that encodes and decodes values with a hidden prefix.\n *\n * - **Encoding:** Prefixes the value with hidden data before encoding.\n * - **Decoding:** Skips the hidden prefix before decoding the main value.\n *\n * This is useful for any implicit metadata that should be present in\n * binary formats but omitted from the API.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param codec - The codec for the main value.\n * @param prefixedCodecs - A list of void codecs that produce the hidden prefix.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding values with a hidden prefix.\n *\n * @example\n * Encoding and decoding a value with prefixed constants.\n * ```ts\n * const codec = getHiddenPrefixCodec(getUtf8Codec(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * const bytes = codec.encode('Hello');\n * // 0x01020304050648656c6c6f\n * //   |     |     └-- Our encoded value (\"Hello\").\n * //   |     └-- Our second hidden prefix.\n * //   └-- Our first hidden prefix.\n *\n * codec.decode(bytes);\n * // 'Hello'\n * ```\n *\n * @remarks\n * If all you need is padding zeroes before a value, consider using {@link padLeftCodec} instead.\n *\n * Separate {@link getHiddenPrefixEncoder} and {@link getHiddenPrefixDecoder} functions are available.\n *\n * ```ts\n * const bytes = getHiddenPrefixEncoder(getUtf8Encoder(), [\n *   getConstantEncoder(new Uint8Array([1, 2, 3])),\n *   getConstantEncoder(new Uint8Array([4, 5, 6])),\n * ]).encode('Hello');\n *\n * const value = getHiddenPrefixDecoder(getUtf8Decoder(), [\n *   getConstantDecoder(new Uint8Array([1, 2, 3])),\n *   getConstantDecoder(new Uint8Array([4, 5, 6])),\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getHiddenPrefixEncoder}\n * @see {@link getHiddenPrefixDecoder}\n */\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));\n}\n", "import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Returns an encoder that appends hidden data after the encoded value.\n *\n * This encoder applies a list of void encoders after encoding the main value.\n * The suffixed data is encoded after the main value without being exposed to the user.\n *\n * For more details, see {@link getHiddenSuffixCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param encoder - The encoder for the main value.\n * @param suffixedEncoders - A list of void encoders that produce the hidden suffix.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` that encodes the value with a hidden suffix.\n *\n * @example\n * Suffixing a value with constants.\n * ```ts\n * const encoder = getHiddenSuffixEncoder(getUtf8Encoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * encoder.encode('Hello');\n * // 0x48656c6c6f010203040506\n * //   |         |     └-- Our second hidden suffix.\n * //   |         └-- Our first hidden suffix.\n * //   └-- Our encoded value (\"Hello\").\n * ```\n *\n * @see {@link getHiddenSuffixCodec}\n */\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    suffixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([encoder, ...suffixedEncoders]) as Encoder<readonly [TFrom, ...void[]]>,\n        (value: TFrom) => [value, ...suffixedEncoders.map(() => undefined)] as const,\n    );\n}\n\n/**\n * Returns a decoder that skips hidden suffixed data after decoding the main value.\n *\n * This decoder applies a list of void decoders after decoding the main value.\n * The suffixed data is skipped during decoding without being exposed to the user.\n *\n * For more details, see {@link getHiddenSuffixCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param decoder - The decoder for the main value.\n * @param suffixedDecoders - A list of void decoders that produce the hidden suffix.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` that decodes values while ignoring the hidden suffix.\n *\n * @example\n * Decoding a value with suffixed constants.\n * ```ts\n * const decoder = getHiddenSuffixDecoder(getUtf8Decoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * decoder.decode(new Uint8Array([0x48, 0x65, 0x6C, 0x6C, 0x6F, 1, 2, 3, 4, 5, 6]));\n * // 'Hello'\n * ```\n *\n * @see {@link getHiddenSuffixCodec}\n */\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    suffixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([decoder, ...suffixedDecoders]) as Decoder<readonly [TTo, ...void[]]>,\n        tuple => tuple[0],\n    );\n}\n\n/**\n * Returns a codec that encodes and decodes values with a hidden suffix.\n *\n * - **Encoding:** Appends hidden data after encoding the main value.\n * - **Decoding:** Skips the hidden suffix after decoding the main value.\n *\n * This is useful for any implicit metadata that should be present in\n * binary formats but omitted from the API.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param codec - The codec for the main value.\n * @param suffixedCodecs - A list of void codecs that produce the hidden suffix.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding values with a hidden suffix.\n *\n * @example\n * Encoding and decoding a value with suffixed constants.\n * ```ts\n * const codec = getHiddenSuffixCodec(getUtf8Codec(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * const bytes = codec.encode('Hello');\n * // 0x48656c6c6f010203040506\n * //   |         |     └-- Our second hidden suffix.\n * //   |         └-- Our first hidden suffix.\n * //   └-- Our encoded value (\"Hello\").\n *\n * codec.decode(bytes);\n * // 'Hello'\n * ```\n *\n * @remarks\n * If all you need is padding zeroes after a value, consider using {@link padRightCodec} instead.\n *\n * Separate {@link getHiddenSuffixEncoder} and {@link getHiddenSuffixDecoder} functions are available.\n *\n * ```ts\n * const bytes = getHiddenSuffixEncoder(getUtf8Encoder(), [\n *   getConstantEncoder(new Uint8Array([1, 2, 3])),\n *   getConstantEncoder(new Uint8Array([4, 5, 6])),\n * ]).encode('Hello');\n *\n * const value = getHiddenSuffixDecoder(getUtf8Decoder(), [\n *   getConstantDecoder(new Uint8Array([1, 2, 3])),\n *   getConstantDecoder(new Uint8Array([4, 5, 6])),\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getHiddenSuffixEncoder}\n * @see {@link getHiddenSuffixDecoder}\n */\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    suffixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));\n}\n", "import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\n/**\n * Defines the configuration options for literal union codecs.\n *\n * A literal union codec encodes values from a predefined set of literals.\n * The `size` option determines the numerical encoding used for the discriminant.\n * By default, literals are stored as a `u8` (1 byte).\n *\n * @typeParam TDiscriminator - A number codec, encoder, or decoder used for the discriminant.\n */\nexport type LiteralUnionCodecConfig<TDiscriminator = NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec used to encode/decode the discriminator.\n     * @defaultValue `u8` discriminator.\n     */\n    size?: TDiscriminator;\n};\n\ntype Variant = bigint | boolean | number | string | null | undefined;\ntype GetTypeFromVariants<TVariants extends readonly Variant[]> = TVariants[number];\n\n/**\n * Returns an encoder for literal unions.\n *\n * This encoder serializes a value from a predefined set of literals\n * as a numerical index representing its position in the `variants` array.\n *\n * For more details, see {@link getLiteralUnionCodec}.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for encoding the literal union.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding literal unions.\n *\n * @example\n * Encoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeEncoder = getLiteralUnionEncoder(['small', 'medium', 'large']);\n *\n * sizeEncoder.encode('small');  // 0x00\n * sizeEncoder.encode('medium'); // 0x01\n * sizeEncoder.encode('large');  // 0x02\n * ```\n *\n * @see {@link getLiteralUnionCodec}\n */\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeEncoder<GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberEncoder> = {},\n): Encoder<GetTypeFromVariants<TVariants>> {\n    const discriminator = config.size ?? getU8Encoder();\n    return transformEncoder(discriminator, variant => {\n        const index = variants.indexOf(variant);\n        if (index < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT, {\n                value: variant,\n                variants,\n            });\n        }\n        return index;\n    });\n}\n\n/**\n * Returns a decoder for literal unions.\n *\n * This decoder deserializes a numerical index into a corresponding\n * value from a predefined set of literals.\n *\n * For more details, see {@link getLiteralUnionCodec}.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for decoding the literal union.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding literal unions.\n *\n * @example\n * Decoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeDecoder = getLiteralUnionDecoder(['small', 'medium', 'large']);\n *\n * sizeDecoder.decode(new Uint8Array([0x00])); // 'small'\n * sizeDecoder.decode(new Uint8Array([0x01])); // 'medium'\n * sizeDecoder.decode(new Uint8Array([0x02])); // 'large'\n * ```\n *\n * @see {@link getLiteralUnionCodec}\n */\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeDecoder<GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberDecoder> = {},\n): Decoder<GetTypeFromVariants<TVariants>> {\n    const discriminator = config.size ?? getU8Decoder();\n    return transformDecoder(discriminator, (index: bigint | number) => {\n        if (index < 0 || index >= variants.length) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator: index,\n                maxRange: variants.length - 1,\n                minRange: 0,\n            });\n        }\n        return variants[Number(index)];\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding literal unions.\n *\n * A literal union codec serializes and deserializes values\n * from a predefined set of literals, using a numerical index\n * to represent each value in the `variants` array.\n *\n * This allows efficient storage and retrieval of common\n * predefined values such as enum-like structures in TypeScript.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for encoding and decoding the literal union.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding literal unions.\n *\n * @example\n * Encoding and decoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeCodec = getLiteralUnionCodec(['small', 'medium', 'large']);\n *\n * sizeCodec.encode('small');  // 0x00\n * sizeCodec.encode('medium'); // 0x01\n * sizeCodec.encode('large');  // 0x02\n *\n * sizeCodec.decode(new Uint8Array([0x00])); // 'small'\n * sizeCodec.decode(new Uint8Array([0x01])); // 'medium'\n * sizeCodec.decode(new Uint8Array([0x02])); // 'large'\n * ```\n *\n * @example\n * Encoding and decoding a union of number literals.\n * ```ts\n * type Level = 10 | 20 | 30;\n * const levelCodec = getLiteralUnionCodec([10, 20, 30]);\n *\n * levelCodec.encode(10);  // 0x00\n * levelCodec.encode(20);  // 0x01\n * levelCodec.encode(30);  // 0x02\n *\n * levelCodec.decode(new Uint8Array([0x00])); // 10\n * levelCodec.decode(new Uint8Array([0x01])); // 20\n * levelCodec.decode(new Uint8Array([0x02])); // 30\n * ```\n *\n * @example\n * Using a custom discriminator size with different variant types.\n * ```ts\n * type MaybeBoolean = false | true | \"either\";\n * const codec = getLiteralUnionCodec([false, true, 'either'], { size: getU16Codec() });\n *\n * codec.encode(false);    // 0x0000\n * codec.encode(true);     // 0x0100\n * codec.encode('either'); // 0x0200\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // false\n * codec.decode(new Uint8Array([0x01, 0x00])); // true\n * codec.decode(new Uint8Array([0x02, 0x00])); // 'either'\n * ```\n *\n * @remarks\n * Separate {@link getLiteralUnionEncoder} and {@link getLiteralUnionDecoder} functions are available.\n *\n * ```ts\n * const bytes = getLiteralUnionEncoder(['red', 'green', 'blue']).encode('green');\n * const value = getLiteralUnionDecoder(['red', 'green', 'blue']).decode(bytes);\n * ```\n *\n * @see {@link getLiteralUnionEncoder}\n * @see {@link getLiteralUnionDecoder}\n */\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeCodec<GetTypeFromVariants<TVariants>, GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<GetTypeFromVariants<TVariants>, GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberCodec>,\n): VariableSizeCodec<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberCodec> = {},\n): Codec<GetTypeFromVariants<TVariants>> {\n    return combineCodec(getLiteralUnionEncoder(variants, config), getLiteralUnionDecoder(variants, config));\n}\n", "import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Defines the configuration options for map codecs.\n *\n * The `size` option determines how the number of entries in the map is stored.\n * It can be:\n * - A {@link NumberCodec} to prefix the map with its size.\n * - A fixed number of entries.\n * - `'remainder'`, which infers the number of entries based on the remaining bytes.\n *   This option is only available for fixed-size keys and values.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used for the size prefix.\n */\nexport type MapCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the map.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for maps.\n *\n * This encoder serializes maps where the keys and values are encoded\n * using the provided key and value encoders. The number of entries\n * is determined by the `size` configuration.\n *\n * For more details, see {@link getMapCodec}.\n *\n * @typeParam TFromKey - The type of the keys before encoding.\n * @typeParam TFromValue - The type of the values before encoding.\n *\n * @param key - The encoder for the map's keys.\n * @param value - The encoder for the map's values.\n * @param config - Configuration options for encoding the map.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding maps.\n *\n * @example\n * Encoding a map with a `u32` size prefix.\n * ```ts\n * const encoder = getMapEncoder(fixCodecSize(getUtf8Encoder(), 5), getU8Encoder());\n * const bytes = encoder.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x02000000616c6963652a626f62000005\n * //   |       |         | |         └── Value (5)\n * //   |       |         | └── Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |       |         └── Value (42)\n * //   |       └── Key (\"alice\", 5 bytes fixed)\n * //   └── 4-byte prefix (2 entries)\n * ```\n *\n * @see {@link getMapCodec}\n */\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>, 0>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: FixedSizeEncoder<TFromKey>,\n    value: FixedSizeEncoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config?: MapCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> = {},\n): Encoder<Map<TFromKey, TFromValue>> {\n    return transformEncoder(\n        getArrayEncoder(getTupleEncoder([key, value]), config as object),\n        (map: Map<TFromKey, TFromValue>): [TFromKey, TFromValue][] => [...map.entries()],\n    );\n}\n\n/**\n * Returns a decoder for maps.\n *\n * This decoder deserializes maps where the keys and values are decoded\n * using the provided key and value decoders. The number of entries\n * is determined by the `size` configuration.\n *\n * For more details, see {@link getMapCodec}.\n *\n * @typeParam TToKey - The type of the keys after decoding.\n * @typeParam TToValue - The type of the values after decoding.\n *\n * @param key - The decoder for the map's keys.\n * @param value - The decoder for the map's values.\n * @param config - Configuration options for decoding the map.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding maps.\n *\n * @example\n * Decoding a map with a `u32` size prefix.\n * ```ts\n * const decoder = getMapDecoder(fixCodecSize(getUtf8Decoder(), 5), getU8Decoder());\n * const map = decoder.decode(new Uint8Array([\n *   0x02,0x00,0x00,0x00,0x61,0x6c,0x69,0x63,0x65,0x2a,0x62,0x6f,0x62,0x00,0x00,0x05\n * ]));\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @see {@link getMapCodec}\n */\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Map<TToKey, TToValue>, 0>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: FixedSizeDecoder<TToKey>,\n    value: FixedSizeDecoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config?: MapCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> = {},\n): Decoder<Map<TToKey, TToValue>> {\n    return transformDecoder(\n        getArrayDecoder(getTupleDecoder([key, value]), config as object) as Decoder<[TToKey, TToValue][]>,\n        (entries: [TToKey, TToValue][]): Map<TToKey, TToValue> => new Map(entries),\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding maps.\n *\n * This codec serializes maps where the key/value pairs are encoded\n * and decoded one after another using the provided key and value codecs.\n * The number of entries is determined by the `size` configuration and\n * defaults to a `u32` size prefix.\n *\n * @typeParam TFromKey - The type of the keys before encoding.\n * @typeParam TFromValue - The type of the values before encoding.\n * @typeParam TToKey - The type of the keys after decoding.\n * @typeParam TToValue - The type of the values after decoding.\n *\n * @param key - The codec for the map's keys.\n * @param value - The codec for the map's values.\n * @param config - Configuration options for encoding and decoding the map.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding maps.\n *\n * @example\n * Encoding and decoding a map with a `u32` size prefix (default).\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec());\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x02000000616c6963652a626f62000005\n * //   |       |         | |         └── Value (5)\n * //   |       |         | └── Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |       |         └── Value (42)\n * //   |       └── Key (\"alice\", 5 bytes fixed)\n * //   └── 4-byte prefix (2 entries)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a map with a `u16` size prefix.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x0200616c6963652a626f62000005\n * //   |   |         | |         └── Value (5)\n * //   |   |         | └── Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |   |         └── Value (42)\n * //   |   └── Key (\"alice\", 5 bytes fixed)\n * //   └── 2-byte prefix (2 entries)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a fixed-size map.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: 2 });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x616c6963652a626f62000005\n * //   |         | |         └── Value (5)\n * //   |         | └── Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |         └── Value (42)\n * //   └── Key (\"alice\", 5 bytes fixed)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a map with remainder size.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: 'remainder' });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x616c6963652a626f62000005\n * //   |         | |         └── Value (5)\n * //   |         | └── Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |         └── Value (42)\n * //   └── Key (\"alice\", 5 bytes fixed)\n * // No size prefix, the size is inferred from the remaining bytes.\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @remarks\n * Separate {@link getMapEncoder} and {@link getMapDecoder} functions are available.\n * ```ts\n * const bytes = getMapEncoder(fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()).encode(new Map([['alice', 42]]));\n * const map = getMapDecoder(fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getMapEncoder}\n * @see {@link getMapDecoder}\n */\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>, 0>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: FixedSizeCodec<TFromKey, TToKey>,\n    value: FixedSizeCodec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config?: MapCodecConfig<NumberCodec>,\n): VariableSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> = {},\n): Codec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>> {\n    return combineCodec(getMapEncoder(key, value, config as object), getMapDecoder(key, value, config as object));\n}\n", "import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\n/**\n * Returns an encoder for `void` values.\n *\n * This encoder writes nothing to the byte array and has a fixed size of 0 bytes.\n * It is useful when working with structures that require a no-op encoder,\n * such as empty variants in {@link getDiscriminatedUnionEncoder}.\n *\n * For more details, see {@link getUnitCodec}.\n *\n * @returns A `FixedSizeEncoder<void, 0>`, representing an empty encoder.\n *\n * @example\n * Encoding a `void` value.\n * ```ts\n * getUnitEncoder().encode(undefined); // Produces an empty byte array.\n * ```\n *\n * @see {@link getUnitCodec}\n */\nexport function getUnitEncoder(): FixedSizeEncoder<void, 0> {\n    return createEncoder({\n        fixedSize: 0,\n        write: (_value, _bytes, offset) => offset,\n    });\n}\n\n/**\n * Returns a decoder for `void` values.\n *\n * This decoder always returns `undefined` and has a fixed size of 0 bytes.\n * It is useful when working with structures that require a no-op decoder,\n * such as empty variants in {@link getDiscriminatedUnionDecoder}.\n *\n * For more details, see {@link getUnitCodec}.\n *\n * @returns A `FixedSizeDecoder<void, 0>`, representing an empty decoder.\n *\n * @example\n * Decoding a `void` value.\n * ```ts\n * getUnitDecoder().decode(anyBytes); // Returns `undefined`.\n * ```\n *\n * @see {@link getUnitCodec}\n */\nexport function getUnitDecoder(): FixedSizeDecoder<void, 0> {\n    return createDecoder({\n        fixedSize: 0,\n        read: (_bytes: ReadonlyUint8Array | Uint8Array, offset) => [undefined, offset],\n    });\n}\n\n/**\n * Returns a codec for `void` values.\n *\n * This codec does nothing when encoding or decoding and has a fixed size of 0 bytes.\n * Namely, it always returns `undefined` when decoding and produces an empty byte array when encoding.\n *\n * This can be useful when working with structures that require a no-op codec,\n * such as empty variants in {@link getDiscriminatedUnionCodec}.\n *\n * @returns A `FixedSizeCodec<void, void, 0>`, representing an empty codec.\n *\n * @example\n * Encoding and decoding a `void` value.\n * ```ts\n * const codec = getUnitCodec();\n *\n * codec.encode(undefined); // Produces an empty byte array.\n * codec.decode(new Uint8Array([])); // Returns `undefined`.\n * ```\n *\n * @example\n * Using unit codecs as empty variants in a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Enter' }\n *   | { __kind: 'Leave' }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * const messageCodec = getDiscriminatedUnionCodec([\n *   ['Enter', getUnitCodec()], // <- No-op codec for empty data\n *   ['Leave', getUnitCodec()], // <- No-op codec for empty data\n *   ['Move', getStructCodec([...])]\n * ]);\n * ```\n *\n * @remarks\n * Separate {@link getUnitEncoder} and {@link getUnitDecoder} functions are available.\n *\n * ```ts\n * const bytes = getUnitEncoder().encode();\n * const value = getUnitDecoder().decode(bytes);\n * ```\n *\n * @see {@link getUnitEncoder}\n * @see {@link getUnitDecoder}\n */\nexport function getUnitCodec(): FixedSizeCodec<void, void, 0> {\n    return combineCodec(getUnitEncoder(), getUnitDecoder());\n}\n", "import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { getBooleanDecoder, getBooleanEncoder } from './boolean';\nimport { getConstantDecoder, getConstantEncoder } from './constant';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { getUnitDecoder, getUnitEncoder } from './unit';\n\n/**\n * Defines the configuration options for nullable codecs.\n *\n * This configuration controls how nullable values are encoded and decoded.\n *\n * By default, nullable values are prefixed with a `u8` (0 = `null`, 1 = present).\n * The `noneValue` and `prefix` options allow customizing this behavior.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used as the presence prefix.\n *\n * @see {@link getNullableEncoder}\n * @see {@link getNullableDecoder}\n * @see {@link getNullableCodec}\n */\nexport type NullableCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how `null` values are represented in the encoded data.\n     *\n     * - By default, `null` values are omitted from encoding.\n     * - `'zeroes'`: The bytes allocated for the value are filled with zeroes. This requires a fixed-size codec.\n     * - Custom byte array: `null` values are replaced with a predefined byte sequence. This results in a variable-size codec.\n     *\n     * @defaultValue No explicit `noneValue` is used; `null` values are omitted.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The presence prefix used to distinguish between `null` and present values.\n     *\n     * - By default, a `u8` prefix is used (`0 = null`, `1 = present`).\n     * - Custom number codec: Allows defining a different number size for the prefix.\n     * - `null`: No prefix is used; `noneValue` (if provided) determines `null`.\n     *   If no `noneValue` is set, `null` is identified by the absence of bytes.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Returns an encoder for optional values, allowing `null` values to be encoded.\n *\n * This encoder serializes an optional value using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `null` values are encoded as zeroes.\n * - If `noneValue` is a byte array, `null` values are replaced with the provided constant.\n *\n * For more details, see {@link getNullableCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param item - The encoder for the value that may be present.\n * @param config - Configuration options for encoding optional values.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding nullable values.\n *\n * @example\n * Encoding an optional number.\n * ```ts\n * const encoder = getNullableEncoder(getU32Encoder());\n *\n * encoder.encode(null); // 0x00\n * encoder.encode(42);   // 0x012a000000\n * ```\n *\n * @see {@link getNullableCodec}\n */\nexport function getNullableEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<TFrom | null, TSize>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: NullableCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: TFrom): [boolean, TFrom] => [true, value]),\n        ],\n        variant => Number(variant !== null),\n    );\n}\n\n/**\n * Returns a decoder for optional values, allowing `null` values to be recognized.\n *\n * This decoder deserializes an optional value using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `null` values are identified by zeroes.\n * - If `noneValue` is a byte array, `null` values match the provided constant.\n *\n * For more details, see {@link getNullableCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The decoder for the value that may be present.\n * @param config - Configuration options for decoding optional values.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding nullable values.\n *\n * @example\n * Decoding an optional number.\n * ```ts\n * const decoder = getNullableDecoder(getU32Decoder());\n *\n * decoder.decode(new Uint8Array([0x00])); // null\n * decoder.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @see {@link getNullableCodec}\n */\nexport function getNullableDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<TTo | null, TSize>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: NullableCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> = {},\n): Decoder<TTo | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => null),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]): TTo => value),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding optional values, allowing `null` values to be handled.\n *\n * This codec serializes and deserializes optional values using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present).\n *    This can be customized using a custom number codec or even disabled by setting\n *    the `prefix` to `null`.\n * - If `noneValue: 'zeroes'` is set, `null` values are encoded/decoded as zeroes.\n * - If `noneValue` is a byte array, `null` values are represented by the provided constant.\n *\n * For more details on the configuration options, see {@link NullableCodecConfig}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The codec for the value that may be present.\n * @param config - Configuration options for encoding and decoding optional values.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding nullable values.\n *\n * @example\n * Encoding and decoding an optional number using a `u8` prefix (default).\n * ```ts\n * const codec = getNullableCodec(getU32Codec());\n *\n * codec.encode(null); // 0x00\n * codec.encode(42);   // 0x012a000000\n *\n * codec.decode(new Uint8Array([0x00])); // null\n * codec.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding an optional number using a fixed-size codec, by filling `null` values with zeroes.\n * ```ts\n * const codec = getNullableCodec(getU32Codec(), { noneValue: 'zeroes' });\n *\n * codec.encode(null); // 0x0000000000\n * codec.encode(42);   // 0x012a000000\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00])); // null\n * codec.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding `null` values with zeroes and no prefix.\n * ```ts\n * const codec = getNullableCodec(getU32Codec(), {\n *   noneValue: 'zeroes',\n *   prefix: null,\n * });\n *\n * codec.encode(null); // 0x00000000\n * codec.encode(42);   // 0x2a000000\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding `null` values with a custom byte sequence and no prefix.\n * ```ts\n * const codec = getNullableCodec(getU16Codec(), {\n *   noneValue: new Uint8Array([0xff, 0xff]),\n *   prefix: null,\n * });\n *\n * codec.encode(null); // 0xffff\n * codec.encode(42); // 0x2a00\n *\n * codec.decode(new Uint8Array([0xff, 0xff])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @example\n * Identifying `null` values by the absence of bytes.\n * ```ts\n * const codec = getNullableCodec(getU16Codec(), { prefix: null });\n *\n * codec.encode(null); // Empty bytes\n * codec.encode(42); // 0x2a00\n *\n * codec.decode(new Uint8Array([])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @remarks\n * Separate {@link getNullableEncoder} and {@link getNullableDecoder} functions are available.\n *\n * ```ts\n * const bytes = getNullableEncoder(getU32Encoder()).encode(42);\n * const value = getNullableDecoder(getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getNullableEncoder}\n * @see {@link getNullableDecoder}\n */\nexport function getNullableCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<TFrom | null, TTo | null, TSize>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> = {},\n): Codec<TFrom | null, TTo | null> {\n    type ConfigCast = NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getNullableEncoder<TFrom>(item, config as ConfigCast),\n        getNullableDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n", "import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\n\n/**\n * Defines the configuration options for set codecs.\n *\n * This configuration allows specifying how the size of the set is encoded.\n * The `size` option can be:\n *\n * - A {@link NumberCodec}, {@link NumberEncoder}, or {@link NumberDecoder} to store the size as a prefix.\n * - A fixed number of items, enforcing a strict length.\n * - The string `'remainder'` to infer the set size from the remaining bytes (only for fixed-size items).\n *\n * @typeParam TPrefix - The type used for encoding the size of the set.\n */\nexport type SetCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size encoding strategy for the set.\n     * @defaultValue Uses a `u32` prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for sets of items.\n *\n * This encoder serializes `Set<T>` values by encoding each item using the provided item encoder.\n * The number of items is stored as a prefix using a `u32` codec by default.\n *\n * For more details, see {@link getSetCodec}.\n *\n * @typeParam TFrom - The type of the items in the set before encoding.\n *\n * @param item - The encoder to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns An `Encoder<Set<TFrom>>` for encoding sets of items.\n *\n * @example\n * Encoding a set of `u8` numbers.\n * ```ts\n * const encoder = getSetEncoder(getU8Encoder());\n * const bytes = encoder.encode(new Set([1, 2, 3]));\n * // 0x03000000010203\n * //   |       └-- 3 items of 1 byte each.\n * //   └-- 4-byte prefix indicating 3 items.\n * ```\n *\n * @see {@link getSetCodec}\n */\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Set<TFrom>, 0>;\nexport function getSetEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: SetCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> = {},\n): Encoder<Set<TFrom>> {\n    return transformEncoder(getArrayEncoder(item, config as object), (set: Set<TFrom>): TFrom[] => [...set]);\n}\n\n/**\n * Returns a decoder for sets of items.\n *\n * This decoder deserializes a `Set<T>` from a byte array by decoding each item using the provided item decoder.\n * The number of items is determined by a `u32` size prefix by default.\n *\n * For more details, see {@link getSetCodec}.\n *\n * @typeParam TTo - The type of the items in the set after decoding.\n *\n * @param item - The decoder to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns A `Decoder<Set<TTo>>` for decoding sets of items.\n *\n * @example\n * Decoding a set of `u8` numbers.\n * ```ts\n * const decoder = getSetDecoder(getU8Decoder());\n * const value = decoder.decode(new Uint8Array([0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03]));\n * // new Set([1, 2, 3])\n * ```\n *\n * @see {@link getSetCodec}\n */\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Set<TTo>, 0>;\nexport function getSetDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: SetCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(item: Decoder<TTo>, config: SetCodecConfig<NumberDecoder> = {}): Decoder<Set<TTo>> {\n    return transformDecoder(getArrayDecoder(item, config as object), (entries: TTo[]): Set<TTo> => new Set(entries));\n}\n\n/**\n * Returns a codec for encoding and decoding sets of items.\n *\n * This codec serializes `Set<T>` values by encoding each item using the provided item codec.\n * The number of items is stored as a prefix using a `u32` codec by default.\n *\n * @typeParam TFrom - The type of the items in the set before encoding.\n * @typeParam TTo - The type of the items in the set after decoding.\n *\n * @param item - The codec to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns A `Codec<Set<TFrom>, Set<TTo>>` for encoding and decoding sets.\n *\n * @example\n * Encoding and decoding a set of `u8` numbers.\n * ```ts\n * const codec = getSetCodec(getU8Codec());\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x03000000010203\n * //   |       └-- 3 items of 1 byte each.\n * //   └-- 4-byte prefix indicating 3 items.\n *\n * const value = codec.decode(bytes);\n * // new Set([1, 2, 3])\n * ```\n *\n * @example\n * Using a `u16` prefix for size.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x0300010203\n * //   |   └-- 3 items of 1 byte each.\n * //   └-- 2-byte prefix indicating 3 items.\n * ```\n *\n * @example\n * Using a fixed-size set.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: 3 });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x010203\n * //   └-- Exactly 3 items of 1 byte each.\n * ```\n *\n * @example\n * Using remainder to infer set size.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: 'remainder' });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x010203\n * //   └-- 3 items of 1 byte each. The size is inferred from the remaining bytes.\n * ```\n *\n * @remarks\n * Separate {@link getSetEncoder} and {@link getSetDecoder} functions are available.\n *\n * ```ts\n * const bytes = getSetEncoder(getU8Encoder()).encode(new Set([1, 2, 3]));\n * const value = getSetDecoder(getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getSetEncoder}\n * @see {@link getSetDecoder}\n */\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>, 0>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: SetCodecConfig<NumberCodec>,\n): VariableSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> = {},\n): Codec<Set<TFrom>, Set<TTo>> {\n    return combineCodec(getSetEncoder(item, config as object), getSetDecoder(item, config as object));\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\n/**\n * Represents a collection of named fields used in struct codecs.\n *\n * Each field is defined as a tuple containing:\n * - A string key representing the field name.\n * - A codec used to encode and decode the field's value.\n *\n * @typeParam T - The codec type used for each field.\n */\ntype Fields<T> = readonly (readonly [string, T])[];\n\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\n/**\n * Infers the TypeScript type for an object that can be encoded using a struct codec.\n *\n * This type maps the provided field encoders to their corresponding values.\n *\n * @typeParam TFields - The fields of the struct, each paired with an encoder.\n */\ntype GetEncoderTypeFromFields<TFields extends Fields<Encoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\n/**\n * Infers the TypeScript type for an object that can be decoded using a struct codec.\n *\n * This type maps the provided field decoders to their corresponding values.\n *\n * @typeParam TFields - The fields of the struct, each paired with a decoder.\n */\ntype GetDecoderTypeFromFields<TFields extends Fields<Decoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Returns an encoder for custom objects.\n *\n * This encoder serializes an object by encoding its fields sequentially,\n * using the provided field encoders.\n *\n * For more details, see {@link getStructCodec}.\n *\n * @typeParam TFields - The fields of the struct, each paired with an encoder.\n *\n * @param fields - The name and encoder of each field.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding custom objects.\n *\n * @example\n * Encoding a custom struct.\n * ```ts\n * const encoder = getStructEncoder([\n *   ['name', fixCodecSize(getUtf8Encoder(), 5)],\n *   ['age', getU8Encoder()]\n * ]);\n *\n * const bytes = encoder.encode({ name: 'Alice', age: 42 });\n * // 0x416c6963652a\n * //   |         └── Age (42)\n * //   └── Name (\"Alice\")\n * ```\n *\n * @see {@link getStructCodec}\n */\nexport function getStructEncoder<const TFields extends Fields<FixedSizeEncoder<any>>>(\n    fields: TFields,\n): FixedSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): VariableSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): Encoder<GetEncoderTypeFromFields<TFields>> {\n    type TFrom = GetEncoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      fields\n                          .map(([key, codec]) => getEncodedSize(value[key as keyof TFrom], codec))\n                          .reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (struct: TFrom, bytes, offset) => {\n            fields.forEach(([key, codec]) => {\n                offset = codec.write(struct[key as keyof TFrom], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for custom objects.\n *\n * This decoder deserializes an object by decoding its fields sequentially,\n * using the provided field decoders.\n *\n * For more details, see {@link getStructCodec}.\n *\n * @typeParam TFields - The fields of the struct, each paired with a decoder.\n *\n * @param fields - The name and decoder of each field.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding custom objects.\n *\n * @example\n * Decoding a custom struct.\n * ```ts\n * const decoder = getStructDecoder([\n *   ['name', fixCodecSize(getUtf8Decoder(), 5)],\n *   ['age', getU8Decoder()]\n * ]);\n *\n * const struct = decoder.decode(new Uint8Array([\n *   0x41,0x6c,0x69,0x63,0x65,0x2a\n * ]));\n * // { name: 'Alice', age: 42 }\n * ```\n *\n * @see {@link getStructCodec}\n */\nexport function getStructDecoder<const TFields extends Fields<FixedSizeDecoder<any>>>(\n    fields: TFields,\n): FixedSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): VariableSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): Decoder<GetDecoderTypeFromFields<TFields>> {\n    type TTo = GetDecoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const struct = {} as TTo;\n            fields.forEach(([key, codec]) => {\n                const [value, newOffset] = codec.read(bytes, offset);\n                offset = newOffset;\n                struct[key as keyof TTo] = value;\n            });\n            return [struct, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding custom objects.\n *\n * This codec serializes objects by encoding and decoding each field sequentially.\n *\n * @typeParam TFields - The fields of the struct, each paired with a codec.\n *\n * @param fields - The name and codec of each field.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding custom objects.\n *\n * @example\n * Encoding and decoding a custom struct.\n * ```ts\n * const codec = getStructCodec([\n *   ['name', fixCodecSize(getUtf8Codec(), 5)],\n *   ['age', getU8Codec()]\n * ]);\n *\n * const bytes = codec.encode({ name: 'Alice', age: 42 });\n * // 0x416c6963652a\n * //   |         └── Age (42)\n * //   └── Name (\"Alice\")\n *\n * const struct = codec.decode(bytes);\n * // { name: 'Alice', age: 42 }\n * ```\n *\n * @remarks\n * Separate {@link getStructEncoder} and {@link getStructDecoder} functions are available.\n *\n * ```ts\n * const bytes = getStructEncoder([\n *   ['name', fixCodecSize(getUtf8Encoder(), 5)],\n *   ['age', getU8Encoder()]\n * ]).encode({ name: 'Alice', age: 42 });\n *\n * const struct = getStructDecoder([\n *   ['name', fixCodecSize(getUtf8Decoder(), 5)],\n *   ['age', getU8Decoder()]\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getStructEncoder}\n * @see {@link getStructDecoder}\n */\nexport function getStructCodec<const TFields extends Fields<FixedSizeCodec<any>>>(\n    fields: TFields,\n): FixedSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): VariableSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): Codec<GetEncoderTypeFromFields<TFields>, GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>> {\n    return combineCodec(\n        getStructEncoder(fields),\n        getStructDecoder(fields) as Decoder<GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>>,\n    );\n}\n", "/**\n * An implementation of the Rust `Option<T>` type in JavaScript.\n *\n * In Rust, optional values are represented using `Option<T>`, which can be either:\n * - `Some(T)`, indicating a present value.\n * - `None`, indicating the absence of a value.\n *\n * In JavaScript, this is typically represented as `T | null`. However, this approach fails with nested options.\n * For example, `Option<Option<T>>` in Rust would translate to `T | null | null` in JavaScript, which is equivalent to `T | null`.\n * This means there is no way to differentiate between `Some(None)` and `None`, making nested options impossible.\n *\n * This `Option` type helps solve this by mirroring Rust’s `Option<T>` type.\n *\n * ```ts\n * type Option<T> = Some<T> | None;\n * type Some<T> = { __option: 'Some'; value: T };\n * type None = { __option: 'None' };\n * ```\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Here's how you can create `Option` values.\n *\n * To improve developer experience, helper functions are available.\n * TypeScript can infer the type of `T` or it can be explicitly provided.\n *\n * ```ts\n * // Create an option with a value.\n * some('Hello World');\n * some<number | string>(123);\n *\n * // Create an empty option.\n * none();\n * none<number | string>();\n * ```\n *\n * @see {@link Some}\n * @see {@link None}\n * @see {@link some}\n * @see {@link none}\n */\nexport type Option<T> = None | Some<T>;\n\n/**\n * A flexible type that allows working with {@link Option} values or nullable values.\n *\n * It defines a looser type that can be used when encoding {@link Option | Options}.\n * This allows us to pass `null` or the nested value directly whilst still\n * supporting the Option type for use-cases that need more type safety.\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Accepting both `Option<T>` and `T | null` as input.\n * ```ts\n * function double(value: OptionOrNullable<number>) {\n *   const option = isOption(value) ? value : wrapNullable(value);\n *   return isSome(option) ? option.value * 2 : 'No value';\n * }\n *\n * double(42);       // 84\n * double(some(21)); // 42\n * double(none());   // \"No value\"\n * double(null);     // \"No value\"\n * ```\n *\n * @see {@link Option}\n * @see {@link isOption}\n * @see {@link wrapNullable}\n */\nexport type OptionOrNullable<T> = Option<T> | T | null;\n\n/**\n * Represents an {@link Option} that contains a value.\n *\n * This type mirrors Rust’s `Some(T)`, indicating that a value is present.\n *\n * For more details, see {@link Option}.\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Creating a `Some` value.\n * ```ts\n * const value = some(42);\n * isSome(value); // true\n * isNone(value); // false\n * ```\n *\n * @see {@link Option}\n * @see {@link some}\n * @see {@link isSome}\n */\nexport type Some<T> = Readonly<{ __option: 'Some'; value: T }>;\n\n/**\n * Represents an {@link Option} that contains no value.\n *\n * This type mirrors Rust’s `None`, indicating the absence of a value.\n *\n * For more details, see {@link Option}.\n *\n * @example\n * Creating a `None` value.\n * ```ts\n * const empty = none();\n * isNone(empty); // true\n * isSome(empty); // false\n * ```\n *\n * @see {@link Option}\n * @see {@link none}\n * @see {@link isNone}\n */\nexport type None = Readonly<{ __option: 'None' }>;\n\n/**\n * Creates a new {@link Option} that contains a value.\n *\n * This function explicitly wraps a value in an {@link Option} type.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param value - The value to wrap in an {@link Option}.\n * @returns An {@link Option} containing the provided value.\n *\n * @example\n * Wrapping a value in an `Option`.\n * ```ts\n * const option = some('Hello');\n * option.value;     // \"Hello\"\n * isOption(option); // true\n * isSome(option);   // true\n * isNone(option);   // false\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n */\nexport const some = <T>(value: T): Option<T> => ({ __option: 'Some', value });\n\n/**\n * Creates a new {@link Option} that contains no value.\n *\n * This function explicitly represents an absent value.\n *\n * @typeParam T - The type of the expected absent value.\n *\n * @returns An {@link Option} containing no value.\n *\n * @example\n * Creating an empty `Option`.\n * ```ts\n * const empty = none<number>();\n * isOption(empty); // true\n * isSome(empty);   // false\n * isNone(empty);   // true\n * ```\n *\n * @see {@link Option}\n * @see {@link None}\n */\nexport const none = <T>(): Option<T> => ({ __option: 'None' });\n\n/**\n * Checks whether the given value is an {@link Option}.\n *\n * This function determines whether an input follows the `Option<T>` structure.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param input - The value to check.\n * @returns `true` if the value is an {@link Option}, `false` otherwise.\n *\n * @example\n * Checking for `Option` values.\n * ```ts\n * isOption(some(42));        // true\n * isOption(none());          // true\n * isOption(42);              // false\n * isOption(null);            // false\n * isOption(\"anything else\"); // false\n * ```\n *\n * @see {@link Option}\n */\nexport const isOption = <T = unknown>(input: unknown): input is Option<T> =>\n    !!(\n        input &&\n        typeof input === 'object' &&\n        '__option' in input &&\n        ((input.__option === 'Some' && 'value' in input) || input.__option === 'None')\n    );\n\n/**\n * Checks whether the given {@link Option} contains a value.\n *\n * This function acts as a type guard, ensuring the value is a {@link Some}.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param option - The {@link Option} to check.\n * @returns `true` if the option is a {@link Some}, `false` otherwise.\n *\n * @example\n * Checking for `Some` values.\n * ```ts\n * isSome(some(42)); // true\n * isSome(none());   // false\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n */\nexport const isSome = <T>(option: Option<T>): option is Some<T> => option.__option === 'Some';\n\n/**\n * Checks whether the given {@link Option} contains no value.\n *\n * This function acts as a type guard, ensuring the value is a {@link None}.\n *\n * @typeParam T - The type of the expected value.\n *\n * @param option - The {@link Option} to check.\n * @returns `true` if the option is a {@link None}, `false` otherwise.\n *\n * @example\n * Checking for `None` values.\n * ```ts\n * isNone(some(42)); // false\n * isNone(none());   // true\n * ```\n *\n * @see {@link Option}\n * @see {@link None}\n */\nexport const isNone = <T>(option: Option<T>): option is None => option.__option === 'None';\n", "import { isSome, none, Option, some } from './option';\n\n/**\n * Unwraps the value of an {@link Option}, returning its contained value or a fallback.\n *\n * This function extracts the value `T` from an `Option<T>` type.\n * - If the option is {@link Some}, it returns the contained value `T`.\n * - If the option is {@link None}, it returns the fallback value `U`, which defaults to `null`.\n *\n * @typeParam T - The type of the contained value.\n * @typeParam U - The type of the fallback value (defaults to `null`).\n *\n * @param option - The {@link Option} to unwrap.\n * @param fallback - A function that provides a fallback value if the option is {@link None}.\n * @returns The contained value if {@link Some}, otherwise the fallback value.\n *\n * @example\n * Unwrapping an `Option` with no fallback.\n * ```ts\n * unwrapOption(some('Hello World')); // \"Hello World\"\n * unwrapOption(none());              // null\n * ```\n *\n * @example\n * Providing a custom fallback value.\n * ```ts\n * unwrapOption(some('Hello World'), () => 'Default'); // \"Hello World\"\n * unwrapOption(none(), () => 'Default');              // \"Default\"\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n * @see {@link None}\n */\nexport function unwrapOption<T>(option: Option<T>): T | null;\nexport function unwrapOption<T, U>(option: Option<T>, fallback: () => U): T | U;\nexport function unwrapOption<T, U = null>(option: Option<T>, fallback?: () => U): T | U {\n    if (isSome(option)) return option.value;\n    return fallback ? fallback() : (null as U);\n}\n\n/**\n * Wraps a nullable value into an {@link Option}.\n *\n * - If the input value is `null`, this function returns {@link None}.\n * - Otherwise, it wraps the value in {@link Some}.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param nullable - The nullable value to wrap.\n * @returns An {@link Option} wrapping the value.\n *\n * @example\n * Wrapping nullable values.\n * ```ts\n * wrapNullable('Hello World'); // Option<string> (Some)\n * wrapNullable<string>(null);  // Option<string> (None)\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n * @see {@link None}\n */\nexport const wrapNullable = <T>(nullable: T | null): Option<T> => (nullable !== null ? some(nullable) : none<T>());\n", "import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getBooleanDecoder,\n    getBooleanEncoder,\n    getConstantDecoder,\n    getConstantEncoder,\n    getTupleDecoder,\n    getTupleEncoder,\n    getUnionDecoder,\n    getUnionEncoder,\n    getUnitDecoder,\n    getUnitEncoder,\n} from '@solana/codecs-data-structures';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { isOption, isSome, None, none, Option, OptionOrNullable, Some, some } from './option';\nimport { wrapNullable } from './unwrap-option';\n\n/**\n * Defines the configuration options for {@link Option} codecs.\n *\n * The `getOptionCodec` function behaves similarly to {@link getNullableCodec}\n * but encodes `Option<T>` types instead of `T | null` types.\n *\n * This configuration controls how {@link None} values are encoded and how presence\n * is determined when decoding.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used as the presence prefix.\n *\n * @see {@link getOptionEncoder}\n * @see {@link getOptionDecoder}\n * @see {@link getOptionCodec}\n */\nexport type OptionCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how {@link None} values are represented in the encoded data.\n     *\n     * - By default, {@link None} values are omitted from encoding.\n     * - `'zeroes'`: The bytes allocated for the value are filled with zeroes. This requires a fixed-size codec for the item.\n     * - Custom byte array: {@link None} values are replaced with a predefined byte sequence. This results in a variable-size codec.\n     *\n     * @defaultValue No explicit `noneValue` is used; {@link None} values are omitted.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The presence prefix used to distinguish between {@link None} and present values.\n     *\n     * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`).\n     * - Custom number codec: Allows defining a different number size for the prefix.\n     * - `null`: No prefix is used; `noneValue` (if provided) determines {@link None}.\n     *   If no `noneValue` is set, {@link None} is identified by the absence of bytes.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Returns an encoder for optional values using the {@link Option} type.\n *\n * This encoder serializes an {@link OptionOrNullable} value using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, {@link None} values are encoded as zeroes.\n * - If `noneValue` is a byte array, {@link None} values are replaced with the provided constant.\n *\n * Unlike {@link getNullableEncoder}, this encoder accepts both {@link Option} and {@link Nullable} values.\n *\n * For more details, see {@link getOptionCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param item - The encoder for the value that may be present.\n * @param config - Configuration options for encoding optional values.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding option values.\n *\n * @example\n * Encoding an optional string.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const encoder = getOptionEncoder(stringCodec);\n *\n * encoder.encode(some('Hi'));\n * encoder.encode('Hi');\n * // 0x01020000004869\n * //   | |       └-- utf8 string content (\"Hi\").\n * //   | └-- u32 string prefix (2 characters).\n * //   └-- 1-byte prefix (Some).\n *\n * encoder.encode(none());\n * encoder.encode(null);\n * // 0x00\n * //   └-- 1-byte prefix (None).\n * ```\n *\n * @see {@link getOptionCodec}\n */\nexport function getOptionEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: OptionCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<OptionOrNullable<TFrom>, TSize>;\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: OptionCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: OptionCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: OptionCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: OptionCodecConfig<NumberEncoder> = {},\n): Encoder<OptionOrNullable<TFrom>> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: None | null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: Some<TFrom> | TFrom): [boolean, TFrom] => [\n                true,\n                isOption(value) && isSome(value) ? value.value : value,\n            ]),\n        ],\n        variant => {\n            const option = isOption<TFrom>(variant) ? variant : wrapNullable(variant);\n            return Number(isSome(option));\n        },\n    );\n}\n\n/**\n * Returns a decoder for optional values using the {@link Option} type.\n *\n * This decoder deserializes an `Option<T>` value using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `None` values are identified by zeroes.\n * - If `noneValue` is a byte array, `None` values match the provided constant.\n *\n * Unlike {@link getNullableDecoder}, this decoder always outputs an {@link Option} type.\n *\n * For more details, see {@link getOptionCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The decoder for the value that may be present.\n * @param config - Configuration options for decoding optional values.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding option values.\n *\n * @example\n * Decoding an optional string with a size prefix.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const decoder = getOptionDecoder(stringCodec);\n *\n * decoder.decode(new Uint8Array([0x01, 0x02, 0x00, 0x00, 0x00, 0x48, 0x69]));\n * // some('Hi')\n *\n * decoder.decode(new Uint8Array([0x00]));\n * // none()\n * ```\n *\n * @see {@link getOptionCodec}\n */\nexport function getOptionDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: OptionCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<Option<TTo>, TSize>;\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: OptionCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: OptionCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: OptionCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: OptionCodecConfig<NumberDecoder> = {},\n): Decoder<Option<TTo>> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => none<TTo>()),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => some(value)),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding optional values using the {@link Option} type.\n *\n * This codec serializes and deserializes `Option<T>` values using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`).\n * - If `noneValue: 'zeroes'` is set, `None` values are encoded/decoded as zeroes.\n * - If `noneValue` is a byte array, `None` values are represented by the provided constant.\n * - If `prefix: null` is set, the codec determines `None` values solely from `noneValue` or the presence of bytes.\n *\n * For more details on the configuration options, see {@link OptionCodecConfig}.\n *\n * Note that this behaves similarly to {@link getNullableCodec}, except it\n * encodes {@link OptionOrNullable} values and decodes {@link Option} values.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The codec for the value that may be present.\n * @param config - Configuration options for encoding and decoding option values.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding option values.\n *\n * @example\n * Encoding and decoding an optional string with a size prefix.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const codec = getOptionCodec(stringCodec);\n *\n * const someBytes = codec.encode(some('Hi'));\n * // 0x01020000004869\n * //   | |       └-- utf8 string content (\"Hi\").\n * //   | └-- u32 string prefix (2 characters).\n * //   └-- 1-byte prefix (Some).\n *\n * const noneBytes = codec.encode(none());\n * // 0x00\n * //   └-- 1-byte prefix (None).\n *\n * codec.decode(someBytes); // some('Hi')\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding nullable values.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const codec = getOptionCodec(stringCodec);\n *\n * const someBytes = codec.encode('Hi'); // 0x01020000004869\n * const noneBytes = codec.encode(null); // 0x00\n *\n * codec.decode(someBytes); // some('Hi')\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding and decoding an optional number with a fixed size.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), { noneValue: 'zeroes' });\n *\n * const someBytes = codec.encode(some(42)); // 0x012a00\n * const noneBytes = codec.encode(none());   // 0x000000\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding and decoding {@link None} values with a custom byte sequence and no prefix.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), {\n *   noneValue: new Uint8Array([0xff, 0xff]),\n *   prefix: null,\n * });\n *\n * const someBytes = codec.encode(some(42)); // 0x2a00\n * const noneBytes = codec.encode(none());   // 0xffff\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Identifying {@link None} values by the absence of bytes.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), { prefix: null });\n *\n * const someBytes = codec.encode(some(42)); // 0x2a00\n * const noneBytes = codec.encode(none());   // new Uint8Array(0)\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @remarks\n * Separate {@link getOptionEncoder} and {@link getOptionDecoder} functions are available.\n *\n * ```ts\n * const bytes = getOptionEncoder(getU32Encoder()).encode(some(42));\n * const value = getOptionDecoder(getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getOptionEncoder}\n * @see {@link getOptionDecoder}\n */\nexport function getOptionCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: OptionCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>, TSize>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: OptionCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: OptionCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: OptionCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: OptionCodecConfig<NumberCodec> = {},\n): Codec<OptionOrNullable<TFrom>, Option<TTo>> {\n    type ConfigCast = OptionCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getOptionEncoder<TFrom>(item, config as ConfigCast),\n        getOptionDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n", "import { isOption, isSome, None, Some } from './option';\n\n/**\n * Defines types that should not be recursively unwrapped.\n *\n * These types are preserved as-is when using {@link unwrapOptionRecursively}.\n *\n * @see {@link unwrapOptionRecursively}\n */\ntype UnUnwrappables =\n    | Date\n    | Int8Array\n    | Int16Array\n    | Int32Array\n    | Uint8Array\n    | Uint16Array\n    | Uint32Array\n    | bigint\n    | boolean\n    | number\n    | string\n    | symbol\n    | null\n    | undefined;\n\n/**\n * A type that recursively unwraps nested {@link Option} types.\n *\n * This type resolves all nested {@link Option} values, ensuring\n * that deeply wrapped values are properly extracted.\n *\n * - If `T` is an {@link Option}, it resolves to the contained value.\n * - If `T` is a known primitive or immutable type, it remains unchanged.\n * - If `T` is an object or array, it recursively unwraps any options found.\n *\n * The fallback type `U` (default: `null`) is used in place of `None` values.\n *\n * @typeParam T - The type to be unwrapped.\n * @typeParam U - The fallback type for `None` values (defaults to `null`).\n *\n * @example\n * Resolving nested `Option` types.\n * ```ts\n * UnwrappedOption<Some<Some<string>>>; // string\n * UnwrappedOption<None>;               // null\n * ```\n *\n * @example\n * Resolving options inside objects and arrays.\n * ```ts\n * UnwrappedOption<{ a: Some<number>; b: None }>; // { a: number; b: null }\n * UnwrappedOption<[Some<number>, None]>;         // [number, null]\n * ```\n *\n * @see {@link unwrapOptionRecursively}\n */\nexport type UnwrappedOption<T, U = null> =\n    T extends Some<infer TValue>\n        ? UnwrappedOption<TValue, U>\n        : T extends None\n          ? U\n          : T extends UnUnwrappables\n            ? T\n            : T extends object\n              ? { [key in keyof T]: UnwrappedOption<T[key], U> }\n              : T extends Array<infer TItem>\n                ? Array<UnwrappedOption<TItem, U>>\n                : T;\n\n/**\n * Recursively unwraps all nested {@link Option} types within a value.\n *\n * This function traverses a given value and removes all instances\n * of {@link Option}, replacing them with their contained values.\n *\n * - If an {@link Option} is encountered, its value is extracted.\n * - If an array or object is encountered, its elements are traversed recursively.\n * - If `None` is encountered, it is replaced with the fallback value (default: `null`).\n *\n * @typeParam T - The type of the input value.\n * @typeParam U - The fallback type for `None` values (defaults to `null`).\n *\n * @param input - The value to unwrap.\n * @param fallback - A function that provides a fallback value for `None` options.\n * @returns The recursively unwrapped value.\n *\n * @example\n * Recursively unwrapping nested options.\n * ```ts\n * unwrapOptionRecursively(some(some('Hello World'))); // \"Hello World\"\n * unwrapOptionRecursively(some(none<string>()));      // null\n * ```\n *\n * @example\n * Recursively unwrapping options inside objects and arrays.\n * ```ts\n * unwrapOptionRecursively({\n *   a: 'hello',\n *   b: none(),\n *   c: [{ c1: some(42) }, { c2: none() }],\n * });\n * // { a: \"hello\", b: null, c: [{ c1: 42 }, { c2: null }] }\n * ```\n *\n * @example\n * Using a fallback value for `None` options.\n * ```ts\n * unwrapOptionRecursively(\n *   {\n *     a: 'hello',\n *     b: none(),\n *     c: [{ c1: some(42) }, { c2: none() }],\n *   },\n *   () => 'Default',\n * );\n * // { a: \"hello\", b: \"Default\", c: [{ c1: 42 }, { c2: \"Default\" }] }\n * ```\n *\n * @remarks\n * This function does not mutate objects or arrays.\n *\n * @see {@link Option}\n * @see {@link UnwrappedOption}\n */\nexport function unwrapOptionRecursively<T>(input: T): UnwrappedOption<T>;\nexport function unwrapOptionRecursively<T, U>(input: T, fallback: () => U): UnwrappedOption<T, U>;\nexport function unwrapOptionRecursively<T, U = null>(input: T, fallback?: () => U): UnwrappedOption<T, U> {\n    // Types to bypass.\n    if (!input || ArrayBuffer.isView(input)) {\n        return input as UnwrappedOption<T, U>;\n    }\n\n    const next = <X>(x: X) =>\n        (fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x)) as UnwrappedOption<X, U>;\n\n    // Handle Option.\n    if (isOption(input)) {\n        if (isSome(input)) return next(input.value) as UnwrappedOption<T, U>;\n        return (fallback ? fallback() : null) as UnwrappedOption<T, U>;\n    }\n\n    // Walk.\n    if (Array.isArray(input)) {\n        return input.map(next) as UnwrappedOption<T, U>;\n    }\n    if (typeof input === 'object') {\n        return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)])) as UnwrappedOption<T, U>;\n    }\n    return input as UnwrappedOption<T, U>;\n}\n", "/**\n * A pipeline is a solution that allows you to perform successive transforms of a value using functions. This is useful when building up a transaction message.\n *\n * Until the [pipeline operator](https://github.com/tc39/proposal-pipeline-operator) becomes part of JavaScript you can use this utility to create pipelines.\n *\n * Following common implementations of pipe functions that use TypeScript, this function supports a maximum arity of 10 for type safety.\n *\n * Note you can use nested pipes to extend this limitation, like so:\n * ```ts\n * const myValue = pipe(\n *      pipe(\n *          1,\n *          (x) => x + 1,\n *          (x) => x * 2,\n *          (x) => x - 1,\n *      ),\n *      (y) => y / 3,\n *      (y) => y + 1,\n * );\n * ```\n *\n * @see https://github.com/ramda/ramda/blob/master/source/pipe.js\n * @see https://github.com/darky/rocket-pipes/blob/master/index.ts\n *\n * @example Basic\n * ```ts\n * const add = (a, b) => a + b;\n * const add10 = x => add(x, 10);\n * const add100 = x => add(x, 100);\n * const sum = pipe(1, add10, add100);\n * sum === 111; // true\n * ```\n *\n * @example Building a Solana transaction message\n * ```ts\n * const transferTransactionMessage = pipe(\n *     // The result of the first expression...\n *     createTransactionMessage({ version: 0 }),\n *     // ...gets passed as the sole argument to the next function in the pipeline.\n *     tx => setTransactionMessageFeePayer(myAddress, tx),\n *     // The return value of that function gets passed to the next...\n *     tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n *     // ...and so on.\n *     tx => appendTransactionMessageInstruction(createTransferInstruction(myAddress, toAddress, amountInLamports), tx),\n * );\n * ```\n *\n * @returns The initial value\n */\nexport function pipe<TInitial>(\n    /** The initial value */\n    init: TInitial,\n): TInitial;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n): R1;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n): R2;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n): R3;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n): R4;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n): R5;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n): R6;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n): R7;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n    /** The function with which to transform the return value of the prior function */\n    r7_r8: (r7: R7) => R8,\n): R8;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8, R9>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n    /** The function with which to transform the return value of the prior function */\n    r7_r8: (r7: R7) => R8,\n    /** The function with which to transform the return value of the prior function */\n    r8_r9: (r8: R8) => R9,\n): R9;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n    /** The function with which to transform the return value of the prior function */\n    r7_r8: (r7: R7) => R8,\n    /** The function with which to transform the return value of the prior function */\n    r8_r9: (r8: R8) => R9,\n    /** The function with which to transform the return value of the prior function */\n    r9_r10: (r9: R9) => R10,\n): R10;\nexport function pipe<TInitial>(init: TInitial, ...fns: CallableFunction[]) {\n    return fns.reduce((acc, fn) => fn(acc), init);\n}\n", "import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { AccountLookupMeta, AccountMeta } from './accounts';\n\n/**\n * An instruction destined for a given program.\n *\n * @example\n * ```ts\n * type StakeProgramInstruction = Instruction<'StakeConfig11111111111111111111111111111111'>;\n * ```\n */\nexport interface Instruction<\n    TProgramAddress extends string = string,\n    TAccounts extends readonly (AccountLookupMeta | AccountMeta)[] = readonly (AccountLookupMeta | AccountMeta)[],\n> {\n    readonly accounts?: TAccounts;\n    readonly data?: ReadonlyUint8Array;\n    readonly programAddress: Address<TProgramAddress>;\n}\n\n/**\n * An instruction that loads certain accounts.\n *\n * @example\n * ```ts\n * type InstructionWithTwoAccounts = InstructionWithAccounts<\n *     [\n *         WritableAccount, // First account\n *         RentSysvar, // Second account\n *     ]\n * >;\n * ```\n */\nexport interface InstructionWithAccounts<TAccounts extends readonly (AccountLookupMeta | AccountMeta)[]>\n    extends Instruction {\n    readonly accounts: TAccounts;\n}\n\nexport function isInstructionForProgram<TProgramAddress extends string, TInstruction extends Instruction>(\n    instruction: TInstruction,\n    programAddress: Address<TProgramAddress>,\n): instruction is TInstruction & { programAddress: Address<TProgramAddress> } {\n    return instruction.programAddress === programAddress;\n}\n\nexport function assertIsInstructionForProgram<TProgramAddress extends string, TInstruction extends Instruction>(\n    instruction: TInstruction,\n    programAddress: Address<TProgramAddress>,\n): asserts instruction is TInstruction & { programAddress: Address<TProgramAddress> } {\n    if (instruction.programAddress !== programAddress) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH, {\n            actualProgramAddress: instruction.programAddress,\n            expectedProgramAddress: programAddress,\n        });\n    }\n}\n\nexport function isInstructionWithAccounts<\n    TAccounts extends readonly (AccountLookupMeta | AccountMeta)[] = readonly (AccountLookupMeta | AccountMeta)[],\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): instruction is InstructionWithAccounts<TAccounts> & TInstruction {\n    return instruction.accounts !== undefined;\n}\n\nexport function assertIsInstructionWithAccounts<\n    TAccounts extends readonly (AccountLookupMeta | AccountMeta)[] = readonly (AccountLookupMeta | AccountMeta)[],\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): asserts instruction is InstructionWithAccounts<TAccounts> & TInstruction {\n    if (instruction.accounts === undefined) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS, {\n            data: instruction.data,\n            programAddress: instruction.programAddress,\n        });\n    }\n}\n\n/**\n * An instruction whose data conforms to a certain type.\n *\n * This is most useful when you have a branded `Uint8Array` that represents a particular\n * instruction's data.\n *\n * @example A type for the \\`AdvanceNonce\\` instruction of the System program\n * ```ts\n * type AdvanceNonceAccountInstruction<\n *     TNonceAccountAddress extends string = string,\n *     TNonceAuthorityAddress extends string = string,\n * > = Instruction<'11111111111111111111111111111111'> &\n *     InstructionWithAccounts<\n *         [\n *             WritableAccount<TNonceAccountAddress>,\n *             ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n *             ReadonlySignerAccount<TNonceAuthorityAddress>,\n *         ]\n *     > &\n *     InstructionWithData<AdvanceNonceAccountInstructionData>;\n * ```\n */\nexport interface InstructionWithData<TData extends ReadonlyUint8Array> extends Instruction {\n    readonly data: TData;\n}\n\nexport function isInstructionWithData<\n    TData extends ReadonlyUint8Array = ReadonlyUint8Array,\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): instruction is InstructionWithData<TData> & TInstruction {\n    return instruction.data !== undefined;\n}\n\nexport function assertIsInstructionWithData<\n    TData extends ReadonlyUint8Array = ReadonlyUint8Array,\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): asserts instruction is InstructionWithData<TData> & TInstruction {\n    if (instruction.data === undefined) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA, {\n            accountAddresses: instruction.accounts?.map(a => a.address),\n            programAddress: instruction.programAddress,\n        });\n    }\n}\n", "/**\n * Describes the purpose for which an account participates in a transaction.\n *\n * Every account that participates in a transaction can be read from, but only ones that you mark as\n * writable may be written to, and only ones that you indicate must sign the transaction will gain\n * the privileges associated with signers at runtime.\n *\n * |                               | `isSigner` | `isWritable` |\n * | ----------------------------- | ---------- | ------------ |\n * | `AccountRole.READONLY`        | &#x274c;   | &#x274c;     |\n * | `AccountRole.WRITABLE`        | &#x274c;   | &#x2705;     |\n * | `AccountRole.READONLY_SIGNER` | &#x2705;   | &#x274c;     |\n * | `AccountRole.WRITABLE_SIGNER` | &#x2705;   | &#x2705;     |\n */\nexport enum AccountRole {\n    // Bitflag guide: is signer ⌄⌄ is writable\n    WRITABLE_SIGNER = /* 3 */ 0b11, // prettier-ignore\n    READONLY_SIGNER = /* 2 */ 0b10, // prettier-ignore\n    WRITABLE =        /* 1 */ 0b01, // prettier-ignore\n    READONLY =        /* 0 */ 0b00, // prettier-ignore\n}\n\n// Quick primer on bitwise operations: https://stackoverflow.com/a/1436448/802047\nconst IS_SIGNER_BITMASK = 0b10;\nconst IS_WRITABLE_BITMASK = 0b01;\n\n/**\n * @returns An {@link AccountRole} representing the non-signer variant of the supplied role.\n */\nexport function downgradeRoleToNonSigner(role: AccountRole.READONLY_SIGNER): AccountRole.READONLY;\nexport function downgradeRoleToNonSigner(role: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole {\n    return role & ~IS_SIGNER_BITMASK;\n}\n\n/**\n * @returns An {@link AccountRole} representing the read-only variant of the supplied role.\n */\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE): AccountRole.READONLY;\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE_SIGNER): AccountRole.READONLY_SIGNER;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole {\n    return role & ~IS_WRITABLE_BITMASK;\n}\n\n/**\n * Returns `true` if the {@link AccountRole} given represents that of a signer. Also refines the\n * TypeScript type of the supplied role.\n */\nexport function isSignerRole(role: AccountRole): role is AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER {\n    return role >= AccountRole.READONLY_SIGNER;\n}\n\n/**\n * Returns `true` if the {@link AccountRole} given represents that of a writable account. Also\n * refines the TypeScript type of the supplied role.\n */\nexport function isWritableRole(role: AccountRole): role is AccountRole.WRITABLE | AccountRole.WRITABLE_SIGNER {\n    return (role & IS_WRITABLE_BITMASK) !== 0;\n}\n\n/**\n * Given two {@link AccountRole | AccountRoles}, will return the {@link AccountRole} that grants the\n * highest privileges of both.\n *\n * @example\n * ```ts\n * // Returns `AccountRole.WRITABLE_SIGNER`\n * mergeRoles(AccountRole.READONLY_SIGNER, AccountRole.WRITABLE);\n * ```\n */\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE_SIGNER, roleB: AccountRole): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.READONLY_SIGNER): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY, roleB: AccountRole.READONLY): AccountRole.READONLY; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole {\n    return roleA | roleB;\n}\n\n/**\n * @returns An {@link AccountRole} representing the signer variant of the supplied role.\n */\nexport function upgradeRoleToSigner(role: AccountRole.READONLY): AccountRole.READONLY_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole {\n    return role | IS_SIGNER_BITMASK;\n}\n\n/**\n * @returns An {@link AccountRole} representing the writable variant of the supplied role.\n */\nexport function upgradeRoleToWritable(role: AccountRole.READONLY): AccountRole.WRITABLE;\nexport function upgradeRoleToWritable(role: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole {\n    return role | IS_WRITABLE_BITMASK;\n}\n", "export const ED25519_ALGORITHM_IDENTIFIER =\n    // Resist the temptation to convert this to a simple string; As of version 133.0.3, Firefox\n    // requires the object form of `AlgorithmIdentifier` and will throw a `DOMException` otherwise.\n    Object.freeze({ name: 'Ed25519' });\n", "import { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\n\nfunction addPkcs8Header(bytes: ReadonlyUint8Array): ReadonlyUint8Array {\n    // prettier-ignore\n    return new Uint8Array([\n        /**\n         * PKCS#8 header\n         */\n        0x30, // ASN.1 sequence tag\n        0x2e, // Length of sequence (46 more bytes)\n\n            0x02, // ASN.1 integer tag\n            0x01, // Length of integer\n                0x00, // Version number\n\n            0x30, // ASN.1 sequence tag\n            0x05, // Length of sequence\n                0x06, // ASN.1 object identifier tag\n                0x03, // Length of object identifier\n                    // Edwards curve algorithms identifier https://oid-rep.orange-labs.fr/get/1.3.101.112\n                        0x2b, // iso(1) / identified-organization(3) (The first node is multiplied by the decimal 40 and the result is added to the value of the second node)\n                        0x65, // thawte(101)\n                    // Ed25519 identifier\n                        0x70, // id-Ed25519(112)\n\n        /**\n         * Private key payload\n         */\n        0x04, // ASN.1 octet string tag\n        0x22, // String length (34 more bytes)\n\n            // Private key bytes as octet string\n            0x04, // ASN.1 octet string tag\n            0x20, // String length (32 bytes)\n\n        ...bytes\n    ]);\n}\n\n/**\n * Given a private key represented as a 32-byte `Uint8Array`, creates an Ed25519 private key for use\n * with other methods in this package that accept\n * [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) objects.\n *\n * @param bytes 32 bytes that represent the private key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import { createPrivateKeyFromBytes } from '@solana/keys';\n *\n * const privateKey = await createPrivateKeyFromBytes(new Uint8Array([...]));\n * const extractablePrivateKey = await createPrivateKeyFromBytes(new Uint8Array([...]), true);\n * ```\n */\nexport async function createPrivateKeyFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKey> {\n    const actualLength = bytes.byteLength;\n    if (actualLength !== 32) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, {\n            actualLength,\n        });\n    }\n    const privateKeyBytesPkcs8 = addPkcs8Header(bytes);\n    return await crypto.subtle.importKey('pkcs8', privateKeyBytesPkcs8, ED25519_ALGORITHM_IDENTIFIER, extractable, [\n        'sign',\n    ]);\n}\n", "import { assertKeyExporterIsAvailable } from '@solana/assertions';\nimport { SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, SolanaError } from '@solana/errors';\n\n/**\n * Given an extractable [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * private key, gets the corresponding public key as a\n * [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey).\n *\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the public\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import { createPrivateKeyFromBytes, getPublicKeyFromPrivateKey } from '@solana/keys';\n *\n * const privateKey = await createPrivateKeyFromBytes(new Uint8Array([...]), true);\n *\n * const publicKey = await getPublicKeyFromPrivateKey(privateKey);\n * const extractablePublicKey = await getPublicKeyFromPrivateKey(privateKey, true);\n * ```\n */\nexport async function getPublicKeyFromPrivateKey(\n    privateKey: CryptoKey,\n    extractable: boolean = false,\n): Promise<CryptoKey> {\n    assertKeyExporterIsAvailable();\n\n    if (privateKey.extractable === false) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, { key: privateKey });\n    }\n\n    // Export private key.\n    const jwk = await crypto.subtle.exportKey('jwk', privateKey);\n\n    // Import public key.\n    return await crypto.subtle.importKey(\n        'jwk',\n        {\n            crv /* curve */: 'Ed25519',\n            ext /* extractable */: extractable,\n            key_ops /* key operations */: ['verify'],\n            kty /* key type */: 'OKP' /* octet key pair */,\n            x /* public key x-coordinate */: jwk.x,\n        },\n        'Ed25519',\n        extractable,\n        ['verify'],\n    );\n}\n", "import { assertSigningCapabilityIsAvailable, assertVerificationCapabilityIsAvailable } from '@solana/assertions';\nimport { Encoder, ReadonlyUint8Array } from '@solana/codecs-core';\nimport { getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\n\n/**\n * A 64-byte Ed25519 signature as a base58-encoded string.\n */\nexport type Signature = Brand<EncodedString<string, 'base58'>, 'Signature'>;\n/**\n * A 64-byte Ed25519 signature.\n *\n * Whenever you need to verify that a particular signature is, in fact, the one that would have been\n * produced by signing some known bytes using the private key associated with some known public key,\n * use the {@link verifySignature} function in this package.\n */\nexport type SignatureBytes = Brand<Uint8Array, 'SignatureBytes'>;\n\nlet base58Encoder: Encoder<string> | undefined;\n\n/**\n * Asserts that an arbitrary string is a base58-encoded Ed25519 signature.\n *\n * Useful when you receive a string from user input or an untrusted network API that you expect to\n * represent an Ed25519 signature (eg. of a transaction).\n *\n * @example\n * ```ts\n * import { assertIsSignature } from '@solana/keys';\n *\n * // Imagine a function that asserts whether a user-supplied signature is valid or not.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const signature: string = signatureInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `signature` to `Signature`.\n *         assertIsSignature(signature);\n *         // At this point, `signature` is a `Signature` that can be used with the RPC.\n *         const {\n *             value: [status],\n *         } = await rpc.getSignatureStatuses([signature]).send();\n *     } catch (e) {\n *         // `signature` turned out not to be a base58-encoded signature\n *     }\n * }\n * ```\n */\nexport function assertIsSignature(putativeSignature: string): asserts putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeSignature.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\n/**\n * A type guard that accepts a string as input. It will both return `true` if the string conforms to\n * the {@link Signature} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isSignature } from '@solana/keys';\n *\n * if (isSignature(signature)) {\n *     // At this point, `signature` has been refined to a\n *     // `Signature` that can be used with the RPC.\n *     const {\n *         value: [status],\n *     } = await rpc.getSignatureStatuses([signature]).send();\n *     setSignatureStatus(status);\n * } else {\n *     setError(`${signature} is not a transaction signature`);\n * }\n * ```\n */\nexport function isSignature(putativeSignature: string): putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 64) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * Given a private [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) and a\n * `Uint8Array` of bytes, this method will return the 64-byte Ed25519 signature of that data as a\n * `Uint8Array`.\n *\n * @example\n * ```ts\n * import { signBytes } from '@solana/keys';\n *\n * const data = new Uint8Array([1, 2, 3]);\n * const signature = await signBytes(privateKey, data);\n * ```\n */\nexport async function signBytes(key: CryptoKey, data: ReadonlyUint8Array): Promise<SignatureBytes> {\n    assertSigningCapabilityIsAvailable();\n    const signedData = await crypto.subtle.sign(ED25519_ALGORITHM_IDENTIFIER, key, data);\n    return new Uint8Array(signedData) as SignatureBytes;\n}\n\n/**\n * This helper combines _asserting_ that a string is an Ed25519 signature with _coercing_ it to the\n * {@link Signature} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { signature } from '@solana/keys';\n *\n * const signature = signature(userSuppliedSignature);\n * const {\n *     value: [status],\n * } = await rpc.getSignatureStatuses([signature]).send();\n * ```\n */\nexport function signature(putativeSignature: string): Signature {\n    assertIsSignature(putativeSignature);\n    return putativeSignature;\n}\n\n/**\n * Given a public [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey), some\n * {@link SignatureBytes}, and a `Uint8Array` of data, this method will return `true` if the\n * signature was produced by signing the data using the private key associated with the public key,\n * and `false` otherwise.\n *\n * @example\n * ```ts\n * import { verifySignature } from '@solana/keys';\n *\n * const data = new Uint8Array([1, 2, 3]);\n * if (!(await verifySignature(publicKey, signature, data))) {\n *     throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n * }\n * ```\n */\nexport async function verifySignature(\n    key: CryptoKey,\n    signature: SignatureBytes,\n    data: ReadonlyUint8Array,\n): Promise<boolean> {\n    assertVerificationCapabilityIsAvailable();\n    return await crypto.subtle.verify(ED25519_ALGORITHM_IDENTIFIER, key, signature, data);\n}\n", "import { assertKeyGenerationIsAvailable, assertPRNGIsAvailable } from '@solana/assertions';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\nimport { createPrivateKeyFromBytes } from './private-key';\nimport { getPublicKeyFromPrivateKey } from './public-key';\nimport { signBytes, verifySignature } from './signatures';\n\n/**\n * Generates an Ed25519 public/private key pair for use with other methods in this package that\n * accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) objects.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n *\n * const { privateKey, publicKey } = await generateKeyPair();\n * ```\n */\nexport async function generateKeyPair(): Promise<CryptoKeyPair> {\n    await assertKeyGenerationIsAvailable();\n    const keyPair = await crypto.subtle.generateKey(\n        /* algorithm */ ED25519_ALGORITHM_IDENTIFIER, // Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20\n        /* extractable */ false, // Prevents the bytes of the private key from being visible to JS.\n        /* allowed uses */ ['sign', 'verify'],\n    );\n    return keyPair;\n}\n\n/**\n * Given a 64-byte `Uint8Array` secret key, creates an Ed25519 public/private key pair for use with\n * other methods in this package that accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * objects.\n *\n * @param bytes 64 bytes, the first 32 of which represent the private key and the last 32 of which\n * represent its associated public key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import fs from 'fs';\n * import { createKeyPairFromBytes } from '@solana/keys';\n *\n * // Get bytes from local keypair file.\n * const keypairFile = fs.readFileSync('~/.config/solana/id.json');\n * const keypairBytes = new Uint8Array(JSON.parse(keypairFile.toString()));\n *\n * // Create a CryptoKeyPair from the bytes.\n * const { privateKey, publicKey } = await createKeyPairFromBytes(keypairBytes);\n * ```\n */\nexport async function createKeyPairFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKeyPair> {\n    assertPRNGIsAvailable();\n\n    if (bytes.byteLength !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, { byteLength: bytes.byteLength });\n    }\n    const [publicKey, privateKey] = await Promise.all([\n        crypto.subtle.importKey('raw', bytes.slice(32), ED25519_ALGORITHM_IDENTIFIER, /* extractable */ true, [\n            'verify',\n        ]),\n        createPrivateKeyFromBytes(bytes.slice(0, 32), extractable),\n    ]);\n\n    // Verify the key pair\n    const randomBytes = new Uint8Array(32);\n    crypto.getRandomValues(randomBytes);\n    const signedData = await signBytes(privateKey, randomBytes);\n    const isValid = await verifySignature(publicKey, signedData, randomBytes);\n    if (!isValid) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY);\n    }\n\n    return { privateKey, publicKey } as CryptoKeyPair;\n}\n\n/**\n * Given a private key represented as a 32-byte `Uint8Array`, creates an Ed25519 public/private key\n * pair for use with other methods in this package that accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * objects.\n *\n * @param bytes 32 bytes that represent the private key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import { createKeyPairFromPrivateKeyBytes } from '@solana/keys';\n *\n * const { privateKey, publicKey } = await createKeyPairFromPrivateKeyBytes(new Uint8Array([...]));\n * ```\n *\n * This can be useful when you have a private key but not the corresponding public key or when you\n * need to derive key pairs from seeds. For instance, the following code snippet derives a key pair\n * from the hash of a message.\n *\n * ```ts\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { createKeyPairFromPrivateKeyBytes } from '@solana/keys';\n *\n * const message = getUtf8Encoder().encode('Hello, World!');\n * const seed = new Uint8Array(await crypto.subtle.digest('SHA-256', message));\n *\n * const derivedKeypair = await createKeyPairFromPrivateKeyBytes(seed);\n * ```\n */\nexport async function createKeyPairFromPrivateKeyBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKeyPair> {\n    const privateKeyPromise = createPrivateKeyFromBytes(bytes, extractable);\n\n    // Here we need the private key to be extractable in order to export\n    // it as a public key. Therefore, if the `extractable` parameter\n    // is `false`, we need to create two private keys such that:\n    //   - The extractable one is used to create the public key and\n    //   - The non-extractable one is the one we will return.\n    const [publicKey, privateKey] = await Promise.all([\n        // This nested promise makes things efficient by\n        // creating the public key in parallel with the\n        // second private key creation, if it is needed.\n        (extractable ? privateKeyPromise : createPrivateKeyFromBytes(bytes, true /* extractable */)).then(\n            async privateKey => await getPublicKeyFromPrivateKey(privateKey, true /* extractable */),\n        ),\n        privateKeyPromise,\n    ]);\n\n    return { privateKey, publicKey };\n}\n", "import type { Address } from '@solana/addresses';\nimport { isSolanaError, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM, SolanaError } from '@solana/errors';\n\n/**\n * Identifies whether an error -- typically caused by a transaction failure -- is a custom program\n * error from the provided program address.\n *\n * @param transactionMessage The transaction message that failed to execute. Since the RPC response\n * only provides the index of the failed instruction, the transaction message is required to\n * determine its program address\n * @param programAddress The address of the program from which the error is expected to have\n * originated\n * @param code The expected error code of the custom program error. When provided, the function will\n * check that the custom program error code matches the given value.\n *\n * @example\n * ```ts\n * try {\n *     // Send and confirm your transaction.\n * } catch (error) {\n *     if (isProgramError(error, transactionMessage, myProgramAddress, 42)) {\n *         // Handle custom program error 42 from this program.\n *     } else if (isProgramError(error, transactionMessage, myProgramAddress)) {\n *         // Handle all other custom program errors from this program.\n *     } else {\n *         throw error;\n *     }\n * }\n * ```\n */\nexport function isProgramError<TProgramErrorCode extends number>(\n    error: unknown,\n    transactionMessage: { instructions: Record<number, { programAddress: Address }> },\n    programAddress: Address,\n    code?: TProgramErrorCode,\n): error is Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> &\n    SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> {\n    if (!isSolanaError(error, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM)) {\n        return false;\n    }\n    const instructionProgramAddress = transactionMessage.instructions[error.context.index]?.programAddress;\n    if (!instructionProgramAddress || instructionProgramAddress !== programAddress) {\n        return false;\n    }\n    return typeof code === 'undefined' || error.context.code === code;\n}\n", "/**\n * This function is a replacement for `JSON.parse` that can handle large\n * unsafe integers by parsing them as BigInts. It transforms every\n * numerical value into a BigInt without loss of precision.\n */\nexport function parseJsonWithBigInts(json: string): unknown {\n    return JSON.parse(wrapIntegersInBigIntValueObject(json), (_, value) => {\n        return isBigIntValueObject(value) ? unwrapBigIntValueObject(value) : value;\n    });\n}\n\nfunction wrapIntegersInBigIntValueObject(json: string): string {\n    const out = [];\n    let inQuote = false;\n    for (let ii = 0; ii < json.length; ii++) {\n        let isEscaped = false;\n        if (json[ii] === '\\\\') {\n            out.push(json[ii++]);\n            isEscaped = !isEscaped;\n        }\n        if (json[ii] === '\"') {\n            out.push(json[ii]);\n            if (!isEscaped) {\n                inQuote = !inQuote;\n            }\n            continue;\n        }\n        if (!inQuote) {\n            const consumedNumber = consumeNumber(json, ii);\n            if (consumedNumber?.length) {\n                ii += consumedNumber.length - 1;\n                // Don't wrap numbers that contain a decimal point or a negative exponent.\n                if (consumedNumber.match(/\\.|[eE]-/)) {\n                    out.push(consumedNumber);\n                } else {\n                    out.push(wrapBigIntValueObject(consumedNumber));\n                }\n                continue;\n            }\n        }\n        out.push(json[ii]);\n    }\n\n    return out.join('');\n}\n\nfunction consumeNumber(json: string, ii: number): string | null {\n    /** @see https://stackoverflow.com/a/13340826/11440277 */\n    const JSON_NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/;\n\n    // Stop early if the first character isn't a digit or a minus sign.\n    if (!json[ii]?.match(/[-\\d]/)) {\n        return null;\n    }\n\n    // Otherwise, check if the next characters form a valid JSON number.\n    const numberMatch = json.slice(ii).match(JSON_NUMBER_REGEX);\n    return numberMatch ? numberMatch[0] : null;\n}\n\ntype BigIntValueObject = {\n    // `$` implies 'this is a value object'.\n    // `n` implies 'interpret the value as a bigint'.\n    $n: string;\n};\n\nfunction wrapBigIntValueObject(value: string): string {\n    return `{\"$n\":\"${value}\"}`;\n}\n\nfunction unwrapBigIntValueObject({ $n }: BigIntValueObject): bigint {\n    if ($n.match(/[eE]/)) {\n        const [units, exponent] = $n.split(/[eE]/);\n        return BigInt(units) * BigInt(10) ** BigInt(exponent);\n    }\n    return BigInt($n);\n}\n\nfunction isBigIntValueObject(value: unknown): value is BigIntValueObject {\n    return !!value && typeof value === 'object' && '$n' in value && typeof value.$n === 'string';\n}\n", "import { RpcRequest } from './rpc-request';\n\nlet _nextMessageId = 0n;\nfunction getNextMessageId(): string {\n    const id = _nextMessageId;\n    _nextMessageId++;\n    return id.toString();\n}\n\n/**\n * Returns a spec-compliant JSON RPC 2.0 message, given a method name and some params.\n *\n * Generates a new `id` on each call by incrementing a `bigint` and casting it to a string.\n */\nexport function createRpcMessage<TParams>(request: RpcRequest<TParams>) {\n    return {\n        id: getNextMessageId(),\n        jsonrpc: '2.0',\n        method: request.methodName,\n        params: request.params,\n    };\n}\n", "/**\n * Transforms a value into a JSON string, whilst rendering bigints as large unsafe integers.\n */\nexport function stringifyJsonWithBigints(value: unknown, space?: number | string): string {\n    return unwrapBigIntValueObject(\n        JSON.stringify(value, (_, v) => (typeof v === 'bigint' ? wrapBigIntValueObject(v) : v), space),\n    );\n}\n\ntype BigIntValueObject = {\n    // `$` implies 'this is a value object'.\n    // `n` implies 'interpret the value as a bigint'.\n    $n: string;\n};\n\nfunction wrapBigIntValueObject(value: bigint): BigIntValueObject {\n    return { $n: `${value}` };\n}\n\nfunction unwrapBigIntValueObject(value: string): string {\n    return value.replace(/\\{\\s*\"\\$n\"\\s*:\\s*\"(-?\\d+)\"\\s*\\}/g, '$1');\n}\n", "import { SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD, SolanaError } from '@solana/errors';\nimport { Callable, Flatten, OverloadImplementations, UnionToIntersection } from '@solana/rpc-spec-types';\n\nimport { RpcApi, RpcPlan } from './rpc-api';\nimport { RpcTransport } from './rpc-transport';\n\nexport type RpcConfig<TRpcMethods, TRpcTransport extends RpcTransport> = Readonly<{\n    api: RpcApi<TRpcMethods>;\n    transport: TRpcTransport;\n}>;\n\n/**\n * An object that exposes all of the functions described by `TRpcMethods`.\n *\n * Calling each method returns a {@link PendingRpcRequest | PendingRpcRequest<TResponse>} where\n * `TResponse` is that method's response type.\n */\nexport type Rpc<TRpcMethods> = {\n    [TMethodName in keyof TRpcMethods]: PendingRpcRequestBuilder<OverloadImplementations<TRpcMethods, TMethodName>>;\n};\n\n/**\n * Pending requests are the result of calling a supported method on a {@link Rpc} object. They\n * encapsulate all of the information necessary to make the request without actually making it.\n *\n * Calling the {@link PendingRpcRequest.send | `send(options)`} method on a\n * {@link PendingRpcRequest | PendingRpcRequest<TResponse>} will trigger the request and return a\n * promise for `TResponse`.\n */\nexport type PendingRpcRequest<TResponse> = {\n    send(options?: RpcSendOptions): Promise<TResponse>;\n};\n\nexport type RpcSendOptions = Readonly<{\n    /**\n     * An optional signal that you can supply when triggering a {@link PendingRpcRequest} that you\n     * might later need to abort.\n     */\n    abortSignal?: AbortSignal;\n}>;\n\ntype PendingRpcRequestBuilder<TMethodImplementations> = UnionToIntersection<\n    Flatten<{\n        [P in keyof TMethodImplementations]: PendingRpcRequestReturnTypeMapper<TMethodImplementations[P]>;\n    }>\n>;\n\ntype PendingRpcRequestReturnTypeMapper<TMethodImplementation> =\n    // Check that this property of the TRpcMethods interface is, in fact, a function.\n    TMethodImplementation extends Callable\n        ? (...args: Parameters<TMethodImplementation>) => PendingRpcRequest<ReturnType<TMethodImplementation>>\n        : never;\n\n/**\n * Creates a {@link Rpc} instance given a {@link RpcApi | RpcApi<TRpcMethods>} and a\n * {@link RpcTransport} capable of fulfilling them.\n */\nexport function createRpc<TRpcMethods, TRpcTransport extends RpcTransport>(\n    rpcConfig: RpcConfig<TRpcMethods, TRpcTransport>,\n): Rpc<TRpcMethods> {\n    return makeProxy(rpcConfig);\n}\n\nfunction makeProxy<TRpcMethods, TRpcTransport extends RpcTransport>(\n    rpcConfig: RpcConfig<TRpcMethods, TRpcTransport>,\n): Rpc<TRpcMethods> {\n    return new Proxy(rpcConfig.api, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get(target, p, receiver) {\n            if (p === 'then') {\n                return undefined;\n            }\n            return function (...rawParams: unknown[]) {\n                const methodName = p.toString();\n                const getApiPlan = Reflect.get(target, methodName, receiver);\n                if (!getApiPlan) {\n                    throw new SolanaError(SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD, {\n                        method: methodName,\n                        params: rawParams,\n                    });\n                }\n                const apiPlan = getApiPlan(...rawParams);\n                return createPendingRpcRequest(rpcConfig, apiPlan);\n            };\n        },\n    }) as Rpc<TRpcMethods>;\n}\n\nfunction createPendingRpcRequest<TRpcMethods, TRpcTransport extends RpcTransport, TResponse>(\n    { transport }: RpcConfig<TRpcMethods, TRpcTransport>,\n    plan: RpcPlan<TResponse>,\n): PendingRpcRequest<TResponse> {\n    return {\n        async send(options?: RpcSendOptions): Promise<TResponse> {\n            return await plan.execute({ signal: options?.abortSignal, transport });\n        },\n    };\n}\n", "import {\n    Callable,\n    createRpcMessage,\n    RpcRequestTransformer,\n    RpcResponse,\n    RpcResponseTransformer,\n} from '@solana/rpc-spec-types';\n\nimport type { RpcTransport } from './rpc-transport';\n\nexport type RpcApiConfig = Readonly<{\n    /**\n     * An optional function that transforms the {@link RpcRequest} before it is sent to the JSON RPC\n     * server.\n     *\n     * This is useful when the params supplied by the caller need to be transformed before\n     * forwarding the message to the server. Use cases for this include applying defaults,\n     * forwarding calls to renamed methods, and serializing complex values.\n     */\n    requestTransformer?: RpcRequestTransformer;\n    /**\n     * An optional function that transforms the {@link RpcResponse} before it is returned to the\n     * caller.\n     *\n     * Use cases for this include constructing complex data types from serialized data, and throwing\n     * exceptions.\n     */\n    responseTransformer?: RpcResponseTransformer;\n}>;\n\n/**\n * This type allows an {@link RpcApi} to describe how a particular request should be issued to the\n * JSON RPC server.\n *\n * Given a function that was called on a {@link Rpc}, this object exposes an `execute` function that\n * dictates which request will be sent, how the underlying transport will be used, and how the\n * responses will be transformed.\n *\n * This function accepts a {@link RpcTransport} and an `AbortSignal` and asynchronously returns a\n * {@link RpcResponse}. This gives us the opportunity to:\n *\n * - define the `payload` from the requested method name and parameters before passing it to the\n *   transport.\n * - call the underlying transport zero, one or multiple times depending on the use-case (e.g.\n *   caching or aggregating multiple responses).\n * - transform the response from the JSON RPC server, in case it does not match the `TResponse`\n *   specified by the {@link PendingRpcRequest | PendingRpcRequest<TResponse>} returned from that\n *   function.\n */\nexport type RpcPlan<TResponse> = {\n    execute: (\n        config: Readonly<{\n            signal?: AbortSignal;\n            transport: RpcTransport;\n        }>,\n    ) => Promise<RpcResponse<TResponse>>;\n};\n\n/**\n * For each of `TRpcMethods`, this object exposes a method with the same name that maps between its\n * input arguments and a {@link RpcPlan | RpcPlan<TResponse>} that implements the execution of a\n * JSON RPC request to fetch `TResponse`.\n */\nexport type RpcApi<TRpcMethods> = {\n    [MethodName in keyof TRpcMethods]: RpcReturnTypeMapper<TRpcMethods[MethodName]>;\n};\n\ntype RpcReturnTypeMapper<TRpcMethod> = TRpcMethod extends Callable\n    ? (...rawParams: unknown[]) => RpcPlan<ReturnType<TRpcMethod>>\n    : never;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RpcApiMethod = (...args: any) => any;\ninterface RpcApiMethods {\n    [methodName: string]: RpcApiMethod;\n}\n\n/**\n * Creates a JavaScript proxy that converts _any_ function call called on it to a {@link RpcPlan} by\n * creating an `execute` function that:\n *\n * - sets the transport payload to a JSON RPC v2 payload object with the requested `methodName` and\n *   `params` properties, optionally transformed by {@link RpcApiConfig.requestTransformer}.\n * - transforms the transport's response using the {@link RpcApiConfig.responseTransformer}\n *   function, if provided.\n *\n * @example\n * ```ts\n * // For example, given this `RpcApi`:\n * const rpcApi = createJsonRpcApi({\n *     requestTransformer: (...rawParams) => rawParams.reverse(),\n *     responseTransformer: response => response.result,\n * });\n *\n * // ...the following function call:\n * rpcApi.foo('bar', { baz: 'bat' });\n *\n * // ...will produce a `RpcPlan` that:\n * // -   Uses the following payload: { id: 1, jsonrpc: '2.0', method: 'foo', params: [{ baz: 'bat' }, 'bar'] }.\n * // -   Returns the \"result\" property of the RPC response.\n * ```\n */\nexport function createJsonRpcApi<TRpcMethods extends RpcApiMethods>(config?: RpcApiConfig): RpcApi<TRpcMethods> {\n    return new Proxy({} as RpcApi<TRpcMethods>, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get<TMethodName extends keyof RpcApi<TRpcMethods>>(\n            ...args: Parameters<NonNullable<ProxyHandler<RpcApi<TRpcMethods>>['get']>>\n        ) {\n            const [_, p] = args;\n            const methodName = p.toString() as keyof TRpcMethods as string;\n            return function (\n                ...rawParams: Parameters<\n                    TRpcMethods[TMethodName] extends CallableFunction ? TRpcMethods[TMethodName] : never\n                >\n            ): RpcPlan<ReturnType<TRpcMethods[TMethodName]>> {\n                const rawRequest = Object.freeze({ methodName, params: rawParams });\n                const request = config?.requestTransformer ? config?.requestTransformer(rawRequest) : rawRequest;\n                return Object.freeze(<RpcPlan<ReturnType<TRpcMethods[TMethodName]>>>{\n                    execute: async ({ signal, transport }) => {\n                        const payload = createRpcMessage(request);\n                        const response = await transport({ payload, signal });\n                        if (!config?.responseTransformer) {\n                            return response;\n                        }\n                        return config.responseTransformer(response, request);\n                    },\n                });\n            };\n        },\n    });\n}\n", "import { RpcResponse } from '@solana/rpc-spec-types';\n\ntype Config = Readonly<{\n    /** A value of arbitrary type to be sent to a RPC server */\n    payload: unknown;\n    /**\n     * An optional `AbortSignal` on which the `'abort'` event will be fired if the request should be\n     * cancelled.\n     */\n    signal?: AbortSignal;\n}>;\n\n/**\n * A function that can act as a transport for a {@link Rpc}. It need only return a promise for a\n * response given the supplied config.\n */\nexport type RpcTransport = {\n    <TResponse>(config: Config): Promise<RpcResponse<TResponse>>;\n};\n\n/**\n * Returns `true` if the given payload is a JSON RPC v2 payload.\n *\n * This means, the payload is an object such that:\n *\n * - It has a `jsonrpc` property with a value of `'2.0'`.\n * - It has a `method` property that is a string.\n * - It has a `params` property of any type.\n *\n * @example\n * ```ts\n * import { isJsonRpcPayload } from '@solana/rpc-spec';\n *\n * if (isJsonRpcPayload(payload)) {\n *     const payloadMethod: string = payload.method;\n *     const payloadParams: unknown = payload.params;\n * }\n * ```\n */\nexport function isJsonRpcPayload(payload: unknown): payload is Readonly<{\n    jsonrpc: '2.0';\n    method: string;\n    params: unknown;\n}> {\n    if (payload == null || typeof payload !== 'object' || Array.isArray(payload)) {\n        return false;\n    }\n    return (\n        'jsonrpc' in payload &&\n        payload.jsonrpc === '2.0' &&\n        'method' in payload &&\n        typeof payload.method === 'string' &&\n        'params' in payload\n    );\n}\n", "export function downcastNodeToNumberIfBigint(value: bigint): number;\nexport function downcastNodeToNumberIfBigint<T>(value: T): T;\nexport function downcastNodeToNumberIfBigint(value: unknown): unknown {\n    return typeof value === 'bigint'\n        ? // FIXME(solana-labs/solana/issues/30341) Create a data type to represent u64 in the Solana\n          // JSON RPC implementation so that we can throw away this entire patcher instead of unsafely\n          // downcasting `bigints` to `numbers`.\n          Number(value)\n        : value;\n}\n", "import { RpcRequest, RpcRequestTransformer, RpcResponseTransformer } from '@solana/rpc-spec-types';\n\nexport type KeyPathWildcard = { readonly ['__keyPathWildcard:@solana/kit']: unique symbol };\nexport type KeyPath = ReadonlyArray<KeyPath | KeyPathWildcard | number | string>;\n\nexport const KEYPATH_WILDCARD = {} as KeyPathWildcard;\n\ntype NodeVisitor = <TState extends TraversalState>(value: unknown, state: TState) => unknown;\nexport type TraversalState = Readonly<{\n    keyPath: KeyPath;\n}>;\n\nfunction getTreeWalker(visitors: NodeVisitor[]) {\n    return function traverse<TState extends TraversalState>(node: unknown, state: TState): unknown {\n        if (Array.isArray(node)) {\n            return node.map((element, ii) => {\n                const nextState = {\n                    ...state,\n                    keyPath: [...state.keyPath, ii],\n                };\n                return traverse(element, nextState);\n            });\n        } else if (typeof node === 'object' && node !== null) {\n            const out: Record<number | string | symbol, unknown> = {};\n            for (const propName in node) {\n                if (!Object.prototype.hasOwnProperty.call(node, propName)) {\n                    continue;\n                }\n                const nextState = {\n                    ...state,\n                    keyPath: [...state.keyPath, propName],\n                };\n                out[propName] = traverse(node[propName as keyof typeof node], nextState);\n            }\n            return out;\n        } else {\n            return visitors.reduce((acc, visitNode) => visitNode(acc, state), node);\n        }\n    };\n}\n\n/**\n * Creates a transformer that traverses the request parameters and executes the provided visitors at\n * each node. A custom initial state can be provided but must at least provide `{ keyPath: [] }`.\n *\n * @example\n * ```ts\n * import { getTreeWalkerRequestTransformer } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getTreeWalkerRequestTransformer(\n *     [\n *         // Replaces foo.bar with \"baz\".\n *         (node, state) => (state.keyPath === ['foo', 'bar'] ? 'baz' : node),\n *         // Increments all numbers by 1.\n *         node => (typeof node === number ? node + 1 : node),\n *     ],\n *     { keyPath: [] },\n * );\n * ```\n */\nexport function getTreeWalkerRequestTransformer<TState extends TraversalState>(\n    visitors: NodeVisitor[],\n    initialState: TState,\n): RpcRequestTransformer {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const traverse = getTreeWalker(visitors);\n        return Object.freeze({\n            ...request,\n            params: traverse(request.params, initialState),\n        });\n    };\n}\n\nexport function getTreeWalkerResponseTransformer<TState extends TraversalState>(\n    visitors: NodeVisitor[],\n    initialState: TState,\n): RpcResponseTransformer {\n    return json => getTreeWalker(visitors)(json, initialState);\n}\n", "import { downcastNodeToNumberIfBigint } from './request-transformer-bigint-downcast-internal';\nimport { getTreeWalkerRequestTransformer } from './tree-traversal';\n\n/**\n * Creates a transformer that downcasts all `BigInt` values to `Number`.\n *\n * @example\n * ```ts\n * import { getBigIntDowncastRequestTransformer } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getBigIntDowncastRequestTransformer();\n * ```\n *\n */\nexport function getBigIntDowncastRequestTransformer() {\n    return getTreeWalkerRequestTransformer([downcastNodeToNumberIfBigint], { keyPath: [] });\n}\n", "import { Commitment } from '@solana/rpc-types';\n\nexport function applyDefaultCommitment({\n    commitmentPropertyName,\n    params,\n    optionsObjectPositionInParams,\n    overrideCommitment,\n}: Readonly<{\n    commitmentPropertyName: string;\n    optionsObjectPositionInParams: number;\n    overrideCommitment?: Commitment;\n    params: unknown[];\n}>) {\n    const paramInTargetPosition = params[optionsObjectPositionInParams];\n    if (\n        // There's no config.\n        paramInTargetPosition === undefined ||\n        // There is a config object.\n        (paramInTargetPosition && typeof paramInTargetPosition === 'object' && !Array.isArray(paramInTargetPosition))\n    ) {\n        if (\n            // The config object already has a commitment set.\n            paramInTargetPosition &&\n            commitmentPropertyName in paramInTargetPosition\n        ) {\n            if (\n                !paramInTargetPosition[commitmentPropertyName as keyof typeof paramInTargetPosition] ||\n                paramInTargetPosition[commitmentPropertyName as keyof typeof paramInTargetPosition] === 'finalized'\n            ) {\n                // Delete the commitment property; `finalized` is already the server default.\n                const nextParams = [...params];\n                const {\n                    [commitmentPropertyName as keyof typeof paramInTargetPosition]: _, // eslint-disable-line @typescript-eslint/no-unused-vars\n                    ...rest\n                } = paramInTargetPosition;\n                if (Object.keys(rest).length > 0) {\n                    nextParams[optionsObjectPositionInParams] = rest;\n                } else {\n                    if (optionsObjectPositionInParams === nextParams.length - 1) {\n                        nextParams.length--;\n                    } else {\n                        nextParams[optionsObjectPositionInParams] = undefined;\n                    }\n                }\n                return nextParams;\n            }\n        } else if (overrideCommitment !== 'finalized') {\n            // Apply the default commitment.\n            const nextParams = [...params];\n            nextParams[optionsObjectPositionInParams] = {\n                ...paramInTargetPosition,\n                [commitmentPropertyName]: overrideCommitment,\n            };\n            return nextParams;\n        }\n    }\n    return params;\n}\n", "import type { RpcRequest, RpcRequestTransformer } from '@solana/rpc-spec-types';\nimport type { Commitment } from '@solana/rpc-types';\n\nimport { applyDefaultCommitment } from './request-transformer-default-commitment-internal';\n\n/**\n * Creates a transformer that adds the provided default commitment to the configuration object of the request when applicable.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { getDefaultCommitmentRequestTransformer, OPTIONS_OBJECT_POSITION_BY_METHOD } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getDefaultCommitmentRequestTransformer({\n *     defaultCommitment: 'confirmed',\n *     optionsObjectPositionByMethod: OPTIONS_OBJECT_POSITION_BY_METHOD,\n * });\n */\nexport function getDefaultCommitmentRequestTransformer({\n    defaultCommitment,\n    optionsObjectPositionByMethod,\n}: Readonly<{\n    defaultCommitment?: Commitment;\n    optionsObjectPositionByMethod: Record<string, number>;\n}>): RpcRequestTransformer {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const { params, methodName } = request;\n\n        // We only apply default commitment to array parameters.\n        if (!Array.isArray(params)) {\n            return request;\n        }\n\n        // Find the position of the options object in the parameters and abort if not found.\n        const optionsObjectPositionInParams = optionsObjectPositionByMethod[methodName];\n        if (optionsObjectPositionInParams == null) {\n            return request;\n        }\n\n        return Object.freeze({\n            methodName,\n            params: applyDefaultCommitment({\n                commitmentPropertyName: methodName === 'sendTransaction' ? 'preflightCommitment' : 'commitment',\n                optionsObjectPositionInParams,\n                overrideCommitment: defaultCommitment,\n                params,\n            }),\n        });\n    };\n}\n", "import { KeyPath, TraversalState } from './tree-traversal';\n\nexport function getIntegerOverflowNodeVisitor(onIntegerOverflow: (keyPath: KeyPath, value: bigint) => void) {\n    return <T>(value: T, { keyPath }: TraversalState): T => {\n        if (typeof value === 'bigint') {\n            if (onIntegerOverflow && (value > Number.MAX_SAFE_INTEGER || value < -Number.MAX_SAFE_INTEGER)) {\n                onIntegerOverflow(keyPath as (number | string)[], value);\n            }\n        }\n        return value;\n    };\n}\n", "import { RpcRequest } from '@solana/rpc-spec-types';\n\nimport { getIntegerOverflowNodeVisitor } from './request-transformer-integer-overflow-internal';\nimport { getTreeWalkerRequestTransformer, KeyPath } from './tree-traversal';\n\nexport type IntegerOverflowHandler = (request: RpcRequest, keyPath: KeyPath, value: bigint) => void;\n\n/**\n * Creates a transformer that traverses the request parameters and executes the provided handler\n * when an integer overflow is detected.\n *\n * @example\n * ```ts\n * import { getIntegerOverflowRequestTransformer } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getIntegerOverflowRequestTransformer((request, keyPath, value) => {\n *     throw new Error(`Integer overflow at ${keyPath.join('.')}: ${value}`);\n * });\n * ```\n */\nexport function getIntegerOverflowRequestTransformer(onIntegerOverflow: IntegerOverflowHandler) {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const transformer = getTreeWalkerRequestTransformer(\n            [getIntegerOverflowNodeVisitor((...args) => onIntegerOverflow(request, ...args))],\n            { keyPath: [] },\n        );\n        return transformer(request);\n    };\n}\n", "export const OPTIONS_OBJECT_POSITION_BY_METHOD: Record<string, number> = {\n    accountNotifications: 1,\n    blockNotifications: 1,\n    getAccountInfo: 1,\n    getBalance: 1,\n    getBlock: 1,\n    getBlockHeight: 0,\n    getBlockProduction: 0,\n    getBlocks: 2,\n    getBlocksWithLimit: 2,\n    getEpochInfo: 0,\n    getFeeForMessage: 1,\n    getInflationGovernor: 0,\n    getInflationReward: 1,\n    getLargestAccounts: 0,\n    getLatestBlockhash: 0,\n    getLeaderSchedule: 1,\n    getMinimumBalanceForRentExemption: 1,\n    getMultipleAccounts: 1,\n    getProgramAccounts: 1,\n    getSignaturesForAddress: 1,\n    getSlot: 0,\n    getSlotLeader: 0,\n    getStakeMinimumDelegation: 0,\n    getSupply: 0,\n    getTokenAccountBalance: 1,\n    getTokenAccountsByDelegate: 2,\n    getTokenAccountsByOwner: 2,\n    getTokenLargestAccounts: 1,\n    getTokenSupply: 1,\n    getTransaction: 1,\n    getTransactionCount: 0,\n    getVoteAccounts: 0,\n    isBlockhashValid: 1,\n    logsNotifications: 1,\n    programNotifications: 1,\n    requestAirdrop: 2,\n    sendTransaction: 1,\n    signatureNotifications: 1,\n    simulateTransaction: 1,\n};\n", "import { pipe } from '@solana/functional';\nimport { RpcRequest, RpcRequestTransformer } from '@solana/rpc-spec-types';\nimport { Commitment } from '@solana/rpc-types';\n\nimport { getBigIntDowncastRequestTransformer } from './request-transformer-bigint-downcast';\nimport { getDefaultCommitmentRequestTransformer } from './request-transformer-default-commitment';\nimport { getIntegerOverflowRequestTransformer, IntegerOverflowHandler } from './request-transformer-integer-overflow';\nimport { OPTIONS_OBJECT_POSITION_BY_METHOD } from './request-transformer-options-object-position-config';\n\nexport type RequestTransformerConfig = Readonly<{\n    /**\n     * An optional {@link Commitment} value to use as the default when none is supplied by the\n     * caller.\n     */\n    defaultCommitment?: Commitment;\n    /**\n     * An optional function that will be called whenever a `bigint` input exceeds that which can be\n     * expressed using JavaScript numbers.\n     *\n     * This is used in the default {@link SolanaRpcSubscriptionsApi} to throw an exception rather\n     * than to allow truncated values to propagate through a program.\n     */\n    onIntegerOverflow?: IntegerOverflowHandler;\n}>;\n\n/**\n * Returns the default request transformer for the Solana RPC API.\n *\n * Under the hood, this function composes multiple\n * {@link RpcRequestTransformer | RpcRequestTransformers} together such as the\n * {@link getDefaultCommitmentTransformer}, the {@link getIntegerOverflowRequestTransformer} and the\n * {@link getBigIntDowncastRequestTransformer}.\n *\n * @example\n * ```ts\n * import { getDefaultRequestTransformerForSolanaRpc } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getDefaultRequestTransformerForSolanaRpc({\n *     defaultCommitment: 'confirmed',\n *     onIntegerOverflow: (request, keyPath, value) => {\n *         throw new Error(`Integer overflow at ${keyPath.join('.')}: ${value}`);\n *     },\n * });\n * ```\n */\nexport function getDefaultRequestTransformerForSolanaRpc(config?: RequestTransformerConfig): RpcRequestTransformer {\n    const handleIntegerOverflow = config?.onIntegerOverflow;\n    return (request: RpcRequest): RpcRequest => {\n        return pipe(\n            request,\n            handleIntegerOverflow ? getIntegerOverflowRequestTransformer(handleIntegerOverflow) : r => r,\n            getBigIntDowncastRequestTransformer(),\n            getDefaultCommitmentRequestTransformer({\n                defaultCommitment: config?.defaultCommitment,\n                optionsObjectPositionByMethod: OPTIONS_OBJECT_POSITION_BY_METHOD,\n            }),\n        );\n    };\n}\n", "import { KeyPath, KEYPATH_WILDCARD, TraversalState } from './tree-traversal';\n\nexport function getBigIntUpcastVisitor(allowedNumericKeyPaths: readonly KeyPath[]) {\n    return function upcastNodeToBigIntIfNumber(value: unknown, { keyPath }: TraversalState) {\n        const isInteger = (typeof value === 'number' && Number.isInteger(value)) || typeof value === 'bigint';\n        if (!isInteger) return value;\n        if (keyPathIsAllowedToBeNumeric(keyPath, allowedNumericKeyPaths)) {\n            return Number(value);\n        } else {\n            return BigInt(value);\n        }\n    };\n}\n\nfunction keyPathIsAllowedToBeNumeric(keyPath: KeyPath, allowedNumericKeyPaths: readonly KeyPath[]) {\n    return allowedNumericKeyPaths.some(prohibitedKeyPath => {\n        if (prohibitedKeyPath.length !== keyPath.length) {\n            return false;\n        }\n        for (let ii = keyPath.length - 1; ii >= 0; ii--) {\n            const keyPathPart = keyPath[ii];\n            const prohibitedKeyPathPart = prohibitedKeyPath[ii];\n            if (\n                prohibitedKeyPathPart !== keyPathPart &&\n                (prohibitedKeyPathPart !== KEYPATH_WILDCARD || typeof keyPathPart !== 'number')\n            ) {\n                return false;\n            }\n        }\n        return true;\n    });\n}\n", "import { getBigIntUpcastVisitor } from './response-transformer-bigint-upcast-internal';\nimport { getTreeWalkerResponseTransformer, KeyPath } from './tree-traversal';\n\n/**\n * Returns a transformer that upcasts all `Number` values to `BigInts` unless they match within the\n * provided {@link KeyPath | KeyPaths}. In other words, the provided {@link KeyPath | KeyPaths} will\n * remain as `Number` values, any other numeric value will be upcasted to a `BigInt`.\n *\n * Note that you can use {@link KEYPATH_WILDCARD} to match any key within a {@link KeyPath}.\n *\n * @example\n * ```ts\n * import { getBigIntUpcastResponseTransformer } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getBigIntUpcastResponseTransformer([\n *     ['index'],\n *     ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n *     ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n *     ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n * ]);\n * ```\n */\nexport function getBigIntUpcastResponseTransformer(allowedNumericKeyPaths: readonly KeyPath[]) {\n    return getTreeWalkerResponseTransformer([getBigIntUpcastVisitor(allowedNumericKeyPaths)], { keyPath: [] });\n}\n", "import { RpcResponseTransformer } from '@solana/rpc-spec-types';\n\ntype JsonRpcResponse = { result: unknown };\n\n/**\n * Returns a transformer that extracts the `result` field from the body of the RPC response.\n *\n * For instance, we go from `{ jsonrpc: '2.0', result: 'foo', id: 1 }` to `'foo'`.\n *\n * @example\n * ```ts\n * import { getResultResponseTransformer } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getResultResponseTransformer();\n * ```\n */\nexport function getResultResponseTransformer(): RpcResponseTransformer {\n    return json => (json as JsonRpcResponse).result;\n}\n", "import { getSolanaErrorFromJsonRpcError } from '@solana/errors';\nimport { RpcResponseTransformer } from '@solana/rpc-spec-types';\n\ntype JsonRpcResponse = { error: Parameters<typeof getSolanaErrorFromJsonRpcError>[0] } | { result: unknown };\n\n/**\n * Returns a transformer that throws a {@link SolanaError} with the appropriate RPC error code if\n * the body of the RPC response contains an error.\n *\n * @example\n * ```ts\n * import { getThrowSolanaErrorResponseTransformer } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getThrowSolanaErrorResponseTransformer();\n * ```\n */\nexport function getThrowSolanaErrorResponseTransformer(): RpcResponseTransformer {\n    return json => {\n        const jsonRpcResponse = json as JsonRpcResponse;\n        if ('error' in jsonRpcResponse) {\n            throw getSolanaErrorFromJsonRpcError(jsonRpcResponse.error);\n        }\n        return jsonRpcResponse;\n    };\n}\n", "import { pipe } from '@solana/functional';\nimport { RpcRequest, RpcResponse, RpcResponseTransformer } from '@solana/rpc-spec-types';\n\nimport { AllowedNumericKeypaths } from './response-transformer-allowed-numeric-values';\nimport { getBigIntUpcastResponseTransformer } from './response-transformer-bigint-upcast';\nimport { getResultResponseTransformer } from './response-transformer-result';\nimport { getThrowSolanaErrorResponseTransformer } from './response-transformer-throw-solana-error';\n\nexport type ResponseTransformerConfig<TApi> = Readonly<{\n    /**\n     * An optional map from the name of an API method to an array of {@link KeyPath | KeyPaths}\n     * pointing to values in the response that should materialize in the application as `Number`\n     * instead of `BigInt`.\n     */\n    allowedNumericKeyPaths?: AllowedNumericKeypaths<TApi>;\n}>;\n\n/**\n * Returns the default response transformer for the Solana RPC API.\n *\n * Under the hood, this function composes multiple\n * {@link RpcResponseTransformer | RpcResponseTransformers} together such as the\n * {@link getThrowSolanaErrorResponseTransformer}, the {@link getResultResponseTransformer} and the\n * {@link getBigIntUpcastResponseTransformer}.\n *\n * @example\n * ```ts\n * import { getDefaultResponseTransformerForSolanaRpc } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getDefaultResponseTransformerForSolanaRpc({\n *     allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n * });\n * ```\n */\nexport function getDefaultResponseTransformerForSolanaRpc<TApi>(\n    config?: ResponseTransformerConfig<TApi>,\n): RpcResponseTransformer {\n    return (response: RpcResponse, request: RpcRequest): RpcResponse => {\n        const methodName = request.methodName as keyof TApi;\n        const keyPaths =\n            config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : undefined;\n        return pipe(\n            response,\n            r => getThrowSolanaErrorResponseTransformer()(r, request),\n            r => getResultResponseTransformer()(r, request),\n            r => getBigIntUpcastResponseTransformer(keyPaths ?? [])(r, request),\n        );\n    };\n}\n\n/**\n * Returns the default response transformer for the Solana RPC Subscriptions API.\n *\n * Under the hood, this function composes the {@link getBigIntUpcastResponseTransformer}.\n *\n * @example\n * ```ts\n * import { getDefaultResponseTransformerForSolanaRpcSubscriptions } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getDefaultResponseTransformerForSolanaRpcSubscriptions({\n *     allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n * });\n * ```\n */\nexport function getDefaultResponseTransformerForSolanaRpcSubscriptions<TApi>(\n    config?: ResponseTransformerConfig<TApi>,\n): RpcResponseTransformer {\n    return (response: RpcResponse, request: RpcRequest): RpcResponse => {\n        const methodName = request.methodName as keyof TApi;\n        const keyPaths =\n            config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : undefined;\n        return pipe(response, r => getBigIntUpcastResponseTransformer(keyPaths ?? [])(r, request));\n    };\n}\n", "import { KeyPath, KEYPATH_WILDCARD } from './tree-traversal';\n\nexport type AllowedNumericKeypaths<TApi> = Partial<Record<keyof TApi, readonly KeyPath[]>>;\n\n// Numeric values nested in `jsonParsed` accounts\nexport const jsonParsedTokenAccountsConfigs = [\n    // parsed Token/Token22 token account\n    ['data', 'parsed', 'info', 'tokenAmount', 'decimals'],\n    ['data', 'parsed', 'info', 'tokenAmount', 'uiAmount'],\n    ['data', 'parsed', 'info', 'rentExemptReserve', 'decimals'],\n    ['data', 'parsed', 'info', 'rentExemptReserve', 'uiAmount'],\n    ['data', 'parsed', 'info', 'delegatedAmount', 'decimals'],\n    ['data', 'parsed', 'info', 'delegatedAmount', 'uiAmount'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'olderTransferFee', 'transferFeeBasisPoints'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'newerTransferFee', 'transferFeeBasisPoints'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'preUpdateAverageRate'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'currentRate'],\n];\nexport const jsonParsedAccountsConfigs = [\n    ...jsonParsedTokenAccountsConfigs,\n    // parsed AddressTableLookup account\n    ['data', 'parsed', 'info', 'lastExtendedSlotStartIndex'],\n    // parsed Config account\n    ['data', 'parsed', 'info', 'slashPenalty'],\n    ['data', 'parsed', 'info', 'warmupCooldownRate'],\n    // parsed Token/Token22 mint account\n    ['data', 'parsed', 'info', 'decimals'],\n    // parsed Token/Token22 multisig account\n    ['data', 'parsed', 'info', 'numRequiredSigners'],\n    ['data', 'parsed', 'info', 'numValidSigners'],\n    // parsed Stake account\n    ['data', 'parsed', 'info', 'stake', 'delegation', 'warmupCooldownRate'],\n    // parsed Sysvar rent account\n    ['data', 'parsed', 'info', 'exemptionThreshold'],\n    ['data', 'parsed', 'info', 'burnPercent'],\n    // parsed Vote account\n    ['data', 'parsed', 'info', 'commission'],\n    ['data', 'parsed', 'info', 'votes', KEYPATH_WILDCARD, 'confirmationCount'],\n];\nexport const innerInstructionsConfigs = [\n    ['index'],\n    ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n    ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n    ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n];\nexport const messageConfig = [\n    ['addressTableLookups', KEYPATH_WILDCARD, 'writableIndexes', KEYPATH_WILDCARD],\n    ['addressTableLookups', KEYPATH_WILDCARD, 'readonlyIndexes', KEYPATH_WILDCARD],\n    ['header', 'numReadonlySignedAccounts'],\n    ['header', 'numReadonlyUnsignedAccounts'],\n    ['header', 'numRequiredSignatures'],\n    ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n    ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n    ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n] as const;\n", "/**\n * This package contains types that describe the [methods](https://solana.com/docs/rpc/http) of the\n * Solana JSON RPC API, and utilities for creating a {@link RpcApi} implementation with sensible\n * defaults. It can be used standalone, but it is also exported as part of Kit\n * [`@solana/kit`](https://github.com/anza-xyz/kit/tree/main/packages/kit).\n *\n * @example\n * Each RPC method is described in terms of a TypeScript type of the following form:\n *\n * ```ts\n * type ExampleApi = {\n *     getSomething(address: Address): Something;\n * };\n * ```\n *\n * A {@link RpcApi} that implements `ExampleApi` will ultimately expose its defined methods on any\n * {@link Rpc} that uses it.\n *\n * ```ts\n * const rpc: Rpc<ExampleApi> = createExampleRpc(/* ... *\\/);\n * const something: Something = await rpc.getSomething(address('95DpK3y3GF7U8s1k4EvZ7xqyeCkhsHeZaE97iZpHUGMN')).send();\n * ```\n *\n * @packageDocumentation\n */\nimport { createJsonRpcApi, RpcApi } from '@solana/rpc-spec';\nimport {\n    AllowedNumericKeypaths,\n    getDefaultRequestTransformerForSolanaRpc,\n    getDefaultResponseTransformerForSolanaRpc,\n    innerInstructionsConfigs,\n    jsonParsedAccountsConfigs,\n    jsonParsedTokenAccountsConfigs,\n    KEYPATH_WILDCARD,\n    messageConfig,\n    RequestTransformerConfig,\n} from '@solana/rpc-transformers';\n\nimport { GetAccountInfoApi } from './getAccountInfo';\nimport { GetBalanceApi } from './getBalance';\nimport { GetBlockApi } from './getBlock';\nimport { GetBlockCommitmentApi } from './getBlockCommitment';\nimport { GetBlockHeightApi } from './getBlockHeight';\nimport { GetBlockProductionApi } from './getBlockProduction';\nimport { GetBlocksApi } from './getBlocks';\nimport { GetBlocksWithLimitApi } from './getBlocksWithLimit';\nimport { GetBlockTimeApi } from './getBlockTime';\nimport { GetClusterNodesApi } from './getClusterNodes';\nimport { GetEpochInfoApi } from './getEpochInfo';\nimport { GetEpochScheduleApi } from './getEpochSchedule';\nimport { GetFeeForMessageApi } from './getFeeForMessage';\nimport { GetFirstAvailableBlockApi } from './getFirstAvailableBlock';\nimport { GetGenesisHashApi } from './getGenesisHash';\nimport { GetHealthApi } from './getHealth';\nimport { GetHighestSnapshotSlotApi } from './getHighestSnapshotSlot';\nimport { GetIdentityApi } from './getIdentity';\nimport { GetInflationGovernorApi } from './getInflationGovernor';\nimport { GetInflationRateApi } from './getInflationRate';\nimport { GetInflationRewardApi } from './getInflationReward';\nimport { GetLargestAccountsApi } from './getLargestAccounts';\nimport { GetLatestBlockhashApi } from './getLatestBlockhash';\nimport { GetLeaderScheduleApi } from './getLeaderSchedule';\nimport { GetMaxRetransmitSlotApi } from './getMaxRetransmitSlot';\nimport { GetMaxShredInsertSlotApi } from './getMaxShredInsertSlot';\nimport { GetMinimumBalanceForRentExemptionApi } from './getMinimumBalanceForRentExemption';\nimport { GetMultipleAccountsApi } from './getMultipleAccounts';\nimport { GetProgramAccountsApi } from './getProgramAccounts';\nimport { GetRecentPerformanceSamplesApi } from './getRecentPerformanceSamples';\nimport { GetRecentPrioritizationFeesApi } from './getRecentPrioritizationFees';\nimport { GetSignaturesForAddressApi } from './getSignaturesForAddress';\nimport { GetSignatureStatusesApi } from './getSignatureStatuses';\nimport { GetSlotApi } from './getSlot';\nimport { GetSlotLeaderApi } from './getSlotLeader';\nimport { GetSlotLeadersApi } from './getSlotLeaders';\nimport { GetStakeMinimumDelegationApi } from './getStakeMinimumDelegation';\nimport { GetSupplyApi } from './getSupply';\nimport { GetTokenAccountBalanceApi } from './getTokenAccountBalance';\nimport { GetTokenAccountsByDelegateApi } from './getTokenAccountsByDelegate';\nimport { GetTokenAccountsByOwnerApi } from './getTokenAccountsByOwner';\nimport { GetTokenLargestAccountsApi } from './getTokenLargestAccounts';\nimport { GetTokenSupplyApi } from './getTokenSupply';\nimport { GetTransactionApi } from './getTransaction';\nimport { GetTransactionCountApi } from './getTransactionCount';\nimport { GetVersionApi } from './getVersion';\nimport { GetVoteAccountsApi } from './getVoteAccounts';\nimport { IsBlockhashValidApi } from './isBlockhashValid';\nimport { MinimumLedgerSlotApi } from './minimumLedgerSlot';\nimport { RequestAirdropApi } from './requestAirdrop';\nimport { SendTransactionApi } from './sendTransaction';\nimport { SimulateTransactionApi } from './simulateTransaction';\n\ntype SolanaRpcApiForAllClusters = GetAccountInfoApi &\n    GetBalanceApi &\n    GetBlockApi &\n    GetBlockCommitmentApi &\n    GetBlockHeightApi &\n    GetBlockProductionApi &\n    GetBlocksApi &\n    GetBlocksWithLimitApi &\n    GetBlockTimeApi &\n    GetClusterNodesApi &\n    GetEpochInfoApi &\n    GetEpochScheduleApi &\n    GetFeeForMessageApi &\n    GetFirstAvailableBlockApi &\n    GetGenesisHashApi &\n    GetHealthApi &\n    GetHighestSnapshotSlotApi &\n    GetIdentityApi &\n    GetInflationGovernorApi &\n    GetInflationRateApi &\n    GetInflationRewardApi &\n    GetLargestAccountsApi &\n    GetLatestBlockhashApi &\n    GetLeaderScheduleApi &\n    GetMaxRetransmitSlotApi &\n    GetMaxShredInsertSlotApi &\n    GetMinimumBalanceForRentExemptionApi &\n    GetMultipleAccountsApi &\n    GetProgramAccountsApi &\n    GetRecentPerformanceSamplesApi &\n    GetRecentPrioritizationFeesApi &\n    GetSignaturesForAddressApi &\n    GetSignatureStatusesApi &\n    GetSlotApi &\n    GetSlotLeaderApi &\n    GetSlotLeadersApi &\n    GetStakeMinimumDelegationApi &\n    GetSupplyApi &\n    GetTokenAccountBalanceApi &\n    GetTokenAccountsByDelegateApi &\n    GetTokenAccountsByOwnerApi &\n    GetTokenLargestAccountsApi &\n    GetTokenSupplyApi &\n    GetTransactionApi &\n    GetTransactionCountApi &\n    GetVersionApi &\n    GetVoteAccountsApi &\n    IsBlockhashValidApi &\n    MinimumLedgerSlotApi &\n    SendTransactionApi &\n    SimulateTransactionApi;\ntype SolanaRpcApiForTestClusters = RequestAirdropApi & SolanaRpcApiForAllClusters;\n/**\n * Represents the RPC methods available on test clusters.\n *\n * For instance, the test clusters support the {@link RequestAirdropApi} while mainnet does not.\n */\nexport type SolanaRpcApi = SolanaRpcApiForTestClusters;\n/**\n * Represents the RPC methods available on the devnet cluster.\n *\n * For instance, the devnet cluster supports the {@link RequestAirdropApi} while mainnet does not.\n */\nexport type SolanaRpcApiDevnet = SolanaRpcApiForTestClusters;\n/**\n * Represents the RPC methods available on the testnet cluster.\n *\n * For instance, the testnet cluster supports the {@link RequestAirdropApi} while mainnet does not.\n */\nexport type SolanaRpcApiTestnet = SolanaRpcApiForTestClusters;\n/**\n * Represents the RPC methods available on the mainnet cluster.\n *\n * For instance, the mainnet cluster does not support the {@link RequestAirdropApi} whereas test\n * clusters do.\n */\nexport type SolanaRpcApiMainnet = SolanaRpcApiForAllClusters;\n\nexport type {\n    GetAccountInfoApi,\n    GetBalanceApi,\n    GetBlockApi,\n    GetBlockCommitmentApi,\n    GetBlockHeightApi,\n    GetBlockProductionApi,\n    GetBlocksApi,\n    GetBlocksWithLimitApi,\n    GetBlockTimeApi,\n    GetClusterNodesApi,\n    GetEpochInfoApi,\n    GetEpochScheduleApi,\n    GetFeeForMessageApi,\n    GetFirstAvailableBlockApi,\n    GetGenesisHashApi,\n    GetHealthApi,\n    GetHighestSnapshotSlotApi,\n    GetIdentityApi,\n    GetInflationGovernorApi,\n    GetInflationRateApi,\n    GetInflationRewardApi,\n    GetLargestAccountsApi,\n    GetLatestBlockhashApi,\n    GetLeaderScheduleApi,\n    GetMaxRetransmitSlotApi,\n    GetMaxShredInsertSlotApi,\n    GetMinimumBalanceForRentExemptionApi,\n    GetMultipleAccountsApi,\n    GetProgramAccountsApi,\n    GetRecentPerformanceSamplesApi,\n    GetRecentPrioritizationFeesApi,\n    GetSignaturesForAddressApi,\n    GetSignatureStatusesApi,\n    GetSlotApi,\n    GetSlotLeaderApi,\n    GetSlotLeadersApi,\n    GetStakeMinimumDelegationApi,\n    GetSupplyApi,\n    GetTokenAccountBalanceApi,\n    GetTokenAccountsByDelegateApi,\n    GetTokenAccountsByOwnerApi,\n    GetTokenLargestAccountsApi,\n    GetTokenSupplyApi,\n    GetTransactionApi,\n    GetTransactionCountApi,\n    GetVersionApi,\n    GetVoteAccountsApi,\n    IsBlockhashValidApi,\n    MinimumLedgerSlotApi,\n    RequestAirdropApi,\n    SendTransactionApi,\n    SimulateTransactionApi,\n};\n\ntype Config = RequestTransformerConfig;\n\n/**\n * Creates a {@link RpcApi} implementation of the Solana JSON RPC API with some default behaviours.\n *\n * The default behaviours include:\n * - A transform that converts `bigint` inputs to `number` for compatibility with version 1.0 of the\n *   Solana JSON RPC.\n * - A transform that calls the config's {@link Config.onIntegerOverflow | onIntegerOverflow}\n *   handler whenever a `bigint` input would overflow a JavaScript IEEE 754 number. See\n *   [this](https://github.com/solana-labs/solana-web3.js/issues/1116) GitHub issue for more\n *   information.\n * - A transform that applies a default commitment wherever not specified\n */\nexport function createSolanaRpcApi<\n    // eslint-disable-next-line @typescript-eslint/no-duplicate-type-constituents\n    TRpcMethods extends SolanaRpcApi | SolanaRpcApiDevnet | SolanaRpcApiMainnet | SolanaRpcApiTestnet = SolanaRpcApi,\n>(config?: Config): RpcApi<TRpcMethods> {\n    return createJsonRpcApi<TRpcMethods>({\n        requestTransformer: getDefaultRequestTransformerForSolanaRpc(config),\n        responseTransformer: getDefaultResponseTransformerForSolanaRpc({\n            allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n        }),\n    });\n}\n\nlet memoizedKeypaths: AllowedNumericKeypaths<RpcApi<SolanaRpcApi>>;\n\n/**\n * These are keypaths at the end of which you will find a numeric value that should *not* be upcast\n * to a `bigint`. These are values that are legitimately defined as `u8` or `usize` on the backend.\n */\nfunction getAllowedNumericKeypaths(): AllowedNumericKeypaths<RpcApi<SolanaRpcApi>> {\n    if (!memoizedKeypaths) {\n        memoizedKeypaths = {\n            getAccountInfo: jsonParsedAccountsConfigs.map(c => ['value', ...c]),\n            getBlock: [\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'preTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'preTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'postTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'postTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                ...innerInstructionsConfigs.map(c => [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    ...c,\n                ]),\n                ...messageConfig.map(c => ['transactions', KEYPATH_WILDCARD, 'transaction', 'message', ...c] as const),\n                ['rewards', KEYPATH_WILDCARD, 'commission'],\n            ],\n            getClusterNodes: [\n                [KEYPATH_WILDCARD, 'featureSet'],\n                [KEYPATH_WILDCARD, 'shredVersion'],\n            ],\n            getInflationGovernor: [['initial'], ['foundation'], ['foundationTerm'], ['taper'], ['terminal']],\n            getInflationRate: [['foundation'], ['total'], ['validator']],\n            getInflationReward: [[KEYPATH_WILDCARD, 'commission']],\n            getMultipleAccounts: jsonParsedAccountsConfigs.map(c => ['value', KEYPATH_WILDCARD, ...c]),\n            getProgramAccounts: jsonParsedAccountsConfigs.flatMap(c => [\n                ['value', KEYPATH_WILDCARD, 'account', ...c],\n                [KEYPATH_WILDCARD, 'account', ...c],\n            ]),\n            getRecentPerformanceSamples: [[KEYPATH_WILDCARD, 'samplePeriodSecs']],\n            getTokenAccountBalance: [\n                ['value', 'decimals'],\n                ['value', 'uiAmount'],\n            ],\n            getTokenAccountsByDelegate: jsonParsedTokenAccountsConfigs.map(c => [\n                'value',\n                KEYPATH_WILDCARD,\n                'account',\n                ...c,\n            ]),\n            getTokenAccountsByOwner: jsonParsedTokenAccountsConfigs.map(c => [\n                'value',\n                KEYPATH_WILDCARD,\n                'account',\n                ...c,\n            ]),\n            getTokenLargestAccounts: [\n                ['value', KEYPATH_WILDCARD, 'decimals'],\n                ['value', KEYPATH_WILDCARD, 'uiAmount'],\n            ],\n            getTokenSupply: [\n                ['value', 'decimals'],\n                ['value', 'uiAmount'],\n            ],\n            getTransaction: [\n                ['meta', 'preTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                ['meta', 'preTokenBalances', KEYPATH_WILDCARD, 'uiTokenAmount', 'decimals'],\n                ['meta', 'postTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                ['meta', 'postTokenBalances', KEYPATH_WILDCARD, 'uiTokenAmount', 'decimals'],\n                ['meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                ...innerInstructionsConfigs.map(c => ['meta', 'innerInstructions', KEYPATH_WILDCARD, ...c]),\n                ...messageConfig.map(c => ['transaction', 'message', ...c] as const),\n            ],\n            getVersion: [['feature-set']],\n            getVoteAccounts: [\n                ['current', KEYPATH_WILDCARD, 'commission'],\n                ['delinquent', KEYPATH_WILDCARD, 'commission'],\n            ],\n            simulateTransaction: [\n                ...jsonParsedAccountsConfigs.map(c => ['value', 'accounts', KEYPATH_WILDCARD, ...c]),\n                ...innerInstructionsConfigs.map(c => ['value', 'innerInstructions', KEYPATH_WILDCARD, ...c]),\n            ],\n        };\n    }\n    return memoizedKeypaths;\n}\n", "import { SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, SolanaError } from '@solana/errors';\n\nexport type AllowedHttpRequestHeaders = Readonly<\n    {\n        // Someone can still sneak a forbidden header past Typescript if they do something like\n        // fOo-BaR, but at that point they deserve the runtime failure.\n        [K in DisallowedHeaders | ForbiddenHeaders as\n            | Capitalize<Lowercase<K>> // `Foo-bar`\n            | K // `Foo-Bar`\n            | Lowercase<K> // `foo-bar`\n            | Uncapitalize<K> // `foo-Bar`\n            // `FOO-BAR`\n            | Uppercase<K>]?: never;\n    } & { [headerName: string]: string }\n>;\n// These are headers that we simply don't allow the developer to override because they're\n// fundamental to the operation of the JSON-RPC transport.\ntype DisallowedHeaders = 'Accept' | 'Content-Length' | 'Content-Type' | 'Solana-Client';\ntype ForbiddenHeaders =\n    | 'Accept-Charset'\n    // Though technically forbidden in non-Node environments, we don't have a way to target\n    // TypeScript types depending on which platform you are authoring for. `Accept-Encoding` is\n    // therefore omitted from the forbidden headers type, but is still a runtime error in dev mode\n    // when supplied in a non-Node context.\n    // | 'Accept-Encoding'\n    | 'Access-Control-Request-Headers'\n    | 'Access-Control-Request-Method'\n    | 'Connection'\n    | 'Content-Length'\n    | 'Cookie'\n    | 'Date'\n    | 'DNT'\n    | 'Expect'\n    | 'Host'\n    | 'Keep-Alive'\n    | 'Origin'\n    | 'Permissions-Policy'\n    | 'Referer'\n    | 'TE'\n    | 'Trailer'\n    | 'Transfer-Encoding'\n    | 'Upgrade'\n    | 'Via'\n    | `Proxy-${string}`\n    | `Sec-${string}`;\n\n// These are headers which are fundamental to the JSON-RPC transport, and must not be modified.\nconst DISALLOWED_HEADERS: Record<string, boolean> = {\n    accept: true,\n    'content-length': true,\n    'content-type': true,\n};\n// https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\nconst FORBIDDEN_HEADERS: Record<string, boolean> = /* @__PURE__ */ Object.assign(\n    {\n        'accept-charset': true,\n        'access-control-request-headers': true,\n        'access-control-request-method': true,\n        connection: true,\n        'content-length': true,\n        cookie: true,\n        date: true,\n        dnt: true,\n        expect: true,\n        host: true,\n        'keep-alive': true,\n        origin: true,\n        'permissions-policy': true,\n        // Prefix matching is implemented in code, below.\n        // 'proxy-': true,\n        // 'sec-': true,\n        referer: true,\n        te: true,\n        trailer: true,\n        'transfer-encoding': true,\n        upgrade: true,\n        via: true,\n    },\n    __NODEJS__ ? undefined : { 'accept-encoding': true },\n);\n\nexport function assertIsAllowedHttpRequestHeaders(\n    headers: Record<string, string>,\n): asserts headers is AllowedHttpRequestHeaders {\n    const badHeaders = Object.keys(headers).filter(headerName => {\n        const lowercaseHeaderName = headerName.toLowerCase();\n        return (\n            DISALLOWED_HEADERS[headerName.toLowerCase()] === true ||\n            FORBIDDEN_HEADERS[headerName.toLowerCase()] === true ||\n            lowercaseHeaderName.startsWith('proxy-') ||\n            lowercaseHeaderName.startsWith('sec-')\n        );\n    });\n    if (badHeaders.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, {\n            headers: badHeaders,\n        });\n    }\n}\n\n// Lowercasing header names makes it easier to override user-supplied headers, such as those defined\n// in the `DisallowedHeaders` type.\nexport function normalizeHeaders<T extends Record<string, string>>(\n    headers: T,\n): { [K in string & keyof T as Lowercase<K>]: T[K] } {\n    const out: Record<string, string> = {};\n    for (const headerName in headers) {\n        out[headerName.toLowerCase()] = headers[headerName];\n    }\n    return out as { [K in string & keyof T as Lowercase<K>]: T[K] };\n}\n", "import { SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, SolanaError } from '@solana/errors';\nimport type { RpcTransport } from '@solana/rpc-spec';\nimport type { RpcResponse } from '@solana/rpc-spec-types';\nimport type Dispatcher from 'undici-types/dispatcher';\n\nimport { HttpTransportConfig as Config } from './http-transport-config';\nimport { assertIsAllowedHttpRequestHeaders, normalizeHeaders } from './http-transport-headers';\n\nlet didWarnDispatcherWasSuppliedInNonNodeEnvironment = false;\nfunction warnDispatcherWasSuppliedInNonNodeEnvironment() {\n    if (didWarnDispatcherWasSuppliedInNonNodeEnvironment) {\n        return;\n    }\n    didWarnDispatcherWasSuppliedInNonNodeEnvironment = true;\n    console.warn(\n        'You have supplied a `Dispatcher` to `createHttpTransport()`. It has been ignored ' +\n            'because Undici dispatchers only work in Node environments. To eliminate this ' +\n            'warning, omit the `dispatcher_NODE_ONLY` property from your config when running in ' +\n            'a non-Node environment.',\n    );\n}\n\n/**\n * Creates a function you can use to make `POST` requests with headers suitable for sending JSON\n * data to a server.\n *\n * @example\n * ```ts\n * import { createHttpTransport } from '@solana/rpc-transport-http';\n *\n * const transport = createHttpTransport({ url: 'https://api.mainnet-beta.solana.com' });\n * const response = await transport({\n *     payload: { id: 1, jsonrpc: '2.0', method: 'getSlot' },\n * });\n * const data = await response.json();\n * ```\n */\nexport function createHttpTransport(config: Config): RpcTransport {\n    if (process.env.NODE_ENV !== \"production\" && !__NODEJS__ && 'dispatcher_NODE_ONLY' in config) {\n        warnDispatcherWasSuppliedInNonNodeEnvironment();\n    }\n    const { fromJson, headers, toJson, url } = config;\n    if (process.env.NODE_ENV !== \"production\" && headers) {\n        assertIsAllowedHttpRequestHeaders(headers);\n    }\n    let dispatcherConfig: { dispatcher: Dispatcher | undefined } | undefined;\n    if (__NODEJS__ && 'dispatcher_NODE_ONLY' in config) {\n        dispatcherConfig = { dispatcher: config.dispatcher_NODE_ONLY };\n    }\n    const customHeaders = headers && normalizeHeaders(headers);\n    return async function makeHttpRequest<TResponse>({\n        payload,\n        signal,\n    }: Parameters<RpcTransport>[0]): Promise<RpcResponse<TResponse>> {\n        const body = toJson ? toJson(payload) : JSON.stringify(payload);\n        const requestInfo = {\n            ...dispatcherConfig,\n            body,\n            headers: {\n                ...customHeaders,\n                // Keep these headers lowercase so they will override any user-supplied headers above.\n                accept: 'application/json',\n                'content-length': body.length.toString(),\n                'content-type': 'application/json; charset=utf-8',\n            },\n            method: 'POST',\n            signal,\n        };\n        const response = await fetch(url, requestInfo);\n        if (!response.ok) {\n            throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, {\n                headers: response.headers,\n                message: response.statusText,\n                statusCode: response.status,\n            });\n        }\n        if (fromJson) {\n            return fromJson(await response.text(), payload) as TResponse;\n        }\n        return await response.json();\n    };\n}\n", "import { isJsonRpcPayload } from '@solana/rpc-spec';\n\nconst SOLANA_RPC_METHODS = [\n    'getAccountInfo',\n    'getBalance',\n    'getBlock',\n    'getBlockCommitment',\n    'getBlockHeight',\n    'getBlockProduction',\n    'getBlocks',\n    'getBlocksWithLimit',\n    'getBlockTime',\n    'getClusterNodes',\n    'getEpochInfo',\n    'getEpochSchedule',\n    'getFeeForMessage',\n    'getFirstAvailableBlock',\n    'getGenesisHash',\n    'getHealth',\n    'getHighestSnapshotSlot',\n    'getIdentity',\n    'getInflationGovernor',\n    'getInflationRate',\n    'getInflationReward',\n    'getLargestAccounts',\n    'getLatestBlockhash',\n    'getLeaderSchedule',\n    'getMaxRetransmitSlot',\n    'getMaxShredInsertSlot',\n    'getMinimumBalanceForRentExemption',\n    'getMultipleAccounts',\n    'getProgramAccounts',\n    'getRecentPerformanceSamples',\n    'getRecentPrioritizationFees',\n    'getSignaturesForAddress',\n    'getSignatureStatuses',\n    'getSlot',\n    'getSlotLeader',\n    'getSlotLeaders',\n    'getStakeMinimumDelegation',\n    'getSupply',\n    'getTokenAccountBalance',\n    'getTokenAccountsByDelegate',\n    'getTokenAccountsByOwner',\n    'getTokenLargestAccounts',\n    'getTokenSupply',\n    'getTransaction',\n    'getTransactionCount',\n    'getVersion',\n    'getVoteAccounts',\n    'index',\n    'isBlockhashValid',\n    'minimumLedgerSlot',\n    'requestAirdrop',\n    'sendTransaction',\n    'simulateTransaction',\n] as const;\n\n/**\n * Helper function that checks if a given `RpcRequest` comes from the Solana RPC API.\n */\nexport function isSolanaRequest(payload: unknown): payload is Readonly<{\n    jsonrpc: '2.0';\n    method: (typeof SOLANA_RPC_METHODS)[number];\n    params: unknown;\n}> {\n    return isJsonRpcPayload(payload) && (SOLANA_RPC_METHODS as readonly string[]).includes(payload.method);\n}\n", "import { RpcTransport } from '@solana/rpc-spec';\nimport { parseJsonWithBigInts, stringifyJsonWithBigints } from '@solana/rpc-spec-types';\n\nimport { createHttpTransport } from './http-transport';\nimport { HttpTransportConfig } from './http-transport-config';\nimport { isSolanaRequest } from './is-solana-request';\n\ntype Config = Pick<HttpTransportConfig, 'dispatcher_NODE_ONLY' | 'headers' | 'url'>;\n\n/**\n * Creates a {@link RpcTransport} that uses JSON HTTP requests — much like the\n * {@link createHttpTransport} function - except that it also uses custom `toJson` and `fromJson`\n * functions in order to allow `bigint` values to be serialized and deserialized correctly over the\n * wire.\n *\n * Since this is something specific to the Solana RPC API, these custom JSON functions are only\n * triggered when the request is recognized as a Solana RPC request. Normal RPC APIs should aim to\n * wrap their `bigint` values — e.g. `u64` or `i64` — in special value objects that represent the\n * number as a string to avoid numerical values going above `Number.MAX_SAFE_INTEGER`.\n *\n * It has the same configuration options as {@link createHttpTransport}, but without the `fromJson`\n * and `toJson` options.\n */\nexport function createHttpTransportForSolanaRpc(config: Config): RpcTransport {\n    return createHttpTransport({\n        ...config,\n        fromJson: (rawResponse: string, payload: unknown) =>\n            isSolanaRequest(payload) ? parseJsonWithBigInts(rawResponse) : JSON.parse(rawResponse),\n        toJson: (payload: unknown) =>\n            isSolanaRequest(payload) ? stringifyJsonWithBigints(payload) : JSON.stringify(payload),\n    });\n}\n", "/**\n * This project is a fork of [nickyout/fast-stable-stringify](https://github.com/nickyout/fast-stable-stringify)\n *\n * The most popular repository providing this feature is [substack's json-stable-stringify](https://www.npmjs.com/package/json-stable-stringify). The intent of this library is to provide a faster alternative for when performance is more important than features. It assumes you provide basic javascript values without circular references, and returns a non-indented string.\n *\n * Just like substack's, it:\n *\n * - handles all variations of all basic javascript values (number, string, boolean, array, object, null, Date, BigInt)\n * - handles undefined _and_ function in the same way as `JSON.stringify`\n * - **does not support ie8 (and below) with complete certainty**.\n *\n * Unlike substack's, it:\n *\n * - does not implement the 'replacer' or 'space' arguments of the JSON.stringify method\n * - does not check for circular references\n *\n * @example\n * ```js\n * import stringify from '@solana/fast-stable-stringify';\n * stringify({ d: 0, c: 1, a: 2, b: 3, e: 4 }); // '{\"a\":2,\"b\":3,\"c\":1,\"d\":0,\"e\":4}'\n * ```\n *\n * @packageDocumentation\n */\nconst objToString = Object.prototype.toString;\nconst objKeys =\n    Object.keys ||\n    function (obj) {\n        const keys = [];\n        for (const name in obj) {\n            keys.push(name);\n        }\n        return keys;\n    };\n\nfunction stringify(val: unknown, isArrayProp: boolean) {\n    let i, max, str, keys, key, propVal, toStr;\n    if (val === true) {\n        return 'true';\n    }\n    if (val === false) {\n        return 'false';\n    }\n    switch (typeof val) {\n        case 'object':\n            if (val === null) {\n                return null;\n            } else if ('toJSON' in val && typeof val.toJSON === 'function') {\n                return stringify(val.toJSON(), isArrayProp);\n            } else {\n                toStr = objToString.call(val);\n                if (toStr === '[object Array]') {\n                    str = '[';\n                    max = (val as unknown[]).length - 1;\n                    for (i = 0; i < max; i++) {\n                        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                        str += stringify((val as unknown[])[i], true) + ',';\n                    }\n                    if (max > -1) {\n                        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                        str += stringify((val as unknown[])[i], true);\n                    }\n                    return str + ']';\n                } else if (toStr === '[object Object]') {\n                    // only object is left\n                    keys = objKeys(val).sort();\n                    max = keys.length;\n                    str = '';\n                    i = 0;\n                    while (i < max) {\n                        key = keys[i];\n                        propVal = stringify((val as Record<typeof key, unknown>)[key], false);\n                        if (propVal !== undefined) {\n                            if (str) {\n                                str += ',';\n                            }\n                            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                            str += JSON.stringify(key) + ':' + propVal;\n                        }\n                        i++;\n                    }\n                    return '{' + str + '}';\n                } else {\n                    return JSON.stringify(val);\n                }\n            }\n        case 'function':\n        case 'undefined':\n            return isArrayProp ? null : undefined;\n        case 'bigint':\n            return `${val.toString()}n`;\n        case 'string':\n            return JSON.stringify(val);\n        default:\n            return isFinite(val as number) ? val : null;\n    }\n}\n\nexport default function (\n    val:\n        | Function // eslint-disable-line @typescript-eslint/no-unsafe-function-type\n        | undefined,\n): undefined;\nexport default function (val: unknown): string;\nexport default function (val: unknown): string | undefined {\n    const returnVal = stringify(val, false);\n    if (returnVal !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        return '' + returnVal;\n    }\n}\n", "import { safeCaptureStackTrace, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, SolanaError } from '@solana/errors';\nimport type { KeyPath } from '@solana/rpc-transformers';\n\nexport function createSolanaJsonRpcIntegerOverflowError(\n    methodName: string,\n    keyPath: KeyPath,\n    value: bigint,\n): SolanaError<typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW> {\n    let argumentLabel = '';\n    if (typeof keyPath[0] === 'number') {\n        const argPosition = keyPath[0] + 1;\n        const lastDigit = argPosition % 10;\n        const lastTwoDigits = argPosition % 100;\n        if (lastDigit == 1 && lastTwoDigits != 11) {\n            argumentLabel = argPosition + 'st';\n        } else if (lastDigit == 2 && lastTwoDigits != 12) {\n            argumentLabel = argPosition + 'nd';\n        } else if (lastDigit == 3 && lastTwoDigits != 13) {\n            argumentLabel = argPosition + 'rd';\n        } else {\n            argumentLabel = argPosition + 'th';\n        }\n    } else {\n        argumentLabel = `\\`${keyPath[0].toString()}\\``;\n    }\n    const path =\n        keyPath.length > 1\n            ? keyPath\n                  .slice(1)\n                  .map(pathPart => (typeof pathPart === 'number' ? `[${pathPart}]` : pathPart))\n                  .join('.')\n            : undefined;\n    const error = new SolanaError(SOLANA_ERROR__RPC__INTEGER_OVERFLOW, {\n        argumentLabel,\n        keyPath: keyPath as readonly (number | string | symbol)[],\n        methodName,\n        optionalPathLabel: path ? ` at path \\`${path}\\`` : '',\n        value,\n        ...(path !== undefined ? { path } : undefined),\n    });\n    safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError);\n    return error;\n}\n", "import type { createSolanaRpcApi } from '@solana/rpc-api';\n\nimport { createSolanaJsonRpcIntegerOverflowError } from './rpc-integer-overflow-error';\n\n/**\n * When you create {@link Rpc} instances with custom transports but otherwise the default RPC API\n * behaviours, use this.\n *\n * @example\n * ```ts\n * const myCustomRpc = createRpc({\n *     api: createSolanaRpcApi(DEFAULT_RPC_CONFIG),\n *     transport: myCustomTransport,\n * });\n * ```\n */\nexport const DEFAULT_RPC_CONFIG: Partial<NonNullable<Parameters<typeof createSolanaRpcApi>[0]>> = {\n    defaultCommitment: 'confirmed',\n    onIntegerOverflow(request, keyPath, value) {\n        throw createSolanaJsonRpcIntegerOverflowError(request.methodName, keyPath, value);\n    },\n};\n", "export const AbortController = globalThis.AbortController;\nexport const EventTarget = globalThis.EventTarget;\n", "import { AbortController } from '@solana/event-target-impl';\nimport type { RpcTransport } from '@solana/rpc-spec';\nimport type { RpcResponse } from '@solana/rpc-spec-types';\n\ntype CoalescedRequest = {\n    readonly abortController: AbortController;\n    numConsumers: number;\n    readonly responsePromise: Promise<RpcResponse>;\n};\n\ntype GetDeduplicationKeyFn = (payload: unknown) => string | undefined;\n\n// This used to be a `Symbol()`, but there's a bug in Node <21 where the `undici` library passes\n// the `reason` property of the `AbortSignal` straight to `Error.captureStackTrace()` without first\n// typechecking it. `Error.captureStackTrace()` fatals when given a `Symbol`.\n// See https://github.com/nodejs/undici/pull/2597\nlet EXPLICIT_ABORT_TOKEN: ReturnType<typeof createExplicitAbortToken>;\nfunction createExplicitAbortToken() {\n    // This function is an annoying workaround to prevent `process.env.NODE_ENV` from appearing at\n    // the top level of this module and thwarting an optimizing compiler's attempt to tree-shake.\n    return process.env.NODE_ENV !== \"production\"\n        ? {\n              EXPLICIT_ABORT_TOKEN:\n                  'This object is thrown from the request that underlies a series of coalesced ' +\n                  'requests when the last request in that series aborts',\n          }\n        : {};\n}\n\nexport function getRpcTransportWithRequestCoalescing<TTransport extends RpcTransport>(\n    transport: TTransport,\n    getDeduplicationKey: GetDeduplicationKeyFn,\n): TTransport {\n    let coalescedRequestsByDeduplicationKey: Record<string, CoalescedRequest> | undefined;\n    return async function makeCoalescedHttpRequest<TResponse>(\n        request: Parameters<RpcTransport>[0],\n    ): Promise<RpcResponse<TResponse>> {\n        const { payload, signal } = request;\n        const deduplicationKey = getDeduplicationKey(payload);\n        if (deduplicationKey === undefined) {\n            return await transport(request);\n        }\n        if (!coalescedRequestsByDeduplicationKey) {\n            queueMicrotask(() => {\n                coalescedRequestsByDeduplicationKey = undefined;\n            });\n            coalescedRequestsByDeduplicationKey = {};\n        }\n        if (coalescedRequestsByDeduplicationKey[deduplicationKey] == null) {\n            const abortController = new AbortController();\n            const responsePromise = (async () => {\n                try {\n                    return await transport<TResponse>({\n                        ...request,\n                        signal: abortController.signal,\n                    });\n                } catch (e) {\n                    if (e === (EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken())) {\n                        // We triggered this error when the last subscriber aborted. Letting this\n                        // error bubble up from here would cause runtime fatals where there should\n                        // be none.\n                        return;\n                    }\n                    throw e;\n                }\n            })();\n            coalescedRequestsByDeduplicationKey[deduplicationKey] = {\n                abortController,\n                numConsumers: 0,\n                responsePromise,\n            };\n        }\n        const coalescedRequest = coalescedRequestsByDeduplicationKey[deduplicationKey];\n        coalescedRequest.numConsumers++;\n        if (signal) {\n            const responsePromise = coalescedRequest.responsePromise as Promise<RpcResponse<TResponse>>;\n            return await new Promise<RpcResponse<TResponse>>((resolve, reject) => {\n                const handleAbort = (e: AbortSignalEventMap['abort']) => {\n                    signal.removeEventListener('abort', handleAbort);\n                    coalescedRequest.numConsumers -= 1;\n                    queueMicrotask(() => {\n                        if (coalescedRequest.numConsumers === 0) {\n                            const abortController = coalescedRequest.abortController;\n                            abortController.abort((EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken()));\n                        }\n                    });\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                    reject((e.target as AbortSignal).reason);\n                };\n                signal.addEventListener('abort', handleAbort);\n                responsePromise\n                    .then(resolve)\n                    .catch(reject)\n                    .finally(() => {\n                        signal.removeEventListener('abort', handleAbort);\n                    });\n            });\n        } else {\n            return (await coalescedRequest.responsePromise) as RpcResponse<TResponse>;\n        }\n    } as TTransport;\n}\n", "import fastStableStringify from '@solana/fast-stable-stringify';\nimport { isJsonRpcPayload } from '@solana/rpc-spec';\n\nexport function getSolanaRpcPayloadDeduplicationKey(payload: unknown): string | undefined {\n    return isJsonRpcPayload(payload) ? fastStableStringify([payload.method, payload.params]) : undefined;\n}\n", "import { pipe } from '@solana/functional';\nimport { createHttpTransport, createHttpTransportForSolanaRpc } from '@solana/rpc-transport-http';\nimport type { ClusterUrl } from '@solana/rpc-types';\n\nimport { RpcTransportFromClusterUrl } from './rpc-clusters';\nimport { getRpcTransportWithRequestCoalescing } from './rpc-request-coalescer';\nimport { getSolanaRpcPayloadDeduplicationKey } from './rpc-request-deduplication';\n\ntype RpcTransportConfig = Parameters<typeof createHttpTransport>[0];\ninterface DefaultRpcTransportConfig<TClusterUrl extends ClusterUrl> extends RpcTransportConfig {\n    url: TClusterUrl;\n}\n\nfunction normalizeHeaders<T extends Record<string, string>>(\n    headers: T,\n): { [K in string & keyof T as Lowercase<K>]: T[K] } {\n    const out: Record<string, string> = {};\n    for (const headerName in headers) {\n        // Lowercasing header names makes it easier to override user-supplied headers.\n        out[headerName.toLowerCase()] = headers[headerName];\n    }\n    return out as { [K in string & keyof T as Lowercase<K>]: T[K] };\n}\n\n/**\n * Creates a {@link RpcTransport} with some default behaviours.\n *\n * The default behaviours include:\n * - An automatically-set `Solana-Client` request header, containing the version of `@solana/kit`\n * - Logic that coalesces multiple calls in the same runloop, for the same methods with the same\n *   arguments, into a single network request.\n * - [node-only] An automatically-set `Accept-Encoding` request header asking the server to compress\n *   responses\n *\n * @param config\n */\nexport function createDefaultRpcTransport<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcTransportConfig<TClusterUrl>,\n): RpcTransportFromClusterUrl<TClusterUrl> {\n    return pipe(\n        createHttpTransportForSolanaRpc({\n            ...config,\n            headers: {\n                ...(__NODEJS__ &&\n                    ({\n                        // Keep these headers lowercase so they will be overridden by any user-supplied headers below.\n                        'accept-encoding':\n                            // Natively supported by Node LTS v20.18.0 and above.\n                            'br,gzip,deflate', // Brotli, gzip, and Deflate, in that order.\n                    } as { [overrideHeader: string]: string })),\n                ...(config.headers ? normalizeHeaders(config.headers) : undefined),\n                ...({\n                    // Keep these headers lowercase so they will override any user-supplied headers above.\n                    'solana-client': __VERSION__ ? `js/${__VERSION__}` : 'UNKNOWN',\n                } as { [overrideHeader: string]: string }),\n            },\n        }) as RpcTransportFromClusterUrl<TClusterUrl>,\n        transport => getRpcTransportWithRequestCoalescing(transport, getSolanaRpcPayloadDeduplicationKey),\n    );\n}\n", "import { createSolanaRpcApi } from '@solana/rpc-api';\nimport { createRpc, RpcTransport } from '@solana/rpc-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport type { RpcFromTransport, SolanaRpcApiFromTransport } from './rpc-clusters';\nimport { DEFAULT_RPC_CONFIG } from './rpc-default-config';\nimport { createDefaultRpcTransport } from './rpc-transport';\n\ntype DefaultRpcTransportConfig<TClusterUrl extends ClusterUrl> = Parameters<\n    typeof createDefaultRpcTransport<TClusterUrl>\n>[0];\n\n/**\n * Creates a {@link Rpc} instance that exposes the Solana JSON RPC API given a cluster URL and some\n * optional transport config. See {@link createDefaultRpcTransport} for the shape of the transport\n * config.\n */\nexport function createSolanaRpc<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<DefaultRpcTransportConfig<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcFromTransport(createDefaultRpcTransport({ url: clusterUrl, ...config }));\n}\n\n/**\n * Creates a {@link Rpc} instance that exposes the Solana JSON RPC API given the supplied\n * {@link RpcTransport}.\n */\nexport function createSolanaRpcFromTransport<TTransport extends RpcTransport>(transport: TTransport) {\n    return createRpc({\n        api: createSolanaRpcApi(DEFAULT_RPC_CONFIG),\n        transport,\n    }) as RpcFromTransport<SolanaRpcApiFromTransport<TTransport>, TTransport>;\n}\n", "\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map", "export const AbortController = globalThis.AbortController;\nexport const EventTarget = globalThis.EventTarget;\n", "import {\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { AbortController } from '@solana/event-target-impl';\n\nimport { DataPublisher } from './data-publisher';\n\ntype Config = Readonly<{\n    /**\n     * Triggering this abort signal will cause all iterators spawned from this iterator to return\n     * once they have published all queued messages.\n     */\n    abortSignal: AbortSignal;\n    /**\n     * Messages from this channel of `dataPublisher` will be the ones yielded through the iterators.\n     *\n     * Messages only begin to be queued after the first time an iterator begins to poll. Channel\n     * messages published before that time will be dropped.\n     */\n    dataChannelName: string;\n    // FIXME: It would be nice to be able to constrain the type of `dataPublisher` to one that\n    //        definitely supports the `dataChannelName` and `errorChannelName` channels, and\n    //        furthermore publishes `TData` on the `dataChannelName` channel. This is more difficult\n    //        than it should be: https://tsplay.dev/NlZelW\n    dataPublisher: DataPublisher;\n    /**\n     * Messages from this channel of `dataPublisher` will be the ones thrown through the iterators.\n     *\n     * Any new iterators created after the first error is encountered will reject with that error\n     * when polled.\n     */\n    errorChannelName: string;\n}>;\n\nconst enum PublishType {\n    DATA,\n    ERROR,\n}\n\ntype IteratorKey = symbol;\ntype IteratorState<TData> =\n    | {\n          __hasPolled: false;\n          publishQueue: (\n              | {\n                    __type: PublishType.DATA;\n                    data: TData;\n                }\n              | {\n                    __type: PublishType.ERROR;\n                    err: unknown;\n                }\n          )[];\n      }\n    | {\n          __hasPolled: true;\n          onData: (data: TData) => void;\n          onError: Parameters<ConstructorParameters<typeof Promise>[0]>[1];\n      };\n\nlet EXPLICIT_ABORT_TOKEN: symbol;\nfunction createExplicitAbortToken() {\n    // This function is an annoying workaround to prevent `process.env.NODE_ENV` from appearing at\n    // the top level of this module and thwarting an optimizing compiler's attempt to tree-shake.\n    return Symbol(\n        process.env.NODE_ENV !== \"production\"\n            ? \"This symbol is thrown from a socket's iterator when the connection is explicitly \" +\n                  'aborted by the user'\n            : undefined,\n    );\n}\n\nconst UNINITIALIZED = Symbol();\n\n/**\n * Returns an `AsyncIterable` given a data publisher.\n *\n * The iterable will produce iterators that vend messages published to `dataChannelName` and will\n * throw the first time a message is published to `errorChannelName`. Triggering the abort signal\n * will cause all iterators spawned from this iterator to return once they have published all queued\n * messages.\n *\n * Things to note:\n *\n * - If a message is published over a channel before the `AsyncIterator` attached to it has polled\n *   for the next result, the message will be queued in memory.\n * - Messages only begin to be queued after the first time an iterator begins to poll. Channel\n *   messages published before that time will be dropped.\n * - If there are messages in the queue and an error occurs, all queued messages will be vended to\n *   the iterator before the error is thrown.\n * - If there are messages in the queue and the abort signal fires, all queued messages will be\n *   vended to the iterator after which it will return.\n * - Any new iterators created after the first error is encountered will reject with that error when\n *   polled.\n *\n * @param config\n *\n * @example\n * ```ts\n * const iterable = createAsyncIterableFromDataPublisher({\n *     abortSignal: AbortSignal.timeout(10_000),\n *     dataChannelName: 'message',\n *     dataPublisher,\n *     errorChannelName: 'error',\n * });\n * try {\n *     for await (const message of iterable) {\n *         console.log('Got message', message);\n *     }\n * } catch (e) {\n *     console.error('An error was published to the error channel', e);\n * } finally {\n *     console.log(\"It's been 10 seconds; that's enough for now.\");\n * }\n * ```\n */\nexport function createAsyncIterableFromDataPublisher<TData>({\n    abortSignal,\n    dataChannelName,\n    dataPublisher,\n    errorChannelName,\n}: Config): AsyncIterable<TData> {\n    const iteratorState: Map<IteratorKey, IteratorState<TData>> = new Map();\n    function publishErrorToAllIterators(reason: unknown) {\n        for (const [iteratorKey, state] of iteratorState.entries()) {\n            if (state.__hasPolled) {\n                iteratorState.delete(iteratorKey);\n                state.onError(reason);\n            } else {\n                state.publishQueue.push({\n                    __type: PublishType.ERROR,\n                    err: reason,\n                });\n            }\n        }\n    }\n    const abortController = new AbortController();\n    abortSignal.addEventListener('abort', () => {\n        abortController.abort();\n        publishErrorToAllIterators((EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken()));\n    });\n    const options = { signal: abortController.signal } as const;\n    let firstError: unknown = UNINITIALIZED;\n    dataPublisher.on(\n        errorChannelName,\n        err => {\n            if (firstError === UNINITIALIZED) {\n                firstError = err;\n                abortController.abort();\n                publishErrorToAllIterators(err);\n            }\n        },\n        options,\n    );\n    dataPublisher.on(\n        dataChannelName,\n        data => {\n            iteratorState.forEach((state, iteratorKey) => {\n                if (state.__hasPolled) {\n                    const { onData } = state;\n                    iteratorState.set(iteratorKey, { __hasPolled: false, publishQueue: [] });\n                    onData(data as TData);\n                } else {\n                    state.publishQueue.push({\n                        __type: PublishType.DATA,\n                        data: data as TData,\n                    });\n                }\n            });\n        },\n        options,\n    );\n    return {\n        async *[Symbol.asyncIterator]() {\n            if (abortSignal.aborted) {\n                return;\n            }\n            if (firstError !== UNINITIALIZED) {\n                throw firstError;\n            }\n            const iteratorKey = Symbol();\n            iteratorState.set(iteratorKey, { __hasPolled: false, publishQueue: [] });\n            try {\n                while (true) {\n                    const state = iteratorState.get(iteratorKey);\n                    if (!state) {\n                        // There should always be state by now.\n                        throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING);\n                    }\n                    if (state.__hasPolled) {\n                        // You should never be able to poll twice in a row.\n                        throw new SolanaError(\n                            SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n                        );\n                    }\n                    const publishQueue = state.publishQueue;\n                    try {\n                        if (publishQueue.length) {\n                            state.publishQueue = [];\n                            for (const item of publishQueue) {\n                                if (item.__type === PublishType.DATA) {\n                                    yield item.data;\n                                } else {\n                                    throw item.err;\n                                }\n                            }\n                        } else {\n                            yield await new Promise<TData>((resolve, reject) => {\n                                iteratorState.set(iteratorKey, {\n                                    __hasPolled: true,\n                                    onData: resolve,\n                                    onError: reject,\n                                });\n                            });\n                        }\n                    } catch (e) {\n                        if (e === (EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken())) {\n                            return;\n                        } else {\n                            throw e;\n                        }\n                    }\n                }\n            } finally {\n                iteratorState.delete(iteratorKey);\n            }\n        },\n    };\n}\n", "import { TypedEventEmitter, TypedEventTarget } from './event-emitter';\n\ntype UnsubscribeFn = () => void;\n\n/**\n * Represents an object with an `on` function that you can call to subscribe to certain data over a\n * named channel.\n *\n * @example\n * ```ts\n * let dataPublisher: DataPublisher<{ error: SolanaError }>;\n * dataPublisher.on('data', handleData); // ERROR. `data` is not a known channel name.\n * dataPublisher.on('error', e => {\n *     console.error(e);\n * }); // OK.\n * ```\n */\nexport interface DataPublisher<TDataByChannelName extends Record<string, unknown> = Record<string, unknown>> {\n    /**\n     * Call this to subscribe to data over a named channel.\n     *\n     * @param channelName The name of the channel on which to subscribe for messages\n     * @param subscriber The function to call when a message becomes available\n     * @param options.signal An abort signal you can fire to unsubscribe\n     *\n     * @returns A function that you can call to unsubscribe\n     */\n    on<const TChannelName extends keyof TDataByChannelName>(\n        channelName: TChannelName,\n        subscriber: (data: TDataByChannelName[TChannelName]) => void,\n        options?: { signal: AbortSignal },\n    ): UnsubscribeFn;\n}\n\n/**\n * Returns an object with an `on` function that you can call to subscribe to certain data over a\n * named channel.\n *\n * The `on` function returns an unsubscribe function.\n *\n * @example\n * ```ts\n * const socketDataPublisher = getDataPublisherFromEventEmitter(new WebSocket('wss://api.devnet.solana.com'));\n * const unsubscribe = socketDataPublisher.on('message', message => {\n *     if (JSON.parse(message.data).id === 42) {\n *         console.log('Got response 42');\n *         unsubscribe();\n *     }\n * });\n * ```\n */\nexport function getDataPublisherFromEventEmitter<TEventMap extends Record<string, Event>>(\n    eventEmitter: TypedEventEmitter<TEventMap> | TypedEventTarget<TEventMap>,\n): DataPublisher<{\n    [TEventType in keyof TEventMap]: TEventMap[TEventType] extends CustomEvent ? TEventMap[TEventType]['detail'] : null;\n}> {\n    return {\n        on(channelName, subscriber, options) {\n            function innerListener(ev: Event) {\n                if (ev instanceof CustomEvent) {\n                    const data = (ev as CustomEvent<TEventMap[typeof channelName]>).detail;\n                    (subscriber as unknown as (data: TEventMap[typeof channelName]) => void)(data);\n                } else {\n                    (subscriber as () => void)();\n                }\n            }\n            eventEmitter.addEventListener(channelName, innerListener, options);\n            return () => {\n                eventEmitter.removeEventListener(channelName, innerListener);\n            };\n        },\n    };\n}\n", "import { EventTarget } from '@solana/event-target-impl';\n\nimport { DataPublisher, getDataPublisherFromEventEmitter } from './data-publisher';\n\n/**\n * Given a channel that carries messages for multiple subscribers on a single channel name, this\n * function returns a new {@link DataPublisher} that splits them into multiple channel names.\n *\n * @param messageTransformer A function that receives the message as the first argument, and returns\n * a tuple of the derived channel name and the message.\n *\n * @example\n * Imagine a channel that carries multiple notifications whose destination is contained within the\n * message itself.\n *\n * ```ts\n * const demuxedDataPublisher = demultiplexDataPublisher(channel, 'message', message => {\n *     const destinationChannelName = `notification-for:${message.subscriberId}`;\n *     return [destinationChannelName, message];\n * });\n * ```\n *\n * Now you can subscribe to _only_ the messages you are interested in, without having to subscribe\n * to the entire `'message'` channel and filter out the messages that are not for you.\n *\n * ```ts\n * demuxedDataPublisher.on(\n *     'notification-for:123',\n *     message => {\n *         console.log('Got a message for subscriber 123', message);\n *     },\n *     { signal: AbortSignal.timeout(5_000) },\n * );\n * ```\n */\nexport function demultiplexDataPublisher<\n    TDataPublisher extends DataPublisher,\n    const TChannelName extends Parameters<TDataPublisher['on']>[0],\n>(\n    publisher: TDataPublisher,\n    sourceChannelName: TChannelName,\n    messageTransformer: (\n        // FIXME: Deriving the type of the message from `TDataPublisher` and `TChannelName` would\n        //        help callers to constrain their transform functions.\n        message: unknown,\n    ) => [destinationChannelName: string, message: unknown] | void,\n): DataPublisher {\n    let innerPublisherState:\n        | {\n              readonly dispose: () => void;\n              numSubscribers: number;\n          }\n        | undefined;\n    const eventTarget = new EventTarget();\n    const demultiplexedDataPublisher = getDataPublisherFromEventEmitter(eventTarget);\n    return {\n        ...demultiplexedDataPublisher,\n        on(channelName, subscriber, options) {\n            if (!innerPublisherState) {\n                const innerPublisherUnsubscribe = publisher.on(sourceChannelName, sourceMessage => {\n                    const transformResult = messageTransformer(sourceMessage);\n                    if (!transformResult) {\n                        return;\n                    }\n                    const [destinationChannelName, message] = transformResult;\n                    eventTarget.dispatchEvent(\n                        new CustomEvent(destinationChannelName, {\n                            detail: message,\n                        }),\n                    );\n                });\n                innerPublisherState = {\n                    dispose: innerPublisherUnsubscribe,\n                    numSubscribers: 0,\n                };\n            }\n            innerPublisherState.numSubscribers++;\n            const unsubscribe = demultiplexedDataPublisher.on(channelName, subscriber, options);\n            let isActive = true;\n            function handleUnsubscribe() {\n                if (!isActive) {\n                    return;\n                }\n                isActive = false;\n                options?.signal.removeEventListener('abort', handleUnsubscribe);\n                innerPublisherState!.numSubscribers--;\n                if (innerPublisherState!.numSubscribers === 0) {\n                    innerPublisherState!.dispose();\n                    innerPublisherState = undefined;\n                }\n                unsubscribe();\n            }\n            options?.signal.addEventListener('abort', handleUnsubscribe);\n            return handleUnsubscribe;\n        },\n    };\n}\n", "/**\n * Forked from https://github.com/digitalloggers/race-as-promised/tree/master\n *\n * Authored by Brian Kim:\n * https://github.com/nodejs/node/issues/17469#issuecomment-685216777\n *\n * Adapted to module structure.\n *\n * This is free and unencumbered software released into the public domain.\n *\n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n *\n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * For more information, please refer to <http://unlicense.org/>\n */\n\ntype Deferred = Readonly<{\n    reject: (reason?: unknown) => void;\n    resolve: (value: unknown) => void;\n}>;\n\nfunction isObject(value: unknown): value is object {\n    return value !== null && (typeof value === 'object' || typeof value === 'function');\n}\n\nfunction addRaceContender(contender: object) {\n    const deferreds = new Set<Deferred>();\n    const record = { deferreds, settled: false };\n\n    // This call to `then` happens once for the lifetime of the value.\n    Promise.resolve(contender).then(\n        value => {\n            for (const { resolve } of deferreds) {\n                resolve(value);\n            }\n\n            deferreds.clear();\n            record.settled = true;\n        },\n        err => {\n            for (const { reject } of deferreds) {\n                reject(err);\n            }\n\n            deferreds.clear();\n            record.settled = true;\n        },\n    );\n    return record;\n}\n\n// Keys are the values passed to race, values are a record of data containing a\n// set of deferreds and whether the value has settled.\nconst wm = new WeakMap<object, { deferreds: Set<Deferred>; settled: boolean }>();\n/**\n * An implementation of [`Promise.race`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race)\n * that causes all of the losing promises to settle. This allows them to be released and garbage\n * collected, preventing memory leaks.\n *\n * Read more here: https://github.com/nodejs/node/issues/17469\n */\nexport async function safeRace<T extends readonly unknown[] | []>(contenders: T): Promise<Awaited<T[number]>> {\n    let deferred: Deferred;\n    const result = new Promise((resolve, reject) => {\n        deferred = { reject, resolve };\n        for (const contender of contenders) {\n            if (!isObject(contender)) {\n                // If the contender is a primitive, attempting to use it as a key in the\n                // weakmap would throw an error. Luckily, it is safe to call\n                // `Promise.resolve(contender).then` on a primitive value multiple times\n                // because the promise fulfills immediately.\n                Promise.resolve(contender).then(resolve, reject);\n                continue;\n            }\n\n            let record = wm.get(contender);\n            if (record === undefined) {\n                record = addRaceContender(contender);\n                record.deferreds.add(deferred);\n                wm.set(contender, record);\n            } else if (record.settled) {\n                // If the value has settled, it is safe to call\n                // `Promise.resolve(contender).then` on it.\n                Promise.resolve(contender).then(resolve, reject);\n            } else {\n                record.deferreds.add(deferred);\n            }\n        }\n    });\n\n    // The finally callback executes when any value settles, preventing any of\n    // the unresolved values from retaining a reference to the resolved value.\n    return await (result.finally(() => {\n        for (const contender of contenders) {\n            if (isObject(contender)) {\n                const record = wm.get(contender)!;\n                record.deferreds.delete(deferred);\n            }\n        }\n    }) as Promise<Awaited<T[number]>>);\n}\n", "import { safeRace } from './race';\n\n/**\n * Returns a new promise that will reject if the abort signal fires before the original promise\n * settles. Resolves or rejects with the value of the original promise otherwise.\n *\n * @example\n * ```ts\n * const result = await getAbortablePromise(\n *     // Resolves or rejects when `fetch` settles.\n *     fetch('https://example.com/json').then(r => r.json()),\n *     // ...unless it takes longer than 5 seconds, after which the `AbortSignal` is triggered.\n *     AbortSignal.timeout(5000),\n * );\n * ```\n */\nexport function getAbortablePromise<T>(promise: Promise<T>, abortSignal?: AbortSignal): Promise<T> {\n    if (!abortSignal) {\n        return promise;\n    } else {\n        return safeRace([\n            // This promise only ever rejects if the signal is aborted. Otherwise it idles forever.\n            // It's important that this come before the input promise; in the event of an abort, we\n            // want to throw even if the input promise's result is ready\n            new Promise<never>((_, reject) => {\n                if (abortSignal.aborted) {\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                    reject(abortSignal.reason);\n                } else {\n                    abortSignal.addEventListener('abort', function () {\n                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                        reject(this.reason);\n                    });\n                }\n            }),\n            promise,\n        ]);\n    }\n}\n", "import { SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN, SolanaError } from '@solana/errors';\nimport { Callable, Flatten, OverloadImplementations, UnionToIntersection } from '@solana/rpc-spec-types';\nimport { createAsyncIterableFromDataPublisher } from '@solana/subscribable';\n\nimport { RpcSubscriptionsApi, RpcSubscriptionsPlan } from './rpc-subscriptions-api';\nimport { PendingRpcSubscriptionsRequest, RpcSubscribeOptions } from './rpc-subscriptions-request';\nimport { RpcSubscriptionsTransport } from './rpc-subscriptions-transport';\n\nexport type RpcSubscriptionsConfig<TRpcMethods> = Readonly<{\n    api: RpcSubscriptionsApi<TRpcMethods>;\n    transport: RpcSubscriptionsTransport;\n}>;\n\n/**\n * An object that exposes all of the functions described by `TRpcSubscriptionsMethods`.\n *\n * Calling each method returns a\n * {@link PendingRpcSubscriptionsRequest | PendingRpcSubscriptionsRequest<TNotification>} where\n * `TNotification` is that method's notification type.\n */\nexport type RpcSubscriptions<TRpcSubscriptionsMethods> = {\n    [TMethodName in keyof TRpcSubscriptionsMethods]: PendingRpcSubscriptionsRequestBuilder<\n        OverloadImplementations<TRpcSubscriptionsMethods, TMethodName>\n    >;\n};\n\ntype PendingRpcSubscriptionsRequestBuilder<TSubscriptionMethodImplementations> = UnionToIntersection<\n    Flatten<{\n        [P in keyof TSubscriptionMethodImplementations]: PendingRpcSubscriptionsRequestReturnTypeMapper<\n            TSubscriptionMethodImplementations[P]\n        >;\n    }>\n>;\n\ntype PendingRpcSubscriptionsRequestReturnTypeMapper<TSubscriptionMethodImplementation> =\n    // Check that this property of the TRpcSubscriptionMethods interface is, in fact, a function.\n    TSubscriptionMethodImplementation extends Callable\n        ? (\n              ...args: Parameters<TSubscriptionMethodImplementation>\n          ) => PendingRpcSubscriptionsRequest<ReturnType<TSubscriptionMethodImplementation>>\n        : never;\n\n/**\n * Creates a {@link RpcSubscriptions} instance given a\n * {@link RpcSubscriptionsApi | RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>} and a\n * {@link RpcSubscriptionsTransport} capable of fulfilling them.\n */\nexport function createSubscriptionRpc<TRpcSubscriptionsApiMethods>(\n    rpcConfig: RpcSubscriptionsConfig<TRpcSubscriptionsApiMethods>,\n): RpcSubscriptions<TRpcSubscriptionsApiMethods> {\n    return new Proxy(rpcConfig.api, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get(target, p, receiver) {\n            if (p === 'then') {\n                return undefined;\n            }\n            return function (...rawParams: unknown[]) {\n                const notificationName = p.toString();\n                const createRpcSubscriptionPlan = Reflect.get(target, notificationName, receiver);\n                if (!createRpcSubscriptionPlan) {\n                    throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN, {\n                        notificationName,\n                    });\n                }\n                const subscriptionPlan = createRpcSubscriptionPlan(...rawParams);\n                return createPendingRpcSubscription(rpcConfig.transport, subscriptionPlan);\n            };\n        },\n    }) as RpcSubscriptions<TRpcSubscriptionsApiMethods>;\n}\n\nfunction createPendingRpcSubscription<TNotification>(\n    transport: RpcSubscriptionsTransport,\n    subscriptionsPlan: RpcSubscriptionsPlan<TNotification>,\n): PendingRpcSubscriptionsRequest<TNotification> {\n    return {\n        async subscribe({ abortSignal }: RpcSubscribeOptions): Promise<AsyncIterable<TNotification>> {\n            const notificationsDataPublisher = await transport({\n                signal: abortSignal,\n                ...subscriptionsPlan,\n            });\n            return createAsyncIterableFromDataPublisher<TNotification>({\n                abortSignal,\n                dataChannelName: 'notification',\n                dataPublisher: notificationsDataPublisher,\n                errorChannelName: 'error',\n            });\n        },\n    };\n}\n", "import { Callable, RpcRequest, RpcRequestTransformer } from '@solana/rpc-spec-types';\nimport { DataPublisher } from '@solana/subscribable';\n\nimport { RpcSubscriptionsChannel } from './rpc-subscriptions-channel';\nimport { RpcSubscriptionsTransportDataEvents } from './rpc-subscriptions-transport';\n\nexport type RpcSubscriptionsApiConfig<TApiMethods extends RpcSubscriptionsApiMethods> = Readonly<{\n    planExecutor: RpcSubscriptionsPlanExecutor<ReturnType<TApiMethods[keyof TApiMethods]>>;\n    /**\n     * An optional function that transforms the {@link RpcRequest} before it is sent to the JSON RPC\n     * server.\n     *\n     * This is useful when the params supplied by the caller need to be transformed before\n     * forwarding the message to the server. Use cases for this include applying defaults,\n     * forwarding calls to renamed methods, and serializing complex values.\n     */\n    requestTransformer?: RpcRequestTransformer;\n}>;\n\n/**\n * A function that implements a protocol for subscribing and unsubscribing from notifications given\n * a {@link RpcSubscriptionsChannel}, a {@link RpcRequest}, and an `AbortSignal`.\n *\n * @returns A {@link DataPublisher} that emits {@link RpcSubscriptionsTransportDataEvents}\n */\ntype RpcSubscriptionsPlanExecutor<TNotification> = (\n    config: Readonly<{\n        channel: RpcSubscriptionsChannel<unknown, unknown>;\n        request: RpcRequest;\n        signal: AbortSignal;\n    }>,\n) => Promise<DataPublisher<RpcSubscriptionsTransportDataEvents<TNotification>>>;\n\n/**\n * This type allows an {@link RpcSubscriptionsApi} to describe how a particular subscription should\n * be issued to the JSON RPC server.\n *\n * Given a function that was called on a {@link RpcSubscriptions}, this object exposes an `execute`\n * function that dictates which subscription request will be sent, how the underlying transport will\n * be used, and how the notifications will be transformed.\n *\n * This function accepts a {@link RpcSubscriptionsChannel} and an `AbortSignal` and asynchronously\n * returns a {@link DataPublisher}. This gives us the opportunity to:\n *\n * - define the `payload` from the requested method name and parameters before passing it to the\n *   channel.\n * - call the underlying channel zero, one or multiple times depending on the use-case (e.g.\n *   caching or coalescing multiple subscriptions).\n * - transform the notification from the JSON RPC server, in case it does not match the\n *   `TNotification` specified by the\n *   {@link PendingRpcSubscriptionsRequest | PendingRpcSubscriptionsRequest<TNotification>} emitted\n *   from the publisher returned.\n */\nexport type RpcSubscriptionsPlan<TNotification> = Readonly<{\n    /**\n     * This method may be called with a newly-opened channel or a pre-established channel.\n     */\n    execute: (\n        config: Readonly<{\n            channel: RpcSubscriptionsChannel<unknown, unknown>;\n            signal: AbortSignal;\n        }>,\n    ) => Promise<DataPublisher<RpcSubscriptionsTransportDataEvents<TNotification>>>;\n    /**\n     * This request is used to uniquely identify the subscription.\n     * It typically comes from the method name and parameters of the subscription call,\n     * after potentially being transformed by the RPC Subscriptions API.\n     */\n    request: RpcRequest;\n}>;\n\n/**\n * For each of `TRpcSubscriptionsMethods`, this object exposes a method with the same name that maps\n * between its input arguments and a\n * {@link RpcSubscriptionsPlan | RpcSubscriptionsPlan<TNotification>} that implements the execution\n * of a JSON RPC subscription for `TNotifications`.\n */\nexport type RpcSubscriptionsApi<TRpcSubscriptionMethods> = {\n    [MethodName in keyof TRpcSubscriptionMethods]: RpcSubscriptionsReturnTypeMapper<\n        TRpcSubscriptionMethods[MethodName]\n    >;\n};\n\ntype RpcSubscriptionsReturnTypeMapper<TRpcMethod> = TRpcMethod extends Callable\n    ? (...rawParams: unknown[]) => RpcSubscriptionsPlan<ReturnType<TRpcMethod>>\n    : never;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RpcSubscriptionsApiMethod = (...args: any) => any;\nexport interface RpcSubscriptionsApiMethods {\n    [methodName: string]: RpcSubscriptionsApiMethod;\n}\n\n/**\n * Creates a JavaScript proxy that converts _any_ function call called on it to a\n * {@link RpcSubscriptionsPlan} by creating an `execute` function that:\n *\n * - calls the supplied {@link RpcSubscriptionsApiConfig.planExecutor} with a JSON RPC v2 payload\n *   object with the requested `methodName` and `params` properties, optionally transformed by\n *   {@link RpcSubscriptionsApiConfig.requestTransformer}.\n *\n * @example\n * ```ts\n * // For example, given this `RpcSubscriptionsApi`:\n * const rpcSubscriptionsApi = createJsonRpcSubscriptionsApi({\n *     async planExecutor({ channel, request }) {\n *         await channel.send(request);\n *         return {\n *             ...channel,\n *             on(type, listener, options) {\n *                 if (type !== 'message') {\n *                     return channel.on(type, listener, options);\n *                 }\n *                 return channel.on(\n *                     'message',\n *                     function resultGettingListener(message) {\n *                         listener(message.result);\n *                     },\n *                     options,\n *                 );\n *             }\n *         }\n *     },\n *     requestTransformer: (...rawParams) => rawParams.reverse(),\n * });\n *\n * // ...the following function call:\n * rpcSubscriptionsApi.foo('bar', { baz: 'bat' });\n *\n * // ...will produce a `RpcSubscriptionsPlan` that:\n * // -   Uses the following payload: { id: 1, jsonrpc: '2.0', method: 'foo', params: [{ baz: 'bat' }, 'bar'] }.\n * // -   Emits the \"result\" property of each RPC Subscriptions message.\n * ```\n */\nexport function createRpcSubscriptionsApi<TRpcSubscriptionsApiMethods extends RpcSubscriptionsApiMethods>(\n    config: RpcSubscriptionsApiConfig<TRpcSubscriptionsApiMethods>,\n): RpcSubscriptionsApi<TRpcSubscriptionsApiMethods> {\n    return new Proxy({} as RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get<TNotificationName extends keyof RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>>(\n            ...args: Parameters<NonNullable<ProxyHandler<RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>>['get']>>\n        ) {\n            const [_, p] = args;\n            const methodName = p.toString() as keyof TRpcSubscriptionsApiMethods as string;\n            return function (\n                ...params: Parameters<\n                    TRpcSubscriptionsApiMethods[TNotificationName] extends CallableFunction\n                        ? TRpcSubscriptionsApiMethods[TNotificationName]\n                        : never\n                >\n            ): RpcSubscriptionsPlan<ReturnType<TRpcSubscriptionsApiMethods[TNotificationName]>> {\n                const rawRequest = { methodName, params };\n                const request = config.requestTransformer ? config.requestTransformer(rawRequest) : rawRequest;\n                return {\n                    execute(planConfig) {\n                        return config.planExecutor({ ...planConfig, request });\n                    },\n                    request,\n                };\n            };\n        },\n    });\n}\n", "import {\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SolanaError,\n} from '@solana/errors';\nimport { DataPublisher } from '@solana/subscribable';\n\ntype RpcSubscriptionsChannelSolanaErrorCode =\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT;\n\nexport type RpcSubscriptionChannelEvents<TInboundMessage> = {\n    /**\n     * Fires when the channel closes unexpectedly.\n     * @eventProperty\n     */\n    error: SolanaError<RpcSubscriptionsChannelSolanaErrorCode>;\n    /**\n     * Fires on every message received from the remote end.\n     * @eventProperty\n     */\n    message: TInboundMessage;\n};\n\n/**\n * A {@link DataPublisher} on which you can subscribe to events of type\n * {@link RpcSubscriptionChannelEvents | RpcSubscriptionChannelEvents<TInboundMessage>}.\n * Additionally, you can use this object to send messages of type `TOutboundMessage` back to the\n * remote end by calling its {@link RpcSubscriptionsChannel.send | `send(message)`} method.\n */\nexport interface RpcSubscriptionsChannel<TOutboundMessage, TInboundMessage>\n    extends DataPublisher<RpcSubscriptionChannelEvents<TInboundMessage>> {\n    send(message: TOutboundMessage): Promise<void>;\n}\n\n/**\n * A channel creator is a function that accepts an `AbortSignal`, returns a new\n * {@link RpcSubscriptionsChannel}, and tears down the channel when the abort signal fires.\n */\nexport type RpcSubscriptionsChannelCreator<TOutboundMessage, TInboundMessage> = (\n    config: Readonly<{\n        abortSignal: AbortSignal;\n    }>,\n) => Promise<RpcSubscriptionsChannel<TOutboundMessage, TInboundMessage>>;\n\n/**\n * Given a channel with inbound messages of type `T` and a function of type `T => U`, returns a new\n * channel with inbound messages of type `U`.\n *\n * Note that this only affects messages of type `\"message\"` and thus, does not affect incoming error\n * messages.\n *\n * @example Parsing incoming JSON messages\n * ```ts\n * const transformedChannel = transformChannelInboundMessages(channel, JSON.parse);\n * ```\n */\nexport function transformChannelInboundMessages<TOutboundMessage, TNewInboundMessage, TInboundMessage>(\n    channel: RpcSubscriptionsChannel<TOutboundMessage, TInboundMessage>,\n    transform: (message: TInboundMessage) => TNewInboundMessage,\n): RpcSubscriptionsChannel<TOutboundMessage, TNewInboundMessage> {\n    return Object.freeze<RpcSubscriptionsChannel<TOutboundMessage, TNewInboundMessage>>({\n        ...channel,\n        on(type, subscriber, options) {\n            if (type !== 'message') {\n                return channel.on(\n                    type,\n                    subscriber as (data: RpcSubscriptionChannelEvents<TInboundMessage>[typeof type]) => void,\n                    options,\n                );\n            }\n            return channel.on(\n                'message',\n                message => (subscriber as (data: TNewInboundMessage) => void)(transform(message)),\n                options,\n            );\n        },\n    });\n}\n\n/**\n * Given a channel with outbound messages of type `T` and a function of type `U => T`, returns a new\n * channel with outbound messages of type `U`.\n *\n * @example Stringifying JSON messages before sending them over the wire\n * ```ts\n * const transformedChannel = transformChannelOutboundMessages(channel, JSON.stringify);\n * ```\n */\nexport function transformChannelOutboundMessages<TNewOutboundMessage, TOutboundMessage, TInboundMessage>(\n    channel: RpcSubscriptionsChannel<TOutboundMessage, TInboundMessage>,\n    transform: (message: TNewOutboundMessage) => TOutboundMessage,\n): RpcSubscriptionsChannel<TNewOutboundMessage, TInboundMessage> {\n    return Object.freeze<RpcSubscriptionsChannel<TNewOutboundMessage, TInboundMessage>>({\n        ...channel,\n        send: message => channel.send(transform(message)),\n    });\n}\n", "export const AbortController = globalThis.AbortController;\nexport const EventTarget = globalThis.EventTarget;\n", "import {\n    getSolanaErrorFromJsonRpcError,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID,\n    SolanaError,\n} from '@solana/errors';\nimport { AbortController } from '@solana/event-target-impl';\nimport { safeRace } from '@solana/promises';\nimport { createRpcMessage, RpcRequest, RpcResponseData, RpcResponseTransformer } from '@solana/rpc-spec-types';\nimport { DataPublisher } from '@solana/subscribable';\nimport { demultiplexDataPublisher } from '@solana/subscribable';\n\nimport { RpcSubscriptionChannelEvents } from './rpc-subscriptions-channel';\nimport { RpcSubscriptionsChannel } from './rpc-subscriptions-channel';\n\ntype Config<TNotification> = Readonly<{\n    channel: RpcSubscriptionsChannel<unknown, RpcNotification<TNotification> | RpcResponseData<RpcSubscriptionId>>;\n    responseTransformer?: RpcResponseTransformer;\n    signal: AbortSignal;\n    subscribeRequest: RpcRequest;\n    unsubscribeMethodName: string;\n}>;\n\ntype RpcNotification<TNotification> = Readonly<{\n    method: string;\n    params: Readonly<{\n        result: TNotification;\n        subscription: number;\n    }>;\n}>;\n\ntype RpcSubscriptionId = number;\n\ntype RpcSubscriptionNotificationEvents<TNotification> = Omit<RpcSubscriptionChannelEvents<TNotification>, 'message'> & {\n    notification: TNotification;\n};\n\nconst subscriberCountBySubscriptionIdByChannel = new WeakMap<WeakKey, Record<number, number>>();\nfunction decrementSubscriberCountAndReturnNewCount(channel: WeakKey, subscriptionId?: number): number | undefined {\n    return augmentSubscriberCountAndReturnNewCount(-1, channel, subscriptionId);\n}\nfunction incrementSubscriberCount(channel: WeakKey, subscriptionId?: number): void {\n    augmentSubscriberCountAndReturnNewCount(1, channel, subscriptionId);\n}\nfunction getSubscriberCountBySubscriptionIdForChannel(channel: WeakKey): Record<number, number> {\n    let subscriberCountBySubscriptionId = subscriberCountBySubscriptionIdByChannel.get(channel);\n    if (!subscriberCountBySubscriptionId) {\n        subscriberCountBySubscriptionIdByChannel.set(channel, (subscriberCountBySubscriptionId = {}));\n    }\n    return subscriberCountBySubscriptionId;\n}\nfunction augmentSubscriberCountAndReturnNewCount(\n    amount: -1 | 1,\n    channel: WeakKey,\n    subscriptionId?: number,\n): number | undefined {\n    if (subscriptionId === undefined) {\n        return;\n    }\n    const subscriberCountBySubscriptionId = getSubscriberCountBySubscriptionIdForChannel(channel);\n    if (!subscriberCountBySubscriptionId[subscriptionId] && amount > 0) {\n        subscriberCountBySubscriptionId[subscriptionId] = 0;\n    }\n    const newCount = amount + subscriberCountBySubscriptionId[subscriptionId];\n    if (newCount <= 0) {\n        delete subscriberCountBySubscriptionId[subscriptionId];\n    } else {\n        subscriberCountBySubscriptionId[subscriptionId] = newCount;\n    }\n    return newCount;\n}\n\nconst cache = new WeakMap();\nfunction getMemoizedDemultiplexedNotificationPublisherFromChannelAndResponseTransformer<TNotification>(\n    channel: RpcSubscriptionsChannel<unknown, RpcNotification<TNotification>>,\n    subscribeRequest: RpcRequest,\n    responseTransformer?: RpcResponseTransformer,\n): DataPublisher<{\n    [channelName: `notification:${number}`]: TNotification;\n}> {\n    let publisherByResponseTransformer = cache.get(channel);\n    if (!publisherByResponseTransformer) {\n        cache.set(channel, (publisherByResponseTransformer = new WeakMap()));\n    }\n    const responseTransformerKey = responseTransformer ?? channel;\n    let publisher = publisherByResponseTransformer.get(responseTransformerKey);\n    if (!publisher) {\n        publisherByResponseTransformer.set(\n            responseTransformerKey,\n            (publisher = demultiplexDataPublisher(channel, 'message', rawMessage => {\n                const message = rawMessage as RpcNotification<unknown> | RpcResponseData<unknown>;\n                if (!('method' in message)) {\n                    return;\n                }\n                const transformedNotification = responseTransformer\n                    ? responseTransformer(message.params.result, subscribeRequest)\n                    : message.params.result;\n                return [`notification:${message.params.subscription}`, transformedNotification];\n            })),\n        );\n    }\n    return publisher;\n}\n\n/**\n * Given a channel, this function executes the particular subscription plan required by the Solana\n * JSON RPC Subscriptions API.\n *\n * @param config\n *\n * 1. Calls the `subscribeRequest` on the remote RPC\n * 2. Waits for a response containing the subscription id\n * 3. Returns a {@link DataPublisher} that publishes notifications related to that subscriptions id,\n *    filtering out all others\n * 4. Calls the `unsubscribeMethodName` on the remote RPC when the abort signal is fired.\n */\nexport async function executeRpcPubSubSubscriptionPlan<TNotification>({\n    channel,\n    responseTransformer,\n    signal,\n    subscribeRequest,\n    unsubscribeMethodName,\n}: Config<TNotification>): Promise<DataPublisher<RpcSubscriptionNotificationEvents<TNotification>>> {\n    let subscriptionId: number | undefined;\n    channel.on(\n        'error',\n        () => {\n            // An error on the channel indicates that the subscriptions are dead.\n            // There is no longer any sense hanging on to subscription ids.\n            // Erasing it here will prevent the unsubscribe code from running.\n            subscriptionId = undefined;\n            subscriberCountBySubscriptionIdByChannel.delete(channel);\n        },\n        { signal },\n    );\n    /**\n     * STEP 1\n     * Create a promise that rejects if this subscription is aborted and sends\n     * the unsubscribe message if the subscription is active at that time.\n     */\n    const abortPromise = new Promise<never>((_, reject) => {\n        function handleAbort(this: AbortSignal) {\n            /**\n             * Because of https://github.com/solana-labs/solana/pull/18943, two subscriptions for\n             * materially the same notification will be coalesced on the server. This means they\n             * will be assigned the same subscription id, and will occupy one subscription slot. We\n             * must be careful not to send the unsubscribe message until the last subscriber aborts.\n             */\n            if (decrementSubscriberCountAndReturnNewCount(channel, subscriptionId) === 0) {\n                const unsubscribePayload = createRpcMessage({\n                    methodName: unsubscribeMethodName,\n                    params: [subscriptionId],\n                });\n                subscriptionId = undefined;\n                channel.send(unsubscribePayload).catch(() => {});\n            }\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            reject(this.reason);\n        }\n        if (signal.aborted) {\n            handleAbort.call(signal);\n        } else {\n            signal.addEventListener('abort', handleAbort);\n        }\n    });\n    /**\n     * STEP 2\n     * Send the subscription request.\n     */\n    const subscribePayload = createRpcMessage(subscribeRequest);\n    await channel.send(subscribePayload);\n    /**\n     * STEP 3\n     * Wait for the acknowledgement from the server with the subscription id.\n     */\n    const subscriptionIdPromise = new Promise<RpcSubscriptionId>((resolve, reject) => {\n        const abortController = new AbortController();\n        signal.addEventListener('abort', abortController.abort.bind(abortController));\n        const options = { signal: abortController.signal } as const;\n        channel.on(\n            'error',\n            err => {\n                abortController.abort();\n                reject(err);\n            },\n            options,\n        );\n        channel.on(\n            'message',\n            message => {\n                if (message && typeof message === 'object' && 'id' in message && message.id === subscribePayload.id) {\n                    abortController.abort();\n                    if ('error' in message) {\n                        reject(getSolanaErrorFromJsonRpcError(message.error));\n                    } else {\n                        resolve(message.result);\n                    }\n                }\n            },\n            options,\n        );\n    });\n    subscriptionId = await safeRace([abortPromise, subscriptionIdPromise]);\n    if (subscriptionId == null) {\n        throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID);\n    }\n    incrementSubscriberCount(channel, subscriptionId);\n    /**\n     * STEP 4\n     * Filter out notifications unrelated to this subscription.\n     */\n    const notificationPublisher = getMemoizedDemultiplexedNotificationPublisherFromChannelAndResponseTransformer(\n        channel,\n        subscribeRequest,\n        responseTransformer,\n    );\n    const notificationKey = `notification:${subscriptionId}` as const;\n    return {\n        on(type, listener, options) {\n            switch (type) {\n                case 'notification':\n                    return notificationPublisher.on(\n                        notificationKey,\n                        listener as (data: RpcSubscriptionNotificationEvents<TNotification>['notification']) => void,\n                        options,\n                    );\n                case 'error':\n                    return channel.on(\n                        'error',\n                        listener as (data: RpcSubscriptionNotificationEvents<TNotification>['error']) => void,\n                        options,\n                    );\n                default:\n                    throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED, {\n                        channelName: type,\n                        supportedChannelNames: ['notification', 'error'],\n                    });\n            }\n        },\n    };\n}\n", "import {\n    createRpcSubscriptionsApi,\n    executeRpcPubSubSubscriptionPlan,\n    RpcSubscriptionsApi,\n    RpcSubscriptionsApiMethods,\n} from '@solana/rpc-subscriptions-spec';\nimport {\n    AllowedNumericKeypaths,\n    getDefaultRequestTransformerForSolanaRpc,\n    getDefaultResponseTransformerForSolanaRpcSubscriptions,\n    jsonParsedAccountsConfigs,\n    KEYPATH_WILDCARD,\n    RequestTransformerConfig,\n} from '@solana/rpc-transformers';\n\nimport { AccountNotificationsApi } from './account-notifications';\nimport { BlockNotificationsApi } from './block-notifications';\nimport { LogsNotificationsApi } from './logs-notifications';\nimport { ProgramNotificationsApi } from './program-notifications';\nimport { RootNotificationsApi } from './root-notifications';\nimport { SignatureNotificationsApi } from './signature-notifications';\nimport { SlotNotificationsApi } from './slot-notifications';\nimport { SlotsUpdatesNotificationsApi } from './slots-updates-notifications';\nimport { VoteNotificationsApi } from './vote-notifications';\n\nexport type SolanaRpcSubscriptionsApi = AccountNotificationsApi &\n    LogsNotificationsApi &\n    ProgramNotificationsApi &\n    RootNotificationsApi &\n    SignatureNotificationsApi &\n    SlotNotificationsApi;\nexport type SolanaRpcSubscriptionsApiUnstable = BlockNotificationsApi &\n    SlotsUpdatesNotificationsApi &\n    VoteNotificationsApi;\n\nexport type {\n    AccountNotificationsApi,\n    BlockNotificationsApi,\n    LogsNotificationsApi,\n    ProgramNotificationsApi,\n    RootNotificationsApi,\n    SignatureNotificationsApi,\n    SlotNotificationsApi,\n    SlotsUpdatesNotificationsApi,\n    VoteNotificationsApi,\n};\n\ntype Config = RequestTransformerConfig;\n\nfunction createSolanaRpcSubscriptionsApi_INTERNAL<TApi extends RpcSubscriptionsApiMethods>(\n    config?: Config,\n): RpcSubscriptionsApi<TApi> {\n    const requestTransformer = getDefaultRequestTransformerForSolanaRpc(config);\n    const responseTransformer = getDefaultResponseTransformerForSolanaRpcSubscriptions({\n        allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n    });\n    return createRpcSubscriptionsApi<TApi>({\n        planExecutor({ request, ...rest }) {\n            return executeRpcPubSubSubscriptionPlan({\n                ...rest,\n                responseTransformer,\n                subscribeRequest: { ...request, methodName: request.methodName.replace(/Notifications$/, 'Subscribe') },\n                unsubscribeMethodName: request.methodName.replace(/Notifications$/, 'Unsubscribe'),\n            });\n        },\n        requestTransformer,\n    });\n}\n\nexport function createSolanaRpcSubscriptionsApi<TApi extends RpcSubscriptionsApiMethods = SolanaRpcSubscriptionsApi>(\n    config?: Config,\n): RpcSubscriptionsApi<TApi> {\n    return createSolanaRpcSubscriptionsApi_INTERNAL<TApi>(config);\n}\n\nexport function createSolanaRpcSubscriptionsApi_UNSTABLE(config?: Config) {\n    return createSolanaRpcSubscriptionsApi_INTERNAL<SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>(\n        config,\n    );\n}\n\nlet memoizedKeypaths: AllowedNumericKeypaths<\n    RpcSubscriptionsApi<SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>\n>;\n\n/**\n * These are keypaths at the end of which you will find a numeric value that should *not* be upcast\n * to a `bigint`. These are values that are legitimately defined as `u8` or `usize` on the backend.\n */\nfunction getAllowedNumericKeypaths(): AllowedNumericKeypaths<\n    RpcSubscriptionsApi<SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>\n> {\n    if (!memoizedKeypaths) {\n        memoizedKeypaths = {\n            accountNotifications: jsonParsedAccountsConfigs.map(c => ['value', ...c]),\n            blockNotifications: [\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'preTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'accountIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'preTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'postTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'accountIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'postTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['value', 'block', 'transactions', KEYPATH_WILDCARD, 'meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'index',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'programIdIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'accounts',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'addressTableLookups',\n                    KEYPATH_WILDCARD,\n                    'writableIndexes',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'addressTableLookups',\n                    KEYPATH_WILDCARD,\n                    'readonlyIndexes',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'programIdIndex',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'instructions',\n                    KEYPATH_WILDCARD,\n                    'accounts',\n                    KEYPATH_WILDCARD,\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'header',\n                    'numReadonlySignedAccounts',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'header',\n                    'numReadonlyUnsignedAccounts',\n                ],\n                [\n                    'value',\n                    'block',\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'transaction',\n                    'message',\n                    'header',\n                    'numRequiredSignatures',\n                ],\n                ['value', 'block', 'rewards', KEYPATH_WILDCARD, 'commission'],\n            ],\n            programNotifications: jsonParsedAccountsConfigs.flatMap(c => [\n                ['value', KEYPATH_WILDCARD, 'account', ...c],\n                [KEYPATH_WILDCARD, 'account', ...c],\n            ]),\n        };\n    }\n    return memoizedKeypaths;\n}\n", "export const AbortController = globalThis.AbortController;\nexport const EventTarget = globalThis.EventTarget;\n", "export default globalThis.WebSocket;\n", "import {\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SolanaError,\n} from '@solana/errors';\nimport { EventTarget } from '@solana/event-target-impl';\nimport { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\nimport { getDataPublisherFromEventEmitter } from '@solana/subscribable';\nimport WebSocket from '@solana/ws-impl';\n\nexport type Config = Readonly<{\n    /**\n     * The number of bytes to admit into the WebSocket's send buffer before queueing messages on the\n     * client.\n     *\n     * When you call {@link RpcSubscriptionsChannel.send | `send()`} on a `WebSocket` the runtime\n     * might add the message to a buffer rather than send it right away. In the event that\n     * `socket.bufferedAmount` exceeds the value configured here, messages will be added to a queue\n     * in your application code instead of being sent to the WebSocket, until such time as the\n     * `bufferedAmount` falls back below the high watermark.\n     */\n    sendBufferHighWatermark: number;\n    /**\n     * An `AbortSignal` to fire when you want to explicitly close the `WebSocket`.\n     *\n     * If the channel is open it will be closed with a normal closure code\n     * (https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1) If the channel has not been\n     * established yet, firing this signal will result in the `AbortError` being thrown to the\n     * caller who was trying to open the channel.\n     */\n    signal: AbortSignal;\n    /**\n     * A string representing the target endpoint.\n     *\n     * In Node, it must be an absolute URL using the `ws` or `wss` protocol.\n     */\n    url: string;\n}>;\n\ntype WebSocketMessage = ArrayBufferLike | ArrayBufferView | Blob | string;\n\nconst NORMAL_CLOSURE_CODE = 1000; // https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1\n\n/**\n * Creates an object that represents an open channel to a `WebSocket` server.\n *\n * You can use it to send messages by calling its\n * {@link RpcSubscriptionsChannel.send | `send()`} function and you can receive them by subscribing\n * to the {@link RpcSubscriptionChannelEvents} it emits.\n */\nexport function createWebSocketChannel({\n    sendBufferHighWatermark,\n    signal,\n    url,\n}: Config): Promise<RpcSubscriptionsChannel<WebSocketMessage, string>> {\n    if (signal.aborted) {\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        return Promise.reject(signal.reason);\n    }\n    let bufferDrainWatcher: Readonly<{ onCancel(): void; promise: Promise<void> }> | undefined;\n    let hasConnected = false;\n    const listenerRemovers = new Set<() => void>();\n    function cleanupListeners() {\n        listenerRemovers.forEach(r => {\n            r();\n        });\n        listenerRemovers.clear();\n    }\n    function handleAbort() {\n        cleanupListeners();\n        if (!hasConnected) {\n            rejectOpen(signal.reason);\n        }\n        if (webSocket.readyState !== WebSocket.CLOSED && webSocket.readyState !== WebSocket.CLOSING) {\n            webSocket.close(NORMAL_CLOSURE_CODE);\n        }\n    }\n    function handleClose(ev: CloseEvent) {\n        cleanupListeners();\n        bufferDrainWatcher?.onCancel();\n        signal.removeEventListener('abort', handleAbort);\n        webSocket.removeEventListener('close', handleClose);\n        webSocket.removeEventListener('error', handleError);\n        webSocket.removeEventListener('message', handleMessage);\n        webSocket.removeEventListener('open', handleOpen);\n        if (!signal.aborted && !(ev.wasClean && ev.code === NORMAL_CLOSURE_CODE)) {\n            eventTarget.dispatchEvent(\n                new CustomEvent('error', {\n                    detail: new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED, {\n                        cause: ev,\n                    }),\n                }),\n            );\n        }\n    }\n    function handleError(ev: Event) {\n        if (signal.aborted) {\n            return;\n        }\n        if (!hasConnected) {\n            const failedToConnectError = new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT, {\n                errorEvent: ev,\n            });\n            rejectOpen(failedToConnectError);\n            eventTarget.dispatchEvent(\n                new CustomEvent('error', {\n                    detail: failedToConnectError,\n                }),\n            );\n        }\n    }\n    function handleMessage(ev: MessageEvent) {\n        if (signal.aborted) {\n            return;\n        }\n        eventTarget.dispatchEvent(new CustomEvent('message', { detail: ev.data }));\n    }\n    const eventTarget = new EventTarget();\n    const dataPublisher = getDataPublisherFromEventEmitter(eventTarget);\n    function handleOpen() {\n        hasConnected = true;\n        resolveOpen({\n            ...dataPublisher,\n            async send(message) {\n                if (webSocket.readyState !== WebSocket.OPEN) {\n                    throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED);\n                }\n                if (!bufferDrainWatcher && webSocket.bufferedAmount > sendBufferHighWatermark) {\n                    let onCancel!: () => void;\n                    const promise = new Promise<void>((resolve, reject) => {\n                        const intervalId = setInterval(() => {\n                            if (\n                                webSocket.readyState !== WebSocket.OPEN ||\n                                !(webSocket.bufferedAmount > sendBufferHighWatermark)\n                            ) {\n                                clearInterval(intervalId);\n                                bufferDrainWatcher = undefined;\n                                resolve();\n                            }\n                        }, 16);\n                        onCancel = () => {\n                            bufferDrainWatcher = undefined;\n                            clearInterval(intervalId);\n                            reject(\n                                new SolanaError(\n                                    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n                                ),\n                            );\n                        };\n                    });\n                    bufferDrainWatcher = {\n                        onCancel,\n                        promise,\n                    };\n                }\n                if (bufferDrainWatcher) {\n                    if (ArrayBuffer.isView(message) && !(message instanceof DataView)) {\n                        const TypedArrayConstructor = message.constructor as {\n                            new (...args: [typeof message]): typeof message;\n                        };\n                        // Clone the message to prevent mutation while queued.\n                        message = new TypedArrayConstructor(message);\n                    }\n                    await bufferDrainWatcher.promise;\n                }\n                webSocket.send(message);\n            },\n        });\n    }\n    const webSocket = new WebSocket(url);\n    signal.addEventListener('abort', handleAbort);\n    webSocket.addEventListener('close', handleClose);\n    webSocket.addEventListener('error', handleError);\n    webSocket.addEventListener('message', handleMessage);\n    webSocket.addEventListener('open', handleOpen);\n    let rejectOpen!: (e: SolanaError) => void;\n    let resolveOpen!: (value: RpcSubscriptionsChannel<WebSocketMessage, string>) => void;\n    return new Promise<RpcSubscriptionsChannel<WebSocketMessage, string>>((resolve, reject) => {\n        rejectOpen = reject;\n        resolveOpen = resolve;\n    });\n}\n", "import { safeCaptureStackTrace, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, SolanaError } from '@solana/errors';\nimport type { KeyPath } from '@solana/rpc-transformers';\n\nexport function createSolanaJsonRpcIntegerOverflowError(\n    methodName: string,\n    keyPath: KeyPath,\n    value: bigint,\n): SolanaError<typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW> {\n    let argumentLabel = '';\n    if (typeof keyPath[0] === 'number') {\n        const argPosition = keyPath[0] + 1;\n        const lastDigit = argPosition % 10;\n        const lastTwoDigits = argPosition % 100;\n        if (lastDigit == 1 && lastTwoDigits != 11) {\n            argumentLabel = argPosition + 'st';\n        } else if (lastDigit == 2 && lastTwoDigits != 12) {\n            argumentLabel = argPosition + 'nd';\n        } else if (lastDigit == 3 && lastTwoDigits != 13) {\n            argumentLabel = argPosition + 'rd';\n        } else {\n            argumentLabel = argPosition + 'th';\n        }\n    } else {\n        argumentLabel = `\\`${keyPath[0].toString()}\\``;\n    }\n    const path =\n        keyPath.length > 1\n            ? keyPath\n                  .slice(1)\n                  .map(pathPart => (typeof pathPart === 'number' ? `[${pathPart}]` : pathPart))\n                  .join('.')\n            : undefined;\n    const error = new SolanaError(SOLANA_ERROR__RPC__INTEGER_OVERFLOW, {\n        argumentLabel,\n        keyPath: keyPath as readonly (number | string | symbol)[],\n        methodName,\n        optionalPathLabel: path ? ` at path \\`${path}\\`` : '',\n        value,\n        ...(path !== undefined ? { path } : undefined),\n    });\n    safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError);\n    return error;\n}\n", "import type { createSolanaRpcSubscriptionsApi } from '@solana/rpc-subscriptions-api';\n\nimport { createSolanaJsonRpcIntegerOverflowError } from './rpc-integer-overflow-error';\n\nexport const DEFAULT_RPC_SUBSCRIPTIONS_CONFIG: Partial<\n    NonNullable<Parameters<typeof createSolanaRpcSubscriptionsApi>[0]>\n> = {\n    defaultCommitment: 'confirmed',\n    onIntegerOverflow(request, keyPath, value) {\n        throw createSolanaJsonRpcIntegerOverflowError(request.methodName, keyPath, value);\n    },\n};\n", "export const AbortController = globalThis.AbortController;\nexport const EventTarget = globalThis.EventTarget;\n", "import { isSolanaError, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED } from '@solana/errors';\nimport { AbortController } from '@solana/event-target-impl';\nimport type { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\n\ntype Config<TChannel extends RpcSubscriptionsChannel<unknown, unknown>> = Readonly<{\n    abortSignal: AbortSignal;\n    channel: TChannel;\n    intervalMs: number;\n}>;\n\nconst PING_PAYLOAD = {\n    jsonrpc: '2.0',\n    method: 'ping',\n} as const;\n\n/**\n * Given a {@link RpcSubscriptionsChannel}, will return a new channel that sends a ping message to\n * the inner channel if a message has not been sent or received in the last `intervalMs`. In web\n * browsers, this implementation sends no ping when the network is down, and sends a ping\n * immediately upon the network coming back up.\n */\nexport function getRpcSubscriptionsChannelWithAutoping<TChannel extends RpcSubscriptionsChannel<object, unknown>>({\n    abortSignal: callerAbortSignal,\n    channel,\n    intervalMs,\n}: Config<TChannel>): TChannel {\n    let intervalId: ReturnType<typeof setInterval> | undefined;\n    function sendPing() {\n        channel.send(PING_PAYLOAD).catch((e: unknown) => {\n            if (isSolanaError(e, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED)) {\n                pingerAbortController.abort();\n            }\n        });\n    }\n    function restartPingTimer() {\n        clearInterval(intervalId);\n        intervalId = setInterval(sendPing, intervalMs);\n    }\n    const pingerAbortController = new AbortController();\n    pingerAbortController.signal.addEventListener('abort', () => {\n        clearInterval(intervalId);\n    });\n    callerAbortSignal.addEventListener('abort', () => {\n        pingerAbortController.abort();\n    });\n    channel.on(\n        'error',\n        () => {\n            pingerAbortController.abort();\n        },\n        { signal: pingerAbortController.signal },\n    );\n    channel.on('message', restartPingTimer, { signal: pingerAbortController.signal });\n    if (!__BROWSER__ || globalThis.navigator.onLine) {\n        restartPingTimer();\n    }\n    if (__BROWSER__) {\n        globalThis.addEventListener(\n            'offline',\n            function handleOffline() {\n                clearInterval(intervalId);\n            },\n            { signal: pingerAbortController.signal },\n        );\n        globalThis.addEventListener(\n            'online',\n            function handleOnline() {\n                sendPing();\n                restartPingTimer();\n            },\n            { signal: pingerAbortController.signal },\n        );\n    }\n    return {\n        ...channel,\n        send(...args) {\n            if (!pingerAbortController.signal.aborted) {\n                restartPingTimer();\n            }\n            return channel.send(...args);\n        },\n    };\n}\n", "import { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\n\nexport type ChannelPoolEntry = {\n    channel: PromiseLike<RpcSubscriptionsChannel<unknown, unknown>> | RpcSubscriptionsChannel<unknown, unknown>;\n    readonly dispose: () => void;\n    subscriptionCount: number;\n};\n\ntype ChannelPool = { readonly entries: ChannelPoolEntry[]; freeChannelIndex: number };\n\nexport function createChannelPool(): ChannelPool {\n    return {\n        entries: [],\n        freeChannelIndex: -1,\n    };\n}\n", "import { AbortController } from '@solana/event-target-impl';\nimport { RpcSubscriptionsChannelCreator } from '@solana/rpc-subscriptions-spec';\n\nimport { ChannelPoolEntry, createChannelPool } from './rpc-subscriptions-channel-pool-internal';\n\ntype Config = Readonly<{\n    maxSubscriptionsPerChannel: number;\n    minChannels: number;\n}>;\n\n/**\n * Given a channel creator, will return a new channel creator with the following behavior.\n *\n * 1. When called, returns a {@link RpcSubscriptionsChannel}. Adds that channel to a pool.\n * 2. When called again, creates and returns new\n *    {@link RpcSubscriptionChannel | RpcSubscriptionChannels} up to the number specified by\n *    `minChannels`.\n * 3. When `minChannels` channels have been created, subsequent calls vend whichever existing\n *    channel from the pool has the fewest subscribers, or the next one in rotation in the event of\n *    a tie.\n * 4. Once all channels carry the number of subscribers specified by the number\n *    `maxSubscriptionsPerChannel`, new channels in excess of `minChannel` will be created,\n *    returned, and added to the pool.\n * 5. A channel will be destroyed once all of its subscribers' abort signals fire.\n */\nexport function getChannelPoolingChannelCreator<\n    TChannelCreator extends RpcSubscriptionsChannelCreator<unknown, unknown>,\n>(createChannel: TChannelCreator, { maxSubscriptionsPerChannel, minChannels }: Config): TChannelCreator {\n    const pool = createChannelPool();\n    /**\n     * This function advances the free channel index to the pool entry with the most capacity. It\n     * sets the index to `-1` if all channels are full.\n     */\n    function recomputeFreeChannelIndex() {\n        if (pool.entries.length < minChannels) {\n            // Don't set the free channel index until the pool fills up; we want to keep creating\n            // channels before we start rotating among them.\n            pool.freeChannelIndex = -1;\n            return;\n        }\n        let mostFreeChannel: Readonly<{ poolIndex: number; subscriptionCount: number }> | undefined;\n        for (let ii = 0; ii < pool.entries.length; ii++) {\n            const nextPoolIndex = (pool.freeChannelIndex + ii + 2) % pool.entries.length;\n            const nextPoolEntry =\n                // Start from the item two positions after the current item. This way, the\n                // search will finish on the item after the current one. This ensures that, if\n                // any channels tie for having the most capacity, the one that will be chosen is\n                // the one immediately to the current one's right (wrapping around).\n                pool.entries[nextPoolIndex];\n            if (\n                nextPoolEntry.subscriptionCount < maxSubscriptionsPerChannel &&\n                (!mostFreeChannel || mostFreeChannel.subscriptionCount >= nextPoolEntry.subscriptionCount)\n            ) {\n                mostFreeChannel = {\n                    poolIndex: nextPoolIndex,\n                    subscriptionCount: nextPoolEntry.subscriptionCount,\n                };\n            }\n        }\n        pool.freeChannelIndex = mostFreeChannel?.poolIndex ?? -1;\n    }\n    return function getExistingChannelWithMostCapacityOrCreateChannel({ abortSignal }) {\n        let poolEntry: ChannelPoolEntry;\n        function destroyPoolEntry() {\n            const index = pool.entries.findIndex(entry => entry === poolEntry);\n            pool.entries.splice(index, 1);\n            poolEntry.dispose();\n            recomputeFreeChannelIndex();\n        }\n        if (pool.freeChannelIndex === -1) {\n            const abortController = new AbortController();\n            const newChannelPromise = createChannel({ abortSignal: abortController.signal });\n            newChannelPromise\n                .then(newChannel => {\n                    newChannel.on('error', destroyPoolEntry, { signal: abortController.signal });\n                })\n                .catch(destroyPoolEntry);\n            poolEntry = {\n                channel: newChannelPromise,\n                dispose() {\n                    abortController.abort();\n                },\n                subscriptionCount: 0,\n            };\n            pool.entries.push(poolEntry);\n        } else {\n            poolEntry = pool.entries[pool.freeChannelIndex];\n        }\n        /**\n         * A note about subscription counts.\n         * Because of https://github.com/solana-labs/solana/pull/18943, two subscriptions for\n         * materially the same notification will be coalesced on the server. This means they will be\n         * assigned the same subscription id, and will occupy one subscription slot. We can't tell,\n         * from here, whether a subscription will be treated in this way or not, so we\n         * unconditionally increment the subscription count every time a subscription request is\n         * made. This may result in subscription channels being treated as out-of-capacity when in\n         * fact they are not.\n         */\n        poolEntry.subscriptionCount++;\n        abortSignal.addEventListener('abort', function destroyConsumer() {\n            poolEntry.subscriptionCount--;\n            if (poolEntry.subscriptionCount === 0) {\n                destroyPoolEntry();\n            } else if (pool.freeChannelIndex !== -1) {\n                // Back the free channel index up one position, and recompute it.\n                pool.freeChannelIndex--;\n                recomputeFreeChannelIndex();\n            }\n        });\n        recomputeFreeChannelIndex();\n        return poolEntry.channel;\n    } as TChannelCreator;\n}\n", "import { pipe } from '@solana/functional';\nimport {\n    RpcSubscriptionsChannel,\n    transformChannelInboundMessages,\n    transformChannelOutboundMessages,\n} from '@solana/rpc-subscriptions-spec';\n\n/**\n * Given a {@link RpcSubscriptionsChannel}, will return a new channel that parses data published to\n * the `'message'` channel as JSON, and JSON-stringifies messages sent via the\n * {@link RpcSubscriptionsChannel.send | send(message)} method.\n */\nexport function getRpcSubscriptionsChannelWithJSONSerialization(\n    channel: RpcSubscriptionsChannel<string, string>,\n): RpcSubscriptionsChannel<unknown, unknown> {\n    return pipe(\n        channel,\n        c => transformChannelInboundMessages(c, JSON.parse),\n        c => transformChannelOutboundMessages(c, JSON.stringify),\n    );\n}\n", "import { pipe } from '@solana/functional';\nimport { parseJsonWithBigInts, stringifyJsonWithBigints } from '@solana/rpc-spec-types';\nimport {\n    RpcSubscriptionsChannel,\n    transformChannelInboundMessages,\n    transformChannelOutboundMessages,\n} from '@solana/rpc-subscriptions-spec';\n\n/**\n * Similarly, to {@link getRpcSubscriptionsChannelWithJSONSerialization}, this function will\n * stringify and parse JSON message to and from the given `string` channel. However, this function\n * parses any integer value as a `BigInt` in order to safely handle numbers that exceed the\n * JavaScript [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\n * value.\n */\nexport function getRpcSubscriptionsChannelWithBigIntJSONSerialization(\n    channel: RpcSubscriptionsChannel<string, string>,\n): RpcSubscriptionsChannel<unknown, unknown> {\n    return pipe(\n        channel,\n        c => transformChannelInboundMessages(c, parseJsonWithBigInts),\n        c => transformChannelOutboundMessages(c, stringifyJsonWithBigints),\n    );\n}\n", "import { createWebSocketChannel } from '@solana/rpc-subscriptions-channel-websocket';\nimport type { RpcSubscriptionsChannel } from '@solana/rpc-subscriptions-spec';\nimport type { ClusterUrl } from '@solana/rpc-types';\n\nimport { getRpcSubscriptionsChannelWithAutoping } from './rpc-subscriptions-autopinger';\nimport { getChannelPoolingChannelCreator } from './rpc-subscriptions-channel-pool';\nimport { RpcSubscriptionsChannelCreatorFromClusterUrl } from './rpc-subscriptions-clusters';\nimport { getRpcSubscriptionsChannelWithJSONSerialization } from './rpc-subscriptions-json';\nimport { getRpcSubscriptionsChannelWithBigIntJSONSerialization } from './rpc-subscriptions-json-bigint';\n\nexport type DefaultRpcSubscriptionsChannelConfig<TClusterUrl extends ClusterUrl> = Readonly<{\n    /**\n     * The number of milliseconds to wait since the last message sent or received over the channel\n     * before sending a ping message to keep the channel open.\n     */\n    intervalMs?: number;\n    /**\n     * The number of subscribers that may share a channel before a new channel must be created.\n     *\n     * It is important that you set this to the maximum number of subscriptions that your RPC\n     * provider recommends making over a single connection; the default is set deliberately low, so\n     * as to comply with the restrictive limits of the public mainnet RPC node.\n     *\n     * @defaultValue 100\n     */\n    maxSubscriptionsPerChannel?: number;\n    /** The number of channels to create before reusing a channel for a new subscription. */\n    minChannels?: number;\n    /**\n     * The number of bytes of data to admit into the\n     * [`WebSocket`](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket) buffer before\n     * buffering data on the client.\n     */\n    sendBufferHighWatermark?: number;\n    /** The URL of the web socket server. Must use the `ws` or `wss` protocols. */\n    url: TClusterUrl;\n}>;\n\n/**\n * Similar to {@link createDefaultRpcSubscriptionsChannelCreator} with some Solana-specific\n * defaults.\n *\n * For instance, it safely handles `BigInt` values in JSON messages since Solana RPC servers accept\n * and return integers larger than [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER).\n */\nexport function createDefaultSolanaRpcSubscriptionsChannelCreator<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl>,\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    return createDefaultRpcSubscriptionsChannelCreatorImpl({\n        ...config,\n        jsonSerializer: getRpcSubscriptionsChannelWithBigIntJSONSerialization,\n    });\n}\n\n/**\n * Creates a function that returns new subscription channels when called.\n */\nexport function createDefaultRpcSubscriptionsChannelCreator<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl>,\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    return createDefaultRpcSubscriptionsChannelCreatorImpl({\n        ...config,\n        jsonSerializer: getRpcSubscriptionsChannelWithJSONSerialization,\n    });\n}\n\nfunction createDefaultRpcSubscriptionsChannelCreatorImpl<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcSubscriptionsChannelConfig<TClusterUrl> & {\n        jsonSerializer: (channel: RpcSubscriptionsChannel<string, string>) => RpcSubscriptionsChannel<unknown, unknown>;\n    },\n): RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown> {\n    if (/^wss?:/i.test(config.url) === false) {\n        const protocolMatch = config.url.match(/^([^:]+):/);\n        throw new DOMException(\n            protocolMatch\n                ? \"Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or \" +\n                  `'wss'. '${protocolMatch[1]}:' is not allowed.`\n                : `Failed to construct 'WebSocket': The URL '${config.url}' is invalid.`,\n        );\n    }\n    const { intervalMs, ...rest } = config;\n    const createDefaultRpcSubscriptionsChannel = (({ abortSignal }) => {\n        return createWebSocketChannel({\n            ...rest,\n            sendBufferHighWatermark:\n                config.sendBufferHighWatermark ??\n                // Let 128KB of data into the WebSocket buffer before buffering it in the app.\n                131_072,\n            signal: abortSignal,\n        })\n            .then(config.jsonSerializer)\n            .then(channel =>\n                getRpcSubscriptionsChannelWithAutoping({\n                    abortSignal,\n                    channel,\n                    intervalMs: intervalMs ?? 5_000,\n                }),\n            );\n    }) as RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown>;\n    return getChannelPoolingChannelCreator(createDefaultRpcSubscriptionsChannel, {\n        maxSubscriptionsPerChannel:\n            config.maxSubscriptionsPerChannel ??\n            /**\n             * A note about this default. The idea here is that, because some RPC providers impose\n             * an upper limit on the number of subscriptions you can make per channel, we must\n             * choose a number low enough to avoid hitting that limit. Without knowing what provider\n             * a given person is using, or what their limit is, we have to choose the lowest of all\n             * known limits. As of this writing (October 2024) that is the public mainnet RPC node\n             * (api.mainnet-beta.solana.com) at 100 subscriptions.\n             */\n            100,\n        minChannels: config.minChannels ?? 1,\n    });\n}\n", "import { AbortController } from '@solana/event-target-impl';\nimport fastStableStringify from '@solana/fast-stable-stringify';\nimport { RpcSubscriptionsTransport } from '@solana/rpc-subscriptions-spec';\nimport { DataPublisher } from '@solana/subscribable';\n\ntype CacheEntry = {\n    readonly abortController: AbortController;\n    readonly dataPublisherPromise: Promise<DataPublisher>;\n    numSubscribers: number;\n};\n\n/**\n * Given a {@link RpcSubscriptionsTransport}, will return a new transport that coalesces identical\n * subscriptions into a single subscription request to the server. The determination of whether a\n * subscription is the same as another is based on the `rpcRequest` returned by its\n * {@link RpcSubscriptionsPlan}. The subscription will only be aborted once all subscribers abort,\n * or there is an error.\n */\nexport function getRpcSubscriptionsTransportWithSubscriptionCoalescing<TTransport extends RpcSubscriptionsTransport>(\n    transport: TTransport,\n): TTransport {\n    const cache = new Map<string, CacheEntry>();\n    return function rpcSubscriptionsTransportWithSubscriptionCoalescing(config) {\n        const { request, signal } = config;\n        const subscriptionConfigurationHash = fastStableStringify([request.methodName, request.params]);\n\n        let cachedDataPublisherPromise = cache.get(subscriptionConfigurationHash);\n        if (!cachedDataPublisherPromise) {\n            const abortController = new AbortController();\n            const dataPublisherPromise = transport({\n                ...config,\n                signal: abortController.signal,\n            });\n            dataPublisherPromise\n                .then(dataPublisher => {\n                    dataPublisher.on(\n                        'error',\n                        () => {\n                            cache.delete(subscriptionConfigurationHash);\n                            abortController.abort();\n                        },\n                        { signal: abortController.signal },\n                    );\n                })\n                .catch(() => {});\n            cache.set(\n                subscriptionConfigurationHash,\n                (cachedDataPublisherPromise = {\n                    abortController,\n                    dataPublisherPromise,\n                    numSubscribers: 0,\n                }),\n            );\n        }\n        cachedDataPublisherPromise.numSubscribers++;\n        signal.addEventListener(\n            'abort',\n            () => {\n                cachedDataPublisherPromise.numSubscribers--;\n                if (cachedDataPublisherPromise.numSubscribers === 0) {\n                    queueMicrotask(() => {\n                        if (cachedDataPublisherPromise.numSubscribers === 0) {\n                            cache.delete(subscriptionConfigurationHash);\n                            cachedDataPublisherPromise.abortController.abort();\n                        }\n                    });\n                }\n            },\n            { signal: cachedDataPublisherPromise.abortController.signal },\n        );\n        return cachedDataPublisherPromise.dataPublisherPromise;\n    } as TTransport;\n}\n", "import { pipe } from '@solana/functional';\nimport { RpcSubscriptionsChannelCreator, RpcSubscriptionsTransport } from '@solana/rpc-subscriptions-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport {\n    RpcSubscriptionsChannelCreatorDevnet,\n    RpcSubscriptionsChannelCreatorFromClusterUrl,\n    RpcSubscriptionsChannelCreatorMainnet,\n    RpcSubscriptionsChannelCreatorTestnet,\n    RpcSubscriptionsTransportDevnet,\n    RpcSubscriptionsTransportFromClusterUrl,\n    RpcSubscriptionsTransportMainnet,\n    RpcSubscriptionsTransportTestnet,\n} from './rpc-subscriptions-clusters';\nimport { getRpcSubscriptionsTransportWithSubscriptionCoalescing } from './rpc-subscriptions-coalescer';\n\nexport type DefaultRpcSubscriptionsTransportConfig<TClusterUrl extends ClusterUrl> = Readonly<{\n    createChannel: RpcSubscriptionsChannelCreatorFromClusterUrl<TClusterUrl, unknown, unknown>;\n}>;\n\n/**\n * Creates a {@link RpcSubscriptionsTransport} with some default behaviours.\n *\n * The default behaviours include:\n * - Logic that coalesces multiple subscriptions for the same notifications with the same arguments\n *   into a single subscription.\n *\n * @param config\n */\nexport function createDefaultRpcSubscriptionsTransport<TClusterUrl extends ClusterUrl>({\n    createChannel,\n}: DefaultRpcSubscriptionsTransportConfig<TClusterUrl>) {\n    return pipe(\n        createRpcSubscriptionsTransportFromChannelCreator(\n            createChannel,\n        ) as RpcSubscriptionsTransport as RpcSubscriptionsTransportFromClusterUrl<TClusterUrl>,\n        transport => getRpcSubscriptionsTransportWithSubscriptionCoalescing(transport),\n    );\n}\n\nexport function createRpcSubscriptionsTransportFromChannelCreator<\n    TChannelCreator extends RpcSubscriptionsChannelCreator<TOutboundMessage, TInboundMessage>,\n    TInboundMessage,\n    TOutboundMessage,\n>(createChannel: TChannelCreator) {\n    return (async ({ execute, signal }) => {\n        const channel = await createChannel({ abortSignal: signal });\n        return await execute({ channel, signal });\n    }) as TChannelCreator extends RpcSubscriptionsChannelCreatorDevnet<TOutboundMessage, TInboundMessage>\n        ? RpcSubscriptionsTransportDevnet\n        : TChannelCreator extends RpcSubscriptionsChannelCreatorTestnet<TOutboundMessage, TInboundMessage>\n          ? RpcSubscriptionsTransportTestnet\n          : TChannelCreator extends RpcSubscriptionsChannelCreatorMainnet<TOutboundMessage, TInboundMessage>\n            ? RpcSubscriptionsTransportMainnet\n            : RpcSubscriptionsTransport;\n}\n", "import type { SolanaRpcSubscriptionsApi, SolanaRpcSubscriptionsApiUnstable } from '@solana/rpc-subscriptions-api';\nimport { createSolanaRpcSubscriptionsApi } from '@solana/rpc-subscriptions-api';\nimport {\n    createSubscriptionRpc,\n    RpcSubscriptionsApiMethods,\n    type RpcSubscriptionsTransport,\n} from '@solana/rpc-subscriptions-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport { DEFAULT_RPC_SUBSCRIPTIONS_CONFIG } from './rpc-default-config';\nimport {\n    createDefaultSolanaRpcSubscriptionsChannelCreator,\n    DefaultRpcSubscriptionsChannelConfig,\n} from './rpc-subscriptions-channel';\nimport type { RpcSubscriptionsFromTransport } from './rpc-subscriptions-clusters';\nimport { createDefaultRpcSubscriptionsTransport } from './rpc-subscriptions-transport';\n\ntype Config<TClusterUrl extends ClusterUrl> = DefaultRpcSubscriptionsChannelConfig<TClusterUrl>;\n\nfunction createSolanaRpcSubscriptionsImpl<TClusterUrl extends ClusterUrl, TApi extends RpcSubscriptionsApiMethods>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    const transport = createDefaultRpcSubscriptionsTransport({\n        createChannel: createDefaultSolanaRpcSubscriptionsChannelCreator({ ...config, url: clusterUrl }),\n    });\n    return createSolanaRpcSubscriptionsFromTransport<typeof transport, TApi>(transport);\n}\n\n/**\n * Creates a {@link RpcSubscriptions} instance that exposes the Solana JSON RPC WebSocket API given\n * a cluster URL and some optional channel config. See\n * {@link createDefaultRpcSubscriptionsChannelCreator} for the shape of the channel config.\n */\nexport function createSolanaRpcSubscriptions<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcSubscriptionsImpl<TClusterUrl, SolanaRpcSubscriptionsApi>(clusterUrl, config);\n}\n\n/**\n * Creates a {@link RpcSubscriptions} instance that exposes the Solana JSON RPC WebSocket API,\n * including its unstable methods, given a cluster URL and some optional channel config. See\n * {@link createDefaultRpcSubscriptionsChannelCreator} for the shape of the channel config.\n */\nexport function createSolanaRpcSubscriptions_UNSTABLE<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<Config<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcSubscriptionsImpl<TClusterUrl, SolanaRpcSubscriptionsApi & SolanaRpcSubscriptionsApiUnstable>(\n        clusterUrl,\n        config,\n    );\n}\n\n/**\n * Creates a {@link RpcSubscriptions} instance that exposes the Solana JSON RPC WebSocket API given\n * the supplied {@link RpcSubscriptionsTransport}.\n */\nexport function createSolanaRpcSubscriptionsFromTransport<\n    TTransport extends RpcSubscriptionsTransport,\n    TApi extends RpcSubscriptionsApiMethods = SolanaRpcSubscriptionsApi,\n>(transport: TTransport) {\n    return createSubscriptionRpc({\n        api: createSolanaRpcSubscriptionsApi<TApi>(DEFAULT_RPC_SUBSCRIPTIONS_CONFIG),\n        transport,\n    }) as RpcSubscriptionsFromTransport<TApi, TTransport>;\n}\n", "import { Address, assertIsAddress, getAddressDecoder, getAddressEncoder, isAddress } from '@solana/addresses';\nimport { combineCodec, createEncoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nexport type Blockhash = Brand<EncodedString<string, 'base58'>, 'Blockhash'>;\n\n/**\n * A type guard that returns `true` if the input string conforms to the {@link Blockhash} type, and\n * refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isBlockhash } from '@solana/rpc-types';\n *\n * if (isBlockhash(blockhash)) {\n *     // At this point, `blockhash` has been refined to a\n *     // `Blockhash` that can be used with the RPC.\n *     const { value: isValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsFresh(isValid);\n * } else {\n *     setError(`${blockhash} is not a blockhash`);\n * }\n * ```\n */\nexport function isBlockhash(putativeBlockhash: string): putativeBlockhash is Blockhash {\n    return isAddress(putativeBlockhash);\n}\n\n/**\n * From time to time you might acquire a string, that you expect to validate as a blockhash, from an\n * untrusted network API or user input. Use this function to assert that such an arbitrary string is\n * a base58-encoded blockhash.\n *\n * @example\n * ```ts\n * import { assertIsBlockhash } from '@solana/rpc-types';\n *\n * // Imagine a function that determines whether a blockhash is fresh when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const blockhash: string = blockhashInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `blockhash` to `Blockhash`.\n *         assertIsBlockhash(blockhash);\n *         // At this point, `blockhash` is a `Blockhash` that can be used with the RPC.\n *         const { value: isValid } = await rpc.isBlockhashValid(blockhash).send();\n *     } catch (e) {\n *         // `blockhash` turned out not to be a base58-encoded blockhash\n *     }\n * }\n * ```\n */\nexport function assertIsBlockhash(putativeBlockhash: string): asserts putativeBlockhash is Blockhash {\n    try {\n        assertIsAddress(putativeBlockhash);\n    } catch (error) {\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE)) {\n            throw new SolanaError(SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, error.context);\n        }\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH)) {\n            throw new SolanaError(SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, error.context);\n        }\n        throw error;\n    }\n}\n\n/**\n * Combines _asserting_ that a string is a blockhash with _coercing_ it to the {@link Blockhash}\n * type. It's most useful with untrusted input.\n *\n * @example\n * ```ts\n * import { blockhash } from '@solana/rpc-types';\n *\n * const { value: isValid } = await rpc.isBlockhashValid(blockhash(blockhashFromUserInput)).send();\n * ```\n *\n * > [!TIP]\n * > When starting from a known-good blockhash as a string, it's more efficient to typecast it\n * rather than to use the {@link blockhash} helper, because the helper unconditionally performs\n * validation on its input.\n * >\n * > ```ts\n * > import { Blockhash } from '@solana/rpc-types';\n * >\n * > const blockhash = 'ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48' as Blockhash;\n * > ```\n */\nexport function blockhash(putativeBlockhash: string): Blockhash {\n    assertIsBlockhash(putativeBlockhash);\n    return putativeBlockhash;\n}\n\n/**\n * Returns an encoder that you can use to encode a base58-encoded blockhash to a byte array.\n *\n * @example\n * ```ts\n * import { getBlockhashEncoder } from '@solana/rpc-types';\n *\n * const blockhash = 'ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48' as Blockhash;\n * const blockhashEncoder = getBlockhashEncoder();\n * const blockhashBytes = blockhashEncoder.encode(blockhash);\n * // Uint8Array(32) [\n * //   136, 123,  44, 249,  43,  19,  60,  14,\n * //   144,  16, 168, 241, 121, 111,  70, 232,\n * //   186,  26, 140, 202, 213,  64, 231,  82,\n * //   179,  66, 103, 237,  52, 117, 217,  93\n * // ]\n * ```\n */\nexport function getBlockhashEncoder(): FixedSizeEncoder<Blockhash, 32> {\n    const addressEncoder = getAddressEncoder();\n    return createEncoder({\n        fixedSize: 32,\n        write: (value: string, bytes, offset) => {\n            assertIsBlockhash(value);\n            return addressEncoder.write(value as string as Address, bytes, offset);\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to convert an array of 32 bytes representing a blockhash to\n * the base58-encoded representation of that blockhash.\n *\n * @example\n * ```ts\n * import { getBlockhashDecoder } from '@solana/rpc-types';\n *\n * const blockhashBytes = new Uint8Array([\n *     136, 123,  44, 249,  43,  19,  60,  14,\n *     144,  16, 168, 241, 121, 111,  70, 232,\n *     186,  26, 140, 202, 213,  64, 231,  82,\n *     179,  66, 103, 237,  52, 117, 217,  93\n * ]);\n * const blockhashDecoder = getBlockhashDecoder();\n * const blockhash = blockhashDecoder.decode(blockhashBytes); // ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48\n * ```\n */\nexport function getBlockhashDecoder(): FixedSizeDecoder<Blockhash, 32> {\n    return getAddressDecoder() as FixedSizeDecoder<string, 32> as FixedSizeDecoder<Blockhash, 32>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a base-58 encoded blockhash.\n *\n * @see {@link getBlockhashDecoder}\n * @see {@link getBlockhashEncoder}\n */\nexport function getBlockhashCodec(): FixedSizeCodec<Blockhash, Blockhash, 32> {\n    return combineCodec(getBlockhashEncoder(), getBlockhashDecoder());\n}\n\nexport function getBlockhashComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n", "export type MainnetUrl = string & { '~cluster': 'mainnet' };\nexport type DevnetUrl = string & { '~cluster': 'devnet' };\nexport type TestnetUrl = string & { '~cluster': 'testnet' };\nexport type ClusterUrl = DevnetUrl | MainnetUrl | TestnetUrl | string;\n\n/** Given a URL casts it to a type that is only accepted where mainnet URLs are expected. */\nexport function mainnet(putativeString: string): MainnetUrl {\n    return putativeString as MainnetUrl;\n}\n/** Given a URL casts it to a type that is only accepted where devnet URLs are expected. */\nexport function devnet(putativeString: string): DevnetUrl {\n    return putativeString as DevnetUrl;\n}\n/** Given a URL casts it to a type that is only accepted where testnet URLs are expected. */\nexport function testnet(putativeString: string): TestnetUrl {\n    return putativeString as TestnetUrl;\n}\n", "import { SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, SolanaError } from '@solana/errors';\n\n/**\n * A union of all possible commitment statuses -- each a measure of the network confirmation and\n * stake levels on a particular block.\n *\n * Read more about the statuses themselves, [here](https://docs.solana.com/cluster/commitments).\n */\nexport type Commitment = 'confirmed' | 'finalized' | 'processed';\n\nfunction getCommitmentScore(commitment: Commitment): number {\n    switch (commitment) {\n        case 'finalized':\n            return 2;\n        case 'confirmed':\n            return 1;\n        case 'processed':\n            return 0;\n        default:\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                unexpectedValue: commitment satisfies never,\n            });\n    }\n}\n\nexport function commitmentComparator(a: Commitment, b: Commitment): -1 | 0 | 1 {\n    if (a === b) {\n        return 0;\n    }\n    return getCommitmentScore(a) < getCommitmentScore(b) ? -1 : 1;\n}\n", "import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n} from '@solana/codecs-core';\nimport { getU64Decoder, getU64Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * Represents an integer value denominated in Lamports (ie. $1 \\times 10^{-9}$ ◎).\n *\n * It is represented as a `bigint` in client code and an `u64` in server code.\n */\nexport type Lamports = Brand<bigint, 'Lamports'>;\n\n// Largest possible value to be represented by a u64\nconst maxU64Value = 18446744073709551615n; // 2n ** 64n - 1n\n\nlet memoizedU64Encoder: FixedSizeEncoder<bigint | number, 8> | undefined;\nlet memoizedU64Decoder: FixedSizeDecoder<bigint, 8> | undefined;\n\nfunction getMemoizedU64Encoder(): FixedSizeEncoder<bigint | number, 8> {\n    if (!memoizedU64Encoder) memoizedU64Encoder = getU64Encoder();\n    return memoizedU64Encoder;\n}\n\nfunction getMemoizedU64Decoder(): FixedSizeDecoder<bigint, 8> {\n    if (!memoizedU64Decoder) memoizedU64Decoder = getU64Decoder();\n    return memoizedU64Decoder;\n}\n\n/**\n * This is a type guard that accepts a `bigint` as input. It will both return `true` if the integer\n * conforms to the {@link Lamports} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isLamports } from '@solana/rpc-types';\n *\n * if (isLamports(lamports)) {\n *     // At this point, `lamports` has been refined to a\n *     // `Lamports` that can be used anywhere Lamports are expected.\n *     await transfer(fromAddress, toAddress, lamports);\n * } else {\n *     setError(`${lamports} is not a quantity of Lamports`);\n * }\n * ```\n */\nexport function isLamports(putativeLamports: bigint): putativeLamports is Lamports {\n    return putativeLamports >= 0 && putativeLamports <= maxU64Value;\n}\n\n/**\n * Lamport values returned from the RPC API conform to the type {@link Lamports}. You can use a\n * value of that type wherever a quantity of Lamports is expected.\n *\n * @example\n * From time to time you might acquire a number that you expect to be a quantity of Lamports, from\n * an untrusted network API or user input. To assert that such an arbitrary number is usable as a\n * quantity of Lamports, use this function.\n *\n * ```ts\n * import { assertIsLamports } from '@solana/rpc-types';\n *\n * // Imagine a function that creates a transfer instruction when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `number` type.\n *     const lamports: number = parseInt(quantityInput.value, 10);\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `lamports` to `Lamports`.\n *         assertIsLamports(lamports);\n *         // At this point, `lamports` is a `Lamports` that can be used anywhere Lamports are expected.\n *         await transfer(fromAddress, toAddress, lamports);\n *     } catch (e) {\n *         // `lamports` turned out not to validate as a quantity of Lamports.\n *     }\n * }\n * ```\n */\nexport function assertIsLamports(putativeLamports: bigint): asserts putativeLamports is Lamports {\n    if (putativeLamports < 0 || putativeLamports > maxU64Value) {\n        throw new SolanaError(SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE);\n    }\n}\n\n/**\n * This helper combines _asserting_ that a number is a possible number of {@link Lamports} with\n * _coercing_ it to the {@link Lamports} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { lamports } from '@solana/rpc-types';\n *\n * await transfer(address(fromAddress), address(toAddress), lamports(100000n));\n * ```\n */\nexport function lamports(putativeLamports: bigint): Lamports {\n    assertIsLamports(putativeLamports);\n    return putativeLamports;\n}\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\n/**\n * Returns an encoder that you can use to encode a 64-bit {@link Lamports} value to 8 bytes in\n * little endian order.\n */\nexport function getDefaultLamportsEncoder(): FixedSizeEncoder<Lamports, 8> {\n    return getLamportsEncoder(getMemoizedU64Encoder());\n}\n\n/**\n * Returns an encoder that you can use to encode a {@link Lamports} value to a byte array.\n *\n * You must supply a number decoder that will determine how encode the numeric value.\n *\n * @example\n * ```ts\n * import { getLamportsEncoder } from '@solana/rpc-types';\n * import { getU16Encoder } from '@solana/codecs-numbers';\n *\n * const lamports = lamports(256n);\n * const lamportsEncoder = getLamportsEncoder(getU16Encoder());\n * const lamportsBytes = lamportsEncoder.encode(lamports);\n * // Uint8Array(2) [ 0, 1 ]\n * ```\n */\nexport function getLamportsEncoder<TEncoder extends NumberEncoder>(\n    innerEncoder: TEncoder,\n): Encoder<Lamports> & ExtractAdditionalProps<TEncoder, NumberEncoder> {\n    return innerEncoder;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a 64-bit little endian\n * number to a {@link Lamports} value.\n */\nexport function getDefaultLamportsDecoder(): FixedSizeDecoder<Lamports, 8> {\n    return getLamportsDecoder(getMemoizedU64Decoder());\n}\n\n/**\n * Returns a decoder that you can use to convert an array of bytes representing a number to a\n * {@link Lamports} value.\n *\n * You must supply a number decoder that will determine how many bits to use to decode the numeric\n * value.\n *\n * @example\n * ```ts\n * import { getLamportsDecoder } from '@solana/rpc-types';\n * import { getU16Decoder } from '@solana/codecs-numbers';\n *\n * const lamportsBytes = new Uint8Array([ 0, 1 ]);\n * const lamportsDecoder = getLamportsDecoder(getU16Decoder());\n * const lamports = lamportsDecoder.decode(lamportsBytes); // lamports(256n)\n * ```\n */\nexport function getLamportsDecoder<TDecoder extends NumberDecoder>(\n    innerDecoder: TDecoder,\n): Decoder<Lamports> & ExtractAdditionalProps<TDecoder, NumberDecoder> {\n    return transformDecoder<bigint | number, Lamports>(innerDecoder, value =>\n        lamports(typeof value === 'bigint' ? value : BigInt(value)),\n    ) as Decoder<Lamports> & ExtractAdditionalProps<TDecoder, NumberDecoder>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a 64-bit {@link Lamports} value.\n *\n * @see {@link getDefaultLamportsDecoder}\n * @see {@link getDefaultLamportsEncoder}\n */\nexport function getDefaultLamportsCodec(): FixedSizeCodec<Lamports, Lamports, 8> {\n    return combineCodec(getDefaultLamportsEncoder(), getDefaultLamportsDecoder());\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link Lamports} value.\n *\n * @see {@link getLamportsDecoder}\n * @see {@link getLamportsEncoder}\n */\nexport function getLamportsCodec<TCodec extends NumberCodec>(\n    innerCodec: TCodec,\n): Codec<Lamports, Lamports> & ExtractAdditionalProps<TCodec, NumberCodec> {\n    return combineCodec(getLamportsEncoder(innerCodec), getLamportsDecoder(innerCodec)) as Codec<Lamports, Lamports> &\n        ExtractAdditionalProps<TCodec, NumberCodec>;\n}\n", "import { SOLANA_ERROR__MALFORMED_BIGINT_STRING, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * This type represents a `bigint` which has been encoded as a string for transit over a transport\n * that does not support `bigint` values natively. The JSON-RPC is such a transport.\n */\nexport type StringifiedBigInt = Brand<string, 'StringifiedBigInt'>;\n\n/**\n * A type guard that returns `true` if the input string parses as a `BigInt`, and refines its type\n * for use in your program.\n *\n * @example\n * ```ts\n * import { isStringifiedBigInt } from '@solana/rpc-types';\n *\n * if (isStringifiedBigInt(bigintString)) {\n *     // At this point, `bigintString` has been refined to a `StringifiedBigInt`\n *     bigintString satisfies StringifiedBigInt; // OK\n * } else {\n *     setError(`${bigintString} does not represent a BigInt`);\n * }\n * ```\n */\nexport function isStringifiedBigInt(putativeBigInt: string): putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * From time to time you might acquire a string, that you expect to parse as a `BigInt`, from an\n * untrusted network API or user input. Use this function to assert that such an arbitrary string\n * will in fact parse as a `BigInt`.\n *\n * @example\n * ```ts\n * import { assertIsStringifiedBigInt } from '@solana/rpc-types';\n *\n * // Imagine having received a value that you presume represents the supply of some token.\n * // At this point we know only that it conforms to the `string` type.\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `supplyString` to `StringifiedBigInt`.\n *     assertIsStringifiedBigInt(supplyString);\n *     // At this point, `supplyString` is a `StringifiedBigInt`.\n *     supplyString satisfies StringifiedBigInt;\n * } catch (e) {\n *     // `supplyString` turned out not to parse as a `BigInt`\n * }\n * ```\n */\nexport function assertIsStringifiedBigInt(putativeBigInt: string): asserts putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_BIGINT_STRING, {\n            value: putativeBigInt,\n        });\n    }\n}\n\n/**\n * This helper combines _asserting_ that a string will parse as a `BigInt` with _coercing_ it to the\n * {@link StringifiedBigInt} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { stringifiedBigInt } from '@solana/rpc-types';\n *\n * const supplyString = stringifiedBigInt('1000000000');\n * ```\n */\nexport function stringifiedBigInt(putativeBigInt: string): StringifiedBigInt {\n    assertIsStringifiedBigInt(putativeBigInt);\n    return putativeBigInt;\n}\n", "import { SOLANA_ERROR__MALFORMED_NUMBER_STRING, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * This type represents a number which has been encoded as a string for transit over a transport\n * where loss of precision when using the native number type is a concern. The JSON-RPC is such a\n * transport.\n */\nexport type StringifiedNumber = Brand<string, 'StringifiedNumber'>;\n\n/**\n * A type guard that returns `true` if the input string parses as a `Number`, and refines its type\n * for use in your program.\n *\n * @example\n * ```ts\n * import { isStringifiedNumber } from '@solana/rpc-types';\n *\n * if (isStringifiedNumber(numericString)) {\n *     // At this point, `numericString` has been refined to a `StringifiedNumber`\n *     numericString satisfies StringifiedNumber; // OK\n * } else {\n *     setError(`${numericString} does not represent a number`);\n * }\n * ```\n */\nexport function isStringifiedNumber(putativeNumber: string): putativeNumber is StringifiedNumber {\n    return !Number.isNaN(Number(putativeNumber));\n}\n\n/**\n * From time to time you might acquire a string, that you expect to parse as a `Number`, from an\n * untrusted network API or user input. Use this function to assert that such an arbitrary string\n * will in fact parse as a `Number`.\n *\n * @example\n * ```ts\n * import { assertIsStringifiedNumber } from '@solana/rpc-types';\n *\n * // Imagine having received a value that you presume represents some decimal number.\n * // At this point we know only that it conforms to the `string` type.\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `decimalNumberString` to `StringifiedNumber`.\n *     assertIsStringifiedNumber(decimalNumberString);\n *     // At this point, `decimalNumberString` is a `StringifiedNumber`.\n *     decimalNumberString satisfies StringifiedNumber;\n * } catch (e) {\n *     // `decimalNumberString` turned out not to parse as a number.\n * }\n * ```\n */\nexport function assertIsStringifiedNumber(putativeNumber: string): asserts putativeNumber is StringifiedNumber {\n    if (Number.isNaN(Number(putativeNumber))) {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_NUMBER_STRING, {\n            value: putativeNumber,\n        });\n    }\n}\n\n/**\n * This helper combines _asserting_ that a string will parse as a `Number` with _coercing_ it to the\n * {@link StringifiedNumber} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { stringifiedNumber } from '@solana/rpc-types';\n *\n * const decimalNumberString = stringifiedNumber('-42.1');\n * ```\n */\nexport function stringifiedNumber(putativeNumber: string): StringifiedNumber {\n    assertIsStringifiedNumber(putativeNumber);\n    return putativeNumber;\n}\n", "import { SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * This type represents a Unix timestamp in _seconds_.\n *\n * It is represented as a `bigint` in client code and an `i64` in server code.\n */\nexport type UnixTimestamp = Brand<bigint, 'UnixTimestamp'>;\n\n// Largest possible value to be represented by an i64\nconst maxI64Value = 9223372036854775807n; // 2n ** 63n - 1n\nconst minI64Value = -9223372036854775808n; // -(2n ** 63n)\n\n/**\n * This is a type guard that accepts a `bigint` as input. It will both return `true` if the integer\n * conforms to the {@link UnixTimestamp} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isUnixTimestamp } from '@solana/rpc-types';\n *\n * if (isUnixTimestamp(timestamp)) {\n *     // At this point, `timestamp` has been refined to a\n *     // `UnixTimestamp` that can be used anywhere timestamps are expected.\n *     timestamp satisfies UnixTimestamp;\n * } else {\n *     setError(`${timestamp} is not a Unix timestamp`);\n * }\n * ```\n */\n\nexport function isUnixTimestamp(putativeTimestamp: bigint): putativeTimestamp is UnixTimestamp {\n    return putativeTimestamp >= minI64Value && putativeTimestamp <= maxI64Value;\n}\n\n/**\n * Timestamp values returned from the RPC API conform to the type {@link UnixTimestamp}. You can use\n * a value of that type wherever a timestamp is expected.\n *\n * @example\n * From time to time you might acquire a number that you expect to be a timestamp, from an untrusted\n * network API or user input. To assert that such an arbitrary number is usable as a Unix timestamp,\n * use this function.\n *\n * ```ts\n * import { assertIsUnixTimestamp } from '@solana/rpc-types';\n *\n * // Imagine having received a value that you presume represents a timestamp.\n * // At this point we know only that it conforms to the `bigint` type.\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `timestamp` to `UnixTimestamp`.\n *     assertIsUnixTimestamp(timestamp);\n *     // At this point, `timestamp` is a `UnixTimestamp`.\n *     timestamp satisfies UnixTimestamp;\n * } catch (e) {\n *     // `timestamp` turned out not to be a valid Unix timestamp\n * }\n * ```\n */\nexport function assertIsUnixTimestamp(putativeTimestamp: bigint): asserts putativeTimestamp is UnixTimestamp {\n    if (putativeTimestamp < minI64Value || putativeTimestamp > maxI64Value) {\n        throw new SolanaError(SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, {\n            value: putativeTimestamp,\n        });\n    }\n}\n\n/**\n * This helper combines _asserting_ that a `bigint` represents a Unix timestamp with _coercing_ it\n * to the {@link UnixTimestamp} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { unixTimestamp } from '@solana/rpc-types';\n *\n * const timestamp = unixTimestamp(-42n); // Wednesday, December 31, 1969 3:59:18 PM GMT-08:00\n * ```\n */\nexport function unixTimestamp(putativeTimestamp: bigint): UnixTimestamp {\n    assertIsUnixTimestamp(putativeTimestamp);\n    return putativeTimestamp;\n}\n", "import { SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SolanaError } from '@solana/errors';\nimport { type Blockhash, isBlockhash } from '@solana/rpc-types';\n\nimport { ExcludeTransactionMessageLifetime, TransactionMessageWithLifetime } from './lifetime';\nimport { BaseTransactionMessage } from './transaction-message';\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network. The transaction message will continue to be eligible to land\n * until the network considers the `blockhash` to be expired.\n *\n * This can happen when the network proceeds past the `lastValidBlockHeight` for which the blockhash\n * is considered valid, or when the network switches to a fork where that blockhash is not present.\n */\ntype BlockhashLifetimeConstraint = Readonly<{\n    /**\n     * A recent blockhash observed by the transaction proposer.\n     *\n     * The transaction message will be considered eligible to land until the network determines this\n     * blockhash to be too old, or has switched to a fork where it is not present.\n     */\n    blockhash: Blockhash;\n    /**\n     * This is the block height beyond which the network will consider the blockhash to be too old\n     * to make a transaction message eligible to land.\n     */\n    lastValidBlockHeight: bigint;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the age of the blockhash it\n * includes.\n *\n * Such a transaction can only be landed on the network if the current block height of the network\n * is less than or equal to the value of\n * `TransactionMessageWithBlockhashLifetime['lifetimeConstraint']['lastValidBlockHeight']`.\n */\nexport interface TransactionMessageWithBlockhashLifetime {\n    readonly lifetimeConstraint: BlockhashLifetimeConstraint;\n}\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithBlockhashLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * if (isTransactionMessageWithBlockhashLifetime(message)) {\n *     // At this point, `message` has been refined to a `TransactionMessageWithBlockhashLifetime`.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsValid(blockhashIsValid);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a blockhash-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithBlockhashLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n): transactionMessage is BaseTransactionMessage & TransactionMessageWithBlockhashLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.blockhash === 'string' &&\n        typeof transactionMessage.lifetimeConstraint.lastValidBlockHeight === 'bigint' &&\n        isBlockhash(transactionMessage.lifetimeConstraint.blockhash)\n    );\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * blockhash-based lifetime, from an untrusted network API or user input. Use this function to\n * assert that such a transaction message actually has a blockhash-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithBlockhashLifetime`.\n *     assertIsTransactionMessageWithBlockhashLifetime(message);\n *     // At this point, `message` is a `TransactionMessageWithBlockhashLifetime` that can be used\n *     // with the RPC.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n * } catch (e) {\n *     // `message` turned out not to have a blockhash-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithBlockhashLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n): asserts transactionMessage is BaseTransactionMessage & TransactionMessageWithBlockhashLifetime {\n    if (!isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\n\n/**\n * Given a blockhash and the last block height at which that blockhash is considered usable to land\n * transactions, this method will return a new transaction message having the same type as the one\n * supplied plus the `TransactionMessageWithBlockhashLifetime` type.\n *\n * @example\n * ```ts\n * import { setTransactionMessageLifetimeUsingBlockhash } from '@solana/transaction-messages';\n *\n * const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n * const txMessageWithBlockhashLifetime = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, txMessage);\n * ```\n */\nexport function setTransactionMessageLifetimeUsingBlockhash<\n    TTransactionMessage extends BaseTransactionMessage & Partial<TransactionMessageWithLifetime>,\n>(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageLifetime<TTransactionMessage> & TransactionMessageWithBlockhashLifetime {\n    type ReturnType = ExcludeTransactionMessageLifetime<TTransactionMessage> & TransactionMessageWithBlockhashLifetime;\n\n    if (\n        'lifetimeConstraint' in transactionMessage &&\n        transactionMessage.lifetimeConstraint &&\n        'blockhash' in transactionMessage.lifetimeConstraint &&\n        transactionMessage.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash &&\n        transactionMessage.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight\n    ) {\n        return transactionMessage as ReturnType;\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        lifetimeConstraint: Object.freeze(blockhashLifetimeConstraint),\n    }) as ReturnType;\n}\n", "import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n", "import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n", "import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n", "import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    type Encoder,\n    transformDecoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport type { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\n\ntype AddressTableLookup = ReturnType<typeof getCompiledAddressTableLookups>[number];\n\nlet memoizedAddressTableLookupEncoder: VariableSizeEncoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupEncoder(): VariableSizeEncoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupEncoder) {\n        const indexEncoder = getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() }) as Encoder<\n            readonly number[]\n        >;\n        memoizedAddressTableLookupEncoder = getStructEncoder([\n            ['lookupTableAddress', getAddressEncoder()],\n            ['writableIndexes', indexEncoder],\n            ['readonlyIndexes', indexEncoder],\n        ]);\n    }\n\n    return memoizedAddressTableLookupEncoder;\n}\n\nlet memoizedAddressTableLookupDecoder: VariableSizeDecoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupDecoder(): VariableSizeDecoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupDecoder) {\n        const indexEncoder = getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() });\n        // @ts-expect-error Remove when `readableIndices` and `writableIndices` are removed.\n        memoizedAddressTableLookupDecoder = transformDecoder(\n            getStructDecoder([\n                ['lookupTableAddress', getAddressDecoder()],\n                ['writableIndexes', indexEncoder],\n                ['readonlyIndexes', indexEncoder],\n            ]),\n            lookupTable =>\n                'readableIndices' in lookupTable\n                    ? ({\n                          ...lookupTable,\n                          readonlyIndexes: lookupTable.readableIndices,\n                          // @ts-expect-error Remove when `readableIndices` and `writableIndices` are removed.\n                          writableIndexes: lookupTable.writableIndices,\n                      } as AddressTableLookup)\n                    : lookupTable,\n        );\n    }\n\n    // @ts-expect-error Remove when `readableIndices` and `writableIndices` are removed.\n    return memoizedAddressTableLookupDecoder;\n}\n\nexport function getAddressTableLookupCodec(): VariableSizeCodec<AddressTableLookup> {\n    return combineCodec(getAddressTableLookupEncoder(), getAddressTableLookupDecoder());\n}\n", "import { FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport { getStructCodec, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getU8Codec, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledMessageHeader } from '../compile/header';\n\ntype MessageHeader = ReturnType<typeof getCompiledMessageHeader>;\n\nlet memoizedU8Encoder: FixedSizeEncoder<number, 1> | undefined;\nfunction getMemoizedU8Encoder(): FixedSizeEncoder<number, 1> {\n    if (!memoizedU8Encoder) memoizedU8Encoder = getU8Encoder();\n    return memoizedU8Encoder;\n}\n\nlet memoizedU8Decoder: FixedSizeDecoder<number, 1> | undefined;\nfunction getMemoizedU8Decoder(): FixedSizeDecoder<number, 1> {\n    if (!memoizedU8Decoder) memoizedU8Decoder = getU8Decoder();\n    return memoizedU8Decoder;\n}\n\nlet memoizedU8Codec: FixedSizeCodec<number, number, 1> | undefined;\nfunction getMemoizedU8Codec(): FixedSizeCodec<number, number, 1> {\n    if (!memoizedU8Codec) memoizedU8Codec = getU8Codec();\n    return memoizedU8Codec;\n}\n\nexport function getMessageHeaderEncoder(): FixedSizeEncoder<MessageHeader, 3> {\n    return getStructEncoder([\n        ['numSignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Encoder()],\n    ]) as FixedSizeEncoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderDecoder(): FixedSizeDecoder<MessageHeader, 3> {\n    return getStructDecoder([\n        ['numSignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Decoder()],\n    ]) as FixedSizeDecoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderCodec(): FixedSizeCodec<MessageHeader, MessageHeader, 3> {\n    return getStructCodec([\n        ['numSignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlySignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Codec()],\n    ]) as FixedSizeCodec<MessageHeader, MessageHeader, 3>;\n}\n", "import {\n    addDecoderSizePrefix,\n    addEncoderSizePrefix,\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledInstructions } from '../compile/instructions';\n\ntype Instruction = ReturnType<typeof getCompiledInstructions>[number];\n\nlet memoizedGetInstructionEncoder: VariableSizeEncoder<Instruction> | undefined;\nexport function getInstructionEncoder(): VariableSizeEncoder<Instruction> {\n    if (!memoizedGetInstructionEncoder) {\n        memoizedGetInstructionEncoder = transformEncoder<Required<Instruction>, Instruction>(\n            getStructEncoder([\n                ['programAddressIndex', getU8Encoder()],\n                ['accountIndices', getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() })],\n                ['data', addEncoderSizePrefix(getBytesEncoder(), getShortU16Encoder())],\n            ]),\n            // Convert an instruction to have all fields defined\n            (instruction: Instruction): Required<Instruction> => {\n                if (instruction.accountIndices !== undefined && instruction.data !== undefined) {\n                    return instruction as Required<Instruction>;\n                }\n                return {\n                    ...instruction,\n                    accountIndices: instruction.accountIndices ?? [],\n                    data: instruction.data ?? new Uint8Array(0),\n                } as Required<Instruction>;\n            },\n        );\n    }\n\n    return memoizedGetInstructionEncoder;\n}\n\nlet memoizedGetInstructionDecoder: VariableSizeDecoder<Instruction> | undefined;\nexport function getInstructionDecoder(): VariableSizeDecoder<Instruction> {\n    if (!memoizedGetInstructionDecoder) {\n        memoizedGetInstructionDecoder = transformDecoder<Required<Instruction>, Instruction>(\n            getStructDecoder([\n                ['programAddressIndex', getU8Decoder()],\n                ['accountIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n                [\n                    'data',\n                    addDecoderSizePrefix(getBytesDecoder(), getShortU16Decoder()) as VariableSizeDecoder<Uint8Array>,\n                ],\n            ]),\n            // Convert an instruction to exclude optional fields if they are empty\n            (instruction: Required<Instruction>): Instruction => {\n                if (instruction.accountIndices.length && instruction.data.byteLength) {\n                    return instruction;\n                }\n                const { accountIndices, data, ...rest } = instruction;\n                return {\n                    ...rest,\n                    ...(accountIndices.length ? { accountIndices } : null),\n                    ...(data.byteLength ? { data } : null),\n                };\n            },\n        );\n    }\n    return memoizedGetInstructionDecoder;\n}\n\nexport function getInstructionCodec(): VariableSizeCodec<Instruction> {\n    return combineCodec(getInstructionEncoder(), getInstructionDecoder());\n}\n", "import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { TransactionVersion } from '../transaction-message';\n\nconst VERSION_FLAG_MASK = 0x80;\n\n/**\n * Returns an encoder that you can use to encode a {@link TransactionVersion} to a byte array.\n *\n * Legacy messages will produce an empty array and will not advance the offset. Versioned messages\n * will produce an array with a single byte.\n */\nexport function getTransactionVersionEncoder(): VariableSizeEncoder<TransactionVersion> {\n    return createEncoder({\n        getSizeFromValue: value => (value === 'legacy' ? 0 : 1),\n        maxSize: 1,\n        write: (value, bytes, offset) => {\n            if (value === 'legacy') {\n                return offset;\n            }\n            if (value < 0 || value > 127) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, {\n                    actualVersion: value,\n                });\n            }\n            bytes.set([value | VERSION_FLAG_MASK], offset);\n            return offset + 1;\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link TransactionVersion}.\n *\n * When the byte at the current offset is determined to represent a legacy transaction, this decoder\n * will return `'legacy'` and will not advance the offset.\n */\nexport function getTransactionVersionDecoder(): VariableSizeDecoder<TransactionVersion> {\n    return createDecoder({\n        maxSize: 1,\n        read: (bytes, offset) => {\n            const firstByte = bytes[offset];\n            if ((firstByte & VERSION_FLAG_MASK) === 0) {\n                // No version flag set; it's a legacy (unversioned) transaction.\n                return ['legacy', offset];\n            } else {\n                const version = (firstByte ^ VERSION_FLAG_MASK) as TransactionVersion;\n                return [version, offset + 1];\n            }\n        },\n    });\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link TransactionVersion}\n *\n * @see {@link getTransactionVersionDecoder}\n * @see {@link getTransactionVersionEncoder}\n */\nexport function getTransactionVersionCodec(): VariableSizeCodec<TransactionVersion> {\n    return combineCodec(getTransactionVersionEncoder(), getTransactionVersionDecoder());\n}\n", "import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    createEncoder,\n    Decoder,\n    fixDecoderSize,\n    fixEncoderSize,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder } from '@solana/codecs-numbers';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\n\nimport { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\nimport { CompiledTransactionMessage } from '../compile/message';\nimport { getAddressTableLookupDecoder, getAddressTableLookupEncoder } from './address-table-lookup';\nimport { getMessageHeaderDecoder, getMessageHeaderEncoder } from './header';\nimport { getInstructionDecoder, getInstructionEncoder } from './instruction';\nimport { getTransactionVersionDecoder, getTransactionVersionEncoder } from './transaction-version';\n\nfunction getCompiledMessageLegacyEncoder(): VariableSizeEncoder<CompiledTransactionMessage> {\n    return getStructEncoder(getPreludeStructEncoderTuple()) as VariableSizeEncoder<CompiledTransactionMessage>;\n}\n\nfunction getCompiledMessageVersionedEncoder(): VariableSizeEncoder<CompiledTransactionMessage> {\n    return transformEncoder(\n        getStructEncoder([\n            ...getPreludeStructEncoderTuple(),\n            ['addressTableLookups', getAddressTableLookupArrayEncoder()],\n        ]) as VariableSizeEncoder<CompiledTransactionMessage>,\n        (value: CompiledTransactionMessage) => {\n            if (value.version === 'legacy') {\n                return value;\n            }\n            return {\n                ...value,\n                addressTableLookups: value.addressTableLookups ?? [],\n            } as Exclude<CompiledTransactionMessage, { readonly version: 'legacy' }>;\n        },\n    );\n}\n\nfunction getPreludeStructEncoderTuple() {\n    return [\n        ['version', getTransactionVersionEncoder()],\n        ['header', getMessageHeaderEncoder()],\n        ['staticAccounts', getArrayEncoder(getAddressEncoder(), { size: getShortU16Encoder() })],\n        ['lifetimeToken', fixEncoderSize(getBase58Encoder(), 32)],\n        ['instructions', getArrayEncoder(getInstructionEncoder(), { size: getShortU16Encoder() })],\n    ] as const;\n}\n\nfunction getPreludeStructDecoderTuple() {\n    return [\n        ['version', getTransactionVersionDecoder() as Decoder<number>],\n        ['header', getMessageHeaderDecoder()],\n        ['staticAccounts', getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })],\n        ['lifetimeToken', fixDecoderSize(getBase58Decoder(), 32)],\n        ['instructions', getArrayDecoder(getInstructionDecoder(), { size: getShortU16Decoder() })],\n        ['addressTableLookups', getAddressTableLookupArrayDecoder()],\n    ] as const;\n}\n\nfunction getAddressTableLookupArrayEncoder() {\n    return getArrayEncoder(getAddressTableLookupEncoder(), { size: getShortU16Encoder() });\n}\n\nfunction getAddressTableLookupArrayDecoder() {\n    return getArrayDecoder(getAddressTableLookupDecoder(), { size: getShortU16Decoder() });\n}\n\n/**\n * Returns an encoder that you can use to encode a {@link CompiledTransactionMessage} to a byte\n * array.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. The byte array produced by this encoder is the message part.\n */\nexport function getCompiledTransactionMessageEncoder(): VariableSizeEncoder<CompiledTransactionMessage> {\n    return createEncoder({\n        getSizeFromValue: (compiledMessage: CompiledTransactionMessage) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);\n            } else {\n                return getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);\n            }\n        },\n        write: (compiledMessage, bytes, offset) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);\n            } else {\n                return getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);\n            }\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link CompiledTransactionMessage}.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. You can use this decoder to decode the message part.\n */\nexport function getCompiledTransactionMessageDecoder(): VariableSizeDecoder<CompiledTransactionMessage> {\n    return transformDecoder(\n        getStructDecoder(getPreludeStructDecoderTuple()) as VariableSizeDecoder<\n            CompiledTransactionMessage & { addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups> }\n        >,\n        ({ addressTableLookups, ...restOfMessage }) => {\n            if (restOfMessage.version === 'legacy' || !addressTableLookups?.length) {\n                return restOfMessage;\n            }\n            return { ...restOfMessage, addressTableLookups } as Exclude<\n                CompiledTransactionMessage,\n                { readonly version: 'legacy' }\n            >;\n        },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link CompiledTransactionMessage}\n *\n * @see {@link getCompiledTransactionMessageDecoder}\n * @see {@link getCompiledTransactionMessageEncoder}\n */\nexport function getCompiledTransactionMessageCodec(): VariableSizeCodec<CompiledTransactionMessage> {\n    return combineCodec(getCompiledTransactionMessageEncoder(), getCompiledTransactionMessageDecoder());\n}\n", "import { Address, getAddressComparator } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SolanaError,\n} from '@solana/errors';\nimport {\n    AccountLookupMeta,\n    AccountMeta,\n    AccountRole,\n    Instruction,\n    isSignerRole,\n    isWritableRole,\n    mergeRoles,\n    ReadonlyAccount,\n    ReadonlyAccountLookup,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableAccountLookup,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport const enum AddressMapEntryType {\n    FEE_PAYER,\n    LOOKUP_TABLE,\n    STATIC,\n}\n\ntype AddressMap = {\n    [address: string]: FeePayerAccountEntry | LookupTableAccountEntry | StaticAccountEntry;\n};\ntype FeePayerAccountEntry = Omit<WritableSignerAccount, 'address'> & {\n    [TYPE]: AddressMapEntryType.FEE_PAYER;\n};\ntype LookupTableAccountEntry = Omit<ReadonlyAccountLookup | WritableAccountLookup, 'address'> & {\n    [TYPE]: AddressMapEntryType.LOOKUP_TABLE;\n};\nexport type OrderedAccounts = Brand<(AccountLookupMeta | AccountMeta)[], 'OrderedAccounts'>;\ntype StaticAccountEntry = Omit<\n    ReadonlyAccount | ReadonlySignerAccount | WritableAccount | WritableSignerAccount,\n    'address'\n> & { [TYPE]: AddressMapEntryType.STATIC };\n\nfunction upsert(\n    addressMap: AddressMap,\n    address: Address,\n    update: (\n        entry: FeePayerAccountEntry | LookupTableAccountEntry | Record<never, never> | StaticAccountEntry,\n    ) => AddressMap[Address],\n) {\n    addressMap[address] = update(addressMap[address] ?? { role: AccountRole.READONLY });\n}\n\nconst TYPE = Symbol('AddressMapTypeProperty');\nexport const ADDRESS_MAP_TYPE_PROPERTY: typeof TYPE = TYPE;\n\nexport function getAddressMapFromInstructions(feePayer: Address, instructions: readonly Instruction[]): AddressMap {\n    const addressMap: AddressMap = {\n        [feePayer]: { [TYPE]: AddressMapEntryType.FEE_PAYER, role: AccountRole.WRITABLE_SIGNER },\n    };\n    const addressesOfInvokedPrograms = new Set<Address>();\n    for (const instruction of instructions) {\n        upsert(addressMap, instruction.programAddress, entry => {\n            addressesOfInvokedPrograms.add(instruction.programAddress);\n            if (TYPE in entry) {\n                if (isWritableRole(entry.role)) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, {\n                                programAddress: instruction.programAddress,\n                            });\n                        default:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {\n                                programAddress: instruction.programAddress,\n                            });\n                    }\n                }\n                if (entry[TYPE] === AddressMapEntryType.STATIC) {\n                    return entry;\n                }\n            }\n            return { [TYPE]: AddressMapEntryType.STATIC, role: AccountRole.READONLY };\n        });\n        let addressComparator: ReturnType<typeof getAddressComparator>;\n        if (!instruction.accounts) {\n            continue;\n        }\n        for (const account of instruction.accounts) {\n            upsert(addressMap, account.address, entry => {\n                const {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    address: _,\n                    ...accountMeta\n                } = account;\n                if (TYPE in entry) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            // The fee payer already has the highest rank -- it is by definition\n                            // writable-signer. Return it, no matter how `account` is configured\n                            return entry;\n                        case AddressMapEntryType.LOOKUP_TABLE: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if ('lookupTableAddress' in accountMeta) {\n                                const shouldReplaceEntry =\n                                    // Consider using the new LOOKUP_TABLE if its address is different...\n                                    entry.lookupTableAddress !== accountMeta.lookupTableAddress &&\n                                    // ...and sorts before the existing one.\n                                    (addressComparator ||= getAddressComparator())(\n                                        accountMeta.lookupTableAddress,\n                                        entry.lookupTableAddress,\n                                    ) < 0;\n                                if (shouldReplaceEntry) {\n                                    return {\n                                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                        ...accountMeta,\n                                        role: nextRole,\n                                    } as LookupTableAccountEntry;\n                                }\n                            } else if (isSignerRole(accountMeta.role)) {\n                                // Upgrade this LOOKUP_TABLE entry to a static entry if it must sign.\n                                return {\n                                    [TYPE]: AddressMapEntryType.STATIC,\n                                    role: nextRole,\n                                } as StaticAccountEntry;\n                            }\n                            if (entry.role !== nextRole) {\n                                return {\n                                    ...entry,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                return entry;\n                            }\n                        }\n                        case AddressMapEntryType.STATIC: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if (\n                                // Check to see if this address represents a program that is invoked\n                                // in this transaction.\n                                addressesOfInvokedPrograms.has(account.address)\n                            ) {\n                                if (isWritableRole(accountMeta.role)) {\n                                    throw new SolanaError(\n                                        SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n                                        {\n                                            programAddress: account.address,\n                                        },\n                                    );\n                                }\n                                if (entry.role !== nextRole) {\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            } else if (\n                                'lookupTableAddress' in accountMeta &&\n                                // Static accounts can be 'upgraded' to lookup table accounts as\n                                // long as they are not require to sign the transaction.\n                                !isSignerRole(entry.role)\n                            ) {\n                                return {\n                                    ...accountMeta,\n                                    [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                if (entry.role !== nextRole) {\n                                    // The account's role ranks higher than the current entry's.\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            }\n                        }\n                    }\n                }\n                if ('lookupTableAddress' in accountMeta) {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                    };\n                } else {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.STATIC,\n                    };\n                }\n            });\n        }\n    }\n    return addressMap;\n}\n\nexport function getOrderedAccountsFromAddressMap(addressMap: AddressMap): OrderedAccounts {\n    let addressComparator: ReturnType<typeof getAddressComparator>;\n    const orderedAccounts: (AccountLookupMeta | AccountMeta)[] = Object.entries(addressMap)\n        .sort(([leftAddress, leftEntry], [rightAddress, rightEntry]) => {\n            // STEP 1: Rapid precedence check. Fee payer, then static addresses, then lookups.\n            if (leftEntry[TYPE] !== rightEntry[TYPE]) {\n                if (leftEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return 1;\n                } else if (leftEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return 1;\n                }\n            }\n            // STEP 2: Sort by signer-writability.\n            const leftIsSigner = isSignerRole(leftEntry.role);\n            if (leftIsSigner !== isSignerRole(rightEntry.role)) {\n                return leftIsSigner ? -1 : 1;\n            }\n            const leftIsWritable = isWritableRole(leftEntry.role);\n            if (leftIsWritable !== isWritableRole(rightEntry.role)) {\n                return leftIsWritable ? -1 : 1;\n            }\n            // STEP 3: Sort by address.\n            addressComparator ||= getAddressComparator();\n            if (\n                leftEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                rightEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress\n            ) {\n                return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);\n            } else {\n                return addressComparator(leftAddress, rightAddress);\n            }\n        })\n        .map(([address, addressMeta]) => ({\n            address: address as Address<typeof address>,\n            ...addressMeta,\n        }));\n    return orderedAccounts as unknown as OrderedAccounts;\n}\n", "import { Address, getAddressComparator } from '@solana/addresses';\nimport { AccountRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype AddressTableLookup = Readonly<{\n    /** The address of the address lookup table account. */\n    lookupTableAddress: Address;\n    /** @deprecated Use `readonlyIndexes` */\n    readableIndices: readonly number[];\n    /** Indexes of accounts in a lookup table to load as read-only. */\n    readonlyIndexes: readonly number[];\n    /** Indexes of accounts in a lookup table to load as writable. */\n    writableIndexes: readonly number[];\n    /** @deprecated Use `writableIndexes` */\n    writableIndices: readonly number[];\n}>;\n\nexport function getCompiledAddressTableLookups(orderedAccounts: OrderedAccounts): AddressTableLookup[] {\n    const index: Record<\n        Address,\n        Readonly<{\n            [K in keyof Omit<AddressTableLookup, 'lookupTableAddress'>]: number[];\n        }>\n    > = {};\n    for (const account of orderedAccounts) {\n        if (!('lookupTableAddress' in account)) {\n            continue;\n        }\n        const entry = (index[account.lookupTableAddress] ||= {\n            /** @deprecated Remove in a future major version */\n            readableIndices: [],\n            readonlyIndexes: [],\n            writableIndexes: [],\n            /** @deprecated Remove in a future major version */\n            writableIndices: [],\n        });\n        if (account.role === AccountRole.WRITABLE) {\n            entry.writableIndexes.push(account.addressIndex);\n            /** @deprecated Remove in a future major version */\n            entry.writableIndices.push(account.addressIndex);\n        } else {\n            /** @deprecated Remove in a future major version */\n            entry.readableIndices.push(account.addressIndex);\n            entry.readonlyIndexes.push(account.addressIndex);\n        }\n    }\n    return Object.keys(index)\n        .sort(getAddressComparator())\n        .map(lookupTableAddress => ({\n            lookupTableAddress: lookupTableAddress as Address,\n            ...index[lookupTableAddress as unknown as Address],\n        }));\n}\n", "import { isSignerRole, isWritableRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype MessageHeader = Readonly<{\n    /**\n     * The number of accounts in the static accounts list that are neither writable nor\n     * signers.\n     *\n     * Adding this number to `numSignerAccounts` yields the index of the first read-only non-signer\n     * account in the static accounts list.\n     */\n    numReadonlyNonSignerAccounts: number;\n    /**\n     * The number of read-only accounts in the static accounts list that must sign this\n     * transaction.\n     *\n     * Subtracting this number from `numSignerAccounts` yields the index of the first read-only\n     * signer account in the static accounts list.\n     */\n    numReadonlySignerAccounts: number;\n    /**\n     * The number of accounts in the static accounts list that must sign this transaction.\n     *\n     * Subtracting `numReadonlySignerAccounts` from this number yields the number of\n     * writable signer accounts in the static accounts list. Writable signer accounts always\n     * begin at index zero in the static accounts list.\n     *\n     * This number itself is the index of the first non-signer account in the static\n     * accounts list.\n     */\n    numSignerAccounts: number;\n}>;\n\nexport function getCompiledMessageHeader(orderedAccounts: OrderedAccounts): MessageHeader {\n    let numReadonlyNonSignerAccounts = 0;\n    let numReadonlySignerAccounts = 0;\n    let numSignerAccounts = 0;\n    for (const account of orderedAccounts) {\n        if ('lookupTableAddress' in account) {\n            break;\n        }\n        const accountIsWritable = isWritableRole(account.role);\n        if (isSignerRole(account.role)) {\n            numSignerAccounts++;\n            if (!accountIsWritable) {\n                numReadonlySignerAccounts++;\n            }\n        } else if (!accountIsWritable) {\n            numReadonlyNonSignerAccounts++;\n        }\n    }\n    return {\n        numReadonlyNonSignerAccounts,\n        numReadonlySignerAccounts,\n        numSignerAccounts,\n    };\n}\n", "import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { Instruction } from '@solana/instructions';\n\nimport { OrderedAccounts } from './accounts';\n\ntype CompiledInstruction = Readonly<{\n    /**\n     * An ordered list of indices that indicate which accounts in the transaction message's\n     * accounts list are loaded by this instruction.\n     */\n    accountIndices?: number[];\n    /** The input to the invoked program */\n    data?: ReadonlyUint8Array;\n    /**\n     * The index of the address in the transaction message's accounts list associated with the\n     * program to invoke.\n     */\n    programAddressIndex: number;\n}>;\n\nfunction getAccountIndex(orderedAccounts: OrderedAccounts) {\n    const out: Record<Address, number> = {};\n    for (const [index, account] of orderedAccounts.entries()) {\n        out[account.address] = index;\n    }\n    return out;\n}\n\nexport function getCompiledInstructions(\n    instructions: readonly Instruction[],\n    orderedAccounts: OrderedAccounts,\n): CompiledInstruction[] {\n    const accountIndex = getAccountIndex(orderedAccounts);\n    return instructions.map(({ accounts, data, programAddress }) => {\n        return {\n            programAddressIndex: accountIndex[programAddress],\n            ...(accounts ? { accountIndices: accounts.map(({ address }) => accountIndex[address]) } : null),\n            ...(data ? { data } : null),\n        };\n    });\n}\n", "import { TransactionMessageWithBlockhashLifetime, TransactionMessageWithDurableNonceLifetime } from '../index';\n\nexport function getCompiledLifetimeToken(\n    lifetimeConstraint: (\n        | TransactionMessageWithBlockhashLifetime\n        | TransactionMessageWithDurableNonceLifetime\n    )['lifetimeConstraint'],\n): string {\n    if ('nonce' in lifetimeConstraint) {\n        return lifetimeConstraint.nonce;\n    }\n    return lifetimeConstraint.blockhash;\n}\n", "import { Address } from '@solana/addresses';\n\nimport { OrderedAccounts } from './accounts';\n\nexport function getCompiledStaticAccounts(orderedAccounts: OrderedAccounts): Address[] {\n    const firstLookupTableAccountIndex = orderedAccounts.findIndex(account => 'lookupTableAddress' in account);\n    const orderedStaticAccounts =\n        firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);\n    return orderedStaticAccounts.map(({ address }) => address);\n}\n", "import { CompilableTransactionMessage } from '../compilable-transaction-message';\nimport { getAddressMapFromInstructions, getOrderedAccountsFromAddressMap } from './accounts';\nimport { getCompiledAddressTableLookups } from './address-table-lookups';\nimport { getCompiledMessageHeader } from './header';\nimport { getCompiledInstructions } from './instructions';\nimport { getCompiledLifetimeToken } from './lifetime-token';\nimport { getCompiledStaticAccounts } from './static-accounts';\n\ntype BaseCompiledTransactionMessage = Readonly<{\n    /**\n     * Information about the version of the transaction message and the role of the accounts it\n     * loads.\n     */\n    header: ReturnType<typeof getCompiledMessageHeader>;\n    instructions: ReturnType<typeof getCompiledInstructions>;\n    /**\n     * 32 bytes of data observed by the transaction proposed that makes a transaction eligible to\n     * land on the network.\n     *\n     * In the case of a transaction message with a nonce lifetime constraint, this will be the value\n     * of the nonce itself. In all other cases this will be a recent blockhash.\n     */\n    lifetimeToken: ReturnType<typeof getCompiledLifetimeToken>;\n    /** A list of addresses indicating which accounts to load */\n    staticAccounts: ReturnType<typeof getCompiledStaticAccounts>;\n}>;\n\n/**\n * A transaction message in a form suitable for encoding for execution on the network.\n *\n * You can not fully reconstruct a source message from a compiled message without extra information.\n * In particular, supporting details about the lifetime constraint and the concrete addresses of\n * accounts sourced from account lookup tables are lost to compilation.\n */\nexport type CompiledTransactionMessage = LegacyCompiledTransactionMessage | VersionedCompiledTransactionMessage;\n\ntype LegacyCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        version: 'legacy';\n    }>;\n\ntype VersionedCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        /** A list of address tables and the accounts that this transaction loads from them */\n        addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n        version: number;\n    }>;\n\n/**\n * Converts the type of transaction message data structure that you create in your application to\n * the type of transaction message data structure that can be encoded for execution on the network.\n *\n * This is a lossy process; you can not fully reconstruct a source message from a compiled message\n * without extra information. In particular, supporting details about the lifetime constraint and\n * the concrete addresses of accounts sourced from account lookup tables will be lost to\n * compilation.\n *\n * @see {@link decompileTransactionMessage}\n */\nexport function compileTransactionMessage(\n    transactionMessage: CompilableTransactionMessage & Readonly<{ version: 'legacy' }>,\n): LegacyCompiledTransactionMessage;\nexport function compileTransactionMessage(\n    transactionMessage: CompilableTransactionMessage,\n): VersionedCompiledTransactionMessage;\nexport function compileTransactionMessage(\n    transactionMessage: CompilableTransactionMessage,\n): CompiledTransactionMessage {\n    const addressMap = getAddressMapFromInstructions(\n        transactionMessage.feePayer.address,\n        transactionMessage.instructions,\n    );\n    const orderedAccounts = getOrderedAccountsFromAddressMap(addressMap);\n    return {\n        ...(transactionMessage.version !== 'legacy'\n            ? { addressTableLookups: getCompiledAddressTableLookups(orderedAccounts) }\n            : null),\n        header: getCompiledMessageHeader(orderedAccounts),\n        instructions: getCompiledInstructions(transactionMessage.instructions, orderedAccounts),\n        lifetimeToken: getCompiledLifetimeToken(transactionMessage.lifetimeConstraint),\n        staticAccounts: getCompiledStaticAccounts(orderedAccounts),\n        version: transactionMessage.version,\n    };\n}\n", "import { Address } from '@solana/addresses';\nimport { AccountLookupMeta, AccountMeta, AccountRole, Instruction, isSignerRole } from '@solana/instructions';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { BaseTransactionMessage, TransactionMessage } from './transaction-message';\n\ntype Mutable<T> = {\n    -readonly [P in keyof T]: T[P];\n};\n\n// Look up the address in lookup tables, return a lookup meta if it is found in any of them\nfunction findAddressInLookupTables(\n    address: Address,\n    role: AccountRole.READONLY | AccountRole.WRITABLE,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): AccountLookupMeta | undefined {\n    for (const [lookupTableAddress, addresses] of Object.entries(addressesByLookupTableAddress)) {\n        for (let i = 0; i < addresses.length; i++) {\n            if (address === addresses[i]) {\n                return {\n                    address,\n                    addressIndex: i,\n                    lookupTableAddress: lookupTableAddress as Address,\n                    role,\n                };\n            }\n        }\n    }\n}\n\ntype TransactionMessageNotLegacy = Exclude<TransactionMessage, { version: 'legacy' }>;\n\n// Each account can be AccountLookupMeta | AccountMeta\ntype WidenInstructionAccounts<TInstruction extends Instruction> =\n    TInstruction extends Instruction<infer TProgramAddress, infer TAccounts>\n        ? Instruction<\n              TProgramAddress,\n              {\n                  [K in keyof TAccounts]: TAccounts[K] extends AccountMeta<infer TAddress>\n                      ? AccountLookupMeta<TAddress> | AccountMeta<TAddress>\n                      : TAccounts[K];\n              }\n          >\n        : TInstruction;\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\ntype WidenTransactionMessageInstructions<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends BaseTransactionMessage<infer TVersion, infer TInstruction>\n        ? BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>> &\n              ExtractAdditionalProps<\n                  TTransactionMessage,\n                  BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>>\n              >\n        : TTransactionMessage;\n\n/**\n * Given a transaction message and a mapping of lookup tables to the addresses stored in them, this\n * function will return a new transaction message with the same instructions but with all non-signer\n * accounts that are found in the given lookup tables represented by an {@link AccountLookupMeta}\n * instead of an {@link AccountMeta}.\n *\n * This means that these accounts will take up less space in the compiled transaction message. This\n * size reduction is most significant when the transaction includes many accounts from the same\n * lookup table.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { compressTransactionMessageUsingAddressLookupTables } from '@solana/transaction-messages';\n *\n * const lookupTableAddress = address('4QwSwNriKPrz8DLW4ju5uxC2TN5cksJx6tPUPj7DGLAW');\n * const accountAddress = address('5n2ADjHPsqB4EVUNEX48xRqtnmuLu5XSHDwkJRR98qpM');\n * const lookupTableAddresses: AddressesByLookupTableAddress = {\n *     [lookupTableAddress]: [accountAddress],\n * };\n *\n * const compressedTransactionMessage = compressTransactionMessageUsingAddressLookupTables(\n *     transactionMessage,\n *     lookupTableAddresses,\n * );\n * ```\n *\n */\nexport function compressTransactionMessageUsingAddressLookupTables<\n    TTransactionMessage extends TransactionMessageNotLegacy = TransactionMessageNotLegacy,\n>(\n    transactionMessage: TTransactionMessage,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): TTransactionMessage | WidenTransactionMessageInstructions<TTransactionMessage> {\n    const lookupTableAddresses = new Set(Object.values(addressesByLookupTableAddress).flatMap(a => a));\n\n    const newInstructions: Instruction[] = [];\n    let updatedAnyInstructions = false;\n    for (const instruction of transactionMessage.instructions) {\n        if (!instruction.accounts) {\n            newInstructions.push(instruction);\n            continue;\n        }\n\n        const newAccounts: Mutable<NonNullable<Instruction['accounts']>> = [];\n        let updatedAnyAccounts = false;\n        for (const account of instruction.accounts) {\n            // If the address is already a lookup, is not in any lookup tables, or is a signer role, return as-is\n            if (\n                'lookupTableAddress' in account ||\n                !lookupTableAddresses.has(account.address) ||\n                isSignerRole(account.role)\n            ) {\n                newAccounts.push(account);\n                continue;\n            }\n\n            // We already checked it's in one of the lookup tables\n            const lookupMetaAccount = findAddressInLookupTables(\n                account.address,\n                account.role,\n                addressesByLookupTableAddress,\n            )!;\n            newAccounts.push(Object.freeze(lookupMetaAccount));\n            updatedAnyAccounts = true;\n            updatedAnyInstructions = true;\n        }\n\n        newInstructions.push(\n            Object.freeze(updatedAnyAccounts ? { ...instruction, accounts: newAccounts } : instruction),\n        );\n    }\n\n    return Object.freeze(\n        updatedAnyInstructions ? { ...transactionMessage, instructions: newInstructions } : transactionMessage,\n    );\n}\n", "import { TransactionMessage, TransactionVersion } from './transaction-message';\nimport { TransactionMessageWithinSizeLimit } from './transaction-message-size';\n\ntype TransactionConfig<TVersion extends TransactionVersion> = Readonly<{\n    version: TVersion;\n}>;\n\ntype EmptyTransactionMessage<TVersion extends TransactionVersion> = Omit<\n    Extract<TransactionMessage, { version: TVersion }>,\n    'instructions'\n> &\n    TransactionMessageWithinSizeLimit & { instructions: readonly [] };\n\n/**\n * Given a {@link TransactionVersion} this method will return an empty transaction having the\n * capabilities of that version.\n *\n * @example\n * ```ts\n * import { createTransactionMessage } from '@solana/transaction-messages';\n *\n * const message = createTransactionMessage({ version: 0 });\n * ```\n */\nexport function createTransactionMessage<TVersion extends TransactionVersion>(\n    config: TransactionConfig<TVersion>,\n): EmptyTransactionMessage<TVersion> {\n    return Object.freeze({\n        instructions: Object.freeze([]),\n        version: config.version,\n    }) as EmptyTransactionMessage<TVersion>;\n}\n", "import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    AccountRole,\n    Instruction,\n    InstructionWithAccounts,\n    InstructionWithData,\n    isSignerRole,\n    ReadonlyAccount,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport type AdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n> = Instruction<'11111111111111111111111111111111'> &\n    InstructionWithAccounts<\n        readonly [\n            WritableAccount<TNonceAccountAddress>,\n            ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n            ReadonlySignerAccount<TNonceAuthorityAddress> | WritableSignerAccount<TNonceAuthorityAddress>,\n        ]\n    > &\n    InstructionWithData<AdvanceNonceAccountInstructionData>;\n\ntype AdvanceNonceAccountInstructionData = Brand<Uint8Array, 'AdvanceNonceAccountInstructionData'>;\n\nconst RECENT_BLOCKHASHES_SYSVAR_ADDRESS =\n    'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\nconst SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n\n/**\n * Creates an instruction for the System program to advance a nonce.\n *\n * This instruction is a prerequisite for a transaction with a nonce-based lifetime to be landed on\n * the network. In order to be considered valid, the transaction must meet all of these criteria.\n *\n * 1. Its lifetime constraint must be a {@link NonceLifetimeConstraint}.\n * 2. The value contained in the on-chain account at the address `nonceAccountAddress` must be equal\n *    to {@link NonceLifetimeConstraint.nonce} at the time the transaction is landed.\n * 3. The first instruction in that transaction message must be the one returned by this function.\n *\n * You could also use the `getAdvanceNonceAccountInstruction` method of `@solana-program/system`.\n */\nexport function createAdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n>(\n    nonceAccountAddress: Address<TNonceAccountAddress>,\n    nonceAuthorityAddress: Address<TNonceAuthorityAddress>,\n): AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return {\n        accounts: [\n            { address: nonceAccountAddress, role: AccountRole.WRITABLE },\n            {\n                address: RECENT_BLOCKHASHES_SYSVAR_ADDRESS,\n                role: AccountRole.READONLY,\n            },\n            { address: nonceAuthorityAddress, role: AccountRole.READONLY_SIGNER },\n        ],\n        data: new Uint8Array([4, 0, 0, 0]) as AdvanceNonceAccountInstructionData,\n        programAddress: SYSTEM_PROGRAM_ADDRESS,\n    };\n}\n\n/**\n * A type guard that returns `true` if the instruction conforms to the\n * {@link AdvanceNonceAccountInstruction} type, and refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isAdvanceNonceAccountInstruction } from '@solana/transaction-messages';\n *\n * if (isAdvanceNonceAccountInstruction(message.instructions[0])) {\n *     // At this point, the first instruction in the message has been refined to a\n *     // `AdvanceNonceAccountInstruction`.\n *     setNonceAccountAddress(message.instructions[0].accounts[0].address);\n * } else {\n *     setError('The first instruction is not an `AdvanceNonce` instruction');\n * }\n * ```\n */\nexport function isAdvanceNonceAccountInstruction(\n    instruction: Instruction,\n): instruction is AdvanceNonceAccountInstruction {\n    return (\n        instruction.programAddress === SYSTEM_PROGRAM_ADDRESS &&\n        // Test for `AdvanceNonceAccount` instruction data\n        instruction.data != null &&\n        isAdvanceNonceAccountInstructionData(instruction.data) &&\n        // Test for exactly 3 accounts\n        instruction.accounts?.length === 3 &&\n        // First account is nonce account address\n        instruction.accounts[0].address != null &&\n        instruction.accounts[0].role === AccountRole.WRITABLE &&\n        // Second account is recent blockhashes sysvar\n        instruction.accounts[1].address === RECENT_BLOCKHASHES_SYSVAR_ADDRESS &&\n        instruction.accounts[1].role === AccountRole.READONLY &&\n        // Third account is nonce authority account\n        instruction.accounts[2].address != null &&\n        isSignerRole(instruction.accounts[2].role)\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionData(data: ReadonlyUint8Array): data is AdvanceNonceAccountInstructionData {\n    // AdvanceNonceAccount is the fifth instruction in the System Program (index 4)\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n", "import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SolanaError } from '@solana/errors';\nimport { Instruction } from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nimport {\n    AdvanceNonceAccountInstruction,\n    createAdvanceNonceAccountInstruction,\n    isAdvanceNonceAccountInstruction,\n} from './durable-nonce-instruction';\nimport { ExcludeTransactionMessageLifetime } from './lifetime';\nimport { BaseTransactionMessage } from './transaction-message';\nimport { ExcludeTransactionMessageWithinSizeLimit } from './transaction-message-size';\n\ntype DurableNonceConfig<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Readonly<{\n    readonly nonce: Nonce<TNonceValue>;\n    readonly nonceAccountAddress: Address<TNonceAccountAddress>;\n    readonly nonceAuthorityAddress: Address<TNonceAuthorityAddress>;\n}>;\n\n/** Represents a string that is particularly known to be the base58-encoded value of a nonce. */\nexport type Nonce<TNonceValue extends string = string> = Brand<TNonceValue, 'Nonce'>;\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network.\n *\n * The transaction message will continue to be eligible to land until the network considers the\n * `nonce` to have advanced. This can happen when the nonce account in which this nonce is found is\n * destroyed, or the nonce value within changes.\n */\ntype NonceLifetimeConstraint<TNonceValue extends string = string> = Readonly<{\n    /**\n     * A value contained in the related nonce account at the time the transaction was prepared.\n     *\n     * The transaction will be considered eligible to land until the nonce account ceases to exist\n     * or contain this value.\n     */\n    nonce: Nonce<TNonceValue>;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the value of a nonce it includes.\n *\n * Such a transaction can only be landed on the network if the nonce is known to the network and has\n * not already been used to land a different transaction.\n */\nexport interface TransactionMessageWithDurableNonceLifetime<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> {\n    readonly instructions: readonly [\n        // The first instruction *must* be the system program's `AdvanceNonceAccount` instruction.\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...Instruction[],\n    ];\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n}\n\n/**\n * A helper type to exclude the durable nonce lifetime constraint from a transaction message.\n */\nexport type ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage extends BaseTransactionMessage> =\n    TTransactionMessage extends TransactionMessageWithDurableNonceLifetime\n        ? ExcludeTransactionMessageLifetime<TTransactionMessage>\n        : TTransactionMessage;\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithDurableNonceLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithDurableNonceLifetime } from '@solana/transaction-messages';\n * import { fetchNonce } from \"@solana-program/system\";\n *\n * if (isTransactionMessageWithDurableNonceLifetime(message)) {\n *     // At this point, `message` has been refined to a\n *     // `TransactionMessageWithDurableNonceLifetime`.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n *     setNonceIsValid(nonce === actualNonce);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a nonce-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithDurableNonceLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): transactionMessage is BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.nonce === 'string' &&\n        transactionMessage.instructions[0] != null &&\n        isAdvanceNonceAccountInstruction(transactionMessage.instructions[0])\n    );\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * nonce-based lifetime, from an untrusted network API or user input. Use this function to assert\n * that such a transaction message actually has a nonce-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsDurableNonceTransactionMessage } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithDurableNonceLifetime`.\n *     assertIsDurableNonceTransactionMessage(message);\n *     // At this point, `message` is a `TransactionMessageWithDurableNonceLifetime` that can be used\n *     // with the RPC.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n * } catch (e) {\n *     // `message` turned out not to have a nonce-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithDurableNonceLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): asserts transactionMessage is BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    if (!isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\n\nfunction isAdvanceNonceAccountInstructionForNonce<\n    TNonceAccountAddress extends Address = Address,\n    TNonceAuthorityAddress extends Address = Address,\n>(\n    instruction: AdvanceNonceAccountInstruction,\n    nonceAccountAddress: TNonceAccountAddress,\n    nonceAuthorityAddress: TNonceAuthorityAddress,\n): instruction is AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return (\n        instruction.accounts[0].address === nonceAccountAddress &&\n        instruction.accounts[2].address === nonceAuthorityAddress\n    );\n}\n\n/**\n * Given a nonce, the account where the value of the nonce is stored, and the address of the account\n * authorized to consume that nonce, this method will return a new transaction having the same type\n * as the one supplied plus the {@link TransactionMessageWithDurableNonceLifetime} type.\n *\n * In particular, this method _prepends_ an instruction to the transaction message designed to\n * consume (or 'advance') the nonce in the same transaction whose lifetime is defined by it.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { setTransactionMessageLifetimeUsingDurableNonce } from '@solana/transactions';\n *\n * const NONCE_VALUE_OFFSET =\n *     4 + // version(u32)\n *     4 + // state(u32)\n *     32; // nonce authority(pubkey)\n * // Then comes the nonce value.\n *\n * const nonceAccountAddress = address('EGtMh4yvXswwHhwVhyPxGrVV2TkLTgUqGodbATEPvojZ');\n * const nonceAuthorityAddress = address('4KD1Rdrd89NG7XbzW3xsX9Aqnx2EExJvExiNme6g9iAT');\n * const { value: nonceAccount } = await rpc\n *     .getAccountInfo(nonceAccountAddress, {\n *         dataSlice: { length: 32, offset: NONCE_VALUE_OFFSET },\n *         encoding: 'base58',\n *     })\n *     .send();\n * const nonce =\n *     // This works because we asked for the exact slice of data representing the nonce\n *     // value, and furthermore asked for it in `base58` encoding.\n *     nonceAccount!.data[0] as unknown as Nonce;\n *\n * const durableNonceTransactionMessage = setTransactionMessageLifetimeUsingDurableNonce(\n *     { nonce, nonceAccountAddress, nonceAuthorityAddress },\n *     tx,\n * );\n * ```\n */\nexport function setTransactionMessageLifetimeUsingDurableNonce<\n    TTransactionMessage extends BaseTransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n>(\n    {\n        nonce,\n        nonceAccountAddress,\n        nonceAuthorityAddress,\n    }: DurableNonceConfig<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue>,\n    transactionMessage: TTransactionMessage,\n): SetTransactionMessageWithDurableNonceLifetime<\n    TTransactionMessage,\n    TNonceAccountAddress,\n    TNonceAuthorityAddress,\n    TNonceValue\n> {\n    type ReturnType = SetTransactionMessageWithDurableNonceLifetime<\n        TTransactionMessage,\n        TNonceAccountAddress,\n        TNonceAuthorityAddress,\n        TNonceValue\n    >;\n\n    let newInstructions: [\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...Instruction[],\n    ];\n\n    const firstInstruction = transactionMessage.instructions[0];\n    if (firstInstruction && isAdvanceNonceAccountInstruction(firstInstruction)) {\n        if (isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {\n            if (\n                isTransactionMessageWithDurableNonceLifetime(transactionMessage) &&\n                transactionMessage.lifetimeConstraint.nonce === nonce\n            ) {\n                return transactionMessage as unknown as ReturnType;\n            } else {\n                // we already have the right first instruction, leave it as-is\n                newInstructions = [firstInstruction, ...transactionMessage.instructions.slice(1)];\n            }\n        } else {\n            // we have a different advance nonce instruction as the first instruction, replace it\n            newInstructions = [\n                Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n                ...transactionMessage.instructions.slice(1),\n            ];\n        }\n    } else {\n        // we don't have an existing advance nonce instruction as the first instruction, prepend one\n        newInstructions = [\n            Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n            ...transactionMessage.instructions,\n        ];\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze(newInstructions),\n        lifetimeConstraint: Object.freeze({ nonce }),\n    }) as unknown as ReturnType;\n}\n\n/**\n * Helper type that transforms a given transaction message type into a new one that has the\n * `AdvanceNonceAccount` instruction as the first instruction and a lifetime constraint\n * representing the nonce value.\n */\ntype SetTransactionMessageWithDurableNonceLifetime<\n    TTransactionMessage extends BaseTransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Omit<\n    // 1. The transaction message only grows in size if it currently has a different (or no) lifetime.\n    TTransactionMessage extends TransactionMessageWithDurableNonceLifetime\n        ? TTransactionMessage\n        : ExcludeTransactionMessageWithinSizeLimit<TTransactionMessage>,\n    // 2. Remove the instructions array as we are going to replace it with a new one.\n    'instructions'\n> & {\n    // 3. Replace or prepend the first instruction with the advance nonce account instruction.\n    readonly instructions: TTransactionMessage['instructions'] extends readonly [\n        AdvanceNonceAccountInstruction,\n        ...infer TTail extends readonly Instruction[],\n    ]\n        ? readonly [AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>, ...TTail]\n        : readonly [\n              AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n              ...TTransactionMessage['instructions'],\n          ];\n    // 4. Set the lifetime constraint to the nonce value.\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n};\n", "import { Address } from '@solana/addresses';\n\nimport { BaseTransactionMessage } from './transaction-message';\n\n/**\n * Represents a transaction message for which a fee payer has been declared. A transaction must\n * conform to this type to be compiled and landed on the network.\n */\nexport interface TransactionMessageWithFeePayer<TAddress extends string = string> {\n    readonly feePayer: Readonly<{ address: Address<TAddress> }>;\n}\n\n/**\n * A helper type to exclude the fee payer from a transaction message.\n */\ntype ExcludeTransactionMessageFeePayer<TTransactionMessage extends BaseTransactionMessage> = Omit<\n    TTransactionMessage,\n    'feePayer'\n>;\n\n/**\n * Given a base58-encoded address of a system account, this method will return a new transaction\n * message having the same type as the one supplied plus the {@link TransactionMessageWithFeePayer}\n * type.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { setTransactionMessageFeePayer } from '@solana/transaction-messages';\n *\n * const myAddress = address('mpngsFd4tmbUfzDYJayjKZwZcaR7aWb2793J6grLsGu');\n * const txPaidByMe = setTransactionMessageFeePayer(myAddress, tx);\n * ```\n */\nexport function setTransactionMessageFeePayer<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends BaseTransactionMessage & Partial<TransactionMessageWithFeePayer>,\n>(\n    feePayer: Address<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageFeePayer<TTransactionMessage> & TransactionMessageWithFeePayer<TFeePayerAddress> {\n    if (\n        'feePayer' in transactionMessage &&\n        feePayer === transactionMessage.feePayer?.address &&\n        isAddressOnlyFeePayer(transactionMessage.feePayer)\n    ) {\n        return transactionMessage as unknown as Omit<TTransactionMessage, 'feePayer'> &\n            TransactionMessageWithFeePayer<TFeePayerAddress>;\n    }\n    const out = {\n        ...transactionMessage,\n        feePayer: Object.freeze({ address: feePayer }),\n    };\n    Object.freeze(out);\n    return out;\n}\n\nfunction isAddressOnlyFeePayer(\n    feePayer: Partial<TransactionMessageWithFeePayer>['feePayer'],\n): feePayer is { address: Address } {\n    return (\n        !!feePayer &&\n        'address' in feePayer &&\n        typeof feePayer.address === 'string' &&\n        Object.keys(feePayer).length === 1\n    );\n}\n", "import { Instruction } from '@solana/instructions';\n\nimport { ExcludeTransactionMessageDurableNonceLifetime } from './durable-nonce';\nimport { BaseTransactionMessage } from './transaction-message';\nimport { ExcludeTransactionMessageWithinSizeLimit } from './transaction-message-size';\n\n/**\n * A helper type to append instructions to a transaction message\n * without losing type information about the current instructions.\n */\ntype AppendTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstructions extends readonly Instruction[],\n> = Omit<ExcludeTransactionMessageWithinSizeLimit<TTransactionMessage>, 'instructions'> & {\n    readonly instructions: readonly [...TTransactionMessage['instructions'], ...TInstructions];\n};\n\n/**\n * A helper type to prepend instructions to a transaction message\n * without losing type information about the current instructions.\n */\ntype PrependTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstructions extends readonly Instruction[],\n> = Omit<\n    ExcludeTransactionMessageWithinSizeLimit<ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage>>,\n    'instructions'\n> & {\n    readonly instructions: readonly [...TInstructions, ...TTransactionMessage['instructions']];\n};\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstructions} if you need to append multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { appendTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransaction = appendTransactionMessageInstruction(\n *     {\n *         data: new TextEncoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     tx,\n * );\n * ```\n */\nexport function appendTransactionMessageInstruction<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstruction extends Instruction,\n>(\n    instruction: TInstruction,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage, [TInstruction]> {\n    return appendTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstruction} if you only need to append one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { appendTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = appendTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function appendTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    const TInstructions extends readonly Instruction[],\n>(\n    instructions: TInstructions,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage, TInstructions> {\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze([\n            ...(transactionMessage.instructions as TTransactionMessage['instructions']),\n            ...instructions,\n        ] as readonly [...TTransactionMessage['instructions'], ...TInstructions]),\n    });\n}\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstructions} if you need to prepend multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstruction(\n *     {\n *         data: new TextEncoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstruction<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstruction extends Instruction,\n>(\n    instruction: TInstruction,\n    transactionMessage: TTransactionMessage,\n): PrependTransactionMessageInstructions<TTransactionMessage, [TInstruction]> {\n    return prependTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstruction} if you only need to prepend one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    const TInstructions extends readonly Instruction[],\n>(\n    instructions: TInstructions,\n    transactionMessage: TTransactionMessage,\n): PrependTransactionMessageInstructions<TTransactionMessage, TInstructions> {\n    return Object.freeze({\n        ...(transactionMessage as ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage>),\n        instructions: Object.freeze([\n            ...instructions,\n            ...(transactionMessage.instructions as TTransactionMessage['instructions']),\n        ] as readonly [...TInstructions, ...TTransactionMessage['instructions']]),\n    });\n}\n", "import { Address, assertIsAddress } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\nimport { pipe } from '@solana/functional';\nimport { AccountLookupMeta, AccountMeta, AccountRole, Instruction } from '@solana/instructions';\nimport type { Blockhash } from '@solana/rpc-types';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { setTransactionMessageLifetimeUsingBlockhash } from './blockhash';\nimport { CompilableTransactionMessage } from './compilable-transaction-message';\nimport { CompiledTransactionMessage } from './compile';\nimport type { getCompiledAddressTableLookups } from './compile/address-table-lookups';\nimport { createTransactionMessage } from './create-transaction-message';\nimport { Nonce, setTransactionMessageLifetimeUsingDurableNonce } from './durable-nonce';\nimport { isAdvanceNonceAccountInstruction } from './durable-nonce-instruction';\nimport { setTransactionMessageFeePayer, TransactionMessageWithFeePayer } from './fee-payer';\nimport { appendTransactionMessageInstruction } from './instructions';\nimport { BaseTransactionMessage, TransactionVersion } from './transaction-message';\n\nfunction getAccountMetas(message: CompiledTransactionMessage): AccountMeta[] {\n    const { header } = message;\n    const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;\n    const numWritableNonSignerAccounts =\n        message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;\n\n    const accountMetas: AccountMeta[] = [];\n\n    let accountIndex = 0;\n    for (let i = 0; i < numWritableSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlySignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < numWritableNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlyNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY,\n        });\n        accountIndex++;\n    }\n\n    return accountMetas;\n}\n\nfunction getAddressLookupMetas(\n    compiledAddressTableLookups: ReturnType<typeof getCompiledAddressTableLookups>,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): AccountLookupMeta[] {\n    // check that all message lookups are known\n    const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map(l => l.lookupTableAddress);\n    const missing = compiledAddressTableLookupAddresses.filter(a => addressesByLookupTableAddress[a] === undefined);\n    if (missing.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, {\n            lookupTableAddresses: missing,\n        });\n    }\n\n    const readOnlyMetas: AccountLookupMeta[] = [];\n    const writableMetas: AccountLookupMeta[] = [];\n\n    // we know that for each lookup, knownLookups[lookup.lookupTableAddress] is defined\n    for (const lookup of compiledAddressTableLookups) {\n        const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];\n        const readonlyIndexes =\n            lookup.readonlyIndexes ??\n            /** @deprecated Remove in a future major version */\n            lookup.readableIndices;\n        const writableIndexes =\n            lookup.writableIndexes ??\n            /** @deprecated Remove in a future major version */\n            lookup.writableIndices;\n\n        const highestIndex = Math.max(...readonlyIndexes, ...writableIndexes);\n        if (highestIndex >= addresses.length) {\n            throw new SolanaError(\n                SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n                {\n                    highestKnownIndex: addresses.length - 1,\n                    highestRequestedIndex: highestIndex,\n                    lookupTableAddress: lookup.lookupTableAddress,\n                },\n            );\n        }\n\n        const readOnlyForLookup: AccountLookupMeta[] = readonlyIndexes.map(r => ({\n            address: addresses[r],\n            addressIndex: r,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.READONLY,\n        }));\n        readOnlyMetas.push(...readOnlyForLookup);\n\n        const writableForLookup: AccountLookupMeta[] = writableIndexes.map(w => ({\n            address: addresses[w],\n            addressIndex: w,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.WRITABLE,\n        }));\n        writableMetas.push(...writableForLookup);\n    }\n\n    return [...writableMetas, ...readOnlyMetas];\n}\n\nfunction convertInstruction(\n    instruction: CompiledTransactionMessage['instructions'][0],\n    accountMetas: AccountMeta[],\n): Instruction {\n    const programAddress = accountMetas[instruction.programAddressIndex]?.address;\n    if (!programAddress) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, {\n            index: instruction.programAddressIndex,\n        });\n    }\n\n    const accounts = instruction.accountIndices?.map(accountIndex => accountMetas[accountIndex]);\n    const { data } = instruction;\n\n    return Object.freeze({\n        programAddress,\n        ...(accounts && accounts.length ? { accounts: Object.freeze(accounts) } : {}),\n        ...(data && data.length ? { data } : {}),\n    });\n}\n\ntype LifetimeConstraint =\n    | {\n          blockhash: Blockhash;\n          lastValidBlockHeight: bigint;\n      }\n    | {\n          nonce: Nonce;\n          nonceAccountAddress: Address;\n          nonceAuthorityAddress: Address;\n      };\n\nfunction getLifetimeConstraint(\n    messageLifetimeToken: string,\n    firstInstruction?: Instruction,\n    lastValidBlockHeight?: bigint,\n): LifetimeConstraint {\n    if (!firstInstruction || !isAdvanceNonceAccountInstruction(firstInstruction)) {\n        // first instruction is not advance durable nonce, so use blockhash lifetime constraint\n        return {\n            blockhash: messageLifetimeToken as Blockhash,\n            lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n, // U64 MAX\n        };\n    } else {\n        // We know these accounts are defined because we checked `isAdvanceNonceAccountInstruction`\n        const nonceAccountAddress = firstInstruction.accounts[0].address;\n        assertIsAddress(nonceAccountAddress);\n\n        const nonceAuthorityAddress = firstInstruction.accounts[2].address;\n        assertIsAddress(nonceAuthorityAddress);\n\n        return {\n            nonce: messageLifetimeToken as Nonce,\n            nonceAccountAddress,\n            nonceAuthorityAddress,\n        };\n    }\n}\n\nexport type DecompileTransactionMessageConfig = {\n    /**\n     * If the compiled message loads addresses from one or more address lookup tables, you will have\n     * to supply a map of those tables to an array of the addresses they contained at the time that\n     * the transaction message was constructed.\n     *\n     * @see {@link decompileTransactionMessageFetchingLookupTables} if you do not already have this.\n     */\n    addressesByLookupTableAddress?: AddressesByLookupTableAddress;\n    /**\n     * If the compiled message has a blockhash-based lifetime constraint, you will have to supply\n     * the block height after which that blockhash is no longer valid for use as a lifetime\n     * constraint.\n     */\n    lastValidBlockHeight?: bigint;\n};\n\n/**\n * Converts the type of transaction message data structure appropriate for execution on the network\n * to the type of transaction message data structure designed for use in your application.\n *\n * Because compilation is a lossy process, you can not fully reconstruct a source message from a\n * compiled message without extra information. In order to faithfully reconstruct the original\n * source message you will need to supply supporting details about the lifetime constraint and the\n * concrete addresses of any accounts sourced from account lookup tables.\n *\n * @see {@link compileTransactionMessage}\n */\nexport function decompileTransactionMessage(\n    compiledTransactionMessage: CompiledTransactionMessage,\n    config?: DecompileTransactionMessageConfig,\n): CompilableTransactionMessage {\n    const feePayer = compiledTransactionMessage.staticAccounts[0];\n    if (!feePayer) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING);\n    }\n\n    const accountMetas = getAccountMetas(compiledTransactionMessage);\n    const accountLookupMetas =\n        'addressTableLookups' in compiledTransactionMessage &&\n        compiledTransactionMessage.addressTableLookups !== undefined &&\n        compiledTransactionMessage.addressTableLookups.length > 0\n            ? getAddressLookupMetas(\n                  compiledTransactionMessage.addressTableLookups,\n                  config?.addressesByLookupTableAddress ?? {},\n              )\n            : [];\n    const transactionMetas = [...accountMetas, ...accountLookupMetas];\n\n    const instructions: Instruction[] = compiledTransactionMessage.instructions.map(compiledInstruction =>\n        convertInstruction(compiledInstruction, transactionMetas),\n    );\n\n    const firstInstruction = instructions[0];\n    const lifetimeConstraint = getLifetimeConstraint(\n        compiledTransactionMessage.lifetimeToken,\n        firstInstruction,\n        config?.lastValidBlockHeight,\n    );\n\n    return pipe(\n        createTransactionMessage({ version: compiledTransactionMessage.version as TransactionVersion }),\n        m => setTransactionMessageFeePayer(feePayer, m),\n        m =>\n            instructions.reduce(\n                (acc, instruction) => appendTransactionMessageInstruction(instruction, acc),\n                m as BaseTransactionMessage & TransactionMessageWithFeePayer,\n            ),\n        m =>\n            'blockhash' in lifetimeConstraint\n                ? setTransactionMessageLifetimeUsingBlockhash(lifetimeConstraint, m)\n                : setTransactionMessageLifetimeUsingDurableNonce(lifetimeConstraint, m),\n    );\n}\n", "import type { Address } from '@solana/addresses';\n\nimport {\n    assertIsTransactionMessageWithDurableNonceLifetime,\n    isTransactionMessageWithDurableNonceLifetime,\n} from './durable-nonce';\n\n/**\n * Represents a transaction message for which a fee payer has been declared. A transaction must\n * conform to this type to be compiled and landed on the network.\n *\n * @deprecated Use {@link TransactionMessageWithFeePayer} instead. It was only renamed.\n */\nexport interface ITransactionMessageWithFeePayer<TAddress extends string = string> {\n    readonly feePayer: Readonly<{ address: Address<TAddress> }>;\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * nonce-based lifetime, from an untrusted network API or user input. Use this function to assert\n * that such a transaction message actually has a nonce-based lifetime.\n *\n * @deprecated Use {@link assertIsTransactionMessageWithDurableNonceLifetime} instead. It was only renamed.\n *\n * @example\n * ```ts\n * import { assertIsDurableNonceTransactionMessage } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithDurableNonceLifetime`.\n *     assertIsDurableNonceTransactionMessage(message);\n *     // At this point, `message` is a `TransactionMessageWithDurableNonceLifetime` that can be used\n *     // with the RPC.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n * } catch (e) {\n *     // `message` turned out not to have a nonce-based lifetime\n * }\n * ```\n */\nexport const assertIsDurableNonceTransactionMessage = assertIsTransactionMessageWithDurableNonceLifetime;\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithDurableNonceLifetime} type, and refines its type for use in your\n * program.\n *\n * @deprecated Use {@link isTransactionMessageWithDurableNonceLifetime} instead. It was only renamed.\n *\n * @example\n * ```ts\n * import { isDurableNonceTransaction } from '@solana/transaction-messages';\n * import { fetchNonce } from \"@solana-program/system\";\n *\n * if (isDurableNonceTransaction(message)) {\n *     // At this point, `message` has been refined to a\n *     // `TransactionMessageWithDurableNonceLifetime`.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n *     setNonceIsValid(nonce === actualNonce);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a nonce-based lifetime`,\n *     );\n * }\n * ```\n */\nexport const isDurableNonceTransaction = isTransactionMessageWithDurableNonceLifetime;\n", "import { fixEncoderSize, transformEncoder, VariableSizeEncoder } from '@solana/codecs-core';\nimport { getArrayEncoder, getBytesEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Encoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { SignaturesMap } from '../transaction';\n\nfunction getSignaturesToEncode(signaturesMap: SignaturesMap): SignatureBytes[] {\n    const signatures = Object.values(signaturesMap);\n    if (signatures.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES);\n    }\n\n    return signatures.map(signature => {\n        if (!signature) {\n            return new Uint8Array(64).fill(0) as SignatureBytes;\n        }\n        return signature;\n    });\n}\n\nexport function getSignaturesEncoder(): VariableSizeEncoder<SignaturesMap> {\n    return transformEncoder(\n        getArrayEncoder(fixEncoderSize(getBytesEncoder(), 64), { size: getShortU16Encoder() }),\n        getSignaturesToEncode,\n    );\n}\n", "import { getAddressDecoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    fixDecoderSize,\n    padRightDecoder,\n    ReadonlyUint8Array,\n    transformDecoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getTupleDecoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getU8Decoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { getTransactionVersionDecoder } from '@solana/transaction-messages';\n\nimport { SignaturesMap, Transaction, TransactionMessageBytes } from '../transaction';\nimport { getSignaturesEncoder } from './signatures-encoder';\n\n/**\n * Returns an encoder that you can use to encode a {@link Transaction} to a byte array in a wire\n * format appropriate for sending to the Solana network for execution.\n */\nexport function getTransactionEncoder(): VariableSizeEncoder<Transaction> {\n    return getStructEncoder([\n        ['signatures', getSignaturesEncoder()],\n        ['messageBytes', getBytesEncoder()],\n    ]);\n}\n\n/**\n * Returns a decoder that you can use to convert a byte array in the Solana transaction wire format\n * to a {@link Transaction} object.\n *\n * @example\n * ```ts\n * import { getTransactionDecoder } from '@solana/transactions';\n *\n * const transactionDecoder = getTransactionDecoder();\n * const transaction = transactionDecoder.decode(wireTransactionBytes);\n * for (const [address, signature] in Object.entries(transaction.signatures)) {\n *     console.log(`Signature by ${address}`, signature);\n * }\n * ```\n */\n\nexport function getTransactionDecoder(): VariableSizeDecoder<Transaction> {\n    return transformDecoder(\n        getStructDecoder([\n            ['signatures', getArrayDecoder(fixDecoderSize(getBytesDecoder(), 64), { size: getShortU16Decoder() })],\n            ['messageBytes', getBytesDecoder()],\n        ]),\n        decodePartiallyDecodedTransaction,\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a {@link Transaction}\n *\n * @see {@link getTransactionDecoder}\n * @see {@link getTransactionEncoder}\n */\nexport function getTransactionCodec(): VariableSizeCodec<Transaction> {\n    return combineCodec(getTransactionEncoder(), getTransactionDecoder());\n}\n\ntype PartiallyDecodedTransaction = {\n    messageBytes: ReadonlyUint8Array;\n    signatures: ReadonlyUint8Array[];\n};\n\nfunction decodePartiallyDecodedTransaction(transaction: PartiallyDecodedTransaction): Transaction {\n    const { messageBytes, signatures } = transaction;\n\n    /*\n    Relevant message structure is at the start:\n    - transaction version (0 bytes for legacy transactions, 1 byte for versioned transactions)\n    - `numRequiredSignatures` (1 byte, we verify this matches the length of signatures)\n    - `numReadOnlySignedAccounts` (1 byte, not used here)\n    - `numReadOnlyUnsignedAccounts` (1 byte, not used here)\n    - static addresses, with signers first. This is an array of addresses, prefixed with a short-u16 length\n    */\n\n    const signerAddressesDecoder = getTupleDecoder([\n        // read transaction version\n        getTransactionVersionDecoder(),\n        // read first byte of header, `numSignerAccounts`\n        // padRight to skip the next 2 bytes, `numReadOnlySignedAccounts` and `numReadOnlyUnsignedAccounts` which we don't need\n        padRightDecoder(getU8Decoder(), 2),\n        // read static addresses\n        getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() }),\n    ]);\n    const [_txVersion, numRequiredSignatures, staticAddresses] = signerAddressesDecoder.decode(messageBytes);\n\n    const signerAddresses = staticAddresses.slice(0, numRequiredSignatures);\n\n    // signer addresses and signatures must be the same length\n    // we encode an all-zero signature when the signature is missing\n    if (signerAddresses.length !== signatures.length) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, {\n            numRequiredSignatures,\n            signaturesLength: signatures.length,\n            signerAddresses,\n        });\n    }\n\n    // combine the signer addresses + signatures into the signatures map\n    const signaturesMap: SignaturesMap = {};\n    signerAddresses.forEach((address, index) => {\n        const signatureForAddress = signatures[index];\n        if (signatureForAddress.every(b => b === 0)) {\n            signaturesMap[address] = null;\n        } else {\n            signaturesMap[address] = signatureForAddress as SignatureBytes;\n        }\n    });\n\n    return {\n        messageBytes: messageBytes as TransactionMessageBytes,\n        signatures: Object.freeze(signaturesMap),\n    };\n}\n", "import {\n    CompilableTransactionMessage,\n    compileTransactionMessage,\n    getCompiledTransactionMessageEncoder,\n    isTransactionMessageWithBlockhashLifetime,\n} from '@solana/transaction-messages';\n\nimport type { TransactionWithLifetime } from './lifetime';\nimport type {\n    SignaturesMap,\n    TransactionFromCompilableTransactionMessage,\n    TransactionMessageBytes,\n} from './transaction';\n\n/**\n * Returns a {@link Transaction} object for a given {@link TransactionMessage}.\n *\n * This includes the compiled bytes of the transaction message, and a map of signatures. This map\n * will have a key for each address that is required to sign the transaction. The transaction will\n * not yet have signatures for any of these addresses.\n *\n * Whether a transaction message is ready to be compiled or not is enforced for you at the type\n * level. In order to be signable, a transaction message must:\n *\n * - have a version and a list of zero or more instructions (ie. conform to\n *   {@link BaseTransactionMessage})\n * - have a fee payer set (ie. conform to {@link TransactionMessageWithFeePayer})\n * - have a lifetime specified (ie. conform to {@link TransactionMessageWithBlockhashLifetime} or\n *   {@link TransactionMessageWithDurableNonceLifetime})\n */\nexport function compileTransaction<TTransactionMessage extends CompilableTransactionMessage>(\n    transactionMessage: TTransactionMessage,\n): Readonly<TransactionFromCompilableTransactionMessage<TTransactionMessage>> {\n    type ReturnType = Readonly<TransactionFromCompilableTransactionMessage<TTransactionMessage>>;\n\n    const compiledMessage = compileTransactionMessage(transactionMessage);\n    const messageBytes = getCompiledTransactionMessageEncoder().encode(compiledMessage) as TransactionMessageBytes;\n\n    const transactionSigners = compiledMessage.staticAccounts.slice(0, compiledMessage.header.numSignerAccounts);\n    const signatures: SignaturesMap = {};\n    for (const signerAddress of transactionSigners) {\n        signatures[signerAddress] = null;\n    }\n\n    let lifetimeConstraint: TransactionWithLifetime['lifetimeConstraint'];\n    if (isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        lifetimeConstraint = {\n            blockhash: transactionMessage.lifetimeConstraint.blockhash,\n            lastValidBlockHeight: transactionMessage.lifetimeConstraint.lastValidBlockHeight,\n        };\n    } else {\n        lifetimeConstraint = {\n            nonce: transactionMessage.lifetimeConstraint.nonce,\n            nonceAccountAddress: transactionMessage.instructions[0].accounts[0].address,\n        };\n    }\n\n    return Object.freeze({\n        lifetimeConstraint,\n        messageBytes: messageBytes,\n        signatures: Object.freeze(signatures),\n    }) as ReturnType;\n}\n", "import { Address, getAddressFromPublicKey } from '@solana/addresses';\nimport { Decoder } from '@solana/codecs-core';\nimport { getBase58Decoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { Signature, SignatureBytes, signBytes } from '@solana/keys';\nimport { NominalType } from '@solana/nominal-types';\n\nimport { Transaction } from './transaction';\n\n/**\n * Represents a transaction that is signed by all of its required signers. Being fully signed is a\n * prerequisite of functions designed to land transactions on the network.\n */\nexport type FullySignedTransaction = NominalType<'transactionSignedness', 'fullySigned'> & Transaction;\n\nlet base58Decoder: Decoder<string> | undefined;\n\n/**\n * Given a transaction signed by its fee payer, this method will return the {@link Signature} that\n * uniquely identifies it. This string can be used to look up transactions at a later date, for\n * example on a Solana block explorer.\n *\n * @example\n * ```ts\n * import { getSignatureFromTransaction } from '@solana/transactions';\n *\n * const signature = getSignatureFromTransaction(tx);\n * console.debug(`Inspect this transaction at https://explorer.solana.com/tx/${signature}`);\n * ```\n */\nexport function getSignatureFromTransaction(transaction: Transaction): Signature {\n    if (!base58Decoder) base58Decoder = getBase58Decoder();\n\n    // We have ordered signatures from the compiled message accounts\n    // first signature is the fee payer\n    const signatureBytes = Object.values(transaction.signatures)[0];\n    if (!signatureBytes) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING);\n    }\n    const transactionSignature = base58Decoder.decode(signatureBytes);\n    return transactionSignature as Signature;\n}\n\nfunction uint8ArraysEqual(arr1: Uint8Array, arr2: Uint8Array) {\n    return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign a transaction, this method will return a new signed transaction of type\n * {@link Transaction}.\n *\n * Though the resulting transaction might have every signature it needs to land on the network, this\n * function will not assert that it does. A partially signed transaction cannot be landed on the\n * network, but can be serialized and deserialized.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { partiallySignTransaction } from '@solana/transactions';\n *\n * const partiallySignedTransaction = await partiallySignTransaction([myPrivateKey], tx);\n * ```\n *\n * @see {@link signTransaction} if you want to assert that the transaction has all of its required\n * signatures after signing.\n */\nexport async function partiallySignTransaction<T extends Transaction>(\n    keyPairs: CryptoKeyPair[],\n    transaction: T,\n): Promise<T> {\n    let newSignatures: Record<Address, SignatureBytes> | undefined;\n    let unexpectedSigners: Set<Address> | undefined;\n\n    await Promise.all(\n        keyPairs.map(async keyPair => {\n            const address = await getAddressFromPublicKey(keyPair.publicKey);\n            const existingSignature = transaction.signatures[address];\n\n            // Check if the address is expected to sign the transaction\n            if (existingSignature === undefined) {\n                // address is not an expected signer for this transaction\n                unexpectedSigners ||= new Set();\n                unexpectedSigners.add(address);\n                return;\n            }\n\n            // Return if there are any unexpected signers already since we won't be using signatures\n            if (unexpectedSigners) {\n                return;\n            }\n\n            const newSignature = await signBytes(keyPair.privateKey, transaction.messageBytes);\n\n            if (existingSignature !== null && uint8ArraysEqual(newSignature, existingSignature)) {\n                // already have the same signature set\n                return;\n            }\n\n            newSignatures ||= {};\n            newSignatures[address] = newSignature;\n        }),\n    );\n\n    if (unexpectedSigners && unexpectedSigners.size > 0) {\n        const expectedSigners = Object.keys(transaction.signatures);\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION, {\n            expectedAddresses: expectedSigners,\n            unexpectedAddresses: [...unexpectedSigners],\n        });\n    }\n\n    if (!newSignatures) {\n        return transaction;\n    }\n\n    return Object.freeze({\n        ...transaction,\n        signatures: Object.freeze({\n            ...transaction.signatures,\n            ...newSignatures,\n        }),\n    });\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign a transaction, this method will return a new signed transaction of type\n * {@link FullySignedTransaction}.\n *\n * This function will throw unless the resulting transaction is fully signed.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { signTransaction } from '@solana/transactions';\n *\n * const signedTransaction = await signTransaction([myPrivateKey], tx);\n * ```\n *\n * @see {@link partiallySignTransaction} if you want to sign the transaction without asserting that\n * the resulting transaction is fully signed.\n */\nexport async function signTransaction<T extends Transaction>(\n    keyPairs: CryptoKeyPair[],\n    transaction: T,\n): Promise<FullySignedTransaction & T> {\n    const out = await partiallySignTransaction(keyPairs, transaction);\n    assertIsFullySignedTransaction(out);\n    Object.freeze(out);\n    return out;\n}\n\n/**\n * Checks whether a given {@link Transaction} is fully signed.\n *\n * @example\n * ```ts\n * import { isFullySignedTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * if (isFullySignedTransaction(transaction)) {\n *   // At this point we know that the transaction is signed and can be sent to the network.\n * }\n * ```\n */\nexport function isFullySignedTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): transaction is FullySignedTransaction & TTransaction {\n    return Object.entries(transaction.signatures).every(([_, signatureBytes]) => !!signatureBytes);\n}\n\n/**\n * From time to time you might acquire a {@link Transaction}, that you expect to be fully signed,\n * from an untrusted network API or user input. Use this function to assert that such a transaction\n * is fully signed.\n *\n * @example\n * ```ts\n * import { assertIsFullySignedTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * try {\n *     // If this type assertion function doesn't throw, then Typescript will upcast `transaction`\n *     // to `FullySignedTransaction`.\n *     assertIsFullySignedTransaction(transaction);\n *     // At this point we know that the transaction is signed and can be sent to the network.\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n * } catch(e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         setError(`Missing signatures for ${e.context.addresses.join(', ')}`);\n *     }\n *     throw;\n * }\n * ```\n */\nexport function assertIsFullySignedTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): asserts transaction is FullySignedTransaction & TTransaction {\n    const missingSigs: Address[] = [];\n    Object.entries(transaction.signatures).forEach(([address, signatureBytes]) => {\n        if (!signatureBytes) {\n            missingSigs.push(address as Address);\n        }\n    });\n\n    if (missingSigs.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING, {\n            addresses: missingSigs,\n        });\n    }\n}\n", "import { getBase64Decoder } from '@solana/codecs-strings';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nimport { getTransactionEncoder } from './codecs';\nimport { Transaction } from './transaction';\n\n/** Represents the wire format of a transaction as a base64-encoded string. */\nexport type Base64EncodedWireTransaction = Brand<EncodedString<string, 'base64'>, 'Base64EncodedWireTransaction'>;\n\n/**\n * Given a signed transaction, this method returns the transaction as a string that conforms to the\n * {@link Base64EncodedWireTransaction} type.\n *\n * @example\n * ```ts\n * import { getBase64EncodedWireTransaction, signTransaction } from '@solana/transactions';\n *\n * const serializedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n * const signature = await rpc.sendTransaction(serializedTransaction, { encoding: 'base64' }).send();\n * ```\n */\nexport function getBase64EncodedWireTransaction(transaction: Transaction): Base64EncodedWireTransaction {\n    const wireTransactionBytes = getTransactionEncoder().encode(transaction);\n    return getBase64Decoder().decode(wireTransactionBytes) as Base64EncodedWireTransaction;\n}\n", "import { SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, SolanaError } from '@solana/errors';\nimport type { NominalType } from '@solana/nominal-types';\nimport type { BaseTransactionMessage, TransactionMessageWithinSizeLimit } from '@solana/transaction-messages';\n\nimport { getTransactionEncoder } from './codecs';\nimport { Transaction } from './transaction';\n\n/**\n * The maximum size of a transaction packet in bytes.\n */\nexport const TRANSACTION_PACKET_SIZE = 1280;\n\n/**\n * The size of the transaction packet header in bytes.\n * This includes the IPv6 header and the fragment header.\n */\nexport const TRANSACTION_PACKET_HEADER =\n    40 /* 40 bytes is the size of the IPv6 header. */ + 8; /* 8 bytes is the size of the fragment header. */\n\n/**\n * The maximum size of a transaction in bytes.\n *\n * Note that this excludes the transaction packet header.\n * In other words, this is how much content we can fit in a transaction packet.\n */\nexport const TRANSACTION_SIZE_LIMIT = TRANSACTION_PACKET_SIZE - TRANSACTION_PACKET_HEADER;\n\n/**\n * Gets the size of a given transaction in bytes.\n *\n * @example\n * ```ts\n * const transactionSize = getTransactionSize(transaction);\n * ```\n */\nexport function getTransactionSize(transaction: Transaction): number {\n    return getTransactionEncoder().getSizeFromValue(transaction);\n}\n\n/**\n * A type guard that checks if a transaction is within the size limit.\n */\nexport type TransactionWithinSizeLimit = NominalType<'transactionSize', 'withinLimit'>;\n\n/**\n * Helper type that adds the `TransactionWithinSizeLimit` flag to\n * a transaction if and only if the provided transaction message\n * is also within the size limit.\n */\nexport type SetTransactionWithinSizeLimitFromTransactionMessage<\n    TTransaction extends Transaction,\n    TTransactionMessage extends BaseTransactionMessage,\n> = TTransactionMessage extends TransactionMessageWithinSizeLimit\n    ? TransactionWithinSizeLimit & TTransaction\n    : TTransaction;\n\n/**\n * Checks if a transaction is within the size limit.\n *\n * @typeParam TTransaction - The type of the given transaction.\n *\n * @example\n * ```ts\n * if (isTransactionWithinSizeLimit(transaction)) {\n *    transaction satisfies TransactionWithinSizeLimit;\n * }\n * ```\n */\nexport function isTransactionWithinSizeLimit<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): transaction is TransactionWithinSizeLimit & TTransaction {\n    return getTransactionSize(transaction) <= TRANSACTION_SIZE_LIMIT;\n}\n\n/**\n * Asserts that a given transaction is within the size limit.\n *\n * Throws a {@link SolanaError} of code {@link SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT}\n * if the transaction exceeds the size limit.\n *\n * @typeParam TTransaction - The type of the given transaction.\n *\n * @example\n * ```ts\n * assertIsTransactionWithinSizeLimit(transaction);\n * transaction satisfies TransactionWithinSizeLimit;\n * ```\n */\nexport function assertIsTransactionWithinSizeLimit<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): asserts transaction is TransactionWithinSizeLimit & TTransaction {\n    const transactionSize = getTransactionSize(transaction);\n    if (transactionSize > TRANSACTION_SIZE_LIMIT) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, {\n            transactionSize,\n            transactionSizeLimit: TRANSACTION_SIZE_LIMIT,\n        });\n    }\n}\n", "import { SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, SolanaError } from '@solana/errors';\nimport type { CompilableTransactionMessage, TransactionMessageWithinSizeLimit } from '@solana/transaction-messages';\n\nimport { compileTransaction } from './compile-transaction';\nimport { getTransactionSize, TRANSACTION_SIZE_LIMIT } from './transaction-size';\n\n/**\n * Gets the compiled transaction size of a given transaction message in bytes.\n *\n * @example\n * ```ts\n * const transactionSize = getTransactionMessageSize(transactionMessage);\n * ```\n */\nexport function getTransactionMessageSize(transactionMessage: CompilableTransactionMessage): number {\n    return getTransactionSize(compileTransaction(transactionMessage));\n}\n\n/**\n * Checks if a transaction message is within the size limit\n * when compiled into a transaction.\n *\n * @typeParam TTransactionMessage - The type of the given transaction message.\n *\n * @example\n * ```ts\n * if (isTransactionMessageWithinSizeLimit(transactionMessage)) {\n *    transactionMessage satisfies TransactionMessageWithinSizeLimit;\n * }\n * ```\n */\nexport function isTransactionMessageWithinSizeLimit<TTransactionMessage extends CompilableTransactionMessage>(\n    transactionMessage: TTransactionMessage,\n): transactionMessage is TransactionMessageWithinSizeLimit & TTransactionMessage {\n    return getTransactionMessageSize(transactionMessage) <= TRANSACTION_SIZE_LIMIT;\n}\n\n/**\n * Asserts that a given transaction message is within the size limit\n * when compiled into a transaction.\n *\n * Throws a {@link SolanaError} of code {@link SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT}\n * if the transaction message exceeds the size limit.\n *\n * @typeParam TTransactionMessage - The type of the given transaction message.\n *\n * @example\n * ```ts\n * assertIsTransactionMessageWithinSizeLimit(transactionMessage);\n * transactionMessage satisfies TransactionMessageWithinSizeLimit;\n * ```\n */\nexport function assertIsTransactionMessageWithinSizeLimit<TTransactionMessage extends CompilableTransactionMessage>(\n    transactionMessage: TTransactionMessage,\n): asserts transactionMessage is TransactionMessageWithinSizeLimit & TTransactionMessage {\n    const transactionSize = getTransactionMessageSize(transactionMessage);\n    if (transactionSize > TRANSACTION_SIZE_LIMIT) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, {\n            transactionSize,\n            transactionSizeLimit: TRANSACTION_SIZE_LIMIT,\n        });\n    }\n}\n", "import { assertIsFullySignedTransaction } from './signatures';\n\n/**\n * From time to time you might acquire a {@link Transaction}, that you expect to be fully signed,\n * from an untrusted network API or user input. Use this function to assert that such a transaction\n * is fully signed.\n *\n * @deprecated Use {@link assertIsFullySignedTransaction} instead. It was only renamed.\n *\n * @example\n * ```ts\n * import { assertTransactionIsFullySigned } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * try {\n *     // If this type assertion function doesn't throw, then Typescript will upcast `transaction`\n *     // to `FullySignedTransaction`.\n *     assertTransactionIsFullySigned(transaction);\n *     // At this point we know that the transaction is signed and can be sent to the network.\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n * } catch(e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         setError(`Missing signatures for ${e.context.addresses.join(', ')}`);\n *     }\n *     throw;\n * }\n * ```\n */\nexport const assertTransactionIsFullySigned = assertIsFullySignedTransaction;\n", "import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, SolanaError } from '@solana/errors';\n\nimport { MessageSigner } from './message-signer';\nimport { TransactionSigner } from './transaction-signer';\n\n/**\n * Removes all duplicated {@link MessageSigner | MessageSigners} and\n * {@link TransactionSigner | TransactionSigners} from a provided array\n * by comparing their {@link Address | addresses}.\n *\n * @internal\n */\nexport function deduplicateSigners<TSigner extends MessageSigner | TransactionSigner>(\n    signers: readonly TSigner[],\n): readonly TSigner[] {\n    const deduplicated: Record<Address, TSigner> = {};\n    signers.forEach(signer => {\n        if (!deduplicated[signer.address]) {\n            deduplicated[signer.address] = signer;\n        } else if (deduplicated[signer.address] !== signer) {\n            throw new SolanaError(SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, {\n                address: signer.address,\n            });\n        }\n    });\n    return Object.values(deduplicated);\n}\n", "import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\nimport { Transaction } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link TransactionModifyingSigner#modifyAndSignTransactions | modifyAndSignTransactions} method.\n *\n * @see {@link BaseTransactionSignerConfig}\n */\nexport type TransactionModifyingSignerConfig = BaseTransactionSignerConfig;\n\n/**\n * A signer interface that potentially modifies the provided {@link Transaction | Transactions}\n * before signing them.\n *\n * For instance, this enables wallets to inject additional instructions into the\n * transaction before signing them. For each transaction, instead of returning a {@link SignatureDirectory},\n * its {@link TransactionModifyingSigner#modifyAndSignTransactions | modifyAndSignTransactions}\n * function returns an updated {@link Transaction} with a potentially\n * modified set of instructions and signature dictionary.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: TransactionModifyingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     modifyAndSignTransactions: async <T extends Transaction>(\n *         transactions: T[]\n *     ): Promise<T[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Sequential**. Contrary to partial signers, these cannot be executed in\n *   parallel as each call can modify the provided transactions.\n * - **First signers**. For a given transaction, a modifying signer must always\n *   be used before a partial signer as the former will likely modify the\n *   transaction and thus impact the outcome of the latter.\n * - **Potential conflicts**. If more than one modifying signer is provided,\n *   the second signer may invalidate the signature of the first one. However,\n *   modifying signers may decide not to modify a transaction based on the\n *   existence of signatures for that transaction.\n *\n * @see {@link isTransactionModifyingSigner}\n * @see {@link assertIsTransactionModifyingSigner}\n */\nexport type TransactionModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignTransactions<T extends Transaction>(\n        transactions: readonly T[],\n        config?: TransactionModifyingSignerConfig,\n    ): Promise<readonly T[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionModifyingSigner({ address, modifyAndSignTransactions: async () => {} }); // true\n * isTransactionModifyingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionModifyingSigner}\n */\nexport function isTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionModifyingSigner<TAddress> {\n    return 'modifyAndSignTransactions' in value && typeof value.modifyAndSignTransactions === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionModifyingSigner({ address, modifyAndSignTransactions: async () => {} }); // void\n * assertIsTransactionModifyingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionModifyingSigner}\n */\nexport function assertIsTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionModifyingSigner<TAddress> {\n    if (!isTransactionModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n", "import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\nimport { Transaction } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig, SignatureDictionary } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link TransactionPartialSigner#signTransactions | signTransactions} method.\n *\n * @see {@link BaseTransactionSignerConfig}\n */\nexport type TransactionPartialSignerConfig = BaseTransactionSignerConfig;\n\n/**\n * A signer interface that signs an array of {@link Transaction | Transactions}\n *  without modifying their content. It defines a\n * {@link TransactionPartialSigner#signTransactions | signTransactions}\n * function that returns a {@link SignatureDictionary} for each provided transaction.\n *\n * Such signature dictionaries are expected to be merged with the existing ones if any.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: TransactionPartialSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     signTransactions: async (\n *         transactions: Transaction[]\n *     ): Promise<SignatureDictionary[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Parallel**. It returns a signature directory for each provided\n *   transaction without modifying them, making it possible for multiple\n *   partial signers to sign the same transaction in parallel.\n * - **Flexible order**. The order in which we use these signers for\n *   a given transaction doesn’t matter.\n *\n * @see {@link isTransactionPartialSigner}\n * @see {@link assertIsTransactionPartialSigner}\n */\nexport type TransactionPartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signTransactions(\n        transactions: readonly Transaction[],\n        config?: TransactionPartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionPartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionPartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionPartialSigner({ address, signTransactions: async () => {} }); // true\n * isTransactionPartialSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionPartialSigner}\n */\nexport function isTransactionPartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionPartialSigner<TAddress> {\n    return 'signTransactions' in value && typeof value.signTransactions === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionPartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionPartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionPartialSigner({ address, signTransactions: async () => {} }); // void\n * assertIsTransactionPartialSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionPartialSigner}\n */\nexport function assertIsTransactionPartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionPartialSigner<TAddress> {\n    if (!isTransactionPartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n", "import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { Transaction } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link TransactionSendingSignerConfig#signAndSendTransactions | signAndSendTransactions} method.\n *\n * @see {@link BaseTransactionSignerConfig}\n */\nexport type TransactionSendingSignerConfig = BaseTransactionSignerConfig;\n\n/**\n * A signer interface that signs one or multiple transactions\n * before sending them immediately to the blockchain.\n *\n * It defines a {@link TransactionSendingSignerConfig#signAndSendTransactions | signAndSendTransactions}\n * function that returns the transaction signature (i.e. its identifier) for each provided\n * {@link CompilableTransaction}.\n *\n * This interface is required for PDA wallets and other types of wallets that don't provide an\n * interface for signing transactions without sending them.\n *\n * Note that it is also possible for such signers to modify the provided transactions\n * before signing and sending them. This enables use cases where the modified transactions\n * cannot be shared with the app and thus must be sent directly.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const myTransactionSendingSigner: TransactionSendingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     signAndSendTransactions: async (transactions: Transaction[]): Promise<SignatureBytes[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Single signer**. Since this signer also sends the provided transactions,\n *   we can only use a single {@link TransactionSendingSigner} for a given set of transactions.\n * - **Last signer**. Trivially, that signer must also be the last one used.\n * - **Potential conflicts**. Since signers may decide to modify the given\n *   transactions before sending them, they may invalidate previous signatures.\n *   However, signers may decide not to modify a transaction based\n *   on the existence of signatures for that transaction.\n * - **Potential confirmation**. Whilst this is not required by this interface,\n *   it is also worth noting that most wallets will also wait for the transaction\n *   to be confirmed (typically with a `confirmed` commitment)\n *   before notifying the app that they are done.\n *\n * @see {@link isTransactionSendingSigner}\n * @see {@link assertIsTransactionSendingSigner}\n */\nexport type TransactionSendingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signAndSendTransactions(\n        transactions: readonly Transaction[],\n        config?: TransactionSendingSignerConfig,\n    ): Promise<readonly SignatureBytes[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionSendingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionSendingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionSendingSigner({ address, signAndSendTransactions: async () => {} }); // true\n * isTransactionSendingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionSendingSigner}\n */\nexport function isTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSendingSigner<TAddress> {\n    return 'signAndSendTransactions' in value && typeof value.signAndSendTransactions === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionSendingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionSendingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionSendingSigner({ address, signAndSendTransactions: async () => {} }); // void\n * assertIsTransactionSendingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionSendingSigner}\n */\nexport function assertIsTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSendingSigner<TAddress> {\n    if (!isTransactionSendingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n", "import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isTransactionModifyingSigner, TransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner, TransactionSendingSigner } from './transaction-sending-signer';\n\n/**\n * Defines a signer capable of signing transactions.\n *\n * @see {@link TransactionModifyingSigner} For signers that can modify transactions before signing them.\n * @see {@link TransactionPartialSigner} For signers that can be used in parallel.\n * @see {@link TransactionSendingSigner} For signers that send transactions after signing them.\n * @see {@link isTransactionSigner}\n * @see {@link assertIsTransactionSigner}\n */\nexport type TransactionSigner<TAddress extends string = string> =\n    | TransactionModifyingSigner<TAddress>\n    | TransactionPartialSigner<TAddress>\n    | TransactionSendingSigner<TAddress>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionSigner({ address, signTransactions: async () => {} }); // true\n * isTransactionSigner({ address, modifyAndSignTransactions: async () => {} }); // true\n * isTransactionSigner({ address, signAndSendTransactions: async () => {} }); // true\n * isTransactionSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionSigner}\n */\nexport function isTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSigner<TAddress> {\n    return (\n        isTransactionPartialSigner(value) || isTransactionModifyingSigner(value) || isTransactionSendingSigner(value)\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionSigner({ address, signTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address, modifyAndSignTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address, signAndSendTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionSigner}\n */\nexport function assertIsTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSigner<TAddress> {\n    if (!isTransactionSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n", "import { AccountLookupMeta, AccountMeta, AccountRole, Instruction } from '@solana/instructions';\nimport {\n    BaseTransactionMessage,\n    TransactionMessageWithFeePayer,\n    TransactionVersion,\n} from '@solana/transaction-messages';\n\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { TransactionMessageWithFeePayerSigner } from './fee-payer-signer';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\n\n/**\n * An extension of the {@link AccountMeta} type that allows us to store {@link TransactionSigner | TransactionSigners} inside it.\n *\n * Note that, because this type represents a signer, it must use one the following two roles:\n * - {@link AccountRole.READONLY_SIGNER}\n * - {@link AccountRole.WRITABLE_SIGNER}\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for the {@link TransactionSigner} to use within the account meta.\n *\n * @interface\n *\n * @example\n * ```ts\n * import { AccountRole } from '@solana/instructions';\n * import { generateKeyPairSigner, AccountSignerMeta } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * const account: AccountSignerMeta = {\n *     address: signer.address,\n *     role: AccountRole.READONLY_SIGNER,\n *     signer,\n * };\n * ```\n */\nexport interface AccountSignerMeta<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> extends AccountMeta<TAddress> {\n    readonly role: AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER;\n    readonly signer: TSigner;\n}\n\n/**\n * A union type that supports base account metas as well as {@link AccountSignerMeta | signer account metas}.\n */\ntype AccountMetaWithSigner<TSigner extends TransactionSigner = TransactionSigner> =\n    | AccountLookupMeta\n    | AccountMeta\n    | AccountSignerMeta<string, TSigner>;\n\n/**\n * Composable type that allows {@link AccountSignerMeta | AccountSignerMetas} to be used inside the instruction's `accounts` array\n *\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TAccounts - Optionally provide a narrower type for the account metas.\n *\n * @interface\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { generateKeyPairSigner, InstructionWithSigners } from '@solana/signers';\n *\n * const [authority, buffer] = await Promise.all([\n *     generateKeyPairSigner(),\n *     generateKeyPairSigner(),\n * ]);\n * const instruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [\n *         // The authority is a signer account.\n *         {\n *             address: authority.address,\n *             role: AccountRole.READONLY_SIGNER,\n *             signer: authority,\n *         },\n *         // The buffer is a writable account.\n *         { address: buffer.address, role: AccountRole.WRITABLE },\n *     ],\n * };\n * ```\n */\nexport type InstructionWithSigners<\n    TSigner extends TransactionSigner = TransactionSigner,\n    TAccounts extends readonly AccountMetaWithSigner<TSigner>[] = readonly AccountMetaWithSigner<TSigner>[],\n> = Pick<Instruction<string, TAccounts>, 'accounts'>;\n\n/**\n * A {@link BaseTransactionMessage} type extension that accept {@link TransactionSigner | TransactionSigners}.\n *\n * Namely, it allows:\n * - a {@link TransactionSigner} to be used as the fee payer and\n * - {@link InstructionWithSigners} to be used in its instructions.\n *\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TAccounts - Optionally provide a narrower type for the account metas.\n *\n * @example\n * ```ts\n * import { Instruction } from '@solana/instructions';\n * import { BaseTransactionMessage } from '@solana/transaction-messages';\n * import { generateKeyPairSigner, InstructionWithSigners, TransactionMessageWithSigners } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * const firstInstruction: Instruction = { ... };\n * const secondInstruction: InstructionWithSigners = { ... };\n * const transactionMessage: BaseTransactionMessage & TransactionMessageWithSigners = {\n *     feePayer: signer,\n *     instructions: [firstInstruction, secondInstruction],\n * }\n * ```\n */\nexport type TransactionMessageWithSigners<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n    TAccounts extends readonly AccountMetaWithSigner<TSigner>[] = readonly AccountMetaWithSigner<TSigner>[],\n> = Partial<TransactionMessageWithFeePayer<TAddress> | TransactionMessageWithFeePayerSigner<TAddress, TSigner>> &\n    Pick<\n        BaseTransactionMessage<TransactionVersion, Instruction & InstructionWithSigners<TSigner, TAccounts>>,\n        'instructions'\n    >;\n\n/**\n * Extracts and deduplicates all {@link TransactionSigner | TransactionSigners} stored\n * inside the account metas of an {@link InstructionWithSigners | instruction}.\n *\n * Any extracted signers that share the same {@link Address} will be de-duplicated.\n *\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n *\n * @example\n * ```ts\n * import { InstructionWithSigners, getSignersFromInstruction } from '@solana/signers';\n *\n * const signerA = { address: address('1111..1111'), signTransactions: async () => {} };\n * const signerB = { address: address('2222..2222'), signTransactions: async () => {} };\n * const instructionWithSigners: InstructionWithSigners = {\n *     accounts: [\n *         { address: signerA.address, signer: signerA, ... },\n *         { address: signerB.address, signer: signerB, ... },\n *         { address: signerA.address, signer: signerA, ... },\n *     ],\n * };\n *\n * const instructionSigners = getSignersFromInstruction(instructionWithSigners);\n * // ^ [signerA, signerB]\n * ```\n */\nexport function getSignersFromInstruction<TSigner extends TransactionSigner = TransactionSigner>(\n    instruction: InstructionWithSigners<TSigner>,\n): readonly TSigner[] {\n    return deduplicateSigners(\n        (instruction.accounts ?? []).flatMap(account => ('signer' in account ? account.signer : [])),\n    );\n}\n\n/**\n * Extracts and deduplicates all {@link TransactionSigner | TransactionSigners} stored\n * inside a given {@link TransactionMessageWithSigners | transaction message}.\n *\n * This includes any {@link TransactionSigner | TransactionSigners} stored\n * as the fee payer or in the instructions of the transaction message.\n *\n * Any extracted signers that share the same {@link Address} will be de-duplicated.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { Instruction } from '@solana/instructions';\n * import { InstructionWithSigners, TransactionMessageWithSigners, getSignersFromTransactionMessage } from '@solana/signers';\n *\n * const signerA = { address: address('1111..1111'), signTransactions: async () => {} };\n * const signerB = { address: address('2222..2222'), signTransactions: async () => {} };\n * const firstInstruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [{ address: signerA.address, signer: signerA, ... }],\n * };\n * const secondInstruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [{ address: signerB.address, signer: signerB, ... }],\n * };\n * const transactionMessage: TransactionMessageWithSigners = {\n *     feePayer: signerA,\n *     instructions: [firstInstruction, secondInstruction],\n * }\n *\n * const transactionSigners = getSignersFromTransactionMessage(transactionMessage);\n * // ^ [signerA, signerB]\n * ```\n */\nexport function getSignersFromTransactionMessage<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n    TTransactionMessage extends TransactionMessageWithSigners<TAddress, TSigner> = TransactionMessageWithSigners<\n        TAddress,\n        TSigner\n    >,\n>(transaction: TTransactionMessage): readonly TSigner[] {\n    return deduplicateSigners([\n        ...(transaction.feePayer && isTransactionSigner(transaction.feePayer) ? [transaction.feePayer as TSigner] : []),\n        ...transaction.instructions.flatMap(getSignersFromInstruction),\n    ]);\n}\n", "import { Address } from '@solana/addresses';\nimport { Instruction, isSignerRole } from '@solana/instructions';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { AccountSignerMeta, InstructionWithSigners, TransactionMessageWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\n\n/**\n * Attaches the provided {@link TransactionSigner | TransactionSigners} to the\n * account metas of an instruction when applicable.\n *\n * For an account meta to match a provided signer it:\n * - Must have a signer role ({@link AccountRole.READONLY_SIGNER} or {@link AccountRole.WRITABLE_SIGNER}).\n * - Must have the same address as the provided signer.\n * - Must not have an attached signer already.\n *\n * @typeParam TInstruction - The inferred type of the instruction provided.\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { addSignersToInstruction, TransactionSigner } from '@solana/signers';\n *\n * const instruction: Instruction = {\n *     accounts: [\n *         { address: '1111' as Address, role: AccountRole.READONLY_SIGNER },\n *         { address: '2222' as Address, role: AccountRole.WRITABLE_SIGNER },\n *     ],\n *     // ...\n * };\n *\n * const signerA: TransactionSigner<'1111'>;\n * const signerB: TransactionSigner<'2222'>;\n * const instructionWithSigners = addSignersToInstruction(\n *     [signerA, signerB],\n *     instruction\n * );\n *\n * // instructionWithSigners.accounts[0].signer === signerA\n * // instructionWithSigners.accounts[1].signer === signerB\n * ```\n */\nexport function addSignersToInstruction<TInstruction extends Instruction>(\n    signers: TransactionSigner[],\n    instruction: TInstruction | (InstructionWithSigners & TInstruction),\n): InstructionWithSigners & TInstruction {\n    if (!instruction.accounts || instruction.accounts.length === 0) {\n        return instruction as InstructionWithSigners & TInstruction;\n    }\n\n    const signerByAddress = new Map(deduplicateSigners(signers).map(signer => [signer.address, signer]));\n    return Object.freeze({\n        ...instruction,\n        accounts: instruction.accounts.map(account => {\n            const signer = signerByAddress.get(account.address);\n            if (!isSignerRole(account.role) || 'signer' in account || !signer) {\n                return account;\n            }\n            return Object.freeze({ ...account, signer } as AccountSignerMeta);\n        }),\n    });\n}\n\n/**\n * Attaches the provided {@link TransactionSigner | TransactionSigners} to the\n * account metas of all instructions inside a transaction message and/or\n * the transaction message fee payer, when applicable.\n *\n * For an account meta to match a provided signer it:\n * - Must have a signer role ({@link AccountRole.READONLY_SIGNER} or {@link AccountRole.WRITABLE_SIGNER}).\n * - Must have the same address as the provided signer.\n * - Must not have an attached signer already.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { BaseTransactionMessage } from '@solana/transaction-messages';\n * import { addSignersToTransactionMessage, TransactionSigner } from '@solana/signers';\n *\n * const instructionA: Instruction = {\n *     accounts: [{ address: '1111' as Address, role: AccountRole.READONLY_SIGNER }],\n *     // ...\n * };\n * const instructionB: Instruction = {\n *     accounts: [{ address: '2222' as Address, role: AccountRole.WRITABLE_SIGNER }],\n *     // ...\n * };\n * const transactionMessage: BaseTransactionMessage = {\n *     instructions: [instructionA, instructionB],\n *     // ...\n * }\n *\n * const signerA: TransactionSigner<'1111'>;\n * const signerB: TransactionSigner<'2222'>;\n * const transactionMessageWithSigners = addSignersToTransactionMessage(\n *     [signerA, signerB],\n *     transactionMessage\n * );\n *\n * // transactionMessageWithSigners.instructions[0].accounts[0].signer === signerA\n * // transactionMessageWithSigners.instructions[1].accounts[0].signer === signerB\n * ```\n */\nexport function addSignersToTransactionMessage<TTransactionMessage extends BaseTransactionMessage>(\n    signers: TransactionSigner[],\n    transactionMessage: TTransactionMessage | (TransactionMessageWithSigners & TTransactionMessage),\n): TransactionMessageWithSigners & TTransactionMessage {\n    const feePayerSigner = hasAddressOnlyFeePayer(transactionMessage)\n        ? signers.find(signer => signer.address === transactionMessage.feePayer.address)\n        : undefined;\n\n    if (!feePayerSigner && transactionMessage.instructions.length === 0) {\n        return transactionMessage as TransactionMessageWithSigners & TTransactionMessage;\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        ...(feePayerSigner ? { feePayer: feePayerSigner } : null),\n        instructions: transactionMessage.instructions.map(instruction => addSignersToInstruction(signers, instruction)),\n    });\n}\n\nfunction hasAddressOnlyFeePayer(\n    message: BaseTransactionMessage & Partial<TransactionMessageWithFeePayer>,\n): message is BaseTransactionMessage & { feePayer: { address: Address } } {\n    return (\n        !!message &&\n        'feePayer' in message &&\n        !!message.feePayer &&\n        typeof message.feePayer.address === 'string' &&\n        !isTransactionSigner(message.feePayer)\n    );\n}\n", "import { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { TransactionSigner } from './transaction-signer';\n\n/**\n * Alternative to {@link TransactionMessageWithFeePayer} that uses a {@link TransactionSigner} for the fee payer.\n *\n * @typeParam TAddress - Supply a string literal to define a fee payer having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for the {@link TransactionSigner}.\n *\n * @example\n * ```ts\n * import { BaseTransactionMessage } from '@solana/transaction-messages';\n * import { generateKeyPairSigner, TransactionMessageWithFeePayerSigner } from '@solana/signers';\n *\n * const transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayerSigner = {\n *     feePayer: await generateKeyPairSigner(),\n *     instructions: [],\n *     version: 0,\n * };\n * ```\n */\nexport interface TransactionMessageWithFeePayerSigner<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> {\n    readonly feePayer: TSigner;\n}\n\n/**\n * Sets the fee payer of a {@link BaseTransactionMessage | transaction message}\n * using a {@link TransactionSigner}.\n *\n * @typeParam TFeePayerAddress - Supply a string literal to define a fee payer having a particular address.\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { pipe } from '@solana/functional';\n * import { generateKeyPairSigner, setTransactionMessageFeePayerSigner } from '@solana/signers';\n * import { createTransactionMessage } from '@solana/transaction-messages';\n *\n * const feePayer = await generateKeyPairSigner();\n * const transactionMessage = pipe(\n *     createTransactionMessage({ version: 0 }),\n *     message => setTransactionMessageFeePayerSigner(signer, message),\n * );\n * ```\n */\nexport function setTransactionMessageFeePayerSigner<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends BaseTransactionMessage &\n        Partial<TransactionMessageWithFeePayer | TransactionMessageWithFeePayerSigner>,\n>(\n    feePayer: TransactionSigner<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): Omit<TTransactionMessage, 'feePayer'> & TransactionMessageWithFeePayerSigner<TFeePayerAddress> {\n    Object.freeze(feePayer);\n    const out = { ...transactionMessage, feePayer };\n    Object.freeze(out);\n    return out;\n}\n", "import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig, SignatureDictionary } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link MessagePartialSigner#signMessages | signMessages} method.\n *\n * @see {@link BaseSignerConfig}\n */\nexport type MessagePartialSignerConfig = BaseSignerConfig;\n\n/**\n * A signer interface that signs an array of {@link SignableMessage | SignableMessages}\n * without modifying their content.\n *\n * It defines a {@link MessagePartialSigner#signMessages | signMessages} function\n * that returns a {@link SignatureDictionary} for each provided message.\n * Such signature dictionaries are expected to be merged with the existing ones if any.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: MessagePartialSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     signMessages: async (\n *         messages: SignableMessage[]\n *     ): Promise<SignatureDictionary[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Parallel**. When multiple signers sign the same message, we can\n *   perform this operation in parallel to obtain all their signatures.\n * - **Flexible order**. The order in which we use these signers\n *   for a given message doesn’t matter.\n *\n * @see {@link SignableMessage}\n * @see {@link createSignableMessage}\n * @see {@link isMessagePartialSigner}\n * @see {@link assertIsMessagePartialSigner}\n */\nexport type MessagePartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signMessages(\n        messages: readonly SignableMessage[],\n        config?: MessagePartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link MessagePartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessagePartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessagePartialSigner({ address, signMessages: async () => {} }); // true\n * isMessagePartialSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessagePartialSigner}\n */\nexport function isMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessagePartialSigner<TAddress> {\n    return 'signMessages' in value && typeof value.signMessages === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link MessagePartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessagePartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessagePartialSigner({ address, signMessages: async () => {} }); // void\n * assertIsMessagePartialSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessagePartialSigner}\n */\nexport function assertIsMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessagePartialSigner<TAddress> {\n    if (!isMessagePartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n", "import { Address, getAddressFromPublicKey } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, SolanaError } from '@solana/errors';\nimport { createKeyPairFromBytes, createKeyPairFromPrivateKeyBytes, generateKeyPair, signBytes } from '@solana/keys';\nimport { partiallySignTransaction } from '@solana/transactions';\n\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\n\n/**\n * Defines a signer that uses a {@link CryptoKeyPair} to sign messages and transactions.\n *\n * It implements both the {@link MessagePartialSigner} and {@link TransactionPartialSigner}\n * interfaces and keeps track of the {@link CryptoKeyPair} instance used\n * to sign messages and transactions.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner } from '@solana/signers';\n *\n * const signer = generateKeyPairSigner();\n * signer.address; // Address;\n * signer.keyPair; // CryptoKeyPair;\n * const [messageSignatures] = await signer.signMessages([message]);\n * const [transactionSignatures] = await signer.signTransactions([transaction]);\n * ```\n *\n * @see {@link generateKeyPairSigner}\n * @see {@link createSignerFromKeyPair}\n * @see {@link createKeyPairSignerFromBytes}\n * @see {@link createKeyPairSignerFromPrivateKeyBytes}\n * @see {@link isKeyPairSigner}\n * @see {@link assertIsKeyPairSigner}\n */\nexport type KeyPairSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress> & { keyPair: CryptoKeyPair };\n\n/**\n * Checks whether the provided value implements the {@link KeyPairSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner, isKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * isKeyPairSigner(signer); // true\n * isKeyPairSigner({ address: address('1234..5678') }); // false\n * ```\n */\nexport function isKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is KeyPairSigner<TAddress> {\n    return (\n        'keyPair' in value &&\n        typeof value.keyPair === 'object' &&\n        isMessagePartialSigner(value) &&\n        isTransactionPartialSigner(value)\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link KeyPairSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner, assertIsKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * assertIsKeyPairSigner(signer); // void\n * assertIsKeyPairSigner({ address: address('1234..5678') }); // Throws an error.\n * ```\n */\nexport function assertIsKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is KeyPairSigner<TAddress> {\n    if (!isKeyPairSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n\n/**\n * Creates a {@link KeyPairSigner} from a provided {@link CryptoKeyPair}.\n *\n * The {@link MessagePartialSigner#signMessages | signMessages} and\n * {@link TransactionPartialSigner#signTransactions | signTransactions}\n * functions of the returned signer will use the private key of the provided\n * key pair to sign messages and transactions.\n *\n * Note that both the {@link MessagePartialSigner#signMessages | signMessages} and\n * {@link TransactionPartialSigner#signTransactions | signTransactions} implementations\n * are parallelized, meaning that they will sign all provided messages and transactions in parallel.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { createSignerFromKeyPair, KeyPairSigner } from '@solana/signers';\n *\n * const keyPair: CryptoKeyPair = await generateKeyPair();\n * const signer: KeyPairSigner = await createSignerFromKeyPair(keyPair);\n * ```\n */\nexport async function createSignerFromKeyPair(keyPair: CryptoKeyPair): Promise<KeyPairSigner> {\n    const address = await getAddressFromPublicKey(keyPair.publicKey);\n    const out: KeyPairSigner = {\n        address,\n        keyPair,\n        signMessages: messages =>\n            Promise.all(\n                messages.map(async message =>\n                    Object.freeze({ [address]: await signBytes(keyPair.privateKey, message.content) }),\n                ),\n            ),\n        signTransactions: transactions =>\n            Promise.all(\n                transactions.map(async transaction => {\n                    const signedTransaction = await partiallySignTransaction([keyPair], transaction);\n                    // we know that the address has signed `signedTransaction` because it comes from the keypair\n                    return Object.freeze({ [address]: signedTransaction.signatures[address]! });\n                }),\n            ),\n    };\n\n    return Object.freeze(out);\n}\n\n/**\n * Generates a signer capable of signing messages and transactions by generating\n * a {@link CryptoKeyPair} and creating a {@link KeyPairSigner} from it.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * ```\n *\n * @see {@link createSignerFromKeyPair}\n */\nexport async function generateKeyPairSigner(): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await generateKeyPair());\n}\n\n/**\n * Creates a new {@link KeyPairSigner} from a 64-bytes `Uint8Array` secret key (private key and public key).\n *\n * @example\n * ```ts\n * import fs from 'fs';\n * import { createKeyPairSignerFromBytes } from '@solana/signers';\n *\n * // Get bytes from local keypair file.\n * const keypairFile = fs.readFileSync('~/.config/solana/id.json');\n * const keypairBytes = new Uint8Array(JSON.parse(keypairFile.toString()));\n *\n * // Create a KeyPairSigner from the bytes.\n * const signer = await createKeyPairSignerFromBytes(keypairBytes);\n * ```\n *\n * @see {@link createKeyPairSignerFromPrivateKeyBytes} if you only have the 32-bytes private key instead.\n */\nexport async function createKeyPairSignerFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable?: boolean,\n): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await createKeyPairFromBytes(bytes, extractable));\n}\n\n/**\n * Creates a new {@link KeyPairSigner} from a 32-bytes `Uint8Array` private key.\n *\n * @example\n * ```ts\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { createKeyPairSignerFromPrivateKeyBytes } from '@solana/signers';\n *\n * const message = getUtf8Encoder().encode('Hello, World!');\n * const seed = new Uint8Array(await crypto.subtle.digest('SHA-256', message));\n *\n * const derivedSigner = await createKeyPairSignerFromPrivateKeyBytes(seed);\n * ```\n *\n * @see {@link createKeyPairSignerFromBytes} if you have the 64-bytes secret key instead (private key and public key).\n */\nexport async function createKeyPairSignerFromPrivateKeyBytes(\n    bytes: ReadonlyUint8Array,\n    extractable?: boolean,\n): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await createKeyPairFromPrivateKeyBytes(bytes, extractable));\n}\n", "import { Address, isAddress } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link MessageModifyingSigner#modifyAndSignMessages | modifyAndSignMessages} method.\n *\n * @see {@link BaseSignerConfig}\n */\nexport type MessageModifyingSignerConfig = BaseSignerConfig;\n\n/**\n * A signer interface that _potentially_ modifies the content\n * of the provided {@link SignableMessage | SignableMessages} before signing them.\n *\n * For instance, this enables wallets to prefix or suffix nonces to the messages they sign.\n * For each message, instead of returning a {@link SignatureDirectory}, the\n * {@link MessageModifyingSigner#modifyAndSignMessages | modifyAndSignMessages} function\n * returns an updated {@link SignableMessage} with a potentially modified content and signature dictionary.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: MessageModifyingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     modifyAndSignMessages: async (\n *         messages: SignableMessage[]\n *     ): Promise<SignableMessage[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Sequential**. Contrary to partial signers, these cannot be executed in\n *   parallel as each call can modify the content of the message.\n * - **First signers**. For a given message, a modifying signer must always be used\n *   before a partial signer as the former will likely modify the message and\n *   thus impact the outcome of the latter.\n * - **Potential conflicts**. If more than one modifying signer is provided, the second\n *   signer may invalidate the signature of the first one. However, modifying signers\n *   may decide not to modify a message based on the existence of signatures for that message.\n *\n * @see {@link SignableMessage}\n * @see {@link createSignableMessage}\n * @see {@link isMessageModifyingSigner}\n * @see {@link assertIsMessageModifyingSigner}\n */\nexport type MessageModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignMessages(\n        messages: readonly SignableMessage[],\n        config?: MessageModifyingSignerConfig,\n    ): Promise<readonly SignableMessage[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link MessageModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessageModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessageModifyingSigner({ address, modifyAndSignMessages: async () => {} }); // true\n * isMessageModifyingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessageModifyingSigner}\n */\nexport function isMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageModifyingSigner<TAddress> {\n    return (\n        isAddress(value.address) &&\n        'modifyAndSignMessages' in value &&\n        typeof value.modifyAndSignMessages === 'function'\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link MessageModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessageModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessageModifyingSigner({ address, modifyAndSignMessages: async () => {} }); // void\n * assertIsMessageModifyingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessageModifyingSigner}\n */\nexport function assertIsMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageModifyingSigner<TAddress> {\n    if (!isMessageModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n", "import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isMessageModifyingSigner, MessageModifyingSigner } from './message-modifying-signer';\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\n\n/**\n * Defines a signer capable of signing messages.\n *\n * @see {@link MessageModifyingSigner} For signers that can modify messages before signing them.\n * @see {@link MessagePartialSigner} For signers that can be used in parallel.\n * @see {@link isMessageSigner}\n * @see {@link assertIsMessageSigner}\n */\nexport type MessageSigner<TAddress extends string = string> =\n    | MessageModifyingSigner<TAddress>\n    | MessagePartialSigner<TAddress>;\n\n/**\n * Checks whether the provided value implements the {@link MessageSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessageSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessageSigner({ address, signMessages: async () => {} }); // true\n * isMessageSigner({ address, modifyAndSignMessages: async () => {} }); // true\n * isMessageSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessageSigner}\n */\nexport function isMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageSigner<TAddress> {\n    return isMessagePartialSigner(value) || isMessageModifyingSigner(value);\n}\n\n/**\n * Asserts that the provided value implements the {@link MessageSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessageSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessageSigner({ address, signMessages: async () => {} }); // void\n * assertIsMessageSigner({ address, modifyAndSignMessages: async () => {} }); // void\n * assertIsMessageSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessageSigner}\n */\nexport function assertIsMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageSigner<TAddress> {\n    if (!isMessageSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n", "import { Address } from '@solana/addresses';\n\nimport { MessagePartialSigner } from './message-partial-signer';\nimport { TransactionPartialSigner } from './transaction-partial-signer';\n\n/**\n * Defines a Noop (No-Operation) signer that pretends to partially sign messages and transactions.\n *\n * For a given {@link Address}, a Noop Signer can be created to offer an implementation of both\n * the {@link MessagePartialSigner} and {@link TransactionPartialSigner} interfaces such that\n * they do not sign anything. Namely, signing a transaction or a message with a `NoopSigner`\n * will return an empty `SignatureDictionary`.\n *\n * @typeParam TAddress - Supply a string literal to define a Noop signer having a particular address.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { createNoopSigner } from '@solana/signers';\n *\n * const signer = createNoopSigner(address('1234..5678'));\n * const [messageSignatures] = await signer.signMessages([message]);\n * const [transactionSignatures] = await signer.signTransactions([transaction]);\n * // ^ Both messageSignatures and transactionSignatures are empty.\n * ```\n *\n * @remarks\n * This signer may be useful:\n *\n * - For testing purposes.\n * - For indicating that a given account is a signer and taking the responsibility to provide\n *   the signature for that account ourselves. For instance, if we need to send the transaction\n *   to a server that will sign it and send it for us.\n *\n * @see {@link createNoopSigner}\n */\nexport type NoopSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress>;\n\n/**\n * Creates a {@link NoopSigner} from the provided {@link Address}.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { createNoopSigner } from '@solana/signers';\n *\n * const signer = createNoopSigner(address('1234..5678'));\n * ```\n */\nexport function createNoopSigner<TAddress extends string = string>(address: Address<TAddress>): NoopSigner<TAddress> {\n    const out: NoopSigner<TAddress> = {\n        address,\n        signMessages: messages => Promise.resolve(messages.map(() => Object.freeze({}))),\n        signTransactions: transactions => Promise.resolve(transactions.map(() => Object.freeze({}))),\n    };\n\n    return Object.freeze(out);\n}\n", "import {\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\nimport { CompilableTransactionMessage } from '@solana/transaction-messages';\n\nimport { getSignersFromTransactionMessage, TransactionMessageWithSigners } from './account-signer-meta';\nimport { isTransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner } from './transaction-sending-signer';\n\n/**\n * Defines a transaction message with exactly one {@link TransactionSendingSigner}.\n *\n * This type is used to narrow the type of transaction messages that have been\n * checked to have exactly one sending signer.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithSingleSendingSigner } from '@solana/signers';\n *\n * assertIsTransactionMessageWithSingleSendingSigner(transactionMessage);\n * transactionMessage satisfies TransactionMessageWithSingleSendingSigner;\n * ```\n *\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n */\nexport type TransactionMessageWithSingleSendingSigner = Brand<\n    TransactionMessageWithSigners,\n    'TransactionMessageWithSingleSendingSigner'\n>;\n\n/**\n * Checks whether the provided transaction has exactly one {@link TransactionSendingSigner}.\n *\n * This can be useful when using {@link signAndSendTransactionMessageWithSigners} to provide\n * a fallback strategy in case the transaction message cannot be send using this function.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import {\n *     isTransactionMessageWithSingleSendingSigner,\n *     signAndSendTransactionMessageWithSigners,\n *     signTransactionMessageWithSigners,\n * } from '@solana/signers';\n * import { getBase64EncodedWireTransaction } from '@solana/transactions';\n *\n * let transactionSignature: SignatureBytes;\n * if (isTransactionMessageWithSingleSendingSigner(transactionMessage)) {\n *     transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n * } else {\n *     const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);\n *     const encodedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n *     transactionSignature = await rpc.sendTransaction(encodedTransaction).send();\n * }\n * ```\n *\n * @see {@link signAndSendTransactionMessageWithSigners}\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n */\nexport function isTransactionMessageWithSingleSendingSigner<TTransactionMessage extends CompilableTransactionMessage>(\n    transaction: TTransactionMessage,\n): transaction is TransactionMessageWithSingleSendingSigner & TTransactionMessage {\n    try {\n        assertIsTransactionMessageWithSingleSendingSigner(transaction);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Asserts that the provided transaction message has exactly one {@link TransactionSendingSigner}.\n *\n * This can be useful when using the {@link signAndSendTransactionMessageWithSigners} function\n * to ensure it will be able to select the correct signer to send the transaction.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import {\n *     assertIsTransactionMessageWithSingleSendingSigner,\n *     signAndSendTransactionMessageWithSigners\n * } from '@solana/signers';\n *\n * assertIsTransactionMessageWithSingleSendingSigner(transactionMessage);\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n * ```\n *\n * @see {@link signAndSendTransactionMessageWithSigners}\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n */\nexport function assertIsTransactionMessageWithSingleSendingSigner<\n    TTransactionMessage extends CompilableTransactionMessage,\n>(\n    transaction: TTransactionMessage,\n): asserts transaction is TransactionMessageWithSingleSendingSigner & TTransactionMessage {\n    const signers = getSignersFromTransactionMessage(transaction);\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n\n    if (sendingSigners.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    // When identifying if there are multiple sending signers, we only need to check for\n    // sending signers that do not implement other transaction signer interfaces as\n    // they will be used as these other signer interfaces in case of a conflict.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionPartialSigner(signer) && !isTransactionModifyingSigner(signer),\n    );\n\n    if (sendingOnlySigners.length > 1) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS);\n    }\n}\n", "import { SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { CompilableTransactionMessage } from '@solana/transaction-messages';\nimport {\n    assertIsFullySignedTransaction,\n    compileTransaction,\n    FullySignedTransaction,\n    Transaction,\n    TransactionFromCompilableTransactionMessage,\n    TransactionWithLifetime,\n} from '@solana/transactions';\n\nimport { getSignersFromTransactionMessage, TransactionMessageWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport {\n    isTransactionModifyingSigner,\n    TransactionModifyingSigner,\n    TransactionModifyingSignerConfig,\n} from './transaction-modifying-signer';\nimport {\n    isTransactionPartialSigner,\n    TransactionPartialSigner,\n    TransactionPartialSignerConfig,\n} from './transaction-partial-signer';\nimport {\n    isTransactionSendingSigner,\n    TransactionSendingSigner,\n    TransactionSendingSignerConfig,\n} from './transaction-sending-signer';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\nimport { assertIsTransactionMessageWithSingleSendingSigner } from './transaction-with-single-sending-signer';\n\ntype CompilableTransactionMessageWithSigners = CompilableTransactionMessage & TransactionMessageWithSigners;\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to return a signed transaction.\n *\n * It first uses all {@link TransactionModifyingSigner | TransactionModifyingSigners} sequentially before\n * using all {@link TransactionPartialSigner | TransactionPartialSigners} in parallel.\n *\n * If a composite signer implements both interfaces, it will be used as a\n * {@link TransactionModifyingSigner} if no other signer implements that interface.\n * Otherwise, it will be used as a {@link TransactionPartialSigner}.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage);\n * ```\n *\n * It also accepts an optional {@link AbortSignal} that will be propagated to all signers.\n *\n * ```ts\n * const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n * ```\n *\n * @remarks\n * Finally, note that this function ignores {@link TransactionSendingSigner | TransactionSendingSigners}\n * as it does not send the transaction. Check out the {@link signAndSendTransactionMessageWithSigners}\n * function for more details on how to use sending signers.\n *\n * @see {@link signTransactionMessageWithSigners}\n * @see {@link signAndSendTransactionMessageWithSigners}\n */\nexport async function partiallySignTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners,\n>(\n    transactionMessage: TTransactionMessage,\n    config?: TransactionPartialSignerConfig,\n): Promise<TransactionFromCompilableTransactionMessage<TTransactionMessage>> {\n    const { partialSigners, modifyingSigners } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransactionMessage(transactionMessage).filter(isTransactionSigner)),\n        { identifySendingSigner: false },\n    );\n\n    return await signModifyingAndPartialTransactionSigners(\n        transactionMessage,\n        modifyingSigners,\n        partialSigners,\n        config,\n    );\n}\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to return a signed transaction before asserting\n * that all signatures required by the transaction are present.\n *\n * This function delegates to the {@link partiallySignTransactionMessageWithSigners} function\n * in order to extract signers from the transaction message and sign the transaction.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * const mySignedTransaction = await signTransactionMessageWithSigners(myTransactionMessage);\n *\n * // With additional config.\n * const mySignedTransaction = await signTransactionMessageWithSigners(myTransactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n *\n * // We now know the transaction is fully signed.\n * mySignedTransaction satisfies FullySignedTransaction;\n * ```\n *\n * @see {@link partiallySignTransactionMessageWithSigners}\n * @see {@link signAndSendTransactionMessageWithSigners}\n */\nexport async function signTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners,\n>(\n    transactionMessage: TTransactionMessage,\n    config?: TransactionPartialSignerConfig,\n): Promise<FullySignedTransaction & TransactionFromCompilableTransactionMessage<TTransactionMessage>> {\n    const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage, config);\n    assertIsFullySignedTransaction(signedTransaction);\n    return signedTransaction;\n}\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to sign it before sending it immediately to the blockchain.\n *\n * It returns the signature of the sent transaction (i.e. its identifier) as bytes.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { signAndSendTransactionMessageWithSigners } from '@solana/signers';\n *\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n *\n * // With additional config.\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n * ```\n *\n * @remarks\n * Similarly to the {@link partiallySignTransactionMessageWithSigners} function, it first uses all\n * {@link TransactionModifyingSigner | TransactionModifyingSigners} sequentially before using all\n * {@link TransactionPartialSigner | TransactionPartialSigners} in parallel.\n * It then sends the transaction using the {@link TransactionSendingSigner} it identified.\n *\n * Composite transaction signers are treated such that at least one sending signer is used if any.\n * When a {@link TransactionSigner} implements more than one interface, we use it as a:\n *\n * - {@link TransactionSendingSigner}, if no other {@link TransactionSendingSigner} exists.\n * - {@link TransactionModifyingSigner}, if no other {@link TransactionModifyingSigner} exists.\n * - {@link TransactionPartialSigner}, otherwise.\n *\n * The provided transaction must contain exactly one {@link TransactionSendingSigner} inside its account metas.\n * If more than one composite signers implement the {@link TransactionSendingSigner} interface,\n * one of them will be selected as the sending signer. Otherwise, if multiple\n * {@link TransactionSendingSigner | TransactionSendingSigners} must be selected, the function will throw an error.\n *\n * If you'd like to assert that a transaction makes use of exactly one {@link TransactionSendingSigner}\n * _before_ calling this function, you may use the {@link assertIsTransactionMessageWithSingleSendingSigner} function.\n *\n * Alternatively, you may use the {@link isTransactionMessageWithSingleSendingSigner} function to provide a\n * fallback in case the transaction does not contain any sending signer.\n *\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n * @see {@link partiallySignTransactionMessageWithSigners}\n * @see {@link signTransactionMessageWithSigners}\n *\n */\nexport async function signAndSendTransactionMessageWithSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners = CompilableTransactionMessageWithSigners,\n>(transaction: TTransactionMessage, config?: TransactionSendingSignerConfig): Promise<SignatureBytes> {\n    assertIsTransactionMessageWithSingleSendingSigner(transaction);\n\n    const abortSignal = config?.abortSignal;\n    const { partialSigners, modifyingSigners, sendingSigner } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransactionMessage(transaction).filter(isTransactionSigner)),\n    );\n\n    abortSignal?.throwIfAborted();\n    const signedTransaction = await signModifyingAndPartialTransactionSigners(\n        transaction,\n        modifyingSigners,\n        partialSigners,\n        config,\n    );\n\n    if (!sendingSigner) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    abortSignal?.throwIfAborted();\n    const [signature] = await sendingSigner.signAndSendTransactions([signedTransaction], config);\n    abortSignal?.throwIfAborted();\n\n    return signature;\n}\n\n/**\n * Identifies each provided TransactionSigner and categorizes them into their respective types.\n * When a signer implements multiple interface, it will try to used to most powerful interface\n * but fallback to the least powerful interface when necessary.\n * For instance, if a signer implements TransactionSendingSigner and TransactionModifyingSigner,\n * it will be categorized as a TransactionSendingSigner if and only if no other signers implement\n * the TransactionSendingSigner interface.\n */\nfunction categorizeTransactionSigners(\n    signers: readonly TransactionSigner[],\n    config: { identifySendingSigner?: boolean } = {},\n): Readonly<{\n    modifyingSigners: readonly TransactionModifyingSigner[];\n    partialSigners: readonly TransactionPartialSigner[];\n    sendingSigner: TransactionSendingSigner | null;\n}> {\n    // Identify the unique sending signer that should be used.\n    const identifySendingSigner = config.identifySendingSigner ?? true;\n    const sendingSigner = identifySendingSigner ? identifyTransactionSendingSigner(signers) : null;\n\n    // Now, focus on the other signers.\n    // I.e. the modifying or partial signers that are not the identified sending signer.\n    // Note that any other sending only signers will be discarded.\n    const otherSigners = signers.filter(\n        (signer): signer is TransactionModifyingSigner | TransactionPartialSigner =>\n            signer !== sendingSigner && (isTransactionModifyingSigner(signer) || isTransactionPartialSigner(signer)),\n    );\n\n    // Identify the modifying signers from the other signers.\n    const modifyingSigners = identifyTransactionModifyingSigners(otherSigners);\n\n    // Use any remaining signers as partial signers.\n    const partialSigners = otherSigners\n        .filter(isTransactionPartialSigner)\n        .filter(signer => !(modifyingSigners as typeof otherSigners).includes(signer));\n\n    return Object.freeze({ modifyingSigners, partialSigners, sendingSigner });\n}\n\n/** Identifies the best signer to use as a TransactionSendingSigner, if any */\nfunction identifyTransactionSendingSigner(signers: readonly TransactionSigner[]): TransactionSendingSigner | null {\n    // Ensure there are any TransactionSendingSigners in the first place.\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n    if (sendingSigners.length === 0) return null;\n\n    // Prefer sending signers that do not offer other interfaces.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionModifyingSigner(signer) && !isTransactionPartialSigner(signer),\n    );\n    if (sendingOnlySigners.length > 0) {\n        return sendingOnlySigners[0];\n    }\n\n    // Otherwise, choose any sending signer.\n    return sendingSigners[0];\n}\n\n/** Identifies the best signers to use as TransactionModifyingSigners, if any */\nfunction identifyTransactionModifyingSigners(\n    signers: readonly (TransactionModifyingSigner | TransactionPartialSigner)[],\n): readonly TransactionModifyingSigner[] {\n    // Ensure there are any TransactionModifyingSigner in the first place.\n    const modifyingSigners = signers.filter(isTransactionModifyingSigner);\n    if (modifyingSigners.length === 0) return [];\n\n    // Prefer modifying signers that do not offer partial signing.\n    const nonPartialSigners = modifyingSigners.filter(signer => !isTransactionPartialSigner(signer));\n    if (nonPartialSigners.length > 0) return nonPartialSigners;\n\n    // Otherwise, choose only one modifying signer (whichever).\n    return [modifyingSigners[0]];\n}\n\n/**\n * Signs a transaction using the provided TransactionModifyingSigners\n * sequentially followed by the TransactionPartialSigners in parallel.\n */\nasync function signModifyingAndPartialTransactionSigners<\n    TTransactionMessage extends CompilableTransactionMessageWithSigners,\n>(\n    transactionMessage: TTransactionMessage,\n    modifyingSigners: readonly TransactionModifyingSigner[] = [],\n    partialSigners: readonly TransactionPartialSigner[] = [],\n    config?: TransactionModifyingSignerConfig,\n): Promise<TransactionFromCompilableTransactionMessage<TTransactionMessage>> {\n    type ReturnType = TransactionFromCompilableTransactionMessage<TTransactionMessage>;\n\n    // serialize the transaction\n    const transaction = compileTransaction(transactionMessage);\n\n    // Handle modifying signers sequentially.\n    const modifiedTransaction = await modifyingSigners.reduce(\n        async (transaction, modifyingSigner) => {\n            config?.abortSignal?.throwIfAborted();\n            const [tx] = await modifyingSigner.modifyAndSignTransactions([await transaction], config);\n            return Object.freeze(tx);\n        },\n        Promise.resolve(transaction) as Promise<Readonly<Transaction & TransactionWithLifetime>>,\n    );\n\n    // Handle partial signers in parallel.\n    config?.abortSignal?.throwIfAborted();\n    const signatureDictionaries = await Promise.all(\n        partialSigners.map(async partialSigner => {\n            const [signatures] = await partialSigner.signTransactions([modifiedTransaction], config);\n            return signatures;\n        }),\n    );\n\n    return Object.freeze({\n        ...modifiedTransaction,\n        signatures: Object.freeze(\n            signatureDictionaries.reduce((signatures, signatureDictionary) => {\n                return { ...signatures, ...signatureDictionary };\n            }, modifiedTransaction.signatures ?? {}),\n        ),\n    }) as ReturnType;\n}\n", "export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n", "import { TextEncoder } from '@solana/text-encoding-impl';\n\nimport { SignatureDictionary } from './types';\n\n/**\n * Defines a message that needs signing and its current set of signatures if any.\n *\n * This interface allows {@link MessageModifyingSigner | MessageModifyingSigners}\n * to decide on whether or not they should modify the provided message depending\n * on whether or not signatures already exist for such message.\n *\n * It also helps create a more consistent API by providing a structure analogous\n * to transactions which also keep track of their {@link SignatureDictionary}.\n *\n * @example\n * ```ts\n * import { createSignableMessage } from '@solana/signers';\n *\n * const message = createSignableMessage(new Uint8Array([1, 2, 3]));\n * message.content; // The content of the message as bytes.\n * message.signatures; // The current set of signatures for this message.\n * ```\n *\n * @see {@link createSignableMessage}\n */\nexport type SignableMessage = Readonly<{\n    content: Uint8Array;\n    signatures: SignatureDictionary;\n}>;\n\n/**\n * Creates a {@link SignableMessage} from a `Uint8Array` or a UTF-8 string.\n *\n * It optionally accepts a signature dictionary if the message already contains signatures.\n *\n * @example\n * ```ts\n * const message = createSignableMessage(new Uint8Array([1, 2, 3]));\n * const messageFromText = createSignableMessage('Hello world!');\n * const messageWithSignatures = createSignableMessage('Hello world!', {\n *     '1234..5678': new Uint8Array([1, 2, 3]),\n * });\n * ```\n */\nexport function createSignableMessage(\n    content: Uint8Array | string,\n    signatures: SignatureDictionary = {},\n): SignableMessage {\n    return Object.freeze({\n        content: typeof content === 'string' ? new TextEncoder().encode(content) : content,\n        signatures: Object.freeze({ ...signatures }),\n    });\n}\n", "export const AbortController = globalThis.AbortController;\nexport const EventTarget = globalThis.EventTarget;\n", "import { SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED, SolanaError } from '@solana/errors';\nimport { AbortController } from '@solana/event-target-impl';\nimport type { GetEpochInfoApi, Rpc } from '@solana/rpc';\nimport type { RpcSubscriptions, SlotNotificationsApi } from '@solana/rpc-subscriptions';\nimport type { Commitment } from '@solana/rpc-types';\n\ntype GetBlockHeightExceedencePromiseFn = (config: {\n    abortSignal: AbortSignal;\n    /**\n     * Fetch the block height as of the highest slot that has reached this level of commitment.\n     *\n     * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n     * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n     * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n     * default commitment applied by the server is `\"finalized\"`.\n     */\n    commitment?: Commitment;\n    /** The block height after which to reject the promise */\n    lastValidBlockHeight: bigint;\n}) => Promise<void>;\n\ntype CreateBlockHeightExceedencePromiseFactoryConfig<TCluster> = {\n    rpc: Rpc<GetEpochInfoApi> & { '~cluster'?: TCluster };\n    rpcSubscriptions: RpcSubscriptions<SlotNotificationsApi> & { '~cluster'?: TCluster };\n};\n\n/**\n * Creates a promise that throws when the network progresses past the block height after which the\n * supplied blockhash is considered expired for use as a transaction lifetime specifier.\n *\n * When a transaction's lifetime is tied to a blockhash, that transaction can be landed on the\n * network until that blockhash expires. All blockhashes have a block height after which they are\n * considered to have expired.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { isSolanaError, SolanaError } from '@solana/errors';\n * import { createBlockHeightExceedencePromiseFactory } from '@solana/transaction-confirmation';\n *\n * const getBlockHeightExceedencePromise = createBlockHeightExceedencePromiseFactory({\n *     rpc,\n *     rpcSubscriptions,\n * });\n * try {\n *     await getBlockHeightExceedencePromise({ lastValidBlockHeight });\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED)) {\n *         console.error(\n *             `The block height of the network has exceeded ${e.context.lastValidBlockHeight}. ` +\n *                 `It is now ${e.context.currentBlockHeight}`,\n *         );\n *         // Re-sign and retry the transaction.\n *         return;\n *     }\n *     throw e;\n * }\n * ```\n */\nexport function createBlockHeightExceedencePromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateBlockHeightExceedencePromiseFactoryConfig<'devnet'>): GetBlockHeightExceedencePromiseFn;\nexport function createBlockHeightExceedencePromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateBlockHeightExceedencePromiseFactoryConfig<'testnet'>): GetBlockHeightExceedencePromiseFn;\nexport function createBlockHeightExceedencePromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateBlockHeightExceedencePromiseFactoryConfig<'mainnet'>): GetBlockHeightExceedencePromiseFn;\nexport function createBlockHeightExceedencePromiseFactory<\n    TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void,\n>({\n    rpc,\n    rpcSubscriptions,\n}: CreateBlockHeightExceedencePromiseFactoryConfig<TCluster>): GetBlockHeightExceedencePromiseFn {\n    return async function getBlockHeightExceedencePromise({\n        abortSignal: callerAbortSignal,\n        commitment,\n        lastValidBlockHeight,\n    }): Promise<never> {\n        callerAbortSignal.throwIfAborted();\n        const abortController = new AbortController();\n        const handleAbort = () => {\n            abortController.abort();\n        };\n        callerAbortSignal.addEventListener('abort', handleAbort, { signal: abortController.signal });\n        async function getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight() {\n            const { absoluteSlot, blockHeight } = await rpc\n                .getEpochInfo({ commitment })\n                .send({ abortSignal: abortController.signal });\n            return {\n                blockHeight,\n                differenceBetweenSlotHeightAndBlockHeight: absoluteSlot - blockHeight,\n            };\n        }\n        try {\n            const [slotNotifications, { blockHeight: initialBlockHeight, differenceBetweenSlotHeightAndBlockHeight }] =\n                await Promise.all([\n                    rpcSubscriptions.slotNotifications().subscribe({ abortSignal: abortController.signal }),\n                    getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight(),\n                ]);\n            callerAbortSignal.throwIfAborted();\n            let currentBlockHeight = initialBlockHeight;\n            if (currentBlockHeight <= lastValidBlockHeight) {\n                let lastKnownDifferenceBetweenSlotHeightAndBlockHeight = differenceBetweenSlotHeightAndBlockHeight;\n                for await (const slotNotification of slotNotifications) {\n                    const { slot } = slotNotification;\n                    if (slot - lastKnownDifferenceBetweenSlotHeightAndBlockHeight > lastValidBlockHeight) {\n                        // Before making a final decision, recheck the actual block height.\n                        const {\n                            blockHeight: recheckedBlockHeight,\n                            differenceBetweenSlotHeightAndBlockHeight: currentDifferenceBetweenSlotHeightAndBlockHeight,\n                        } = await getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight();\n                        currentBlockHeight = recheckedBlockHeight;\n                        if (currentBlockHeight > lastValidBlockHeight) {\n                            // Verified; the block height has been exceeded.\n                            break;\n                        } else {\n                            // The block height has not been exceeded, which implies that the\n                            // difference between the slot height and the block height has grown\n                            // (ie. some blocks have been skipped since we started). Recalibrate the\n                            // difference and keep waiting.\n                            lastKnownDifferenceBetweenSlotHeightAndBlockHeight =\n                                currentDifferenceBetweenSlotHeightAndBlockHeight;\n                        }\n                    }\n                }\n            }\n            callerAbortSignal.throwIfAborted();\n            throw new SolanaError(SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED, {\n                currentBlockHeight,\n                lastValidBlockHeight,\n            });\n        } finally {\n            abortController.abort();\n        }\n    };\n}\n", "import type { Address } from '@solana/addresses';\nimport { getBase58Decoder, getBase64Encoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__INVALID_NONCE, SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND, SolanaError } from '@solana/errors';\nimport { AbortController } from '@solana/event-target-impl';\nimport { safeRace } from '@solana/promises';\nimport type { GetAccountInfoApi, Rpc } from '@solana/rpc';\nimport type { AccountNotificationsApi, RpcSubscriptions } from '@solana/rpc-subscriptions';\nimport type { Base64EncodedDataResponse, Commitment } from '@solana/rpc-types';\nimport { Nonce } from '@solana/transaction-messages';\n\ntype GetNonceInvalidationPromiseFn = (config: {\n    abortSignal: AbortSignal;\n    /**\n     * Fetch the nonce account details as of the highest slot that has reached this level of\n     * commitment.\n     */\n    commitment: Commitment;\n    /**\n     * The value of the nonce that we would expect to see in the nonce account in order for any\n     * transaction with that nonce-based lifetime to be considered valid.\n     */\n    currentNonceValue: Nonce;\n    /** The address of the account in which the currently-valid nonce value is stored */\n    nonceAccountAddress: Address;\n}) => Promise<void>;\n\ntype CreateNonceInvalidationPromiseFactoryConfig<TCluster> = {\n    rpc: Rpc<GetAccountInfoApi> & { '~cluster'?: TCluster };\n    rpcSubscriptions: RpcSubscriptions<AccountNotificationsApi> & { '~cluster'?: TCluster };\n};\n\nconst NONCE_VALUE_OFFSET =\n    4 + // version(u32)\n    4 + // state(u32)\n    32; // nonce authority(pubkey)\n// Then comes the nonce value.\n\n/**\n * Creates a promise that throws when the value stored in a nonce account is not the expected one.\n *\n * When a transaction's lifetime is tied to the value stored in a nonce account, that transaction\n * can be landed on the network until the nonce is advanced to a new value.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { isSolanaError, SolanaError } from '@solana/errors';\n * import { createNonceInvalidationPromiseFactory } from '@solana/transaction-confirmation';\n *\n * const getNonceInvalidationPromise = createNonceInvalidationPromiseFactory({\n *     rpc,\n *     rpcSubscriptions,\n * });\n * try {\n *     await getNonceInvalidationPromise({\n *         currentNonceValue,\n *         nonceAccountAddress,\n *     });\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__NONCE_INVALID)) {\n *         console.error(`The nonce has advanced to ${e.context.actualNonceValue}`);\n *         // Re-sign and retry the transaction.\n *         return;\n *     } else if (isSolanaError(e, SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND)) {\n *         console.error(`No nonce account was found at ${nonceAccountAddress}`);\n *     }\n *     throw e;\n * }\n * ```\n */\nexport function createNonceInvalidationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateNonceInvalidationPromiseFactoryConfig<'devnet'>): GetNonceInvalidationPromiseFn;\nexport function createNonceInvalidationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateNonceInvalidationPromiseFactoryConfig<'testnet'>): GetNonceInvalidationPromiseFn;\nexport function createNonceInvalidationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateNonceInvalidationPromiseFactoryConfig<'mainnet'>): GetNonceInvalidationPromiseFn;\nexport function createNonceInvalidationPromiseFactory<TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void>({\n    rpc,\n    rpcSubscriptions,\n}: CreateNonceInvalidationPromiseFactoryConfig<TCluster>): GetNonceInvalidationPromiseFn {\n    return async function getNonceInvalidationPromise({\n        abortSignal: callerAbortSignal,\n        commitment,\n        currentNonceValue: expectedNonceValue,\n        nonceAccountAddress,\n    }) {\n        const abortController = new AbortController();\n        function handleAbort() {\n            abortController.abort();\n        }\n        callerAbortSignal.addEventListener('abort', handleAbort, { signal: abortController.signal });\n        /**\n         * STEP 1: Set up a subscription for nonce account changes.\n         */\n        const accountNotifications = await rpcSubscriptions\n            .accountNotifications(nonceAccountAddress, { commitment, encoding: 'base64' })\n            .subscribe({ abortSignal: abortController.signal });\n        const base58Decoder = getBase58Decoder();\n        const base64Encoder = getBase64Encoder();\n        function getNonceFromAccountData([base64EncodedBytes]: Base64EncodedDataResponse): Nonce {\n            const data = base64Encoder.encode(base64EncodedBytes);\n            const nonceValueBytes = data.slice(NONCE_VALUE_OFFSET, NONCE_VALUE_OFFSET + 32);\n            return base58Decoder.decode(nonceValueBytes) as Nonce;\n        }\n        const nonceAccountDidAdvancePromise = (async () => {\n            for await (const accountNotification of accountNotifications) {\n                const nonceValue = getNonceFromAccountData(accountNotification.value.data);\n                if (nonceValue !== expectedNonceValue) {\n                    throw new SolanaError(SOLANA_ERROR__INVALID_NONCE, {\n                        actualNonceValue: nonceValue,\n                        expectedNonceValue,\n                    });\n                }\n            }\n        })();\n        /**\n         * STEP 2: Having subscribed for updates, make a one-shot request for the current nonce\n         *         value to check if it has already been advanced.\n         */\n        const nonceIsAlreadyInvalidPromise = (async () => {\n            const { value: nonceAccount } = await rpc\n                .getAccountInfo(nonceAccountAddress, {\n                    commitment,\n                    dataSlice: { length: 32, offset: NONCE_VALUE_OFFSET },\n                    encoding: 'base58',\n                })\n                .send({ abortSignal: abortController.signal });\n            if (!nonceAccount) {\n                throw new SolanaError(SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND, {\n                    nonceAccountAddress,\n                });\n            }\n            const nonceValue =\n                // This works because we asked for the exact slice of data representing the nonce\n                // value, and furthermore asked for it in `base58` encoding.\n                nonceAccount.data[0] as unknown as Nonce;\n            if (nonceValue !== expectedNonceValue) {\n                throw new SolanaError(SOLANA_ERROR__INVALID_NONCE, {\n                    actualNonceValue: nonceValue,\n                    expectedNonceValue,\n                });\n            } else {\n                await new Promise(() => {\n                    /* never resolve */\n                });\n            }\n        })();\n        try {\n            return await safeRace([nonceAccountDidAdvancePromise, nonceIsAlreadyInvalidPromise]);\n        } finally {\n            abortController.abort();\n        }\n    };\n}\n", "import { getSolanaErrorFromTransactionError } from '@solana/errors';\nimport { AbortController } from '@solana/event-target-impl';\nimport type { Signature } from '@solana/keys';\nimport { safeRace } from '@solana/promises';\nimport type { GetSignatureStatusesApi, Rpc } from '@solana/rpc';\nimport type { RpcSubscriptions, SignatureNotificationsApi } from '@solana/rpc-subscriptions';\nimport { type Commitment, commitmentComparator } from '@solana/rpc-types';\n\ntype GetRecentSignatureConfirmationPromiseFn = (config: {\n    abortSignal: AbortSignal;\n    /**\n     * The level of commitment the transaction must have achieved in order for the promise to\n     * resolve.\n     */\n    commitment: Commitment;\n    /**\n     * A 64 byte Ed25519 signature, encoded as a base-58 string, that uniquely identifies a\n     * transaction by virtue of being the first or only signature in its list of signatures.\n     */\n    signature: Signature;\n}) => Promise<void>;\n\ntype CreateRecentSignatureConfirmationPromiseFactoryConfig<TCluster> = {\n    rpc: Rpc<GetSignatureStatusesApi> & { '~cluster'?: TCluster };\n    rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi> & { '~cluster'?: TCluster };\n};\n\n/**\n * Creates a promise that resolves when a recently-landed transaction achieves the target\n * confirmation commitment, and throws when the transaction fails with an error.\n *\n * The status of recently-landed transactions is available in the network's status cache. This\n * confirmation strategy will only yield a result if the signature is still in the status cache. To\n * fetch the status of transactions older than those available in the status cache, use the\n * {@link GetSignatureStatusesApi.getSignatureStatuses} method setting the\n * `searchTransactionHistory` configuration param to `true`.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { createRecentSignatureConfirmationPromiseFactory } from '@solana/transaction-confirmation';\n *\n * const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({\n *     rpc,\n *     rpcSubscriptions,\n * });\n * try {\n *     await getRecentSignatureConfirmationPromise({\n *         commitment,\n *         signature,\n *     });\n *     console.log(`The transaction with signature \\`${signature}\\` has achieved a commitment level of \\`${commitment}\\``);\n * } catch (e) {\n *     console.error(`The transaction with signature \\`${signature}\\` failed`, e.cause);\n *     throw e;\n * }\n * ```\n */\nexport function createRecentSignatureConfirmationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateRecentSignatureConfirmationPromiseFactoryConfig<'devnet'>): GetRecentSignatureConfirmationPromiseFn;\nexport function createRecentSignatureConfirmationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateRecentSignatureConfirmationPromiseFactoryConfig<'testnet'>): GetRecentSignatureConfirmationPromiseFn;\nexport function createRecentSignatureConfirmationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n}: CreateRecentSignatureConfirmationPromiseFactoryConfig<'mainnet'>): GetRecentSignatureConfirmationPromiseFn;\nexport function createRecentSignatureConfirmationPromiseFactory<\n    TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void,\n>({\n    rpc,\n    rpcSubscriptions,\n}: CreateRecentSignatureConfirmationPromiseFactoryConfig<TCluster>): GetRecentSignatureConfirmationPromiseFn {\n    return async function getRecentSignatureConfirmationPromise({\n        abortSignal: callerAbortSignal,\n        commitment,\n        signature,\n    }) {\n        const abortController = new AbortController();\n        function handleAbort() {\n            abortController.abort();\n        }\n        callerAbortSignal.addEventListener('abort', handleAbort, { signal: abortController.signal });\n        /**\n         * STEP 1: Set up a subscription for status changes to a signature.\n         */\n        const signatureStatusNotifications = await rpcSubscriptions\n            .signatureNotifications(signature, { commitment })\n            .subscribe({ abortSignal: abortController.signal });\n        const signatureDidCommitPromise = (async () => {\n            for await (const signatureStatusNotification of signatureStatusNotifications) {\n                if (signatureStatusNotification.value.err) {\n                    throw getSolanaErrorFromTransactionError(signatureStatusNotification.value.err);\n                } else {\n                    return;\n                }\n            }\n        })();\n        /**\n         * STEP 2: Having subscribed for updates, make a one-shot request for the current status.\n         *         This will only yield a result if the signature is still in the status cache.\n         */\n        const signatureStatusLookupPromise = (async () => {\n            const { value: signatureStatusResults } = await rpc\n                .getSignatureStatuses([signature])\n                .send({ abortSignal: abortController.signal });\n            const signatureStatus = signatureStatusResults[0];\n            if (\n                signatureStatus &&\n                signatureStatus.confirmationStatus &&\n                commitmentComparator(signatureStatus.confirmationStatus, commitment) >= 0\n            ) {\n                return;\n            } else {\n                await new Promise(() => {\n                    /* never resolve */\n                });\n            }\n        })();\n        try {\n            return await safeRace([signatureDidCommitPromise, signatureStatusLookupPromise]);\n        } finally {\n            abortController.abort();\n        }\n    };\n}\n", "import type { Commitment } from '@solana/rpc-types';\n\ntype Config = Readonly<{\n    abortSignal: AbortSignal;\n    /**\n     * The timeout promise will throw after 30 seconds when the commitment is `processed`, and 60\n     * seconds otherwise.\n     */\n    commitment: Commitment;\n}>;\n\n/**\n * When no other heuristic exists to infer that a transaction has expired, you can use this promise\n * factory with a commitment level. It throws after 30 seconds when the commitment is `processed`,\n * and 60 seconds otherwise. You would typically race this with another confirmation strategy.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { safeRace } from '@solana/promises';\n * import { getTimeoutPromise } from '@solana/transaction-confirmation';\n *\n * try {\n *     await safeRace([getCustomTransactionConfirmationPromise(/* ... *\\/), getTimeoutPromise({ commitment })]);\n * } catch (e) {\n *     if (e instanceof DOMException && e.name === 'TimeoutError') {\n *         console.log('Could not confirm transaction after a timeout');\n *     }\n *     throw e;\n * }\n * ```\n */\nexport async function getTimeoutPromise({ abortSignal: callerAbortSignal, commitment }: Config) {\n    return await new Promise((_, reject) => {\n        const handleAbort = (e: AbortSignalEventMap['abort']) => {\n            clearTimeout(timeoutId);\n            const abortError = new DOMException((e.target as AbortSignal).reason, 'AbortError');\n            reject(abortError);\n        };\n        callerAbortSignal.addEventListener('abort', handleAbort);\n        const timeoutMs = commitment === 'processed' ? 30_000 : 60_000;\n        const startMs = performance.now();\n        const timeoutId =\n            // We use `setTimeout` instead of `AbortSignal.timeout()` because we want to measure\n            // elapsed time instead of active time.\n            // See https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/timeout_static\n            setTimeout(() => {\n                const elapsedMs = performance.now() - startMs;\n                reject(new DOMException(`Timeout elapsed after ${elapsedMs} ms`, 'TimeoutError'));\n            }, timeoutMs);\n    });\n}\n", "import { AbortController } from '@solana/event-target-impl';\nimport type { Signature } from '@solana/keys';\nimport { safeRace } from '@solana/promises';\nimport type { Commitment } from '@solana/rpc-types';\n\nimport { createRecentSignatureConfirmationPromiseFactory } from './confirmation-strategy-recent-signature';\n\nexport interface BaseTransactionConfirmationStrategyConfig {\n    abortSignal?: AbortSignal;\n    commitment: Commitment;\n    getRecentSignatureConfirmationPromise: ReturnType<typeof createRecentSignatureConfirmationPromiseFactory>;\n}\n\ntype WithNonNullableAbortSignal<T> = Omit<T, 'abortSignal'> & Readonly<{ abortSignal: AbortSignal }>;\n\nexport async function raceStrategies<TConfig extends BaseTransactionConfirmationStrategyConfig>(\n    signature: Signature,\n    config: TConfig,\n    getSpecificStrategiesForRace: (config: WithNonNullableAbortSignal<TConfig>) => readonly Promise<unknown>[],\n) {\n    const { abortSignal: callerAbortSignal, commitment, getRecentSignatureConfirmationPromise } = config;\n    callerAbortSignal?.throwIfAborted();\n    const abortController = new AbortController();\n    if (callerAbortSignal) {\n        const handleAbort = () => {\n            abortController.abort();\n        };\n        callerAbortSignal.addEventListener('abort', handleAbort, { signal: abortController.signal });\n    }\n    try {\n        const specificStrategies = getSpecificStrategiesForRace({\n            ...config,\n            abortSignal: abortController.signal,\n        });\n        return await safeRace([\n            getRecentSignatureConfirmationPromise({\n                abortSignal: abortController.signal,\n                commitment,\n                signature,\n            }),\n            ...specificStrategies,\n        ]);\n    } finally {\n        abortController.abort();\n    }\n}\n", "import { Signature } from '@solana/keys';\nimport {\n    getSignatureFromTransaction,\n    Transaction,\n    TransactionWithBlockhashLifetime,\n    TransactionWithDurableNonceLifetime,\n} from '@solana/transactions';\n\nimport { createBlockHeightExceedencePromiseFactory } from './confirmation-strategy-blockheight';\nimport { createNonceInvalidationPromiseFactory } from './confirmation-strategy-nonce';\nimport { BaseTransactionConfirmationStrategyConfig, raceStrategies } from './confirmation-strategy-racer';\nimport { getTimeoutPromise } from './confirmation-strategy-timeout';\n\nexport type TransactionWithLastValidBlockHeight = Omit<TransactionWithBlockhashLifetime, 'lifetimeConstraint'> & {\n    lifetimeConstraint: Omit<TransactionWithBlockhashLifetime['lifetimeConstraint'], 'blockhash'>;\n};\n\ninterface WaitForDurableNonceTransactionConfirmationConfig extends BaseTransactionConfirmationStrategyConfig {\n    getNonceInvalidationPromise: ReturnType<typeof createNonceInvalidationPromiseFactory>;\n    transaction: Readonly<Transaction & TransactionWithDurableNonceLifetime>;\n}\n\ninterface WaitForRecentTransactionWithBlockhashLifetimeConfirmationConfig\n    extends BaseTransactionConfirmationStrategyConfig {\n    getBlockHeightExceedencePromise: ReturnType<typeof createBlockHeightExceedencePromiseFactory>;\n    transaction: Readonly<Transaction & TransactionWithLastValidBlockHeight>;\n}\n\ninterface WaitForRecentTransactionWithTimeBasedLifetimeConfirmationConfig\n    extends BaseTransactionConfirmationStrategyConfig {\n    getTimeoutPromise: typeof getTimeoutPromise;\n    /**\n     * A 64 byte Ed25519 signature, encoded as a base-58 string, that uniquely identifies a\n     * transaction by virtue of being the first or only signature in its list of signatures.\n     */\n    signature: Signature;\n}\n\n/**\n * Supply your own confirmation implementations to this function to create a custom nonce\n * transaction confirmation strategy.\n *\n * @example\n * ```ts\n * import { waitForDurableNonceTransactionConfirmation } from '@solana/transaction-confirmation';\n *\n * try {\n *     await waitForDurableNonceTransactionConfirmation({\n *         getNonceInvalidationPromise({ abortSignal, commitment, currentNonceValue, nonceAccountAddress }) {\n *             // Return a promise that rejects when a nonce becomes invalid.\n *         },\n *         getRecentSignatureConfirmationPromise({ abortSignal, commitment, signature }) {\n *             // Return a promise that resolves when a transaction achieves confirmation\n *         },\n *     });\n * } catch (e) {\n *     // Handle errors.\n * }\n * ```\n */\nexport async function waitForDurableNonceTransactionConfirmation(\n    config: WaitForDurableNonceTransactionConfirmationConfig,\n): Promise<void> {\n    await raceStrategies(\n        getSignatureFromTransaction(config.transaction),\n        config,\n        function getSpecificStrategiesForRace({ abortSignal, commitment, getNonceInvalidationPromise, transaction }) {\n            return [\n                getNonceInvalidationPromise({\n                    abortSignal,\n                    commitment,\n                    currentNonceValue: transaction.lifetimeConstraint.nonce,\n                    nonceAccountAddress: transaction.lifetimeConstraint.nonceAccountAddress,\n                }),\n            ];\n        },\n    );\n}\n\n/**\n * Supply your own confirmation implementations to this function to create a custom confirmation\n * strategy for recently-landed transactions.\n *\n * @example\n * ```ts\n * import { waitForRecentTransactionConfirmation } from '@solana/transaction-confirmation';\n *\n * try {\n *     await waitForRecentTransactionConfirmation({\n *         getBlockHeightExceedencePromise({ abortSignal, commitment, lastValidBlockHeight }) {\n *             // Return a promise that rejects when the blockhash's block height has been exceeded\n *         },\n *         getRecentSignatureConfirmationPromise({ abortSignal, commitment, signature }) {\n *             // Return a promise that resolves when a transaction achieves confirmation\n *         },\n *     });\n * } catch (e) {\n *     // Handle errors.\n * }\n * ```\n */\nexport async function waitForRecentTransactionConfirmation(\n    config: WaitForRecentTransactionWithBlockhashLifetimeConfirmationConfig,\n): Promise<void> {\n    await raceStrategies(\n        getSignatureFromTransaction(config.transaction),\n        config,\n        function getSpecificStrategiesForRace({\n            abortSignal,\n            commitment,\n            getBlockHeightExceedencePromise,\n            transaction,\n        }) {\n            return [\n                getBlockHeightExceedencePromise({\n                    abortSignal,\n                    commitment,\n                    lastValidBlockHeight: transaction.lifetimeConstraint.lastValidBlockHeight,\n                }),\n            ];\n        },\n    );\n}\n\n/** @deprecated */\nexport async function waitForRecentTransactionConfirmationUntilTimeout(\n    config: WaitForRecentTransactionWithTimeBasedLifetimeConfirmationConfig,\n): Promise<void> {\n    await raceStrategies(\n        config.signature,\n        config,\n        function getSpecificStrategiesForRace({ abortSignal, commitment, getTimeoutPromise }) {\n            return [\n                getTimeoutPromise({\n                    abortSignal,\n                    commitment,\n                }),\n            ];\n        },\n    );\n}\n", "import type { Address } from '@solana/addresses';\nimport type { Signature } from '@solana/keys';\nimport type { RequestAirdropApi, Rpc } from '@solana/rpc';\nimport type { Commitment, Lamports } from '@solana/rpc-types';\nimport { waitForRecentTransactionConfirmationUntilTimeout } from '@solana/transaction-confirmation';\n\ntype RequestAndConfirmAirdropConfig = Readonly<{\n    abortSignal?: AbortSignal;\n    commitment: Commitment;\n    confirmSignatureOnlyTransaction: (\n        config: Omit<\n            Parameters<typeof waitForRecentTransactionConfirmationUntilTimeout>[0],\n            'getRecentSignatureConfirmationPromise' | 'getTimeoutPromise'\n        >,\n    ) => Promise<void>;\n    lamports: Lamports;\n    recipientAddress: Address;\n    rpc: Rpc<RequestAirdropApi>;\n}>;\n\nexport async function requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    commitment,\n    confirmSignatureOnlyTransaction,\n    lamports,\n    recipientAddress,\n    rpc,\n}: RequestAndConfirmAirdropConfig): Promise<Signature> {\n    const airdropTransactionSignature = await rpc\n        .requestAirdrop(recipientAddress, lamports, { commitment })\n        .send({ abortSignal });\n    await confirmSignatureOnlyTransaction({\n        abortSignal,\n        commitment,\n        signature: airdropTransactionSignature,\n    });\n    return airdropTransactionSignature;\n}\n", "import type { Signature } from '@solana/keys';\nimport type { GetSignatureStatusesApi, RequestAirdropApi, Rpc } from '@solana/rpc';\nimport type { RpcSubscriptions, SignatureNotificationsApi } from '@solana/rpc-subscriptions';\nimport {\n    createRecentSignatureConfirmationPromiseFactory,\n    getTimeoutPromise,\n    waitForRecentTransactionConfirmationUntilTimeout,\n} from '@solana/transaction-confirmation';\n\nimport { requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT } from './airdrop-internal';\n\ntype AirdropFunction = (\n    config: Omit<\n        Parameters<typeof requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT>[0],\n        'confirmSignatureOnlyTransaction' | 'rpc'\n    >,\n) => Promise<Signature>;\n\ntype AirdropFactoryConfig<TCluster> = {\n    /** An object that supports the {@link GetSignatureStatusesApi} and the {@link RequestAirdropApi} of the Solana RPC API */\n    rpc: Rpc<GetSignatureStatusesApi & RequestAirdropApi> & { '~cluster'?: TCluster };\n    /** An object that supports the {@link SignatureNotificationsApi} of the Solana RPC Subscriptions API */\n    rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi> & { '~cluster'?: TCluster };\n};\n\n/**\n * Returns a function that you can call to airdrop a certain amount of {@link Lamports} to a Solana\n * address.\n *\n * > [!NOTE] This only works on test clusters.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { address, airdropFactory, createSolanaRpc, createSolanaRpcSubscriptions, devnet, lamports } from '@solana/kit';\n *\n * const rpc = createSolanaRpc(devnet('http://127.0.0.1:8899'));\n * const rpcSubscriptions = createSolanaRpcSubscriptions(devnet('ws://127.0.0.1:8900'));\n *\n * const airdrop = airdropFactory({ rpc, rpcSubscriptions });\n *\n * await airdrop({\n *     commitment: 'confirmed',\n *     recipientAddress: address('FnHyam9w4NZoWR6mKN1CuGBritdsEWZQa4Z4oawLZGxa'),\n *     lamports: lamports(10_000_000n),\n * });\n * ```\n */\nexport function airdropFactory({ rpc, rpcSubscriptions }: AirdropFactoryConfig<'devnet'>): AirdropFunction;\nexport function airdropFactory({ rpc, rpcSubscriptions }: AirdropFactoryConfig<'mainnet'>): AirdropFunction;\nexport function airdropFactory({ rpc, rpcSubscriptions }: AirdropFactoryConfig<'testnet'>): AirdropFunction;\nexport function airdropFactory<TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void>({\n    rpc,\n    rpcSubscriptions,\n}: AirdropFactoryConfig<TCluster>): AirdropFunction {\n    const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({\n        rpc,\n        rpcSubscriptions,\n    } as Parameters<typeof createRecentSignatureConfirmationPromiseFactory>[0]);\n    async function confirmSignatureOnlyTransaction(\n        config: Omit<\n            Parameters<typeof waitForRecentTransactionConfirmationUntilTimeout>[0],\n            'getRecentSignatureConfirmationPromise' | 'getTimeoutPromise'\n        >,\n    ) {\n        await waitForRecentTransactionConfirmationUntilTimeout({\n            ...config,\n            getRecentSignatureConfirmationPromise,\n            getTimeoutPromise,\n        });\n    }\n    return async function airdrop(config) {\n        return await requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            confirmSignatureOnlyTransaction,\n            rpc,\n        });\n    };\n}\n", "import { Address } from '@solana/addresses';\nimport { getU32Encoder } from '@solana/codecs';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SolanaError,\n} from '@solana/errors';\nimport { Instruction, InstructionWithData, isInstructionForProgram, isInstructionWithData } from '@solana/instructions';\nimport { Rpc, SimulateTransactionApi } from '@solana/rpc';\nimport { Blockhash, Commitment, Slot } from '@solana/rpc-types';\nimport {\n    appendTransactionMessageInstruction,\n    CompilableTransactionMessage,\n    isTransactionMessageWithBlockhashLifetime,\n    isTransactionMessageWithDurableNonceLifetime,\n    setTransactionMessageLifetimeUsingBlockhash,\n    TransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\nimport { compileTransaction, getBase64EncodedWireTransaction } from '@solana/transactions';\n\ntype ComputeUnitEstimateForTransactionMessageConfig = Readonly<{\n    abortSignal?: AbortSignal;\n    /**\n     * Compute the estimate as of the highest slot that has reached this level of commitment.\n     *\n     * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n     * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n     * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n     * default commitment applied by the server is `\"finalized\"`.\n     */\n    commitment?: Commitment;\n    /**\n     * Prevents accessing stale data by enforcing that the RPC node has processed transactions up to\n     * this slot\n     */\n    minContextSlot?: Slot;\n    rpc: Rpc<SimulateTransactionApi>;\n    transactionMessage: CompilableTransactionMessage | (TransactionMessage & TransactionMessageWithFeePayer);\n}>;\n\nconst COMPUTE_BUDGET_PROGRAM_ADDRESS =\n    'ComputeBudget111111111111111111111111111111' as Address<'ComputeBudget111111111111111111111111111111'>;\n// HACK: Since the `compileTransaction()` method will not compile a transaction with no lifetime we\n// supply a dummy lifetime.\nconst INVALID_BUT_SUFFICIENT_FOR_COMPILATION_BLOCKHASH = {\n    blockhash: '11111111111111111111111111111111' as Blockhash,\n    lastValidBlockHeight: 0n, // This is not included in compiled transactions; it can be anything.\n} as const;\nconst SET_COMPUTE_UNIT_LIMIT_INSTRUCTION_INDEX = 0x02;\n\nfunction createComputeUnitLimitInstruction(units: number): Instruction<typeof COMPUTE_BUDGET_PROGRAM_ADDRESS> {\n    const data = new Uint8Array(5);\n    data[0] = SET_COMPUTE_UNIT_LIMIT_INSTRUCTION_INDEX;\n    getU32Encoder().write(units, data, 1 /* offset */);\n    return Object.freeze({\n        data,\n        programAddress: COMPUTE_BUDGET_PROGRAM_ADDRESS,\n    });\n}\n\nfunction isSetComputeLimitInstruction(\n    instruction: Instruction,\n): instruction is Instruction<typeof COMPUTE_BUDGET_PROGRAM_ADDRESS> & InstructionWithData<Uint8Array> {\n    return (\n        isInstructionForProgram(instruction, COMPUTE_BUDGET_PROGRAM_ADDRESS) &&\n        isInstructionWithData(instruction) &&\n        instruction.data[0] === SET_COMPUTE_UNIT_LIMIT_INSTRUCTION_INDEX\n    );\n}\n\n/**\n * Simulates a transaction message on the network and returns the number of compute units it\n * consumed during simulation.\n *\n * The estimate this function returns can be used to set a compute unit limit on the transaction.\n * Correctly budgeting a compute unit limit for your transaction message can increase the probability\n * that your transaction will be accepted for processing.\n *\n * If you don't declare a compute unit limit on your transaction, validators will assume an upper\n * limit of 200K compute units (CU) per instruction. Since validators have an incentive to pack as\n * many transactions into each block as possible, they may choose to include transactions that they\n * know will fit into the remaining compute budget for the current block over transactions that\n * might not. For this reason, you should set a compute unit limit on each of your transaction\n * messages, whenever possible.\n *\n * ## Example\n *\n * ```ts\n * import { getSetComputeLimitInstruction } from '@solana-program/compute-budget';\n * import { createSolanaRpc, getComputeUnitEstimateForTransactionMessageFactory, pipe } from '@solana/kit';\n *\n * // Create an estimator function.\n * const rpc = createSolanaRpc('http://127.0.0.1:8899');\n * const getComputeUnitEstimateForTransactionMessage =\n *     getComputeUnitEstimateForTransactionMessageFactory({ rpc });\n *\n * // Create your transaction message.\n * const transactionMessage = pipe(\n *     createTransactionMessage({ version: 'legacy' }),\n *     /* ... *\\/\n * );\n *\n * // Request an estimate of the actual compute units this message will consume.\n * const computeUnitsEstimate =\n *     await getComputeUnitEstimateForTransactionMessage(transactionMessage);\n *\n * // Set the transaction message's compute unit budget.\n * const transactionMessageWithComputeUnitLimit = prependTransactionMessageInstruction(\n *     getSetComputeLimitInstruction({ units: computeUnitsEstimate }),\n *     transactionMessage,\n * );\n * ```\n *\n * > [!WARNING]\n * > The compute unit estimate is just that &ndash; an estimate. The compute unit consumption of the\n * > actual transaction might be higher or lower than what was observed in simulation. Unless you\n * > are confident that your particular transaction message will consume the same or fewer compute\n * > units as was estimated, you might like to augment the estimate by either a fixed number of CUs\n * > or a multiplier.\n *\n * > [!NOTE]\n * > If you are preparing an _unsigned_ transaction, destined to be signed and submitted to the\n * > network by a wallet, you might like to leave it up to the wallet to determine the compute unit\n * > limit. Consider that the wallet might have a more global view of how many compute units certain\n * > types of transactions consume, and might be able to make better estimates of an appropriate\n * > compute unit budget.\n */\nexport async function getComputeUnitEstimateForTransactionMessage_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    rpc,\n    transactionMessage,\n    ...simulateConfig\n}: ComputeUnitEstimateForTransactionMessageConfig): Promise<number> {\n    /**\n     * STEP 1: Make sure the transaction message will not fail in simulation for lack of a lifetime\n     *         - either a recent blockhash lifetime or a nonce.\n     */\n    const isDurableNonceTransactionMessage = isTransactionMessageWithDurableNonceLifetime(transactionMessage);\n    let compilableTransactionMessage: CompilableTransactionMessage;\n    if (isDurableNonceTransactionMessage || isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        compilableTransactionMessage = transactionMessage;\n    } else {\n        compilableTransactionMessage = setTransactionMessageLifetimeUsingBlockhash(\n            INVALID_BUT_SUFFICIENT_FOR_COMPILATION_BLOCKHASH,\n            transactionMessage,\n        );\n    }\n    /**\n     * STEP 2: Ensure that the message has a `SetComputeLimit` instruction. The set compute limit\n     *         instruction itself consumes compute units, so it must be included in the simulation.\n     */\n    const existingSetComputeUnitLimitInstructionIndex =\n        transactionMessage.instructions.findIndex(isSetComputeLimitInstruction);\n    const maxComputeUnitLimitInstruction = createComputeUnitLimitInstruction(1_400_000 /* MAX_COMPUTE_UNIT_LIMIT */);\n    if (existingSetComputeUnitLimitInstructionIndex === -1) {\n        compilableTransactionMessage = appendTransactionMessageInstruction(\n            maxComputeUnitLimitInstruction,\n            compilableTransactionMessage,\n        ) as CompilableTransactionMessage;\n    } else {\n        const nextInstructions = [...compilableTransactionMessage.instructions];\n        nextInstructions.splice(existingSetComputeUnitLimitInstructionIndex, 1, maxComputeUnitLimitInstruction);\n        compilableTransactionMessage = Object.freeze({\n            ...compilableTransactionMessage,\n            instructions: nextInstructions,\n        } as typeof compilableTransactionMessage);\n    }\n    /**\n     * STEP 3: Simulate the transaction to measure its compute unit consumption.\n     */\n    const compiledTransaction = compileTransaction(compilableTransactionMessage);\n    const wireTransactionBytes = getBase64EncodedWireTransaction(compiledTransaction);\n    try {\n        const {\n            value: { err: transactionError, unitsConsumed },\n        } = await rpc\n            .simulateTransaction(wireTransactionBytes, {\n                ...simulateConfig,\n                encoding: 'base64',\n                replaceRecentBlockhash: !isDurableNonceTransactionMessage,\n                sigVerify: false,\n            })\n            .send({ abortSignal });\n        if (unitsConsumed == null) {\n            // This should never be hit, because all RPCs should support `unitsConsumed` by now.\n            throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT);\n        }\n        // FIXME(https://github.com/anza-xyz/agave/issues/1295): The simulation response returns\n        // compute units as a u64, but the `SetComputeLimit` instruction only accepts a u32. Until\n        // this changes, downcast it.\n        const downcastUnitsConsumed = unitsConsumed > 4_294_967_295n ? 4_294_967_295 : Number(unitsConsumed);\n        if (transactionError) {\n            throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT, {\n                cause: transactionError,\n                unitsConsumed: downcastUnitsConsumed,\n            });\n        }\n        return downcastUnitsConsumed;\n    } catch (e) {\n        if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT)) throw e;\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT, {\n            cause: e,\n        });\n    }\n}\n", "import { Rpc, SimulateTransactionApi } from '@solana/rpc';\nimport {\n    CompilableTransactionMessage,\n    TransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\n\nimport { getComputeUnitEstimateForTransactionMessage_INTERNAL_ONLY_DO_NOT_EXPORT } from './compute-limit-internal';\n\ntype ComputeUnitEstimateForTransactionMessageFactoryConfig = Readonly<{\n    /** An object that supports the {@link SimulateTransactionApi} of the Solana RPC API */\n    rpc: Rpc<SimulateTransactionApi>;\n}>;\ntype ComputeUnitEstimateForTransactionMessageFunction = (\n    transactionMessage: CompilableTransactionMessage | (TransactionMessage & TransactionMessageWithFeePayer),\n    config?: Omit<\n        Parameters<typeof getComputeUnitEstimateForTransactionMessage_INTERNAL_ONLY_DO_NOT_EXPORT>[0],\n        'rpc' | 'transactionMessage'\n    >,\n) => Promise<number>;\n\n/**\n * Use this utility to estimate the actual compute unit cost of a given transaction message.\n *\n * Correctly budgeting a compute unit limit for your transaction message can increase the\n * probability that your transaction will be accepted for processing. If you don't declare a compute\n * unit limit on your transaction, validators will assume an upper limit of 200K compute units (CU)\n * per instruction.\n *\n * Since validators have an incentive to pack as many transactions into each block as possible, they\n * may choose to include transactions that they know will fit into the remaining compute budget for\n * the current block over transactions that might not. For this reason, you should set a compute\n * unit limit on each of your transaction messages, whenever possible.\n *\n * > [!WARNING]\n * > The compute unit estimate is just that -- an estimate. The compute unit consumption of the\n * > actual transaction might be higher or lower than what was observed in simulation. Unless you\n * > are confident that your particular transaction message will consume the same or fewer compute\n * > units as was estimated, you might like to augment the estimate by either a fixed number of CUs\n * > or a multiplier.\n *\n * > [!NOTE]\n * > If you are preparing an _unsigned_ transaction, destined to be signed and submitted to the\n * > network by a wallet, you might like to leave it up to the wallet to determine the compute unit\n * > limit. Consider that the wallet might have a more global view of how many compute units certain\n * > types of transactions consume, and might be able to make better estimates of an appropriate\n * > compute unit budget.\n *\n * > [!INFO]\n * > In the event that a transaction message does not already have a `SetComputeUnitLimit`\n * > instruction, this function will add one before simulation. This ensures that the compute unit\n * > consumption of the `SetComputeUnitLimit` instruction itself is included in the estimate.\n *\n * @param config\n *\n * @deprecated Use `estimateComputeUnitLimitFactory` from `@solana-program/compute-budget` instead.\n *\n * @example\n * ```ts\n * import { getSetComputeUnitLimitInstruction } from '@solana-program/compute-budget';\n * import { createSolanaRpc, getComputeUnitEstimateForTransactionMessageFactory, pipe } from '@solana/kit';\n *\n * // Create an estimator function.\n * const rpc = createSolanaRpc('http://127.0.0.1:8899');\n * const getComputeUnitEstimateForTransactionMessage = getComputeUnitEstimateForTransactionMessageFactory({\n *     rpc,\n * });\n *\n * // Create your transaction message.\n * const transactionMessage = pipe(\n *     createTransactionMessage({ version: 'legacy' }),\n *     /* ... *\\/\n * );\n *\n * // Request an estimate of the actual compute units this message will consume. This is done by\n * // simulating the transaction and grabbing the estimated compute units from the result.\n * const computeUnitsEstimate = await getComputeUnitEstimateForTransactionMessage(transactionMessage);\n *\n * // Set the transaction message's compute unit budget.\n * const transactionMessageWithComputeUnitLimit = prependTransactionMessageInstruction(\n *     getSetComputeUnitLimitInstruction({ units: computeUnitsEstimate }),\n *     transactionMessage,\n * );\n * ```\n */\nexport function getComputeUnitEstimateForTransactionMessageFactory({\n    rpc,\n}: ComputeUnitEstimateForTransactionMessageFactoryConfig): ComputeUnitEstimateForTransactionMessageFunction {\n    return async function getComputeUnitEstimateForTransactionMessage(transactionMessage, config) {\n        return await getComputeUnitEstimateForTransactionMessage_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            rpc,\n            transactionMessage,\n        });\n    };\n}\n", "import {\n    assertAccountsDecoded,\n    assertAccountsExist,\n    type FetchAccountsConfig,\n    fetchJsonParsedAccounts,\n} from '@solana/accounts';\nimport type { Address } from '@solana/addresses';\nimport type { GetMultipleAccountsApi, Rpc } from '@solana/rpc';\nimport { type AddressesByLookupTableAddress } from '@solana/transaction-messages';\n\ntype FetchedAddressLookup = {\n    addresses: Address[];\n};\n\n/**\n * Given a list of addresses belonging to address lookup tables, returns a map of lookup table\n * addresses to an ordered array of the addresses they contain.\n *\n * @param rpc An object that supports the {@link GetMultipleAccountsApi} of the Solana RPC API\n * @param config\n */\nexport async function fetchAddressesForLookupTables(\n    lookupTableAddresses: Address[],\n    rpc: Rpc<GetMultipleAccountsApi>,\n    config?: FetchAccountsConfig,\n): Promise<AddressesByLookupTableAddress> {\n    if (lookupTableAddresses.length === 0) {\n        return {};\n    }\n\n    const fetchedLookupTables = await fetchJsonParsedAccounts<FetchedAddressLookup[]>(\n        rpc,\n        lookupTableAddresses,\n        config,\n    );\n\n    assertAccountsDecoded(fetchedLookupTables);\n    assertAccountsExist(fetchedLookupTables);\n\n    return fetchedLookupTables.reduce<AddressesByLookupTableAddress>((acc, lookup) => {\n        return {\n            ...acc,\n            [lookup.address]: lookup.data.addresses,\n        };\n    }, {});\n}\n", "import { type FetchAccountsConfig } from '@solana/accounts';\nimport type { GetMultipleAccountsApi, Rpc } from '@solana/rpc';\nimport {\n    CompilableTransactionMessage,\n    CompiledTransactionMessage,\n    decompileTransactionMessage,\n} from '@solana/transaction-messages';\n\nimport { fetchAddressesForLookupTables } from './fetch-lookup-tables';\n\ntype DecompileTransactionMessageFetchingLookupTablesConfig = FetchAccountsConfig & {\n    lastValidBlockHeight?: bigint;\n};\n\n/**\n * Returns a {@link TransactionMessage} from a {@link CompiledTransactionMessage}. If any of the\n * accounts in the compiled message require an address lookup table to find their address, this\n * function will use the supplied RPC instance to fetch the contents of the address lookup table\n * from the network.\n *\n * @param rpc An object that supports the {@link GetMultipleAccountsApi} of the Solana RPC API\n * @param config\n */\nexport async function decompileTransactionMessageFetchingLookupTables(\n    compiledTransactionMessage: CompiledTransactionMessage,\n    rpc: Rpc<GetMultipleAccountsApi>,\n    config?: DecompileTransactionMessageFetchingLookupTablesConfig,\n): Promise<CompilableTransactionMessage> {\n    const lookupTables =\n        'addressTableLookups' in compiledTransactionMessage &&\n        compiledTransactionMessage.addressTableLookups !== undefined &&\n        compiledTransactionMessage.addressTableLookups.length > 0\n            ? compiledTransactionMessage.addressTableLookups\n            : [];\n    const lookupTableAddresses = lookupTables.map(l => l.lookupTableAddress);\n\n    const { lastValidBlockHeight, ...fetchAccountsConfig } = config ?? {};\n    const addressesByLookupTableAddress =\n        lookupTableAddresses.length > 0\n            ? await fetchAddressesForLookupTables(lookupTableAddresses, rpc, fetchAccountsConfig)\n            : {};\n\n    return decompileTransactionMessage(compiledTransactionMessage, {\n        addressesByLookupTableAddress,\n        lastValidBlockHeight,\n    });\n}\n", "import type { Signature } from '@solana/keys';\nimport type { Rpc, SendTransactionApi } from '@solana/rpc';\nimport { Commitment, commitmentComparator } from '@solana/rpc-types';\nimport {\n    TransactionWithLastValidBlockHeight,\n    waitForDurableNonceTransactionConfirmation,\n    waitForRecentTransactionConfirmation,\n} from '@solana/transaction-confirmation';\nimport {\n    FullySignedTransaction,\n    getBase64EncodedWireTransaction,\n    TransactionWithDurableNonceLifetime,\n} from '@solana/transactions';\n\ninterface SendAndConfirmDurableNonceTransactionConfig\n    extends SendTransactionBaseConfig,\n        SendTransactionConfigWithoutEncoding {\n    confirmDurableNonceTransaction: (\n        config: Omit<\n            Parameters<typeof waitForDurableNonceTransactionConfirmation>[0],\n            'getNonceInvalidationPromise' | 'getRecentSignatureConfirmationPromise'\n        >,\n    ) => Promise<void>;\n    transaction: FullySignedTransaction & TransactionWithDurableNonceLifetime;\n}\n\ninterface SendAndConfirmTransactionWithBlockhashLifetimeConfig\n    extends SendTransactionBaseConfig,\n        SendTransactionConfigWithoutEncoding {\n    confirmRecentTransaction: (\n        config: Omit<\n            Parameters<typeof waitForRecentTransactionConfirmation>[0],\n            'getBlockHeightExceedencePromise' | 'getRecentSignatureConfirmationPromise'\n        >,\n    ) => Promise<void>;\n    transaction: FullySignedTransaction & TransactionWithLastValidBlockHeight;\n}\n\ninterface SendTransactionBaseConfig extends SendTransactionConfigWithoutEncoding {\n    abortSignal?: AbortSignal;\n    commitment: Commitment;\n    rpc: Rpc<SendTransactionApi>;\n    transaction: FullySignedTransaction;\n}\n\ntype SendTransactionConfigWithoutEncoding = Omit<\n    NonNullable<Parameters<SendTransactionApi['sendTransaction']>[1]>,\n    'encoding'\n>;\n\nfunction getSendTransactionConfigWithAdjustedPreflightCommitment(\n    commitment: Commitment,\n    config?: SendTransactionConfigWithoutEncoding,\n): SendTransactionConfigWithoutEncoding | void {\n    if (\n        // The developer has supplied no value for `preflightCommitment`.\n        !config?.preflightCommitment &&\n        // The value of `commitment` is lower than the server default of `preflightCommitment`.\n        commitmentComparator(commitment, 'finalized' /* default value of `preflightCommitment` */) < 0\n    ) {\n        return {\n            ...config,\n            // In the common case, it is unlikely that you want to simulate a transaction at\n            // `finalized` commitment when your standard of commitment for confirming the\n            // transaction is lower. Cap the simulation commitment level to the level of the\n            // confirmation commitment.\n            preflightCommitment: commitment,\n        };\n    }\n    // The commitment at which the developer wishes to confirm the transaction is at least as\n    // high as the commitment at which they want to simulate it. Honour the config as-is.\n    return config;\n}\n\nexport async function sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    commitment,\n    rpc,\n    transaction,\n    ...sendTransactionConfig\n}: SendTransactionBaseConfig): Promise<Signature> {\n    const base64EncodedWireTransaction = getBase64EncodedWireTransaction(transaction);\n    return await rpc\n        .sendTransaction(base64EncodedWireTransaction, {\n            ...getSendTransactionConfigWithAdjustedPreflightCommitment(commitment, sendTransactionConfig),\n            encoding: 'base64',\n        })\n        .send({ abortSignal });\n}\n\nexport async function sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    commitment,\n    confirmDurableNonceTransaction,\n    rpc,\n    transaction,\n    ...sendTransactionConfig\n}: SendAndConfirmDurableNonceTransactionConfig): Promise<Signature> {\n    const transactionSignature = await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n        ...sendTransactionConfig,\n        abortSignal,\n        commitment,\n        rpc,\n        transaction,\n    });\n    await confirmDurableNonceTransaction({\n        abortSignal,\n        commitment,\n        transaction,\n    });\n    return transactionSignature;\n}\n\nexport async function sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    commitment,\n    confirmRecentTransaction,\n    rpc,\n    transaction,\n    ...sendTransactionConfig\n}: SendAndConfirmTransactionWithBlockhashLifetimeConfig): Promise<Signature> {\n    const transactionSignature = await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n        ...sendTransactionConfig,\n        abortSignal,\n        commitment,\n        rpc,\n        transaction,\n    });\n    await confirmRecentTransaction({\n        abortSignal,\n        commitment,\n        transaction,\n    });\n    return transactionSignature;\n}\n", "import type { GetAccountInfoApi, GetSignatureStatusesApi, Rpc, SendTransactionApi } from '@solana/rpc';\nimport type { AccountNotificationsApi, RpcSubscriptions, SignatureNotificationsApi } from '@solana/rpc-subscriptions';\nimport {\n    createNonceInvalidationPromiseFactory,\n    createRecentSignatureConfirmationPromiseFactory,\n    waitForDurableNonceTransactionConfirmation,\n} from '@solana/transaction-confirmation';\nimport { FullySignedTransaction, TransactionWithDurableNonceLifetime } from '@solana/transactions';\n\nimport { sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT } from './send-transaction-internal';\n\ntype SendAndConfirmDurableNonceTransactionFunction = (\n    transaction: FullySignedTransaction & TransactionWithDurableNonceLifetime,\n    config: Omit<\n        Parameters<typeof sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT>[0],\n        'confirmDurableNonceTransaction' | 'rpc' | 'transaction'\n    >,\n) => Promise<void>;\n\ntype SendAndConfirmDurableNonceTransactionFactoryConfig<TCluster> = {\n    /** An object that supports the {@link GetSignatureStatusesApi} and the {@link SendTransactionApi} of the Solana RPC API */\n    rpc: Rpc<GetAccountInfoApi & GetSignatureStatusesApi & SendTransactionApi> & { '~cluster'?: TCluster };\n    /** An object that supports the {@link AccountNotificationsApi} and the {@link SignatureNotificationsApi} of the Solana RPC Subscriptions API */\n    rpcSubscriptions: RpcSubscriptions<AccountNotificationsApi & SignatureNotificationsApi> & { '~cluster'?: TCluster };\n};\n\n/**\n * Returns a function that you can call to send a nonce-based transaction to the network and to wait\n * until it has been confirmed.\n *\n * @param config\n *\n * @example\n * ```ts\n * import {\n *     isSolanaError,\n *     sendAndConfirmDurableNonceTransactionFactory,\n *     SOLANA_ERROR__INVALID_NONCE,\n *     SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n * } from '@solana/kit';\n *\n * const sendAndConfirmNonceTransaction = sendAndConfirmDurableNonceTransactionFactory({ rpc, rpcSubscriptions });\n *\n * try {\n *     await sendAndConfirmNonceTransaction(transaction, { commitment: 'confirmed' });\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND)) {\n *         console.error(\n *             'The lifetime specified by this transaction refers to a nonce account ' +\n *                 `\\`${e.context.nonceAccountAddress}\\` that does not exist`,\n *         );\n *     } else if (isSolanaError(e, SOLANA_ERROR__INVALID_NONCE)) {\n *         console.error('This transaction depends on a nonce that is no longer valid');\n *     } else {\n *         throw e;\n *     }\n * }\n * ```\n */\nexport function sendAndConfirmDurableNonceTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmDurableNonceTransactionFactoryConfig<'devnet'>): SendAndConfirmDurableNonceTransactionFunction;\nexport function sendAndConfirmDurableNonceTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmDurableNonceTransactionFactoryConfig<'testnet'>): SendAndConfirmDurableNonceTransactionFunction;\nexport function sendAndConfirmDurableNonceTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmDurableNonceTransactionFactoryConfig<'mainnet'>): SendAndConfirmDurableNonceTransactionFunction;\nexport function sendAndConfirmDurableNonceTransactionFactory<\n    TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void,\n>({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmDurableNonceTransactionFactoryConfig<TCluster>): SendAndConfirmDurableNonceTransactionFunction {\n    const getNonceInvalidationPromise = createNonceInvalidationPromiseFactory({ rpc, rpcSubscriptions } as Parameters<\n        typeof createNonceInvalidationPromiseFactory\n    >[0]);\n    const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({\n        rpc,\n        rpcSubscriptions,\n    } as Parameters<typeof createRecentSignatureConfirmationPromiseFactory>[0]);\n    async function confirmDurableNonceTransaction(\n        config: Omit<\n            Parameters<typeof waitForDurableNonceTransactionConfirmation>[0],\n            'getNonceInvalidationPromise' | 'getRecentSignatureConfirmationPromise'\n        >,\n    ) {\n        await waitForDurableNonceTransactionConfirmation({\n            ...config,\n            getNonceInvalidationPromise,\n            getRecentSignatureConfirmationPromise,\n        });\n    }\n    return async function sendAndConfirmDurableNonceTransaction(transaction, config) {\n        await sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            confirmDurableNonceTransaction,\n            rpc,\n            transaction,\n        });\n    };\n}\n", "import type { GetEpochInfoApi, GetSignatureStatusesApi, Rpc, SendTransactionApi } from '@solana/rpc';\nimport type { RpcSubscriptions, SignatureNotificationsApi, SlotNotificationsApi } from '@solana/rpc-subscriptions';\nimport {\n    createBlockHeightExceedencePromiseFactory,\n    createRecentSignatureConfirmationPromiseFactory,\n    TransactionWithLastValidBlockHeight,\n    waitForRecentTransactionConfirmation,\n} from '@solana/transaction-confirmation';\nimport { FullySignedTransaction } from '@solana/transactions';\n\nimport { sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT } from './send-transaction-internal';\n\ntype SendAndConfirmTransactionWithBlockhashLifetimeFunction = (\n    transaction: FullySignedTransaction & TransactionWithLastValidBlockHeight,\n    config: Omit<\n        Parameters<typeof sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT>[0],\n        'confirmRecentTransaction' | 'rpc' | 'transaction'\n    >,\n) => Promise<void>;\n\ntype SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig<TCluster> = {\n    /** An object that supports the {@link GetSignatureStatusesApi} and the {@link SendTransactionApi} of the Solana RPC API */\n    rpc: Rpc<GetEpochInfoApi & GetSignatureStatusesApi & SendTransactionApi> & { '~cluster'?: TCluster };\n    /** An object that supports the {@link SignatureNotificationsApi} and the {@link SlotNotificationsApi} of the Solana RPC Subscriptions API */\n    rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi & SlotNotificationsApi> & { '~cluster'?: TCluster };\n};\n\n/**\n * Returns a function that you can call to send a blockhash-based transaction to the network and to\n * wait until it has been confirmed.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { isSolanaError, sendAndConfirmTransactionFactory, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED } from '@solana/kit';\n *\n * const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });\n *\n * try {\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED)) {\n *         console.error('This transaction depends on a blockhash that has expired');\n *     } else {\n *         throw e;\n *     }\n * }\n * ```\n */\nexport function sendAndConfirmTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig<'devnet'>): SendAndConfirmTransactionWithBlockhashLifetimeFunction;\nexport function sendAndConfirmTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig<'testnet'>): SendAndConfirmTransactionWithBlockhashLifetimeFunction;\nexport function sendAndConfirmTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig<'mainnet'>): SendAndConfirmTransactionWithBlockhashLifetimeFunction;\nexport function sendAndConfirmTransactionFactory<TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void>({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig<TCluster>): SendAndConfirmTransactionWithBlockhashLifetimeFunction {\n    const getBlockHeightExceedencePromise = createBlockHeightExceedencePromiseFactory({\n        rpc,\n        rpcSubscriptions,\n    } as Parameters<typeof createBlockHeightExceedencePromiseFactory>[0]);\n    const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({\n        rpc,\n        rpcSubscriptions,\n    } as Parameters<typeof createRecentSignatureConfirmationPromiseFactory>[0]);\n    async function confirmRecentTransaction(\n        config: Omit<\n            Parameters<typeof waitForRecentTransactionConfirmation>[0],\n            'getBlockHeightExceedencePromise' | 'getRecentSignatureConfirmationPromise'\n        >,\n    ) {\n        await waitForRecentTransactionConfirmation({\n            ...config,\n            getBlockHeightExceedencePromise,\n            getRecentSignatureConfirmationPromise,\n        });\n    }\n    return async function sendAndConfirmTransaction(transaction, config) {\n        await sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            confirmRecentTransaction,\n            rpc,\n            transaction,\n        });\n    };\n}\n", "import type { Rpc, SendTransactionApi } from '@solana/rpc';\nimport { FullySignedTransaction } from '@solana/transactions';\n\nimport { sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT } from './send-transaction-internal';\n\ntype SendTransactionWithoutConfirmingFunction = (\n    transaction: FullySignedTransaction,\n    config: Omit<Parameters<typeof sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT>[0], 'rpc' | 'transaction'>,\n) => Promise<void>;\n\ninterface SendTransactionWithoutConfirmingFactoryConfig {\n    /** An object that supports the {@link SendTransactionApi} of the Solana RPC API */\n    rpc: Rpc<SendTransactionApi>;\n}\n\n/**\n * Returns a function that you can call to send a transaction with any kind of lifetime to the\n * network without waiting for it to be confirmed.\n *\n * @param config\n *\n * @example\n * ```ts\n * import {\n *     sendTransactionWithoutConfirmingFactory,\n *     SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n * } from '@solana/kit';\n *\n * const sendTransaction = sendTransactionWithoutConfirmingFactory({ rpc });\n *\n * try {\n *     await sendTransaction(transaction, { commitment: 'confirmed' });\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE)) {\n *         console.error('The transaction failed in simulation', e.cause);\n *     } else {\n *         throw e;\n *     }\n * }\n * ```\n */\nexport function sendTransactionWithoutConfirmingFactory({\n    rpc,\n}: SendTransactionWithoutConfirmingFactoryConfig): SendTransactionWithoutConfirmingFunction {\n    return async function sendTransactionWithoutConfirming(transaction, config) {\n        await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            rpc,\n            transaction,\n        });\n    };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU8Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedRequestHeapFrameInstruction,\n  type ParsedRequestUnitsInstruction,\n  type ParsedSetComputeUnitLimitInstruction,\n  type ParsedSetComputeUnitPriceInstruction,\n  type ParsedSetLoadedAccountsDataSizeLimitInstruction,\n} from '../instructions';\n\nexport const COMPUTE_BUDGET_PROGRAM_ADDRESS =\n  'ComputeBudget111111111111111111111111111111' as Address<'ComputeBudget111111111111111111111111111111'>;\n\nexport enum ComputeBudgetInstruction {\n  RequestUnits,\n  RequestHeapFrame,\n  SetComputeUnitLimit,\n  SetComputeUnitPrice,\n  SetLoadedAccountsDataSizeLimit,\n}\n\nexport function identifyComputeBudgetInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): ComputeBudgetInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return ComputeBudgetInstruction.RequestUnits;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return ComputeBudgetInstruction.RequestHeapFrame;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return ComputeBudgetInstruction.SetComputeUnitLimit;\n  }\n  if (containsBytes(data, getU8Encoder().encode(3), 0)) {\n    return ComputeBudgetInstruction.SetComputeUnitPrice;\n  }\n  if (containsBytes(data, getU8Encoder().encode(4), 0)) {\n    return ComputeBudgetInstruction.SetLoadedAccountsDataSizeLimit;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a computeBudget instruction.'\n  );\n}\n\nexport type ParsedComputeBudgetInstruction<\n  TProgram extends string = 'ComputeBudget111111111111111111111111111111',\n> =\n  | ({\n      instructionType: ComputeBudgetInstruction.RequestUnits;\n    } & ParsedRequestUnitsInstruction<TProgram>)\n  | ({\n      instructionType: ComputeBudgetInstruction.RequestHeapFrame;\n    } & ParsedRequestHeapFrameInstruction<TProgram>)\n  | ({\n      instructionType: ComputeBudgetInstruction.SetComputeUnitLimit;\n    } & ParsedSetComputeUnitLimitInstruction<TProgram>)\n  | ({\n      instructionType: ComputeBudgetInstruction.SetComputeUnitPrice;\n    } & ParsedSetComputeUnitPriceInstruction<TProgram>)\n  | ({\n      instructionType: ComputeBudgetInstruction.SetLoadedAccountsDataSizeLimit;\n    } & ParsedSetLoadedAccountsDataSizeLimitInstruction<TProgram>);\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n} from '@solana/kit';\nimport { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '../programs';\n\nexport const REQUEST_HEAP_FRAME_DISCRIMINATOR = 1;\n\nexport function getRequestHeapFrameDiscriminatorBytes() {\n  return getU8Encoder().encode(REQUEST_HEAP_FRAME_DISCRIMINATOR);\n}\n\nexport type RequestHeapFrameInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<TRemainingAccounts>;\n\nexport type RequestHeapFrameInstructionData = {\n  discriminator: number;\n  /**\n   * Requested transaction-wide program heap size in bytes.\n   * Must be multiple of 1024. Applies to each program, including CPIs.\n   */\n  bytes: number;\n};\n\nexport type RequestHeapFrameInstructionDataArgs = {\n  /**\n   * Requested transaction-wide program heap size in bytes.\n   * Must be multiple of 1024. Applies to each program, including CPIs.\n   */\n  bytes: number;\n};\n\nexport function getRequestHeapFrameInstructionDataEncoder(): Encoder<RequestHeapFrameInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['bytes', getU32Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: REQUEST_HEAP_FRAME_DISCRIMINATOR })\n  );\n}\n\nexport function getRequestHeapFrameInstructionDataDecoder(): Decoder<RequestHeapFrameInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['bytes', getU32Decoder()],\n  ]);\n}\n\nexport function getRequestHeapFrameInstructionDataCodec(): Codec<\n  RequestHeapFrameInstructionDataArgs,\n  RequestHeapFrameInstructionData\n> {\n  return combineCodec(\n    getRequestHeapFrameInstructionDataEncoder(),\n    getRequestHeapFrameInstructionDataDecoder()\n  );\n}\n\nexport type RequestHeapFrameInput = {\n  bytes: RequestHeapFrameInstructionDataArgs['bytes'];\n};\n\nexport function getRequestHeapFrameInstruction<\n  TProgramAddress extends Address = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n>(\n  input: RequestHeapFrameInput,\n  config?: { programAddress?: TProgramAddress }\n): RequestHeapFrameInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\n  // Original args.\n  const args = { ...input };\n\n  const instruction = {\n    programAddress,\n    data: getRequestHeapFrameInstructionDataEncoder().encode(\n      args as RequestHeapFrameInstructionDataArgs\n    ),\n  } as RequestHeapFrameInstruction<TProgramAddress>;\n\n  return instruction;\n}\n\nexport type ParsedRequestHeapFrameInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n> = {\n  programAddress: Address<TProgram>;\n  data: RequestHeapFrameInstructionData;\n};\n\nexport function parseRequestHeapFrameInstruction<TProgram extends string>(\n  instruction: IInstruction<TProgram> & IInstructionWithData<Uint8Array>\n): ParsedRequestHeapFrameInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getRequestHeapFrameInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n} from '@solana/kit';\nimport { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '../programs';\n\nexport const REQUEST_UNITS_DISCRIMINATOR = 0;\n\nexport function getRequestUnitsDiscriminatorBytes() {\n  return getU8Encoder().encode(REQUEST_UNITS_DISCRIMINATOR);\n}\n\nexport type RequestUnitsInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<TRemainingAccounts>;\n\nexport type RequestUnitsInstructionData = {\n  discriminator: number;\n  /** Units to request for transaction-wide compute. */\n  units: number;\n  /** Prioritization fee lamports. */\n  additionalFee: number;\n};\n\nexport type RequestUnitsInstructionDataArgs = {\n  /** Units to request for transaction-wide compute. */\n  units: number;\n  /** Prioritization fee lamports. */\n  additionalFee: number;\n};\n\nexport function getRequestUnitsInstructionDataEncoder(): Encoder<RequestUnitsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['units', getU32Encoder()],\n      ['additionalFee', getU32Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: REQUEST_UNITS_DISCRIMINATOR })\n  );\n}\n\nexport function getRequestUnitsInstructionDataDecoder(): Decoder<RequestUnitsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['units', getU32Decoder()],\n    ['additionalFee', getU32Decoder()],\n  ]);\n}\n\nexport function getRequestUnitsInstructionDataCodec(): Codec<\n  RequestUnitsInstructionDataArgs,\n  RequestUnitsInstructionData\n> {\n  return combineCodec(\n    getRequestUnitsInstructionDataEncoder(),\n    getRequestUnitsInstructionDataDecoder()\n  );\n}\n\nexport type RequestUnitsInput = {\n  units: RequestUnitsInstructionDataArgs['units'];\n  additionalFee: RequestUnitsInstructionDataArgs['additionalFee'];\n};\n\nexport function getRequestUnitsInstruction<\n  TProgramAddress extends Address = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n>(\n  input: RequestUnitsInput,\n  config?: { programAddress?: TProgramAddress }\n): RequestUnitsInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\n  // Original args.\n  const args = { ...input };\n\n  const instruction = {\n    programAddress,\n    data: getRequestUnitsInstructionDataEncoder().encode(\n      args as RequestUnitsInstructionDataArgs\n    ),\n  } as RequestUnitsInstruction<TProgramAddress>;\n\n  return instruction;\n}\n\nexport type ParsedRequestUnitsInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n> = {\n  programAddress: Address<TProgram>;\n  data: RequestUnitsInstructionData;\n};\n\nexport function parseRequestUnitsInstruction<TProgram extends string>(\n  instruction: IInstruction<TProgram> & IInstructionWithData<Uint8Array>\n): ParsedRequestUnitsInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getRequestUnitsInstructionDataDecoder().decode(instruction.data),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n} from '@solana/kit';\nimport { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '../programs';\n\nexport const SET_COMPUTE_UNIT_LIMIT_DISCRIMINATOR = 2;\n\nexport function getSetComputeUnitLimitDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_COMPUTE_UNIT_LIMIT_DISCRIMINATOR);\n}\n\nexport type SetComputeUnitLimitInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<TRemainingAccounts>;\n\nexport type SetComputeUnitLimitInstructionData = {\n  discriminator: number;\n  /** Transaction-wide compute unit limit. */\n  units: number;\n};\n\nexport type SetComputeUnitLimitInstructionDataArgs = {\n  /** Transaction-wide compute unit limit. */\n  units: number;\n};\n\nexport function getSetComputeUnitLimitInstructionDataEncoder(): Encoder<SetComputeUnitLimitInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['units', getU32Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_COMPUTE_UNIT_LIMIT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetComputeUnitLimitInstructionDataDecoder(): Decoder<SetComputeUnitLimitInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['units', getU32Decoder()],\n  ]);\n}\n\nexport function getSetComputeUnitLimitInstructionDataCodec(): Codec<\n  SetComputeUnitLimitInstructionDataArgs,\n  SetComputeUnitLimitInstructionData\n> {\n  return combineCodec(\n    getSetComputeUnitLimitInstructionDataEncoder(),\n    getSetComputeUnitLimitInstructionDataDecoder()\n  );\n}\n\nexport type SetComputeUnitLimitInput = {\n  units: SetComputeUnitLimitInstructionDataArgs['units'];\n};\n\nexport function getSetComputeUnitLimitInstruction<\n  TProgramAddress extends Address = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n>(\n  input: SetComputeUnitLimitInput,\n  config?: { programAddress?: TProgramAddress }\n): SetComputeUnitLimitInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\n  // Original args.\n  const args = { ...input };\n\n  const instruction = {\n    programAddress,\n    data: getSetComputeUnitLimitInstructionDataEncoder().encode(\n      args as SetComputeUnitLimitInstructionDataArgs\n    ),\n  } as SetComputeUnitLimitInstruction<TProgramAddress>;\n\n  return instruction;\n}\n\nexport type ParsedSetComputeUnitLimitInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n> = {\n  programAddress: Address<TProgram>;\n  data: SetComputeUnitLimitInstructionData;\n};\n\nexport function parseSetComputeUnitLimitInstruction<TProgram extends string>(\n  instruction: IInstruction<TProgram> & IInstructionWithData<Uint8Array>\n): ParsedSetComputeUnitLimitInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getSetComputeUnitLimitInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n} from '@solana/kit';\nimport { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '../programs';\n\nexport const SET_COMPUTE_UNIT_PRICE_DISCRIMINATOR = 3;\n\nexport function getSetComputeUnitPriceDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_COMPUTE_UNIT_PRICE_DISCRIMINATOR);\n}\n\nexport type SetComputeUnitPriceInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<TRemainingAccounts>;\n\nexport type SetComputeUnitPriceInstructionData = {\n  discriminator: number;\n  /** Transaction compute unit price used for prioritization fees. */\n  microLamports: bigint;\n};\n\nexport type SetComputeUnitPriceInstructionDataArgs = {\n  /** Transaction compute unit price used for prioritization fees. */\n  microLamports: number | bigint;\n};\n\nexport function getSetComputeUnitPriceInstructionDataEncoder(): Encoder<SetComputeUnitPriceInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['microLamports', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_COMPUTE_UNIT_PRICE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetComputeUnitPriceInstructionDataDecoder(): Decoder<SetComputeUnitPriceInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['microLamports', getU64Decoder()],\n  ]);\n}\n\nexport function getSetComputeUnitPriceInstructionDataCodec(): Codec<\n  SetComputeUnitPriceInstructionDataArgs,\n  SetComputeUnitPriceInstructionData\n> {\n  return combineCodec(\n    getSetComputeUnitPriceInstructionDataEncoder(),\n    getSetComputeUnitPriceInstructionDataDecoder()\n  );\n}\n\nexport type SetComputeUnitPriceInput = {\n  microLamports: SetComputeUnitPriceInstructionDataArgs['microLamports'];\n};\n\nexport function getSetComputeUnitPriceInstruction<\n  TProgramAddress extends Address = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n>(\n  input: SetComputeUnitPriceInput,\n  config?: { programAddress?: TProgramAddress }\n): SetComputeUnitPriceInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\n  // Original args.\n  const args = { ...input };\n\n  const instruction = {\n    programAddress,\n    data: getSetComputeUnitPriceInstructionDataEncoder().encode(\n      args as SetComputeUnitPriceInstructionDataArgs\n    ),\n  } as SetComputeUnitPriceInstruction<TProgramAddress>;\n\n  return instruction;\n}\n\nexport type ParsedSetComputeUnitPriceInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n> = {\n  programAddress: Address<TProgram>;\n  data: SetComputeUnitPriceInstructionData;\n};\n\nexport function parseSetComputeUnitPriceInstruction<TProgram extends string>(\n  instruction: IInstruction<TProgram> & IInstructionWithData<Uint8Array>\n): ParsedSetComputeUnitPriceInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getSetComputeUnitPriceInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n} from '@solana/kit';\nimport { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '../programs';\n\nexport const SET_LOADED_ACCOUNTS_DATA_SIZE_LIMIT_DISCRIMINATOR = 4;\n\nexport function getSetLoadedAccountsDataSizeLimitDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    SET_LOADED_ACCOUNTS_DATA_SIZE_LIMIT_DISCRIMINATOR\n  );\n}\n\nexport type SetLoadedAccountsDataSizeLimitInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<TRemainingAccounts>;\n\nexport type SetLoadedAccountsDataSizeLimitInstructionData = {\n  discriminator: number;\n  accountDataSizeLimit: number;\n};\n\nexport type SetLoadedAccountsDataSizeLimitInstructionDataArgs = {\n  accountDataSizeLimit: number;\n};\n\nexport function getSetLoadedAccountsDataSizeLimitInstructionDataEncoder(): Encoder<SetLoadedAccountsDataSizeLimitInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['accountDataSizeLimit', getU32Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_LOADED_ACCOUNTS_DATA_SIZE_LIMIT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetLoadedAccountsDataSizeLimitInstructionDataDecoder(): Decoder<SetLoadedAccountsDataSizeLimitInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['accountDataSizeLimit', getU32Decoder()],\n  ]);\n}\n\nexport function getSetLoadedAccountsDataSizeLimitInstructionDataCodec(): Codec<\n  SetLoadedAccountsDataSizeLimitInstructionDataArgs,\n  SetLoadedAccountsDataSizeLimitInstructionData\n> {\n  return combineCodec(\n    getSetLoadedAccountsDataSizeLimitInstructionDataEncoder(),\n    getSetLoadedAccountsDataSizeLimitInstructionDataDecoder()\n  );\n}\n\nexport type SetLoadedAccountsDataSizeLimitInput = {\n  accountDataSizeLimit: SetLoadedAccountsDataSizeLimitInstructionDataArgs['accountDataSizeLimit'];\n};\n\nexport function getSetLoadedAccountsDataSizeLimitInstruction<\n  TProgramAddress extends Address = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n>(\n  input: SetLoadedAccountsDataSizeLimitInput,\n  config?: { programAddress?: TProgramAddress }\n): SetLoadedAccountsDataSizeLimitInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\n  // Original args.\n  const args = { ...input };\n\n  const instruction = {\n    programAddress,\n    data: getSetLoadedAccountsDataSizeLimitInstructionDataEncoder().encode(\n      args as SetLoadedAccountsDataSizeLimitInstructionDataArgs\n    ),\n  } as SetLoadedAccountsDataSizeLimitInstruction<TProgramAddress>;\n\n  return instruction;\n}\n\nexport type ParsedSetLoadedAccountsDataSizeLimitInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n> = {\n  programAddress: Address<TProgram>;\n  data: SetLoadedAccountsDataSizeLimitInstructionData;\n};\n\nexport function parseSetLoadedAccountsDataSizeLimitInstruction<\n  TProgram extends string,\n>(\n  instruction: IInstruction<TProgram> & IInstructionWithData<Uint8Array>\n): ParsedSetLoadedAccountsDataSizeLimitInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getSetLoadedAccountsDataSizeLimitInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n", "/**\n * A provisory compute unit limit is used to indicate that the transaction\n * should be estimated for compute units before being sent to the network.\n *\n * Setting it to zero ensures the transaction fails unless it is properly estimated.\n */\nexport const PROVISORY_COMPUTE_UNIT_LIMIT = 0;\n\n/**\n * The maximum compute unit limit that can be set for a transaction.\n */\nexport const MAX_COMPUTE_UNIT_LIMIT = 1_400_000;\n", "import {\n  BaseTransactionMessage,\n  getU32Decoder,\n  getU64Decoder,\n  IInstruction,\n  MicroLamports,\n  ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  ComputeBudgetInstruction,\n  identifyComputeBudgetInstruction,\n  SetComputeUnitLimitInstruction,\n  SetComputeUnitPriceInstruction,\n} from './generated';\n\n/**\n * Finds the index of the first `SetComputeUnitLimit` instruction in a transaction message\n * and its set limit, if any.\n */\nexport function getSetComputeUnitLimitInstructionIndexAndUnits(\n  transactionMessage: BaseTransactionMessage\n): { index: number; units: number } | null {\n  const index = getSetComputeUnitLimitInstructionIndex(transactionMessage);\n  if (index < 0) {\n    return null;\n  }\n\n  const units = getU32Decoder().decode(\n    transactionMessage.instructions[index].data as ReadonlyUint8Array,\n    1\n  );\n\n  return { index, units };\n}\n\n/**\n * Finds the index of the first `SetComputeUnitLimit` instruction in a transaction message, if any.\n */\nexport function getSetComputeUnitLimitInstructionIndex(\n  transactionMessage: BaseTransactionMessage\n) {\n  return transactionMessage.instructions.findIndex(\n    isSetComputeUnitLimitInstruction\n  );\n}\n\n/**\n * Checks if the given instruction is a `SetComputeUnitLimit` instruction.\n */\nexport function isSetComputeUnitLimitInstruction(\n  instruction: IInstruction\n): instruction is SetComputeUnitLimitInstruction {\n  return (\n    instruction.programAddress === COMPUTE_BUDGET_PROGRAM_ADDRESS &&\n    identifyComputeBudgetInstruction(instruction.data as Uint8Array) ===\n      ComputeBudgetInstruction.SetComputeUnitLimit\n  );\n}\n\n/**\n * Finds the index of the first `SetComputeUnitPrice` instruction in a transaction message\n * and its set micro-lamports, if any.\n */\nexport function getSetComputeUnitPriceInstructionIndexAndMicroLamports(\n  transactionMessage: BaseTransactionMessage\n): { index: number; microLamports: MicroLamports } | null {\n  const index = getSetComputeUnitPriceInstructionIndex(transactionMessage);\n  if (index < 0) {\n    return null;\n  }\n\n  const microLamports = getU64Decoder().decode(\n    transactionMessage.instructions[index].data as ReadonlyUint8Array,\n    1\n  ) as MicroLamports;\n\n  return { index, microLamports };\n}\n\n/**\n * Finds the index of the first `SetComputeUnitPrice` instruction in a transaction message, if any.\n */\nexport function getSetComputeUnitPriceInstructionIndex(\n  transactionMessage: BaseTransactionMessage\n) {\n  return transactionMessage.instructions.findIndex(\n    isSetComputeUnitPriceInstruction\n  );\n}\n\n/**\n * Checks if the given instruction is a `SetComputeUnitPrice` instruction.\n */\nexport function isSetComputeUnitPriceInstruction(\n  instruction: IInstruction\n): instruction is SetComputeUnitPriceInstruction {\n  return (\n    instruction.programAddress === COMPUTE_BUDGET_PROGRAM_ADDRESS &&\n    identifyComputeBudgetInstruction(instruction.data as Uint8Array) ===\n      ComputeBudgetInstruction.SetComputeUnitPrice\n  );\n}\n", "import {\n  appendTransactionMessageInstruction,\n  BaseTransactionMessage,\n} from '@solana/kit';\nimport { PROVISORY_COMPUTE_UNIT_LIMIT } from './constants';\nimport { getSetComputeUnitLimitInstruction } from './generated';\nimport { getSetComputeUnitLimitInstructionIndexAndUnits } from './internal';\n\n/**\n * Appends a `SetComputeUnitLimit` instruction with a provisory\n * compute unit limit to a given transaction message\n * if and only if it does not already have one.\n *\n * @example\n * ```ts\n * const transactionMessage = pipe(\n *   createTransactionMessage({ version: 0 }),\n *   fillProvisorySetComputeUnitLimitInstruction,\n *   // ...\n * );\n * ```\n */\nexport function fillProvisorySetComputeUnitLimitInstruction<\n  TTransactionMessage extends BaseTransactionMessage,\n>(transactionMessage: TTransactionMessage) {\n  return updateOrAppendSetComputeUnitLimitInstruction(\n    (previousUnits) =>\n      previousUnits === null ? PROVISORY_COMPUTE_UNIT_LIMIT : previousUnits,\n    transactionMessage\n  );\n}\n\n/**\n * Updates the first `SetComputeUnitLimit` instruction in a transaction message\n * with the given units, or appends a new instruction if none exists.\n * A function of the current value can be provided instead of a static value.\n *\n * @param units - The new compute unit limit, or a function that takes the previous\n *                compute unit limit and returns the new limit.\n * @param transactionMessage - The transaction message to update.\n *\n * @example\n * ```ts\n * const updatedTransactionMessage = updateOrAppendSetComputeUnitLimitInstruction(\n *   // E.g. Keep the current limit if it is set, otherwise set it to the maximum.\n *   (currentUnits) => currentUnits === null ? MAX_COMPUTE_UNIT_LIMIT : currentUnits,\n *   transactionMessage,\n * );\n * ```\n */\nexport function updateOrAppendSetComputeUnitLimitInstruction<\n  TTransactionMessage extends BaseTransactionMessage,\n>(\n  units: number | ((previousUnits: number | null) => number),\n  transactionMessage: TTransactionMessage\n): TTransactionMessage {\n  const getUnits = (previousUnits: number | null): number =>\n    typeof units === 'function' ? units(previousUnits) : units;\n  const instructionDetails =\n    getSetComputeUnitLimitInstructionIndexAndUnits(transactionMessage);\n\n  if (!instructionDetails) {\n    return appendTransactionMessageInstruction(\n      getSetComputeUnitLimitInstruction({ units: getUnits(null) }),\n      transactionMessage\n    );\n  }\n\n  const { index, units: previousUnits } = instructionDetails;\n  const newUnits = getUnits(previousUnits);\n  if (newUnits === previousUnits) {\n    return transactionMessage;\n  }\n\n  const newInstruction = getSetComputeUnitLimitInstruction({ units: newUnits });\n  const newInstructions = [...transactionMessage.instructions];\n  newInstructions.splice(index, 1, newInstruction);\n  return Object.freeze({\n    ...transactionMessage,\n    instructions: newInstructions,\n  });\n}\n", "import {\n  CompilableTransactionMessage,\n  ITransactionMessageWithFeePayer,\n  TransactionMessage,\n} from '@solana/kit';\nimport {\n  MAX_COMPUTE_UNIT_LIMIT,\n  PROVISORY_COMPUTE_UNIT_LIMIT,\n} from './constants';\nimport {\n  EstimateComputeUnitLimitFactoryFunction,\n  EstimateComputeUnitLimitFactoryFunctionConfig,\n} from './estimateComputeLimitInternal';\nimport { getSetComputeUnitLimitInstructionIndexAndUnits } from './internal';\nimport { updateOrAppendSetComputeUnitLimitInstruction } from './setComputeLimit';\n\ntype EstimateAndUpdateProvisoryComputeUnitLimitFactoryFunction = <\n  TTransactionMessage extends\n    | CompilableTransactionMessage\n    | (TransactionMessage & ITransactionMessageWithFeePayer),\n>(\n  transactionMessage: TTransactionMessage,\n  config?: EstimateComputeUnitLimitFactoryFunctionConfig\n) => Promise<TTransactionMessage>;\n\n/**\n * Given a transaction message, if it does not have an explicit compute unit limit,\n * estimates the compute unit limit and updates the transaction message with\n * the estimated limit. Otherwise, returns the transaction message unchanged.\n *\n * It requires a function that estimates the compute unit limit.\n *\n * @example\n * ```ts\n * const estimateAndUpdateCUs = estimateAndUpdateProvisoryComputeUnitLimitFactory(\n *     estimateComputeUnitLimitFactory({ rpc })\n * );\n *\n * const transactionMessageWithCUs = await estimateAndUpdateCUs(transactionMessage);\n * ```\n *\n * @see {@link estimateAndUpdateProvisoryComputeUnitLimitFactory}\n */\nexport function estimateAndUpdateProvisoryComputeUnitLimitFactory(\n  estimateComputeUnitLimit: EstimateComputeUnitLimitFactoryFunction\n): EstimateAndUpdateProvisoryComputeUnitLimitFactoryFunction {\n  return async function fn(transactionMessage, config) {\n    const instructionDetails =\n      getSetComputeUnitLimitInstructionIndexAndUnits(transactionMessage);\n\n    // If the transaction message already has a compute unit limit instruction\n    // which is set to a specific value — i.e. not 0 or the maximum limit —\n    // we don't need to estimate the compute unit limit.\n    if (\n      instructionDetails &&\n      instructionDetails.units !== PROVISORY_COMPUTE_UNIT_LIMIT &&\n      instructionDetails.units !== MAX_COMPUTE_UNIT_LIMIT\n    ) {\n      return transactionMessage;\n    }\n\n    return updateOrAppendSetComputeUnitLimitInstruction(\n      await estimateComputeUnitLimit(transactionMessage, config),\n      transactionMessage\n    );\n  };\n}\n", "// TODO: Add these helpers to @solana/kit in v3.\n\nimport {\n  BaseTransactionMessage,\n  Blockhash,\n  setTransactionMessageLifetimeUsingBlockhash,\n  TransactionMessageWithBlockhashLifetime,\n  TransactionMessageWithDurableNonceLifetime,\n} from '@solana/kit';\n\n/**\n * An invalid blockhash lifetime constraint used as a placeholder for\n * transaction messages that are not yet ready to be compiled.\n *\n * This enables various operations on the transaction message, such as\n * simulating it or calculating its transaction size, whilst defering\n * the actual blockhash to a later stage.\n */\nexport const PROVISORY_BLOCKHASH_LIFETIME_CONSTRAINT: TransactionMessageWithBlockhashLifetime['lifetimeConstraint'] =\n  {\n    blockhash: '11111111111111111111111111111111' as Blockhash,\n    lastValidBlockHeight: 0n, // This is not included in compiled transactions; it can be anything.\n  };\n\n/**\n * Sets a provisory blockhash lifetime constraint on the transaction message\n * if and only if it doesn't already have a lifetime constraint.\n */\nexport function fillMissingTransactionMessageLifetimeUsingProvisoryBlockhash<\n  TTransactionMessage extends BaseTransactionMessage,\n>(\n  transactionMessage: TTransactionMessage\n): TTransactionMessage &\n  (\n    | TransactionMessageWithBlockhashLifetime\n    | TransactionMessageWithDurableNonceLifetime\n  ) {\n  type ReturnType = TTransactionMessage &\n    (\n      | TransactionMessageWithBlockhashLifetime\n      | TransactionMessageWithDurableNonceLifetime\n    );\n\n  if ('lifetimeConstraint' in transactionMessage) {\n    return transactionMessage as ReturnType;\n  }\n\n  return setTransactionMessageLifetimeUsingProvisoryBlockhash(\n    transactionMessage\n  );\n}\n\n/**\n * Sets a provisory blockhash lifetime constraint on the transaction message.\n */\nexport function setTransactionMessageLifetimeUsingProvisoryBlockhash<\n  TTransactionMessage extends BaseTransactionMessage,\n>(\n  transactionMessage: TTransactionMessage\n): TTransactionMessage & TransactionMessageWithBlockhashLifetime {\n  return setTransactionMessageLifetimeUsingBlockhash(\n    PROVISORY_BLOCKHASH_LIFETIME_CONSTRAINT,\n    transactionMessage\n  );\n}\n", "import {\n  Commitment,\n  CompilableTransactionMessage,\n  compileTransaction,\n  getBase64EncodedWireTransaction,\n  isDurableNonceTransaction,\n  isSolanaError,\n  ITransactionMessageWithFeePayer,\n  pipe,\n  Rpc,\n  SimulateTransactionApi,\n  Slot,\n  SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT,\n  SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n  SolanaError,\n  Transaction,\n  TransactionMessage,\n} from '@solana/kit';\nimport { updateOrAppendSetComputeUnitLimitInstruction } from './setComputeLimit';\nimport { MAX_COMPUTE_UNIT_LIMIT } from './constants';\nimport { fillMissingTransactionMessageLifetimeUsingProvisoryBlockhash } from './internalMoveToKit';\n\nexport type EstimateComputeUnitLimitFactoryConfig = Readonly<{\n  /** An object that supports the {@link SimulateTransactionApi} of the Solana RPC API */\n  rpc: Rpc<SimulateTransactionApi>;\n}>;\n\nexport type EstimateComputeUnitLimitFactoryFunction = (\n  transactionMessage:\n    | CompilableTransactionMessage\n    | (TransactionMessage & ITransactionMessageWithFeePayer),\n  config?: EstimateComputeUnitLimitFactoryFunctionConfig\n) => Promise<number>;\n\nexport type EstimateComputeUnitLimitFactoryFunctionConfig = {\n  abortSignal?: AbortSignal;\n  /**\n   * Compute the estimate as of the highest slot that has reached this level of commitment.\n   *\n   * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n   * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n   * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n   * default commitment applied by the server is `\"finalized\"`.\n   */\n  commitment?: Commitment;\n  /**\n   * Prevents accessing stale data by enforcing that the RPC node has processed transactions up to\n   * this slot\n   */\n  minContextSlot?: Slot;\n};\n\ntype EstimateComputeUnitLimitConfig =\n  EstimateComputeUnitLimitFactoryFunctionConfig &\n    Readonly<{\n      rpc: Rpc<SimulateTransactionApi>;\n      transactionMessage:\n        | CompilableTransactionMessage\n        | (TransactionMessage & ITransactionMessageWithFeePayer);\n    }>;\n\n/**\n * Simulates a transaction message on the network and returns the number of compute units it\n * consumed during simulation.\n *\n * The estimate this function returns can be used to set a compute unit limit on the transaction.\n * Correctly budgeting a compute unit limit for your transaction message can increase the probability\n * that your transaction will be accepted for processing.\n *\n * If you don't declare a compute unit limit on your transaction, validators will assume an upper\n * limit of 200K compute units (CU) per instruction. Since validators have an incentive to pack as\n * many transactions into each block as possible, they may choose to include transactions that they\n * know will fit into the remaining compute budget for the current block over transactions that\n * might not. For this reason, you should set a compute unit limit on each of your transaction\n * messages, whenever possible.\n *\n * ## Example\n *\n * ```ts\n * import { getSetComputeLimitInstruction } from '@solana-program/compute-budget';\n * import { createSolanaRpc, getComputeUnitEstimateForTransactionMessageFactory, pipe } from '@solana/kit';\n *\n * // Create an estimator function.\n * const rpc = createSolanaRpc('http://127.0.0.1:8899');\n * const getComputeUnitEstimateForTransactionMessage =\n *     getComputeUnitEstimateForTransactionMessageFactory({ rpc });\n *\n * // Create your transaction message.\n * const transactionMessage = pipe(\n *     createTransactionMessage({ version: 'legacy' }),\n *     /* ... *\\/\n * );\n *\n * // Request an estimate of the actual compute units this message will consume.\n * const computeUnitsEstimate =\n *     await getComputeUnitEstimateForTransactionMessage(transactionMessage);\n *\n * // Set the transaction message's compute unit budget.\n * const transactionMessageWithComputeUnitLimit = prependTransactionMessageInstruction(\n *     getSetComputeLimitInstruction({ units: computeUnitsEstimate }),\n *     transactionMessage,\n * );\n * ```\n *\n * > [!WARNING]\n * > The compute unit estimate is just that &ndash; an estimate. The compute unit consumption of the\n * > actual transaction might be higher or lower than what was observed in simulation. Unless you\n * > are confident that your particular transaction message will consume the same or fewer compute\n * > units as was estimated, you might like to augment the estimate by either a fixed number of CUs\n * > or a multiplier.\n *\n * > [!NOTE]\n * > If you are preparing an _unsigned_ transaction, destined to be signed and submitted to the\n * > network by a wallet, you might like to leave it up to the wallet to determine the compute unit\n * > limit. Consider that the wallet might have a more global view of how many compute units certain\n * > types of transactions consume, and might be able to make better estimates of an appropriate\n * > compute unit budget.\n */\nexport async function estimateComputeUnitLimit({\n  transactionMessage,\n  ...configs\n}: EstimateComputeUnitLimitConfig): Promise<number> {\n  const replaceRecentBlockhash = !isDurableNonceTransaction(transactionMessage);\n  const transaction = pipe(\n    transactionMessage,\n    fillMissingTransactionMessageLifetimeUsingProvisoryBlockhash,\n    (m) =>\n      updateOrAppendSetComputeUnitLimitInstruction(MAX_COMPUTE_UNIT_LIMIT, m),\n    compileTransaction\n  );\n\n  return await simulateTransactionAndGetConsumedUnits({\n    transaction,\n    replaceRecentBlockhash,\n    ...configs,\n  });\n}\n\ntype SimulateTransactionAndGetConsumedUnitsConfig = Omit<\n  EstimateComputeUnitLimitConfig,\n  'transactionMessage'\n> &\n  Readonly<{ replaceRecentBlockhash?: boolean; transaction: Transaction }>;\n\nasync function simulateTransactionAndGetConsumedUnits({\n  abortSignal,\n  rpc,\n  transaction,\n  ...simulateConfig\n}: SimulateTransactionAndGetConsumedUnitsConfig): Promise<number> {\n  const wireTransactionBytes = getBase64EncodedWireTransaction(transaction);\n\n  try {\n    const {\n      value: { err: transactionError, unitsConsumed },\n    } = await rpc\n      .simulateTransaction(wireTransactionBytes, {\n        ...simulateConfig,\n        encoding: 'base64',\n        sigVerify: false,\n      })\n      .send({ abortSignal });\n    if (unitsConsumed == null) {\n      // This should never be hit, because all RPCs should support `unitsConsumed` by now.\n      throw new SolanaError(\n        SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT\n      );\n    }\n    // FIXME(https://github.com/anza-xyz/agave/issues/1295): The simulation response returns\n    // compute units as a u64, but the `SetComputeLimit` instruction only accepts a u32. Until\n    // this changes, downcast it.\n    const downcastUnitsConsumed =\n      unitsConsumed > 4_294_967_295n ? 4_294_967_295 : Number(unitsConsumed);\n    if (transactionError) {\n      throw new SolanaError(\n        SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n        {\n          cause: transactionError,\n          unitsConsumed: downcastUnitsConsumed,\n        }\n      );\n    }\n    return downcastUnitsConsumed;\n  } catch (e) {\n    if (\n      isSolanaError(\n        e,\n        SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT\n      )\n    )\n      throw e;\n    throw new SolanaError(\n      SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT,\n      { cause: e }\n    );\n  }\n}\n", "import {\n  estimateComputeUnitLimit,\n  EstimateComputeUnitLimitFactoryConfig,\n  EstimateComputeUnitLimitFactoryFunction,\n} from './estimateComputeLimitInternal';\n\n/**\n * Use this utility to estimate the actual compute unit cost of a given transaction message.\n *\n * Correctly budgeting a compute unit limit for your transaction message can increase the\n * probability that your transaction will be accepted for processing. If you don't declare a compute\n * unit limit on your transaction, validators will assume an upper limit of 200K compute units (CU)\n * per instruction.\n *\n * Since validators have an incentive to pack as many transactions into each block as possible, they\n * may choose to include transactions that they know will fit into the remaining compute budget for\n * the current block over transactions that might not. For this reason, you should set a compute\n * unit limit on each of your transaction messages, whenever possible.\n *\n * > [!WARNING]\n * > The compute unit estimate is just that -- an estimate. The compute unit consumption of the\n * > actual transaction might be higher or lower than what was observed in simulation. Unless you\n * > are confident that your particular transaction message will consume the same or fewer compute\n * > units as was estimated, you might like to augment the estimate by either a fixed number of CUs\n * > or a multiplier.\n *\n * > [!NOTE]\n * > If you are preparing an _unsigned_ transaction, destined to be signed and submitted to the\n * > network by a wallet, you might like to leave it up to the wallet to determine the compute unit\n * > limit. Consider that the wallet might have a more global view of how many compute units certain\n * > types of transactions consume, and might be able to make better estimates of an appropriate\n * > compute unit budget.\n *\n * > [!INFO]\n * > In the event that a transaction message does not already have a `SetComputeUnitLimit`\n * > instruction, this function will add one before simulation. This ensures that the compute unit\n * > consumption of the `SetComputeUnitLimit` instruction itself is included in the estimate.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { getSetComputeUnitLimitInstruction } from '@solana-program/compute-budget';\n * import { createSolanaRpc, estimateComputeUnitLimitFactory, pipe } from '@solana/kit';\n *\n * // Create an estimator function.\n * const rpc = createSolanaRpc('http://127.0.0.1:8899');\n * const estimateComputeUnitLimit = estimateComputeUnitLimitFactory({ rpc });\n *\n * // Create your transaction message.\n * const transactionMessage = pipe(\n *     createTransactionMessage({ version: 'legacy' }),\n *     /* ... *\\/\n * );\n *\n * // Request an estimate of the actual compute units this message will consume. This is done by\n * // simulating the transaction and grabbing the estimated compute units from the result.\n * const estimatedUnits = await estimateComputeUnitLimit(transactionMessage);\n *\n * // Set the transaction message's compute unit budget.\n * const transactionMessageWithComputeUnitLimit = prependTransactionMessageInstruction(\n *     getSetComputeUnitLimitInstruction({ units: estimatedUnits }),\n *     transactionMessage,\n * );\n * ```\n */\nexport function estimateComputeUnitLimitFactory({\n  rpc,\n}: EstimateComputeUnitLimitFactoryConfig): EstimateComputeUnitLimitFactoryFunction {\n  return async function estimateComputeUnitLimitFactoryFunction(\n    transactionMessage,\n    config\n  ) {\n    return await estimateComputeUnitLimit({\n      ...config,\n      rpc,\n      transactionMessage,\n    });\n  };\n}\n", "import {\n  appendTransactionMessageInstruction,\n  BaseTransactionMessage,\n  MicroLamports,\n} from '@solana/kit';\nimport { getSetComputeUnitPriceInstruction } from './generated';\nimport { getSetComputeUnitPriceInstructionIndexAndMicroLamports } from './internal';\n\n/**\n * Sets the compute unit price of a transaction message in micro-Lamports.\n *\n * @example\n * ```ts\n * const transactionMessage = pipe(\n *   createTransactionMessage({ version: 0 }),\n *   (m) => setTransactionMessageComputeUnitPrice(10_000, m),\n *   // ...\n * );\n * ```\n */\nexport function setTransactionMessageComputeUnitPrice<\n  TTransactionMessage extends BaseTransactionMessage,\n>(microLamports: number | bigint, transactionMessage: TTransactionMessage) {\n  return appendTransactionMessageInstruction(\n    getSetComputeUnitPriceInstruction({ microLamports }),\n    transactionMessage\n  );\n}\n\n/**\n * Updates the first `SetComputeUnitPrice` instruction in a transaction message\n * with the given micro-Lamports, or appends a new instruction if none exists.\n * A function of the current value can be provided instead of a static value.\n *\n * @param microLamports - The new compute unit price, or a function that\n *                        takes the previous price and returns the new one.\n * @param transactionMessage - The transaction message to update.\n *\n * @example\n * ```ts\n * const updatedTransactionMessage = updateOrAppendSetComputeUnitPriceInstruction(\n *   // E.g. double the current price or set it to 10_000 if it isn't set.\n *   (currentPrice) => currentPrice === null ? 10_000 : currentPrice * 2,\n *   transactionMessage,\n * );\n * ```\n */\nexport function updateOrAppendSetComputeUnitPriceInstruction<\n  TTransactionMessage extends BaseTransactionMessage,\n>(\n  microLamports:\n    | MicroLamports\n    | ((previousMicroLamports: MicroLamports | null) => MicroLamports),\n  transactionMessage: TTransactionMessage\n): TTransactionMessage {\n  const getMicroLamports = (\n    previousMicroLamports: MicroLamports | null\n  ): MicroLamports =>\n    typeof microLamports === 'function'\n      ? microLamports(previousMicroLamports)\n      : microLamports;\n  const instructionDetails =\n    getSetComputeUnitPriceInstructionIndexAndMicroLamports(transactionMessage);\n\n  if (!instructionDetails) {\n    return appendTransactionMessageInstruction(\n      getSetComputeUnitPriceInstruction({\n        microLamports: getMicroLamports(null),\n      }),\n      transactionMessage\n    );\n  }\n\n  const { index, microLamports: previousMicroLamports } = instructionDetails;\n  const newMicroLamports = getMicroLamports(previousMicroLamports);\n  if (newMicroLamports === previousMicroLamports) {\n    return transactionMessage;\n  }\n\n  const newInstruction = getSetComputeUnitPriceInstruction({\n    microLamports: newMicroLamports,\n  });\n  const newInstructions = [...transactionMessage.instructions];\n  newInstructions.splice(index, 1, newInstruction);\n  return Object.freeze({\n    ...transactionMessage,\n    instructions: newInstructions,\n  });\n}\n", "/**\n *\n */\n\ntype LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\n\nconst GILL_LOG_LEVELS: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\ndeclare global {\n  /**\n   * Whether or not to enable debug mode. When enabled, default log level of `info`\n   */\n  var __GILL_DEBUG__: boolean | undefined;\n  /**\n   * Set the a desired level of logs to be output in the application\n   *\n   * - Default: `info`\n   * - Options: `debug` | `info` | `warn` | `error`\n   */\n  var __GILL_DEBUG_LEVEL__: LogLevel | undefined;\n}\n\nconst getMinLogLevel = (): LogLevel =>\n  (process.env.GILL_DEBUG_LEVEL as LogLevel) ||\n  global.__GILL_DEBUG_LEVEL__ ||\n  (typeof window !== \"undefined\" && (window as any).__GILL_DEBUG_LEVEL__) ||\n  \"info\";\n\n/**\n * Check if the `gill` debug logger is enabled or not\n */\nexport const isDebugEnabled = (): boolean =>\n  Boolean(\n    process.env.GILL_DEBUG_LEVEL ||\n      global.__GILL_DEBUG_LEVEL__ ||\n      process.env.GILL_DEBUG === \"true\" ||\n      process.env.GILL_DEBUG === \"1\" ||\n      global.__GILL_DEBUG__ === true ||\n      (typeof window !== \"undefined\" && (window as any).__GILL_DEBUG__ === true),\n  );\n\n/**\n * Log debug messages based on the desired application's logging level.\n *\n * @param message - the message contents to be logged\n * @param level - default: `info` (see: {@link GILL_LOG_LEVELS})\n * @param prefix - default: `[GILL]`\n *\n * To enable gill's debug logger, set any of the following to `true`:\n * - `process.env.GILL_DEBUG`\n * - `global.__GILL_DEBUG__`\n * - `window.__GILL_DEBUG__`\n *\n * To set a desired level of logs to be output in the application, set the value of one of the following:\n * - `process.env.GILL_DEBUG_LEVEL`\n * - `global.__GILL_DEBUG_LEVEL__`\n * - `window.__GILL_DEBUG_LEVEL__`\n */\nexport function debug(message: unknown, level: LogLevel = \"info\", prefix: string = \"[GILL]\") {\n  if (!isDebugEnabled()) return;\n\n  if (GILL_LOG_LEVELS[level] < GILL_LOG_LEVELS[getMinLogLevel()]) return;\n\n  const formattedMessage = typeof message === \"string\" ? message : JSON.stringify(message, null, 2);\n\n  switch (level) {\n    case \"debug\":\n      console.log(prefix, formattedMessage);\n      break;\n    case \"info\":\n      console.info(prefix, formattedMessage);\n      break;\n    case \"warn\":\n      console.warn(prefix, formattedMessage);\n      break;\n    case \"error\":\n      console.error(prefix, formattedMessage);\n      break;\n  }\n}\n", "/** 1 billion lamports per SOL */\nexport const LAMPORTS_PER_SOL = 1_000_000_000;\n\n/**\n * Genesis hash for Solana network clusters\n */\nexport const GENESIS_HASH = {\n  mainnet: \"5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d\",\n  devnet: \"EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG\",\n  testnet: \"4uhcVJyU9pJkvQyS88uRDiswHXSCkY3zQawwpjk2NsNY\",\n};\n", "import {\n  assertIsTransactionSigner,\n  createNoopSigner,\n  isTransactionSigner,\n  type Address,\n  type TransactionSigner,\n} from \"@solana/kit\";\nimport type { SolanaClusterMoniker } from \"../types\";\nimport { GENESIS_HASH } from \"./const\";\n\n/**\n * Determine the Solana moniker from its genesis hash\n *\n * If the hash is NOT known, returns `unknown`\n */\nexport function getMonikerFromGenesisHash(hash: string): SolanaClusterMoniker | \"unknown\" {\n  switch (hash) {\n    case GENESIS_HASH.mainnet:\n      return \"mainnet\";\n    case GENESIS_HASH.devnet:\n      return \"devnet\";\n    case GENESIS_HASH.testnet:\n      return \"testnet\";\n    default:\n      return \"unknown\";\n  }\n}\n\nexport function checkedAddress<TAddress extends string = string>(\n  input: Address<TAddress> | TransactionSigner<TAddress>,\n): Address<TAddress> {\n  return typeof input == \"string\" ? input : input.address;\n}\n\nexport function checkedTransactionSigner<TAddress extends string = string>(\n  input: Address<TAddress> | TransactionSigner<TAddress>,\n): TransactionSigner<TAddress> {\n  if (typeof input === \"string\" || \"address\" in input == false) input = createNoopSigner(input);\n  if (!isTransactionSigner(input)) throw new Error(\"A signer or address is required\");\n  assertIsTransactionSigner(input);\n  return input;\n}\n\n/**\n * Convert a lamport number to the human readable string of a SOL value\n */\nexport function lamportsToSol(lamports: bigint | number): string {\n  // @ts-expect-error This format is valid\n  return new Intl.NumberFormat(\"en-US\", { maximumFractionDigits: 9 }).format(`${lamports}E-9`);\n}\n", "import type { DevnetUrl, MainnetUrl, TestnetUrl } from \"@solana/kit\";\nimport type { LocalnetUrl, ModifiedClusterUrl, SolanaClusterMoniker } from \"../types/rpc\";\n\nexport function localnet(putativeString: string): LocalnetUrl {\n  return putativeString as LocalnetUrl;\n}\n\n/**\n * Get a public Solana RPC endpoint for a cluster based on its moniker\n *\n * Note: These RPC URLs are rate limited and not suitable for production applications.\n */\nexport function getPublicSolanaRpcUrl(\n  cluster: SolanaClusterMoniker | \"mainnet-beta\" | \"localhost\",\n): ModifiedClusterUrl {\n  switch (cluster) {\n    case \"devnet\":\n      return \"https://api.devnet.solana.com\" as DevnetUrl;\n    case \"testnet\":\n      return \"https://api.testnet.solana.com\" as TestnetUrl;\n    case \"mainnet-beta\":\n    case \"mainnet\":\n      return \"https://api.mainnet-beta.solana.com\" as MainnetUrl;\n    case \"localnet\":\n    case \"localhost\":\n      return \"http://127.0.0.1:8899\" as LocalnetUrl;\n    default:\n      throw new Error(\"Invalid cluster moniker\");\n  }\n}\n", "import type { GetExplorerLinkArgs } from \"../types\";\n\n/**\n * Craft a Solana Explorer link on any cluster\n */\nexport function getExplorerLink(props: GetExplorerLinkArgs = {}): string {\n  let url = new URL(\"https://explorer.solana.com\");\n\n  // default to mainnet / mainnet-beta\n  if (!props.cluster || props.cluster == \"mainnet\") props.cluster = \"mainnet-beta\";\n\n  if (\"address\" in props) {\n    url.pathname = `/address/${props.address}`;\n  } else if (\"transaction\" in props) {\n    url.pathname = `/tx/${props.transaction}`;\n  } else if (\"block\" in props) {\n    url.pathname = `/block/${props.block}`;\n  }\n\n  if (props.cluster !== \"mainnet-beta\") {\n    if (props.cluster === \"localnet\" || props.cluster === \"localhost\") {\n      // localnet technically isn't a cluster, so requires special handling\n      url.searchParams.set(\"cluster\", \"custom\");\n      url.searchParams.set(\"customUrl\", \"http://localhost:8899\");\n    } else {\n      url.searchParams.set(\"cluster\", props.cluster);\n    }\n  }\n\n  return url.toString();\n}\n", "import type { Simplify } from \"../types\";\n\nimport { getSetComputeUnitLimitInstruction, getSetComputeUnitPriceInstruction } from \"@solana-program/compute-budget\";\nimport type {\n  Address,\n  TransactionMessageWithBlockhashLifetime,\n  TransactionMessageWithFeePayer,\n  TransactionMessageWithFeePayerSigner,\n  TransactionSigner,\n  TransactionVersion,\n} from \"@solana/kit\";\nimport {\n  appendTransactionMessageInstruction,\n  appendTransactionMessageInstructions,\n  createTransactionMessage,\n  isTransactionSigner,\n  pipe,\n  setTransactionMessageFeePayer,\n  setTransactionMessageFeePayerSigner,\n  setTransactionMessageLifetimeUsingBlockhash,\n} from \"@solana/kit\";\n\nimport type { CreateTransactionInput, FullTransaction } from \"../types/transactions\";\n\n/**\n * Simple interface for creating a Solana transaction\n */\nexport function createTransaction<TVersion extends TransactionVersion, TFeePayer extends TransactionSigner>(\n  props: CreateTransactionInput<TVersion, TFeePayer>,\n): FullTransaction<TVersion, TransactionMessageWithFeePayerSigner>;\nexport function createTransaction<TVersion extends TransactionVersion, TFeePayer extends Address>(\n  props: CreateTransactionInput<TVersion, TFeePayer>,\n): FullTransaction<TVersion, TransactionMessageWithFeePayer>;\nexport function createTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends TransactionSigner,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  props: CreateTransactionInput<TVersion, TFeePayer, TLifetimeConstraint>,\n): Simplify<FullTransaction<TVersion, TransactionMessageWithFeePayerSigner, TransactionMessageWithBlockhashLifetime>>;\nexport function createTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends Address,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  props: CreateTransactionInput<TVersion, TFeePayer, TLifetimeConstraint>,\n): Simplify<FullTransaction<TVersion, TransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;\nexport function createTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends Address | TransactionSigner,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  props: CreateTransactionInput<TVersion, TFeePayer, TLifetimeConstraint>,\n): Simplify<FullTransaction<TVersion, TransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;\nexport function createTransaction<TVersion extends TransactionVersion, TFeePayer extends Address | TransactionSigner>({\n  version,\n  feePayer,\n  instructions,\n  latestBlockhash,\n  computeUnitLimit,\n  computeUnitPrice,\n}: CreateTransactionInput<TVersion, TFeePayer>): FullTransaction<\n  TVersion,\n  TransactionMessageWithFeePayer | TransactionMessageWithFeePayerSigner\n> {\n  return pipe(\n    createTransactionMessage({ version: version ?? (\"legacy\" as TVersion) }),\n    (tx) => {\n      const withLifetime = latestBlockhash ? setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx) : tx;\n      if (typeof feePayer !== \"string\" && \"address\" in feePayer && isTransactionSigner(feePayer)) {\n        return setTransactionMessageFeePayerSigner(feePayer, withLifetime);\n      } else return setTransactionMessageFeePayer(feePayer, withLifetime);\n    },\n    (tx) => {\n      const withComputeLimit =\n        typeof computeUnitLimit !== \"undefined\"\n          ? appendTransactionMessageInstruction(\n              getSetComputeUnitLimitInstruction({ units: Number(computeUnitLimit) }),\n              tx,\n            )\n          : tx;\n\n      const withComputePrice =\n        typeof computeUnitPrice !== \"undefined\"\n          ? appendTransactionMessageInstruction(\n              getSetComputeUnitPriceInstruction({ microLamports: Number(computeUnitPrice) }),\n              withComputeLimit,\n            )\n          : withComputeLimit;\n\n      return appendTransactionMessageInstructions(instructions, withComputePrice);\n    },\n  );\n}\n", "import type {\n  BaseTransactionMessage,\n  CompilableTransactionMessage,\n  FullySignedTransaction,\n  GetEpochInfoApi,\n  GetLatestBlockhashApi,\n  GetSignatureStatusesApi,\n  Rpc,\n  RpcSubscriptions,\n  SendTransactionApi,\n  Signature,\n  SignatureNotificationsApi,\n  SlotNotificationsApi,\n  TransactionMessageWithFeePayer,\n  TransactionWithBlockhashLifetime,\n} from \"@solana/kit\";\nimport {\n  assertIsTransactionMessageWithBlockhashLifetime,\n  Commitment,\n  getBase64EncodedWireTransaction,\n  getSignatureFromTransaction,\n  sendAndConfirmTransactionFactory,\n  setTransactionMessageLifetimeUsingBlockhash,\n  signTransactionMessageWithSigners,\n} from \"@solana/kit\";\nimport { type waitForRecentTransactionConfirmation } from \"@solana/transaction-confirmation\";\nimport { debug } from \"./debug\";\nimport { getExplorerLink } from \"./explorer\";\n\ninterface SendAndConfirmTransactionWithBlockhashLifetimeConfig extends SendTransactionConfigWithoutEncoding {\n  confirmRecentTransaction: (\n    config: Omit<\n      Parameters<typeof waitForRecentTransactionConfirmation>[0],\n      \"getBlockHeightExceedencePromise\" | \"getRecentSignatureConfirmationPromise\"\n    >,\n  ) => Promise<void>;\n  abortSignal?: AbortSignal;\n  commitment: Commitment;\n}\n\ntype SendTransactionConfigWithoutEncoding = Omit<\n  NonNullable<Parameters<SendTransactionApi[\"sendTransaction\"]>[1]>,\n  \"encoding\"\n>;\n\ntype SendableTransaction =\n  | CompilableTransactionMessage\n  | (FullySignedTransaction & TransactionWithBlockhashLifetime)\n  | (BaseTransactionMessage & TransactionMessageWithFeePayer);\n\nexport type SendAndConfirmTransactionWithSignersFunction = (\n  transaction: SendableTransaction,\n  config?: Omit<\n    SendAndConfirmTransactionWithBlockhashLifetimeConfig,\n    \"confirmRecentTransaction\" | \"rpc\" | \"transaction\"\n  >,\n) => Promise<Signature>;\n\ntype SendAndConfirmTransactionWithSignersFactoryConfig<TCluster> = {\n  rpc: Rpc<GetEpochInfoApi & GetSignatureStatusesApi & SendTransactionApi & GetLatestBlockhashApi> & {\n    \"~cluster\"?: TCluster;\n  };\n  rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi & SlotNotificationsApi> & {\n    \"~cluster\"?: TCluster;\n  };\n};\n\nexport function sendAndConfirmTransactionWithSignersFactory({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<\"devnet\">): SendAndConfirmTransactionWithSignersFunction;\nexport function sendAndConfirmTransactionWithSignersFactory({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<\"testnet\">): SendAndConfirmTransactionWithSignersFunction;\nexport function sendAndConfirmTransactionWithSignersFactory({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<\"mainnet\">): SendAndConfirmTransactionWithSignersFunction;\nexport function sendAndConfirmTransactionWithSignersFactory({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<\"localnet\">): SendAndConfirmTransactionWithSignersFunction;\nexport function sendAndConfirmTransactionWithSignersFactory<\n  TCluster extends \"devnet\" | \"mainnet\" | \"testnet\" | \"localnet\" | undefined = undefined,\n>({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<TCluster>): SendAndConfirmTransactionWithSignersFunction {\n  // @ts-ignore - TODO(FIXME)\n  const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });\n  return async function sendAndConfirmTransactionWithSigners(transaction, config = { commitment: \"confirmed\" }) {\n    if (\"messageBytes\" in transaction == false) {\n      if (\"lifetimeConstraint\" in transaction === false) {\n        const { value: latestBlockhash } = await rpc.getLatestBlockhash().send({ abortSignal: config.abortSignal });\n        transaction = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, transaction);\n        assertIsTransactionMessageWithBlockhashLifetime(transaction);\n      }\n      transaction = (await signTransactionMessageWithSigners(transaction)) as Readonly<\n        FullySignedTransaction & TransactionWithBlockhashLifetime\n      >;\n    }\n    debug(`Sending transaction: ${getExplorerLink({ transaction: getSignatureFromTransaction(transaction) })}`);\n    debug(`Transaction as base64: ${getBase64EncodedWireTransaction(transaction)}`, \"debug\");\n    await sendAndConfirmTransaction(transaction, config);\n    return getSignatureFromTransaction(transaction);\n  };\n}\n", "import { COMPUTE_BUDGET_PROGRAM_ADDRESS, ComputeBudgetInstruction } from \"@solana-program/compute-budget\";\nimport type { IInstruction, IInstructionWithData, TransactionMessage } from \"@solana/kit\";\nimport { isInstructionForProgram, isInstructionWithData } from \"@solana/kit\";\n\n/**\n * Check if a given instruction is a `SetComputeUnitLimit` instruction\n */\nexport function isSetComputeLimitInstruction(\n  instruction: IInstruction,\n): instruction is IInstruction<typeof COMPUTE_BUDGET_PROGRAM_ADDRESS> & IInstructionWithData<Uint8Array> {\n  return (\n    isInstructionForProgram(instruction, COMPUTE_BUDGET_PROGRAM_ADDRESS) &&\n    isInstructionWithData(instruction) &&\n    instruction.data[0] === ComputeBudgetInstruction.SetComputeUnitLimit\n  );\n}\n\n/**\n * Check if a given transaction contains a `SetComputeUnitLimit` instruction\n */\nexport function hasSetComputeLimitInstruction(tx: TransactionMessage): boolean {\n  return tx.instructions.filter(isSetComputeLimitInstruction).length == 1;\n}\n\n/**\n * Check if a given instruction is a `SetComputeUnitPrice` instruction\n */\nexport function isSetComputeUnitPriceInstruction(\n  instruction: IInstruction,\n): instruction is IInstruction<typeof COMPUTE_BUDGET_PROGRAM_ADDRESS> & IInstructionWithData<Uint8Array> {\n  return (\n    isInstructionForProgram(instruction, COMPUTE_BUDGET_PROGRAM_ADDRESS) &&\n    isInstructionWithData(instruction) &&\n    instruction.data[0] === ComputeBudgetInstruction.SetComputeUnitPrice\n  );\n}\n\n/**\n * Check if a given transaction contains a `SetComputeUnitPrice` instruction\n */\nexport function hasSetComputeUnitPriceInstruction(tx: TransactionMessage): boolean {\n  return tx.instructions.filter(isSetComputeUnitPriceInstruction).length == 1;\n}\n", "import type { Base64EncodedWireTransaction, CompilableTransactionMessage, Transaction } from \"@solana/kit\";\nimport {\n  compileTransaction,\n  getBase64EncodedWireTransaction,\n  partiallySignTransactionMessageWithSigners,\n  pipe,\n} from \"@solana/kit\";\n\n/**\n * Compile a transaction to a base64 string\n *\n * Note: This will NOT attempt to sign the transaction,\n * so it will be missing `signatures` from any of the attached Signers\n *\n * Use {@link transactionToBase64WithSignatures} sign and base64 encode\n */\nexport function transactionToBase64(tx: CompilableTransactionMessage | Transaction): Base64EncodedWireTransaction {\n  if (\"messageBytes\" in tx) return pipe(tx, getBase64EncodedWireTransaction);\n  else return pipe(tx, compileTransaction, getBase64EncodedWireTransaction);\n}\n\n/**\n * Compile a transaction to a base64 string and sign it with all attached Signers\n *\n * See also {@link partiallySignTransactionMessageWithSigners}\n */\nexport async function transactionToBase64WithSigners(\n  tx: CompilableTransactionMessage | Transaction,\n): Promise<Base64EncodedWireTransaction> {\n  if (\"messageBytes\" in tx) return transactionToBase64(tx);\n  else return transactionToBase64(await partiallySignTransactionMessageWithSigners(tx));\n}\n", "import { COMPUTE_BUDGET_PROGRAM_ADDRESS, getSetComputeUnitLimitInstruction } from \"@solana-program/compute-budget\";\nimport type {\n  CompilableTransactionMessage,\n  GetLatestBlockhashApi,\n  ITransactionMessageWithFeePayer,\n  Rpc,\n  SimulateTransactionApi,\n  TransactionMessage,\n  TransactionMessageWithBlockhashLifetime,\n} from \"@solana/kit\";\nimport {\n  appendTransactionMessageInstruction,\n  assertIsTransactionMessageWithBlockhashLifetime,\n  getComputeUnitEstimateForTransactionMessageFactory,\n  setTransactionMessageLifetimeUsingBlockhash,\n} from \"@solana/kit\";\nimport { isSetComputeLimitInstruction } from \"../programs/compute-budget\";\nimport { transactionToBase64WithSigners } from \"./base64-to-transaction\";\nimport { debug, isDebugEnabled } from \"./debug\";\n\ntype PrepareCompilableTransactionMessage =\n  | CompilableTransactionMessage\n  | (ITransactionMessageWithFeePayer & TransactionMessage);\n\nexport type PrepareTransactionConfig<TMessage extends PrepareCompilableTransactionMessage> = {\n  /**\n   * Transaction to prepare for sending to the blockchain\n   */\n  transaction: TMessage;\n  /**\n   * RPC client capable of simulating transactions and getting the latest blockhash\n   **/\n  rpc: Rpc<GetLatestBlockhashApi & SimulateTransactionApi>;\n  /**\n   * Multiplier applied to the simulated compute unit value obtained from simulation\n   *\n   * Default: `1.1`\n   **/\n  computeUnitLimitMultiplier?: number;\n  /**\n   * Whether or not you wish to force reset the compute unit limit value (if one is already set)\n   * using the simulation response and `computeUnitLimitMultiplier`\n   **/\n  computeUnitLimitReset?: boolean;\n  /**\n   * Whether or not you wish to force reset the latest blockhash (if one is already set)\n   *\n   * Default: `true`\n   **/\n  blockhashReset?: boolean;\n};\n\n/**\n * Prepare a Transaction to be signed and sent to the network. Including:\n * - setting a compute unit limit (if not already set)\n * - fetching the latest blockhash (if not already set)\n * - (optional) simulating and resetting the compute unit limit\n * - (optional) resetting latest blockhash to the most recent\n */\nexport async function prepareTransaction<TMessage extends PrepareCompilableTransactionMessage>(\n  config: PrepareTransactionConfig<TMessage>,\n): Promise<TMessage & TransactionMessageWithBlockhashLifetime> {\n  // set the config defaults\n  if (!config.computeUnitLimitMultiplier) config.computeUnitLimitMultiplier = 1.1;\n  if (config.blockhashReset !== false) config.blockhashReset = true;\n\n  const computeBudgetIndex = {\n    limit: -1,\n    price: -1,\n  };\n\n  config.transaction.instructions.map((ix, index) => {\n    if (ix.programAddress != COMPUTE_BUDGET_PROGRAM_ADDRESS) return;\n\n    if (isSetComputeLimitInstruction(ix)) {\n      computeBudgetIndex.limit = index;\n    }\n    // else if (isSetComputeUnitPriceInstruction(ix)) {\n    //   computeBudgetIndex.price = index;\n    // }\n  });\n\n  // set a compute unit limit instruction\n  if (computeBudgetIndex.limit < 0 || config.computeUnitLimitReset) {\n    const units = await getComputeUnitEstimateForTransactionMessageFactory({ rpc: config.rpc })(config.transaction);\n    debug(`Obtained compute units from simulation: ${units}`, \"debug\");\n    const ix = getSetComputeUnitLimitInstruction({\n      units: units * config.computeUnitLimitMultiplier,\n    });\n\n    if (computeBudgetIndex.limit < 0) {\n      config.transaction = appendTransactionMessageInstruction(ix, config.transaction) as unknown as TMessage;\n    } else if (config.computeUnitLimitReset) {\n      const nextInstructions = [...config.transaction.instructions];\n      nextInstructions.splice(computeBudgetIndex.limit, 1, ix);\n      config.transaction = Object.freeze({\n        ...config.transaction,\n        instructions: nextInstructions,\n      } as TMessage);\n    }\n  }\n\n  // update the latest blockhash\n  if (config.blockhashReset || \"lifetimeConstraint\" in config.transaction == false) {\n    const { value: latestBlockhash } = await config.rpc.getLatestBlockhash().send();\n    if (\"lifetimeConstraint\" in config.transaction == false) {\n      debug(\"Transaction missing latest blockhash, fetching one.\", \"debug\");\n      config.transaction = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, config.transaction) as unknown as TMessage;\n    } else if (config.blockhashReset) {\n      debug(\"Auto resetting the latest blockhash.\", \"debug\");\n      config.transaction = Object.freeze({\n        ...config.transaction,\n        lifetimeConstraint: latestBlockhash,\n      } as TransactionMessageWithBlockhashLifetime & typeof config.transaction);\n    }\n  }\n\n  assertIsTransactionMessageWithBlockhashLifetime(config.transaction);\n\n  // skip the async call if debugging is off\n  if (isDebugEnabled()) {\n    debug(`Transaction as base64: ${await transactionToBase64WithSigners(config.transaction)}`, \"debug\");\n  }\n\n  return config.transaction;\n}\n", "import type { CompilableTransactionMessage, Rpc, SimulateTransactionApi, Transaction } from \"@solana/kit\";\nimport { getBase64EncodedWireTransaction, partiallySignTransactionMessageWithSigners } from \"@solana/kit\";\nimport type { Simplify } from \"./../types/index\";\n\nexport type SimulateTransactionFunction = (\n  transaction: Transaction | CompilableTransactionMessage,\n  config?: Simplify<Omit<Parameters<SimulateTransactionApi[\"simulateTransaction\"]>[1], \"encoding\" | \"sigVerify\">>,\n) => Promise<ReturnType<SimulateTransactionApi[\"simulateTransaction\"]>>;\n\ntype SimulateTransactionFactoryConfig<TCluster> = {\n  rpc: Rpc<SimulateTransactionApi> & {\n    \"~cluster\"?: TCluster;\n  };\n};\n\nexport function simulateTransactionFactory({\n  rpc,\n}: SimulateTransactionFactoryConfig<\"devnet\">): SimulateTransactionFunction;\nexport function simulateTransactionFactory({\n  rpc,\n}: SimulateTransactionFactoryConfig<\"testnet\">): SimulateTransactionFunction;\nexport function simulateTransactionFactory({\n  rpc,\n}: SimulateTransactionFactoryConfig<\"mainnet\">): SimulateTransactionFunction;\nexport function simulateTransactionFactory({\n  rpc,\n}: SimulateTransactionFactoryConfig<\"localnet\">): SimulateTransactionFunction;\nexport function simulateTransactionFactory<\n  TCluster extends \"devnet\" | \"mainnet\" | \"testnet\" | \"localnet\" | void = void,\n>({ rpc }: SimulateTransactionFactoryConfig<TCluster>): SimulateTransactionFunction {\n  return async function simulateTransaction(transaction, config) {\n    if (\"messageBytes\" in transaction == false) {\n      transaction = await partiallySignTransactionMessageWithSigners(transaction);\n    }\n\n    return rpc\n      .simulateTransaction(getBase64EncodedWireTransaction(transaction), {\n        replaceRecentBlockhash: true,\n        // innerInstructions: true,\n        ...config,\n        sigVerify: false,\n        encoding: \"base64\",\n      })\n      .send();\n  };\n}\n", "import type { DevnetUrl, MainnetUrl, TestnetUrl } from \"@solana/kit\";\nimport { createSolanaRpc, createSolanaRpcSubscriptions } from \"@solana/kit\";\n\nimport type { CreateSolanaClientArgs, LocalnetUrl, ModifiedClusterUrl, SolanaClient } from \"../types/rpc\";\nimport { getPublicSolanaRpcUrl } from \"./rpc\";\nimport { sendAndConfirmTransactionWithSignersFactory } from \"./send-and-confirm-transaction-with-signers\";\nimport { simulateTransactionFactory } from \"./simulate-transaction\";\n\n/**\n * Create a Solana `rpc` and `rpcSubscriptions` client\n */\nexport function createSolanaClient(\n  props: Omit<CreateSolanaClientArgs<MainnetUrl | \"mainnet\">, \"urlOrMoniker\"> & {\n    urlOrMoniker: \"mainnet\";\n  },\n): SolanaClient<MainnetUrl>;\nexport function createSolanaClient(\n  props: Omit<CreateSolanaClientArgs<DevnetUrl | \"devnet\">, \"urlOrMoniker\"> & {\n    urlOrMoniker: \"devnet\";\n  },\n): SolanaClient<DevnetUrl>;\nexport function createSolanaClient(\n  props: Omit<CreateSolanaClientArgs<TestnetUrl | \"testnet\">, \"urlOrMoniker\"> & {\n    urlOrMoniker: \"testnet\";\n  },\n): SolanaClient<TestnetUrl>;\nexport function createSolanaClient(\n  props: Omit<CreateSolanaClientArgs<LocalnetUrl | \"localnet\">, \"urlOrMoniker\"> & {\n    urlOrMoniker: \"localnet\";\n  },\n): SolanaClient<LocalnetUrl>;\nexport function createSolanaClient<TClusterUrl extends ModifiedClusterUrl>(\n  props: CreateSolanaClientArgs<TClusterUrl>,\n): SolanaClient<TClusterUrl>;\nexport function createSolanaClient<TCluster extends ModifiedClusterUrl>({\n  urlOrMoniker,\n  rpcConfig,\n  rpcSubscriptionsConfig,\n}: CreateSolanaClientArgs<TCluster>) {\n  if (!urlOrMoniker) throw new Error(\"Cluster url or moniker is required\");\n  if (urlOrMoniker instanceof URL == false) {\n    try {\n      urlOrMoniker = new URL(urlOrMoniker.toString());\n    } catch (err) {\n      try {\n        urlOrMoniker = new URL(getPublicSolanaRpcUrl(urlOrMoniker.toString() as any));\n      } catch (err) {\n        throw new Error(\"Invalid URL or cluster moniker\");\n      }\n    }\n  }\n\n  if (!urlOrMoniker.protocol.match(/^https?/i)) {\n    throw new Error(\"Unsupported protocol. Only HTTP and HTTPS are supported\");\n  }\n\n  if (rpcConfig?.port) {\n    urlOrMoniker.port = rpcConfig.port.toString();\n  }\n\n  const rpc = createSolanaRpc<TCluster>(urlOrMoniker.toString() as TCluster, rpcConfig);\n\n  urlOrMoniker.protocol = urlOrMoniker.protocol.replace('http', 'ws');\n\n  if (rpcSubscriptionsConfig?.port) {\n    urlOrMoniker.port = rpcSubscriptionsConfig.port.toString();\n  } else if (urlOrMoniker.hostname == \"localhost\" || urlOrMoniker.hostname.startsWith(\"127\")) {\n    urlOrMoniker.port = \"8900\";\n  }\n\n  const rpcSubscriptions = createSolanaRpcSubscriptions<TCluster>(\n    urlOrMoniker.toString() as TCluster,\n    rpcSubscriptionsConfig,\n  );\n\n  return {\n    rpc,\n    rpcSubscriptions,\n    sendAndConfirmTransaction: sendAndConfirmTransactionWithSignersFactory({\n      // @ts-ignore - TODO(FIXME:nick)\n      rpc,\n      // @ts-ignore - TODO(FIXME:nick)\n      rpcSubscriptions,\n    }),\n    // @ts-ignore\n    simulateTransaction: simulateTransactionFactory({ rpc }),\n  };\n}\n", "/**\n * Calculate the total rent needed for to create an account, with or without extra data stored in it\n */\nexport function getMinimumBalanceForRentExemption(space: bigint | number = 0) {\n  /**\n   * Default values for Rent calculations\n   *\n   * Values taken from: https://github.com/anza-xyz/solana-sdk/blob/c07f692e41d757057c8700211a9300cdcd6d33b1/rent/src/lib.rs#L93-L97\n   * \n   */\n  const RENT = {\n    /**\n     * Account storage overhead for calculation of base rent. (aka the number of bytes required to store an account with no data.\n     */\n    ACCOUNT_STORAGE_OVERHEAD: 128n,\n    /**\n     * Amount of time (in years) a balance must include rent for the account to\n     * be rent exempt.\n     */\n    DEFAULT_EXEMPTION_THRESHOLD: BigInt(Math.floor(2.0 * 1000)) / 1000n,\n    /**\n     * Default rental rate in lamports/byte-year. This calculation is based on:\n     * - 10^9 lamports per SOL\n     * - $1 per SOL\n     * - $0.01 per megabyte day\n     * - $3.65 per megabyte year\n     */\n    DEFAULT_LAMPORTS_PER_BYTE_YEAR: BigInt(\n      Math.floor(((1_000_000_000 / 100) * 365) / (1024 * 1024)),\n    ),\n  };\n\n  return (\n    ((RENT.ACCOUNT_STORAGE_OVERHEAD + BigInt(space)) *\n      RENT.DEFAULT_LAMPORTS_PER_BYTE_YEAR *\n      RENT.DEFAULT_EXEMPTION_THRESHOLD) /\n    1n\n  );\n}\n", "import { assertKeyExporterIsAvailable, assertKeyGenerationIsAvailable } from \"@solana/assertions\";\nimport type { KeyPairSigner, createKeyPairFromBytes, createKeyPairSignerFromBytes } from \"@solana/kit\";\nimport { createSignerFromKeyPair } from \"@solana/kit\";\n\nexport function assertKeyPairIsExtractable(keyPair: CryptoKeyPair): asserts keyPair is ExtractableCryptoKeyPair {\n  assertKeyExporterIsAvailable();\n\n  if (!keyPair.privateKey) {\n    throw new Error(\"Keypair is missing private key\");\n  }\n\n  if (!keyPair.publicKey) {\n    throw new Error(\"Keypair is missing public key\");\n  }\n\n  if (!keyPair.privateKey.extractable) {\n    throw new Error(\"Private key is not extractable\");\n  }\n}\n\ntype Extractable = { \"~extractable\": true };\n\ntype ExtractableCryptoKeyPair = CryptoKeyPair & Extractable;\ntype ExtractableKeyPairSigner = KeyPairSigner & Extractable;\n\n/**\n * Generates an extractable Ed25519 `CryptoKeyPair` capable of signing messages and transactions\n * */\nexport async function generateExtractableKeyPair(): Promise<ExtractableCryptoKeyPair> {\n  await assertKeyGenerationIsAvailable();\n  return crypto.subtle.generateKey(\n    /* algorithm */ \"Ed25519\", // Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20\n    /* extractable */ true,\n    /* allowed uses */ [\"sign\", \"verify\"],\n  ) as Promise<ExtractableCryptoKeyPair>;\n}\n\n/**\n * Generates an extractable signer capable of signing messages and transactions using a Crypto KeyPair.\n * */\nexport async function generateExtractableKeyPairSigner(): Promise<ExtractableKeyPairSigner> {\n  return createSignerFromKeyPair(await generateExtractableKeyPair()) as Promise<ExtractableKeyPairSigner>;\n}\n\n/**\n * Extracts the raw key material from an extractable Ed25519 CryptoKeyPair.\n *\n * @remarks\n * - Requires a keypair generated with extractable=true. See {@link generateExtractableKeyPair}.\n * - The extracted bytes can be used to reconstruct the `CryptoKeyPair` with {@link createKeyPairFromBytes}.\n *\n * @param keypair An extractable Ed25519 `CryptoKeyPair`\n * @returns Raw key bytes as `Uint8Array`\n */\nexport async function extractBytesFromKeyPair(keypair: ExtractableCryptoKeyPair | CryptoKeyPair): Promise<Uint8Array> {\n  assertKeyPairIsExtractable(keypair);\n\n  const [publicKeyBytes, privateKeyJwk] = await Promise.all([\n    crypto.subtle.exportKey(\"raw\", keypair.publicKey),\n    crypto.subtle.exportKey(\"jwk\", keypair.privateKey),\n  ]);\n\n  if (!privateKeyJwk.d) throw new Error(\"Failed to get private key bytes\");\n\n  return new Uint8Array([...Buffer.from(privateKeyJwk.d, \"base64\"), ...new Uint8Array(publicKeyBytes)]);\n}\n\n/**\n * Extracts the raw key material from an extractable Ed25519 KeyPairSigner.\n *\n * @remarks\n * - Requires a keypair generated with extractable=true. See {@link generateExtractableKeyPairSigner}.\n * - The extracted bytes can be used to reconstruct the `CryptoKeyPair` with {@link createKeyPairSignerFromBytes}.\n *\n * @param keypairSigner An extractable Ed25519 `KeyPairSigner`\n * @returns Raw key bytes as `Uint8Array`\n */\nexport async function extractBytesFromKeyPairSigner(\n  keypairSigner: ExtractableKeyPairSigner | KeyPairSigner,\n): Promise<Uint8Array> {\n  return extractBytesFromKeyPair(keypairSigner.keyPair);\n}\n", "import { createKeyPairFromBytes, createSignerFromKeyPair, getBase58Encoder, type KeyPairSigner } from \"@solana/kit\";\n\n/**\n * Create a `CryptoKeyPair` from as base58 encoded secret key\n */\nexport async function createKeypairFromBase58(punitiveSecretKey: string): Promise<CryptoKeyPair> {\n  return createKeyPairFromBytes(getBase58Encoder().encode(punitiveSecretKey));\n}\n\n/**\n * Create a `KeyPairSigner` from as base58 encoded secret key\n */\nexport async function createKeypairSignerFromBase58(punitiveSecretKey: string): Promise<KeyPairSigner> {\n  return createSignerFromKeyPair(await createKeypairFromBase58(punitiveSecretKey));\n}\n", "import { getBase64Encoder, getTransactionDecoder, type Transaction } from \"@solana/kit\";\nimport type { transactionToBase64, transactionToBase64WithSigners } from \"./base64-to-transaction\";\n\n/**\n * Convert a base64 encoded transaction string into compiled transaction\n *\n * Use {@link transactionToBase64} or {@link transactionToBase64WithSigners} to create the base64 encoded transaction string\n */\nexport function transactionFromBase64(base64EncodedTransaction: string): Transaction {\n  return getTransactionDecoder().decode(getBase64Encoder().encode(base64EncodedTransaction));\n}\n", "import type { Simplify } from \"../types/index\";\n\nimport type { Address, GetSignaturesForAddressApi, Rpc } from \"@solana/kit\";\nimport { isSolanaError, SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN, SolanaError } from \"@solana/kit\";\n\ntype GetOldestSignatureForAddressRpc<TCluster> = Rpc<GetSignaturesForAddressApi> & {\n  \"~cluster\"?: TCluster;\n};\n\ntype GetOldestSignatureForAddressConfig = Simplify<\n  Parameters<GetSignaturesForAddressApi[\"getSignaturesForAddress\"]>[1]\n> & { abortSignal?: AbortSignal };\n\n/**\n * Get the oldest signature for the provided `address`\n */\nexport async function getOldestSignatureForAddress<TCluster>(\n  rpc: GetOldestSignatureForAddressRpc<TCluster>,\n  address: Address,\n  config?: GetOldestSignatureForAddressConfig,\n): Promise<ReturnType<GetSignaturesForAddressApi[\"getSignaturesForAddress\"]>[0]> {\n  const signatures = await rpc.getSignaturesForAddress(address, config).send({ abortSignal: config?.abortSignal });\n\n  if (!signatures.length) {\n    throw new SolanaError(SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN, {\n      errorName: \"OldestSignatureNotFound\",\n    });\n  }\n\n  const oldest = signatures[signatures.length - 1];\n  if (signatures.length < (config?.limit || 1000)) return oldest;\n\n  try {\n    // if signatures are found to the limit, recurse for find the oldest\n    return await getOldestSignatureForAddress(rpc, address, { ...config, before: oldest.signature });\n  } catch (err) {\n    // if signatures found were exactly at the limit, there will be no more to find, so we return the oldest\n    if (isSolanaError(err, SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN)) return oldest;\n    throw err;\n  }\n}\n", "import type { Address, BaseTransactionMessage } from \"@solana/kit\";\nimport { AccountRole, SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR, SolanaError } from \"@solana/kit\";\nimport type { getOldestSignatureForAddress } from \"./get-oldest-signature\";\n\n/**\n * Insert a single of reference key {@link Address} into a transaction message\n *\n * Use {@link getOldestSignatureForAddress} to locate the oldest signature for a reference key's address\n *\n * Note: The `transaction` must have at least one non-memo instruction.\n */\nexport function insertReferenceKeyToTransactionMessage<TTransaction extends BaseTransactionMessage>(\n  reference: Address,\n  transaction: TTransaction,\n): TTransaction {\n  return insertReferenceKeysToTransactionMessage([reference], transaction);\n}\n\n/**\n * Insert multiple reference key {@link Address | Addresses} into a transaction message\n *\n * Use {@link getOldestSignatureForAddress} to locate the oldest signature for a reference key's address\n *\n * Note: The `transaction` must have at least one non-memo instruction.\n */\nexport function insertReferenceKeysToTransactionMessage<TTransaction extends BaseTransactionMessage>(\n  references: Address[],\n  transaction: TTransaction,\n): TTransaction {\n  const nonMemoIndex = transaction.instructions.findIndex(\n    (ix) => ix.programAddress !== \"MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr\",\n  );\n\n  if (transaction.instructions.length == 0 || nonMemoIndex == -1) {\n    throw new SolanaError(SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR, {\n      index: transaction.instructions.length || nonMemoIndex,\n      cause: \"At least one non-memo instruction is required\",\n    });\n  }\n\n  const modifiedIx = {\n    ...transaction.instructions[nonMemoIndex],\n    accounts: [\n      ...(transaction.instructions[nonMemoIndex].accounts || []),\n      // actually insert the reference keys\n      ...references.map((ref) => ({\n        address: ref,\n        role: AccountRole.READONLY,\n      })),\n    ],\n  };\n\n  const instructions = [...transaction.instructions];\n  instructions.splice(nonMemoIndex, 1, modifiedIx);\n\n  return Object.freeze({\n    ...transaction,\n    instructions: Object.freeze(instructions),\n  });\n}\n", "/**\n * Codama dependency map to utilize gill imports\n */\nexport const GILL_EXTERNAL_MODULE_MAP: Record<string, string> = {\n  solanaAccounts: \"gill\",\n  solanaAddresses: \"gill\",\n  solanaCodecsCore: \"gill\",\n  solanaCodecsDataStructures: \"gill\",\n  solanaCodecsNumbers: \"gill\",\n  solanaCodecsStrings: \"gill\",\n  solanaErrors: \"gill\",\n  solanaInstructions: \"gill\",\n  solanaOptions: \"gill\",\n  solanaPrograms: \"gill\",\n  solanaRpcTypes: \"gill\",\n  solanaSigners: \"gill\",\n};\n\n/**\n * Create a Codama CLI configuration to generate a program client from an IDL.\n * Normally saved to `codama.js`.\n *\n * @example\n * ```ts\n * import { createCodamaConfig } from \"gill\";\n *\n * export default createCodamaConfig({\n *  idl: \"program/idl.json\",\n *  clientJs: \"clients/js/src/generated\",\n *  // clientRust: \"clients/rust/src/generated\",\n * });\n * ```\n */\nexport function createCodamaConfig({\n  idl,\n  clientJs,\n  clientRust,\n  dependencyMap = GILL_EXTERNAL_MODULE_MAP,\n}: {\n  idl: string;\n  clientJs: string;\n  clientRust?: string;\n  dependencyMap?: Record<string, string>;\n}) {\n  return {\n    idl,\n    scripts: {\n      js: {\n        args: [clientJs, { dependencyMap }],\n        from: \"@codama/renderers-js\",\n      },\n      rust: clientRust\n        ? {\n            from: \"@codama/renderers-rust\",\n            args: [\n              clientRust,\n              {\n                crateFolder: \"clients/rust\",\n                formatCode: true,\n              },\n            ],\n          }\n        : undefined,\n    },\n  };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AA2BO,IAAM,sCAAsC;AAC5C,IAAM,8BAA8B;AACpC,IAAM,wCAAwC;AAC9C,IAAM,qDAAqD;AAC3D,IAAM,8CAA8C;AACpD,IAAM,sCAAsC;AAC5C,IAAM,wCAAwC;AAC9C,IAAM,wCAAwC;AAC9C,IAAM,uCAAuC;AAC7C,IAAM,yCAAyC;AAK/C,IAAM,sCAAsC;AAC5C,IAAM,yCAAyC;AAC/C,IAAM,yCAAyC;AAC/C,IAAM,2CAA2C;AACjD,IAAM,0CAA0C;AAChD,IAAM,oEAAoE;AAC1E,IAAM,uEAAuE;AAC7E,IAAM,sEAAsE;AAC5E,IAAM,0EAA0E;AAChF,IAAM,qCAAqC;AAC3C,IAAM,yEAAyE;AAC/E,IAAM,yEAAyE;AAC/E,IAAM,sEAAsE;AAC5E,IAAM,mDAAmD;AACzD,IAAM,oDAAoD;AAC1D,IAAM,mFAAmF;AACzF,IAAM,sDAAsD;AAC5D,IAAM,2DAA2D;AACjE,IAAM,kFAAkF;AACxF,IAAM,0EAA0E;AAChF,IAAM,wDAAwD;AAI9D,IAAM,+CAA+C;AACrD,IAAM,sDAAsD;AAC5D,IAAM,0DAA0D;AAChE,IAAM,sDAAsD;AAC5D,IAAM,yCAAyC;AAC/C,IAAM,sDAAsD;AAC5D,IAAM,4DAA4D;AAClE,IAAM,wDAAwD;AAC9D,IAAM,wDAAwD;AAC9D,IAAM,+DAA+D;AACrE,IAAM,oDAAoD;AAC1D,IAAM,qDAAqD;AAI3D,IAAM,4CAA4C;AAClD,IAAM,yDAAyD;AAC/D,IAAM,mDAAmD;AACzD,IAAM,mDAAmD;AACzD,IAAM,8DAA8D;AAIpE,IAAM,8DAA8D;AACpE,IAAM,oDAAoD;AAC1D,IAAM,+DAA+D;AACrE,IAAM,6DAA6D;AACnE,IAAM,+DAA+D;AACrE,IAAM,2DAA2D;AACjE,IAAM,6DAA6D;AACnE,IAAM,iEAAiE;AAIvE,IAAM,6DAA6D;AAInE,IAAM,mDAAmD;AACzD,IAAM,sDAAsD;AAC5D,IAAM,oDAAoD;AAC1D,IAAM,2DAA2D;AACjE,IAAM,wDAAwD;AAI9D,IAAM,uDAAuD;AAC7D,IAAM,mDAAmD;AACzD,IAAM,iDAAiD;AAKvD,IAAM,2CAA2C;AACjD,IAAM,iDAAiD;AACvD,IAAM,oDAAoD;AAC1D,IAAM,4DAA4D;AAClE,IAAM,wDAAwD;AAC9D,IAAM,0DAA0D;AAChE,IAAM,sDAAsD;AAC5D,IAAM,wDAAwD;AAC9D,IAAM,8DAA8D;AACpE,IAAM,+DAA+D;AACrE,IAAM,yDAAyD;AAC/D,IAAM,0DAA0D;AAChE,IAAM,uDAAuD;AAC7D,IAAM,kEAAkE;AACxE,IAAM,kEAAkE;AACxE,IAAM,2DAA2D;AACjE,IAAM,0DAA0D;AAChE,IAAM,2DAA2D;AACjE,IAAM,uDAAuD;AAC7D,IAAM,uDAAuD;AAC7D,IAAM,2DAA2D;AACjE,IAAM,6DAA6D;AACnE,IAAM,0DAA0D;AAChE,IAAM,yDAAyD;AAC/D,IAAM,8DAA8D;AACpE,IAAM,iEAAiE;AACvE,IAAM,0CAA0C;AAChD,IAAM,iDAAiD;AACvD,IAAM,4DAA4D;AAClE,IAAM,6DAA6D;AACnE,IAAM,sEAAsE;AAC5E,IAAM,0DAA0D;AAChE,IAAM,8CAA8C;AACpD,IAAM,mDAAmD;AACzD,IAAM,0DAA0D;AAChE,IAAM,4DAA4D;AAClE,IAAM,iDAAiD;AACvD,IAAM,mDAAmD;AACzD,IAAM,iEAAiE;AACvE,IAAM,wDAAwD;AAC9D,IAAM,qEAAqE;AAC3E,IAAM,8DAA8D;AACpE,IAAM,6DAA6D;AACnE,IAAM,6CAA6C;AACnD,IAAM,uDAAuD;AAC7D,IAAM,kDAAkD;AACxD,IAAM,2DAA2D;AACjE,IAAM,yDAAyD;AAC/D,IAAM,uDAAuD;AAC7D,IAAM,sDAAsD;AAC5D,IAAM,iDAAiD;AACvD,IAAM,0EAA0E;AAChF,IAAM,yDAAyD;AAC/D,IAAM,yEAAyE;AAC/E,IAAM,+EAA+E;AAIrF,IAAM,6DAA6D;AACnE,IAAM,iDAAiD;AACvD,IAAM,gDAAgD;AACtD,IAAM,0DAA0D;AAChE,IAAM,wDAAwD;AAC9D,IAAM,oDAAoD;AAC1D,IAAM,8DAA8D;AACpE,IAAM,4DAA4D;AAClE,IAAM,4DAA4D;AAClE,IAAM,yEAAyE;AAC/E,IAAM,2DAA2D;AACjE,IAAM,uDAAuD;AAI7D,IAAM,8DAA8D;AACpE,IAAM,mEAAmE;AACzE,IAAM,yDAAyD;AAC/D,IAAM,qDAAqD;AAC3D,IAAM,yDAAyD;AAC/D,IAAM,uFAAuF;AAC7F,IAAM,yFAAyF;AAC/F,IAAM,uFAAuF;AAC7F,IAAM,mEAAmE;AACzE,IAAM,gDAAgD;AACtD,IAAM,6CAA6C;AACnD,IAAM,+CAA+C;AACrD,IAAM,yDAAyD;AAC/D,IAAM,4EAA4E;AAClF,IAAM,+FAA+F;AACrG,IAAM,+DAA+D;AACrE,IAAM,iEAAiE;AACvE,IAAM,yDAAyD;AAC/D,IAAM,8DAA8D;AACpE,IAAM,8EAA8E;AACpF,IAAM,gDAAgD;AAKtD,IAAM,2CAA2C;AACjD,IAAM,kDAAkD;AACxD,IAAM,wDAAwD;AAC9D,IAAM,qDAAqD;AAC3D,IAAM,6DAA6D;AACnE,IAAM,8DAA8D;AACpE,IAAM,2DAA2D;AACjE,IAAM,qDAAqD;AAC3D,IAAM,uDAAuD;AAE7D,IAAM,uDAAuD;AAC7D,IAAM,6DAA6D;AACnE,IAAM,yDAAyD;AAC/D,IAAM,qDAAqD;AAC3D,IAAM,iEAAiE;AACvE,IAAM,oDAAoD;AAC1D,IAAM,uDAAuD;AAC7D,IAAM,8DAA8D;AACpE,IAAM,qEAAqE;AAC3E,IAAM,uDAAuD;AAC7D,IAAM,4DAA4D;AAClE,IAAM,uEAAuE;AAC7E,IAAM,yEAAyE;AAC/E,IAAM,0DAA0D;AAChE,IAAM,kEAAkE;AACxE,IAAM,sEAAsE;AAC5E,IAAM,qEAAqE;AAC3E,IAAM,sEAAsE;AAC5E,IAAM,+DAA+D;AACrE,IAAM,oEAAoE;AAC1E,IAAM,yEAAyE;AAC/E,IAAM,yDAAyD;AAC/D,IAAM,+DAA+D;AACrE,IAAM,0EAA0E;AAChF,IAAM,2EAA2E;AACjF,IAAM,yDAAyD;AAC/D,IAAM,4EAA4E;AAClF,IAAM,0DAA0D;AAIhE,IAAM,uDAAuD;AAC7D,IAAM,4CAA4C;AAClD,IAAM,8CAA8C;AACpD,IAAM,iDAAiD;AACvD,IAAM,oEAAoE;AAC1E,IAAM,4DAA4D;AAClE,IAAM,0DAA0D;AAChE,IAAM,gDAAgD;AACtD,IAAM,wDAAwD;AAC9D,IAAM,4DAA4D;AAClE,IAAM,6CAA6C;AACnD,IAAM,4CAA4C;AAClD,IAAM,gDAAgD;AACtD,IAAM,sDAAsD;AAC5D,IAAM,4CAA4C;AAClD,IAAM,sDAAsD;AAC5D,IAAM,iEAAiE;AACvE,IAAM,mDAAmD;AACzD,IAAM,yCAAyC;AAC/C,IAAM,qEAAqE;AAC3E,IAAM,gEAAgE;AACtE,IAAM,0DAA0D;AAChE,IAAM,yEAAyE;AAI/E,IAAM,sCAAsC;AAC5C,IAAM,qDAAqD;AAC3D,IAAM,0CAA0C;AAChD,IAAM,qDAAqD;AAI3D,IAAM,mEAAmE;AACzE,IAAM,mEAAmE;AACzE,IAAM,0EAA0E;AAChF,IAAM,6DAA6D;AACnE,IAAM,6DAA6D;AAMnE,IAAM,yEAAyE;AAC/E,IAAM,mHAAmH;AACzH,IAAM,mFAAmF;AACzF,IAAM,+DAA+D;AACrE,IAAM,0EAA0E;ACgUvF,SAAS,YAAY,OAAwB;AACrC,MAAA,MAAM,QAAQ,KAAK,GAAG;AACtB,UAAM,uBAAuB,MAAM,IAAI,WAAW,EAAE;MAAK;;IAAA;AACzD,WAAO,QAAkB;IAAiC;EAAA,WACnD,OAAO,UAAU,UAAU;AAClC,WAAO,GAAG,KAAK;EAAA,OACZ;AACI,WAAA;MACH;QACI,SAAS,QAAQ,OAAO,eAAe,KAAK,MAAM;;;UAG5C,EAAE,GAAI,MAAiB;YACvB;MAAA;IACV;EACJ;AAER;AAEA,SAAS,yBAAyB,CAAC,KAAK,KAAK,GAAiD;AAC1F,SAAO,GAAG,GAAG,IAAI,YAAY,KAAK,CAAC;AACvC;AAEO,SAAS,oBAAoB,SAAyB;AACnD,QAAA,qBAAqB,OAAO,QAAQ,OAAO,EAAE,IAAI,wBAAwB,EAAE,KAAK,GAAG;AAClF,SAA0E,KAAK,kBAAkB;AAC5G;ACxZO,IAAM,sBAIR;EACD,CAAC,yCAAyC,GAAG;EAC7C,CAAC,2DAA2D,GACxD;EACJ,CAAC,gDAAgD,GAAG;EACpD,CAAC,gDAAgD,GAAG;EACpD,CAAC,sDAAsD,GAAG;EAC1D,CAAC,4DAA4D,GACzD;EACJ,CAAC,uDAAuD,GAAG;EAC3D,CAAC,4CAA4C,GACzC;EACJ,CAAC,mDAAmD,GAAG;EACvD,CAAC,kDAAkD,GAC/C;EACJ,CAAC,qDAAqD,GAAG;EACzD,CAAC,sCAAsC,GACnC;EACJ,CAAC,yDAAyD,GACtD;EACJ,CAAC,qDAAqD,GAClD;EACJ,CAAC,mDAAmD,GAChD;EACJ,CAAC,iDAAiD,GAAG;EACrD,CAAC,mDAAmD,GAChD;EACJ,CAAC,kDAAkD,GAC/C;EACJ,CAAC,mCAAmC,GAChC;EACJ,CAAC,oDAAoD,GACjD;EACJ,CAAC,sEAAsE,GACnE;EACJ,CAAC,6DAA6D,GAC1D;EACJ,CAAC,yDAAyD,GACtD;EACJ,CAAC,uDAAuD,GACpD;EACJ,CAAC,iEAAiE,GAC9D;EACJ,CAAC,qDAAqD,GAClD;EACJ,CAAC,2CAA2C,GAAG;EAC/C,CAAC,mDAAmD,GAChD;EACJ,CAAC,8CAA8C,GAAG;EAClD,CAAC,kEAAkE,GAC/D;EACJ,CAAC,yCAAyC,GACtC;EACJ,CAAC,sCAAsC,GACnC;EACJ,CAAC,yDAAyD,GACtD;EACJ,CAAC,0CAA0C,GACvC;EACJ,CAAC,mDAAmD,GAChD;EACJ,CAAC,6CAA6C,GAC1C;EACJ,CAAC,6CAA6C,GAAG;EACjD,CAAC,8DAA8D,GAC3D;EACJ,CAAC,yCAAyC,GACtC;EACJ,CAAC,yCAAyC,GACtC;EACJ,CAAC,uDAAuD,GACpD;EACJ,CAAC,gDAAgD,GAC7C;EACJ,CAAC,0DAA0D,GAAG;EAC9D,CAAC,4DAA4D,GAAG;EAChE,CAAC,sDAAsD,GACnD;EACJ,CAAC,2DAA2D,GACxD;EACJ,CAAC,0DAA0D,GACvD;EACJ,CAAC,uDAAuD,GAAG;EAC3D,CAAC,uDAAuD,GAAG;EAC3D,CAAC,wDAAwD,GACrD;EACJ,CAAC,oDAAoD,GAAG;EACxD,CAAC,+CAA+C,GAAG;EACnD,CAAC,4EAA4E,GACzE;EACJ,CAAC,2CAA2C,GAAG;EAC/C,CAAC,8DAA8D,GAAG;EAClE,CAAC,uCAAuC,GAAG;EAC3C,CAAC,wDAAwD,GAAG;EAC5D,CAAC,8DAA8D,GAC3D;EACJ,CAAC,mEAAmE,GAAG;EACvE,CAAC,yDAAyD,GAAG;EAC7D,CAAC,0DAA0D,GACvD;EACJ,CAAC,oDAAoD,GAAG;EACxD,CAAC,+DAA+D,GAC5D;EACJ,CAAC,+DAA+D,GAC5D;EACJ,CAAC,8CAA8C,GAAG;EAClD,CAAC,8CAA8C,GAAG;EAClD,CAAC,0CAA0C,GAAG;EAC9C,CAAC,oDAAoD,GAAG;EACxD,CAAC,qDAAqD,GAAG;EACzD,CAAC,mDAAmD,GAAG;EACvD,CAAC,qDAAqD,GAAG;EACzD,CAAC,sDAAsD,GAAG;EAC1D,CAAC,iDAAiD,GAAG;EACrD,CAAC,8CAA8C,GAAG;EAClD,CAAC,yDAAyD,GAAG;EAC7D,CAAC,gDAAgD,GAAG;EACpD,CAAC,8CAA8C,GAAG;EAClD,CAAC,uEAAuE,GACpE;EACJ,CAAC,sDAAsD,GAAG;EAC1D,CAAC,sEAAsE,GAAG;EAC1E,CAAC,yDAAyD,GACtD;EACJ,CAAC,gDAAgD,GAAG;EACpD,CAAC,2DAA2D,GAAG;EAC/D,CAAC,oDAAoD,GACjD;EACJ,CAAC,wDAAwD,GAAG;EAC5D,CAAC,qDAAqD,GAClD;EACJ,CAAC,kEAAkE,GAC/D;EACJ,CAAC,0DAA0D,GAAG;EAC9D,CAAC,2DAA2D,GAAG;EAC/D,CAAC,uDAAuD,GAAG;EAC3D,CAAC,wDAAwD,GACrD;EACJ,CAAC,uDAAuD,GACpD;EACJ,CAAC,oDAAoD,GAAG;EACxD,CAAC,uDAAuD,GACpD;EACJ,CAAC,sDAAsD,GAAG;EAC1D,CAAC,wCAAwC,GAAG;EAC5C,CAAC,uDAAuD,GAAG;EAC3D,CAAC,mDAAmD,GAAG;EACvD,CAAC,oDAAoD,GAAG;EACxD,CAAC,gDAAgD,GAAG;EACpD,CAAC,8CAA8C,GAC3C;EACJ,CAAC,2CAA2C,GACxC;EACJ,CAAC,2BAA2B,GACxB;EACJ,CAAC,gFAAgF,GAC7E;EAGJ,CAAC,uEAAuE,GACpE;EAEJ,CAAC,gHAAgH,GAC7G;EAGJ,CAAC,sEAAsE,GACnE;EAEJ,CAAC,4DAA4D,GACzD;EAGJ,CAAC,sCAAsC,GAAG;EAC1C,CAAC,sCAAsC,GAAG;EAC1C,CAAC,uCAAuC,GACpC;EACJ,CAAC,wCAAwC,GACrC;EACJ,CAAC,mCAAmC,GAChC;EACJ,CAAC,kCAAkC,GAAG;EACtC,CAAC,qDAAqD,GAAG;EACzD,CAAC,wDAAwD,GAAG;EAC5D,CAAC,mEAAmE,GAAG;EACvE,CAAC,sEAAsE,GAAG;EAC1E,CAAC,mEAAmE,GAAG;EACvE,CAAC,iEAAiE,GAAG;EACrE,CAAC,mDAAmD,GAAG;EACvD,CAAC,gDAAgD,GAAG;EACpD,CAAC,uEAAuE,GAAG;EAC3E,CAAC,iDAAiD,GAAG;EACrD,CAAC,sEAAsE,GACnE;EACJ,CAAC,gFAAgF,GAAG;EACpF,CAAC,uEAAuE,GAAG;EAC3E,CAAC,+EAA+E,GAC5E;EACJ,CAAC,oEAAoE,GAAG;EACxE,CAAC,gDAAgD,GAAG;EACpD,CAAC,mDAAmD,GAChD;EACJ,CAAC,iDAAiD,GAC9C;EACJ,CAAC,qDAAqD,GAClD;EACJ,CAAC,wDAAwD,GACrD;EACJ,CAAC,mCAAmC,GAAG;EACvC,CAAC,qCAAqC,GAAG;EACzC,CAAC,sCAAsC,GAAG;EAC1C,CAAC,qCAAqC,GAAG;EACzC,CAAC,qCAAqC,GAAG;EACzC,CAAC,gEAAgE,GAC7D;EAEJ,CAAC,uEAAuE,GACpE;EACJ,CAAC,0DAA0D,GAAG;EAC9D,CAAC,0DAA0D,GAAG;EAC9D,CAAC,gEAAgE,GAC7D;EACJ,CAAC,kDAAkD,GAAG;EACtD,CAAC,mCAAmC,GAChC;EAGJ,CAAC,uCAAuC,GAAG;EAC3C,CAAC,kDAAkD,GAC/C;EAEJ,CAAC,0DAA0D,GACvD;EAEJ,CAAC,8CAA8C,GAC3C;EACJ,CAAC,uDAAuD,GACpD;EACJ,CAAC,qDAAqD,GAClD;EACJ,CAAC,6CAA6C,GAC1C;EACJ,CAAC,2DAA2D,GACxD;EACJ,CAAC,yDAAyD,GACtD;EACJ,CAAC,yDAAyD,GACtD;EACJ,CAAC,iDAAiD,GAC9C;EACJ,CAAC,sEAAsE,GACnE;EACJ,CAAC,wDAAwD,GACrD;EAEJ,CAAC,oDAAoD,GACjD;EACJ,CAAC,8DAA8D,GAAG;EAClE,CAAC,iDAAiD,GAAG;EACrD,CAAC,2DAA2D,GACxD;EAEJ,CAAC,4DAA4D,GACzD;EAKJ,CAAC,0DAA0D,GACvD;EACJ,CAAC,4DAA4D,GAAG;EAChE,CAAC,wDAAwD,GAAG;EAC5D,CAAC,0DAA0D,GAAG;EAC9D,CAAC,oCAAoC,GACjC;EACJ,CAAC,2DAA2D,GACxD;EACJ,CAAC,+CAA+C,GAAG;EACnD,CAAC,qDAAqD,GAAG;EACzD,CAAC,kDAAkD,GAC/C;EACJ,CAAC,+DAA+D,GAC5D;EACJ,CAAC,kDAAkD,GAAG;EACtD,CAAC,oDAAoD,GAAG;EACxD,CAAC,oDAAoD,GAAG;EACxD,CAAC,oDAAoD,GACjD;EACJ,CAAC,sDAAsD,GACnD;EACJ,CAAC,2DAA2D,GAAG;EAC/D,CAAC,4DAA4D,GACzD;EACJ,CAAC,wDAAwD,GAAG;EAC5D,CAAC,sDAAsD,GAAG;EAC1D,CAAC,kEAAkE,GAC/D;EACJ,CAAC,mEAAmE,GAChE;EACJ,CAAC,mEAAmE,GAChE;EACJ,CAAC,wEAAwE,GACrE;EACJ,CAAC,8DAA8D,GAC3D;EACJ,CAAC,4DAA4D,GACzD;EACJ,CAAC,yDAAyD,GACtD;EACJ,CAAC,uEAAuE,GACpE;EACJ,CAAC,0DAA0D,GACvD;EACJ,CAAC,0DAA0D,GAAG;EAC9D,CAAC,yEAAyE,GACtE;EACJ,CAAC,sDAAsD,GAAG;EAC1D,CAAC,iDAAiD,GAAG;EACrD,CAAC,kDAAkD,GAAG;EACtD,CAAC,uDAAuD,GAAG;EAC3D,CAAC,uDAAuD,GACpD;EACJ,CAAC,wCAAwC,GAAG;EAC5C,CAAC,oDAAoD,GAAG;EACxD,CAAC,sEAAsE,GACnE;EACJ,CAAC,sEAAsE,GACnE;EACJ,CAAC,oEAAoE,GACjE;EACJ,CAAC,kEAAkE,GAC/D;EACJ,CAAC,iEAAiE,GAAG;EACrE,CAAC,4DAA4D,GACzD;EACJ,CAAC,0CAA0C,GAAG;EAC9C,CAAC,8DAA8D,GAC3D;EACJ,CAAC,6CAA6C,GAC1C;EACJ,CAAC,sDAAsD,GAAG;EAC1D,CAAC,kDAAkD,GAAG;EACtD,CAAC,oFAAoF,GACjF;EACJ,CAAC,sFAAsF,GACnF;EAGJ,CAAC,gEAAgE,GAAG;EACpE,CAAC,oFAAoF,GACjF;EACJ,CAAC,2DAA2D,GACxD;EAGJ,CAAC,2EAA2E,GACxE;EAIJ,CAAC,4CAA4C,GAAG;EAChD,CAAC,sDAAsD,GACnD;EAEJ,CAAC,4FAA4F,GACzF;EACJ,CAAC,yEAAyE,GACtE;EACJ,CAAC,2DAA2D,GACxD;EAEJ,CAAC,gEAAgE,GAC7D;EAEJ,CAAC,sDAAsD,GACnD;EACJ,CAAC,6CAA6C,GAAG;EACjD,CAAC,sDAAsD,GACnD;AACR;ACpmBA,IAAM,cAAc;AACpB,IAAM,OAAO;AAEN,SAAS,6BACZ,MACA,UAAkB,CAAA,GACZ;AACA,QAAA,sBAAsB,oBAAoB,IAAI;AAChD,MAAA,oBAAoB,WAAW,GAAG;AAC3B,WAAA;EAAA;AAEP,MAAA;AACJ,WAAS,gBAAgB,UAAmB;AACpC,QAAA,MAAM,IAAI,MAAM,GAAoB;AACpC,YAAM,eAAe,oBAAoB,MAAM,MAAM,WAAW,IAAI,GAAG,QAAQ;AAErE,gBAAA;QACN,gBAAgB;;UAEV,GAAG,QAAQ,YAAoC,CAAC;YAChD,IAAI,YAAY;MAAA;IAC1B,WACO,MAAM,IAAI,MAAM,GAAgB;AACvC,gBAAU,KAAK,oBAAoB,MAAM,MAAM,WAAW,GAAG,QAAQ,CAAC;IAAA;EAC1E;AAEJ,QAAM,YAAsB,CAAA;AAC5B,sBAAoB,MAAM,EAAE,EAAE,QAAQ,CAAC,MAAM,OAAO;AAChD,QAAI,OAAO,GAAG;AACF,cAAA;QACJ,CAAC,WAAW,GAAG;QACf,CAAC,IAAI,GACD,oBAAoB,CAAC,MAAM,OACrB,IACA,oBAAoB,CAAC,MAAM,MACzB,IACA;;MAAA;AAEhB;IAAA;AAEA,QAAA;AACI,YAAA,MAAM,IAAI,GAAG;MACjB,KAAK;AACW,oBAAA;UAAE,CAAC,WAAW,GAAG;UAAI,CAAC,IAAI,GAAG;;QAAe;AACxD;MACJ,KAAK;AACD,YAAI,SAAS,MAAM;AACH,sBAAA;YAAE,CAAC,WAAW,GAAG;YAAI,CAAC,IAAI,GAAG;;UAAyB;QAAA,WAC3D,SAAS,KAAK;AACT,sBAAA;YAAE,CAAC,WAAW,GAAG;YAAI,CAAC,IAAI,GAAG;;UAAmB;QAAA;AAEhE;MACJ,KAAK;AACD,YAAI,SAAS,MAAM;AACH,sBAAA;YAAE,CAAC,WAAW,GAAG;YAAI,CAAC,IAAI,GAAG;;UAAyB;QAAA,WAC3D,SAAS,KAAK;AACT,sBAAA;YAAE,CAAC,WAAW,GAAG;YAAI,CAAC,IAAI,GAAG;;UAAmB;QAAA,WACrD,CAAC,KAAK,MAAM,IAAI,GAAG;AACd,sBAAA;YAAE,CAAC,WAAW,GAAG;YAAI,CAAC,IAAI,GAAG;;UAAe;QAAA;AAE5D;IAAA;AAER,QAAI,WAAW;AACX,UAAI,UAAU,WAAW;AACrB,wBAAgB,EAAE;MAAA;AAEd,cAAA;IAAA;EACZ,CACH;AACe,kBAAA;AACT,SAAA,UAAU,KAAK,EAAE;AAC5B;AAEO,SAAS,gBACZ,MACA,UAAmC,CAAA,GAC7B;AACN,MAAI,eAAAA,QAAA,IAAA,aAAyB,cAAc;AAChC,WAAA,6BAA6B,MAAM,OAAO;EAAA,OAC9C;AACH,QAAI,wBAAwB,iBAAiB,IAAI,iEAAiE,IAAI;AACtH,QAAI,OAAO,KAAK,OAAO,EAAE,QAAQ;AAMJ,+BAAA,KAAK,oBAAoB,OAAO,CAAC;IAAA;AAE9D,WAAO,GAAG,qBAAqB;EAAA;AAEvC;AC1DO,SAAS,cACZC,IAKA,MAC4B;AAC5B,QAAMC,iBAAgBD,cAAa,SAASA,GAAE,SAAS;AACvD,MAAIC,gBAAe;AACf,QAAI,SAAS,QAAW;AACZ,aAAAD,GAA8B,QAAQ,WAAW;IAAA;AAEtD,WAAA;EAAA;AAEJ,SAAA;AACX;AAYa,IAAA,cAAN,cAAgF,MAAM;;;;;;;EAOhF,QAA8E,KAAK;;;;EAInF;EACT,eACO,CAAC,MAAM,sBAAsB,GAGlC;AACM,QAAA;AACA,QAAA;AACJ,QAAI,wBAAwB;AAExB,YAAM,EAAE,OAAO,GAAG,YAAA,IAAgB;AAClC,UAAI,OAAO;AACP,uBAAe,EAAE,MAAM;MAAA;AAE3B,UAAI,OAAO,KAAK,WAAW,EAAE,SAAS,GAAG;AAC3B,kBAAA;MAAA;IACd;AAEE,UAAA,UAAU,gBAAgB,MAAM,OAAO;AAC7C,UAAM,SAAS,YAAY;AAC3B,SAAK,UAAU;MACX,QAAQ;MACR,GAAG;IAAA;AAIP,SAAK,OAAO;EAAA;AAEpB;ACjHO,SAAS,yBAAyB,MAAwD;AAC7F,MAAI,uBAAuB,SAAS,OAAO,MAAM,sBAAsB,YAAY;AACzE,UAAA,kBAAkB,GAAG,IAAI;EAAA;AAEvC;AC6BO,SAAS,2BACZ,EAAE,qBAAqB,iBAAiB,mBAAmB,aAAA,GAE3D,gBACW;AACP,MAAA;AACA,MAAA;AACA,MAAA,OAAO,iBAAiB,UAAU;AACnB,mBAAA;EAAA,OACZ;AACH,mBAAe,OAAO,KAAK,YAAY,EAAE,CAAC;AAC1C,sBAAkB,aAAa,YAAY;EAAA;AAEzC,QAAA,aAAa,kBAAkB,QAAQ,YAAY;AACzD,QAAM,YAAa,sBAAsB;AACzC,QAAM,eAAe,gBAAgB,WAAW,cAAc,eAAe;AAC7E,QAAM,MAAM,IAAI,YAAY,WAAW,YAAY;AACnD,wBAAsB,KAAK,cAAc;AAClC,SAAA;AACX;AC5CA,IAAM,sBAAsB;;;;EAIxB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ;AAEO,SAAS,mCAIZ,OACA,kBACW;AACL,QAAA,cAAc,OAAO,KAAK;AACzB,SAAA;IACH;MACI,qBAAqB;MACrB,gBAAgB,WAAW,cAAc,iBAAiB;AACtD,YAAI,cAAc,0CAA0C;AACjD,iBAAA;YACH,WAAW;YACX,OAAO;YACP,GAAI,oBAAoB,SAAY,EAAE,yBAAyB,gBAAA,IAAoB;UAAA;QACvF,WACO,cAAc,yCAAyC;AACvD,iBAAA;YACH,MAAM,OAAO,eAAkC;YAC/C,OAAO;UAAA;QACX,WACO,cAAc,iDAAiD;AAC/D,iBAAA;YACH,aAAa;YACb,OAAO;UAAA;QACX;AAEG,eAAA,EAAE,OAAO,YAAY;MAAA;MAEhC,mBAAmB;MACnB,cAAc;IAAA;IAElB;EAAA;AAER;ACvFA,IAAME,uBAAsB;;;;EAIxB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ;AAEO,SAAS,mCAAmC,kBAAoE;AACnH,MAAI,OAAO,qBAAqB,YAAY,sBAAsB,kBAAkB;AACzE,WAAA;MACH,GAAI,iBAAiB;IAAA;EACzB;AAEG,SAAA;IACH;MACI,qBAAqB;MACrB,gBAAgB,WAAW,cAAc,iBAAiB;AACtD,YAAI,cAAc,0CAA0C;AACjD,iBAAA;YACH,WAAW;YACX,GAAI,oBAAoB,SAAY,EAAE,yBAAyB,gBAAA,IAAoB;UAAA;QACvF,WACO,cAAc,wDAAwD;AACtE,iBAAA;YACH,OAAO,OAAO,eAAkC;UAAA;QACpD,WAEA,cAAc,gEACd,cAAc,2EAChB;AACS,iBAAA;YACH,cAAc,OAAQ,gBAAuD,aAAa;UAAA;QAC9F;MACJ;MAEJ,mBAAmBA;MACnB,cAAc;IAAA;IAElB;EAAA;AAER;ACEO,SAAS,+BAA+B,uBAA6C;AACpF,MAAA;AACA,MAAA,mBAAmB,qBAAqB,GAAG;AAC3C,UAAM,EAAE,MAAM,SAAS,MAAM,QAAA,IAAY;AACnC,UAAA,OAAO,OAAO,OAAO;AAC3B,QAAI,SAAS,yEAAyE;AAClF,YAAM,EAAE,KAAK,GAAG,sBAAA,IAA0B;AAC1C,YAAM,cAAc,MAAM,EAAE,OAAO,mCAAmC,GAAG,EAAA,IAAM;AACzE,YAAA,IAAI,YAAY,yEAAyE;QAC3F,GAAG;QACH,GAAG;MAAA,CACN;IAAA,OACE;AACC,UAAA;AACJ,cAAQ,MAAM;QACV,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;AAKc,yBAAA,EAAE,iBAAiB,QAAQ;AAC1C;QACJ;AACI,cAAI,OAAO,SAAS,YAAY,CAAC,MAAM,QAAQ,IAAI,GAAG;AACnC,2BAAA;UAAA;MACnB;AAEF,YAAA,IAAI,YAAY,MAAyB,YAAmD;IAAA;EACtG,OACG;AACH,UAAM,UACF,OAAO,0BAA0B,YACjC,0BAA0B,QAC1B,aAAa,yBACb,OAAO,sBAAsB,YAAY,WACnC,sBAAsB,UACtB;AACV,UAAM,IAAI,YAAY,wCAAwC,EAAE,OAAO,uBAAuB,QAAA,CAAS;EAAA;AAE3G,wBAAsB,KAAK,8BAA8B;AAClD,SAAA;AACX;AAEA,SAAS,mBAAmB,OAA2C;AACnE,SACI,OAAO,UAAU,YACjB,UAAU,QACV,UAAU,SACV,aAAa,UACZ,OAAO,MAAM,SAAS,YAAY,OAAO,MAAM,SAAS,aACzD,OAAO,MAAM,YAAY;AAEjC;A;;;;;;AC/Ia,IAAA,aAAa,CAAC,eAAyC;AAChE,QAAM,qBAAqB,WAAW,OAAO,CAAA,QAAO,IAAI,MAAM;AAC1D,MAAA,mBAAmB,WAAW,GAAG;AACjC,WAAO,WAAW,SAAS,WAAW,CAAC,IAAI,IAAI,WAAW;EAAA;AAG1D,MAAA,mBAAmB,WAAW,GAAG;AACjC,WAAO,mBAAmB,CAAC;EAAA;AAGzB,QAAA,cAAc,mBAAmB,OAAO,CAAC,OAAO,QAAQ,QAAQ,IAAI,QAAQ,CAAC;AAC7E,QAAA,SAAS,IAAI,WAAW,WAAW;AACzC,MAAI,SAAS;AACb,qBAAmB,QAAQ,CAAO,QAAA;AACvB,WAAA,IAAI,KAAK,MAAM;AACtB,cAAU,IAAI;EAAA,CACjB;AACM,SAAA;AACX;AAyBa,IAAA,WAAW,CAAC,OAAwC,WAAoD;AAC7G,MAAA,MAAM,UAAU,OAAe,QAAA;AACnC,QAAM,cAAc,IAAI,WAAW,MAAM,EAAE,KAAK,CAAC;AACjD,cAAY,IAAI,KAAK;AACd,SAAA;AACX;AAkCO,IAAM,WAAW,CAAC,OAAwC,WAC7D,SAAS,MAAM,UAAU,SAAS,QAAQ,MAAM,MAAM,GAAG,MAAM,GAAG,MAAM;AAkBrE,SAAS,cACZ,MACA,OACA,QACO;AACP,QAAM,QAAQ,WAAW,KAAK,KAAK,WAAW,MAAM,SAAS,OAAO,KAAK,MAAM,QAAQ,SAAS,MAAM,MAAM;AAC5G,MAAI,MAAM,WAAW,MAAM,OAAe,QAAA;AACnC,SAAA,MAAM,MAAM,CAAC,GAAG,MAAM,MAAM,MAAM,CAAC,CAAC;AAC/C;ACyQO,SAAS,eACZ,OACA,SACM;AACN,SAAO,eAAe,UAAU,QAAQ,YAAY,QAAQ,iBAAiB,KAAK;AACtF;AA6FO,SAAS,cACZ,SACc;AACd,SAAO,OAAO,OAAO;IACjB,GAAG;IACH,QAAQ,CAAS,UAAA;AACb,YAAM,QAAQ,IAAI,WAAW,eAAe,OAAO,OAAO,CAAC;AACnD,cAAA,MAAM,OAAO,OAAO,CAAC;AACtB,aAAA;IAAA;EACX,CACH;AACL;AA4FO,SAAS,cACZ,SACY;AACZ,SAAO,OAAO,OAAO;IACjB,GAAG;IACH,QAAQ,CAAC,OAAO,SAAS,MAAM,QAAQ,KAAK,OAAO,MAAM,EAAE,CAAC;EAAA,CAC/D;AACL;AAsHO,SAAS,YACZ,OAGiB;AACjB,SAAO,OAAO,OAAO;IACjB,GAAG;IACH,QAAQ,CAAC,OAAO,SAAS,MAAM,MAAM,KAAK,OAAO,MAAM,EAAE,CAAC;IAC1D,QAAQ,CAAS,UAAA;AACb,YAAM,QAAQ,IAAI,WAAW,eAAe,OAAO,KAAK,CAAC;AACnD,YAAA,MAAM,OAAO,OAAO,CAAC;AACpB,aAAA;IAAA;EACX,CACH;AACL;AAgDO,SAAS,YAAY,OAAqF;AAC7G,SAAO,eAAe,SAAS,OAAO,MAAM,cAAc;AAC9D;AA6CO,SAAS,kBACZ,OACsC;AAClC,MAAA,CAAC,YAAY,KAAK,GAAG;AACf,UAAA,IAAI,YAAY,2CAA2C;EAAA;AAEzE;AAwCO,SAAS,eAAe,OAAoF;AACxG,SAAA,CAAC,YAAY,KAAK;AAC7B;AA4CO,SAAS,qBACZ,OACqC;AACjC,MAAA,CAAC,eAAe,KAAK,GAAG;AAClB,UAAA,IAAI,YAAY,8CAA8C;EAAA;AAE5E;ACtzBO,SAAS,aACZ,SACA,SACiB;AACjB,MAAI,YAAY,OAAO,MAAM,YAAY,OAAO,GAAG;AACzC,UAAA,IAAIC,YAAY,iEAAiE;EAAA;AAGvF,MAAA,YAAY,OAAO,KAAK,YAAY,OAAO,KAAK,QAAQ,cAAc,QAAQ,WAAW;AACnF,UAAA,IAAIA,YAAY,2DAA2D;MAC7E,kBAAkB,QAAQ;MAC1B,kBAAkB,QAAQ;IAAA,CAC7B;EAAA;AAGD,MAAA,CAAC,YAAY,OAAO,KAAK,CAAC,YAAY,OAAO,KAAK,QAAQ,YAAY,QAAQ,SAAS;AACjF,UAAA,IAAIA,YAAY,yDAAyD;MAC3E,gBAAgB,QAAQ;MACxB,gBAAgB,QAAQ;IAAA,CAC3B;EAAA;AAGE,SAAA;IACH,GAAG;IACH,GAAG;IACH,QAAQ,QAAQ;IAChB,QAAQ,QAAQ;IAChB,MAAM,QAAQ;IACd,OAAO,QAAQ;EAAA;AAEvB;AC1FO,SAAS,mBAA0B,SAAyB,UAA8C;AAC7G,QAAM,QAAS,CAAC,OAAO,OAAO,WAAW;AAI/B,UAAA,eAAe,QAAQ,OAAO,KAAK;AACzC,QAAI,kBAAkB,cAAc,QAAQ,KAAK,GAAG;AAC1C,YAAA,IAAIA,YAAY,+DAA+D;QACjF,cAAc;QACd,iBAAiB,SAAS,YAAY;QACtC,aAAa,SAAS,QAAQ;QAC9B;MAAA,CACH;IAAA;AAEC,UAAA,IAAI,cAAc,MAAM;AAC9B,cAAU,aAAa;AACjB,UAAA,IAAI,UAAU,MAAM;AAC1B,cAAU,SAAS;AACZ,WAAA;EAAA;AAGP,MAAA,YAAY,OAAO,GAAG;AACf,WAAA,cAAc,EAAE,GAAG,SAAS,WAAW,QAAQ,YAAY,SAAS,QAAQ,MAAA,CAAO;EAAA;AAG9F,SAAO,cAAc;IACjB,GAAG;IACH,GAAI,QAAQ,WAAW,OAAO,EAAE,SAAS,QAAQ,UAAU,SAAS,OAAO,IAAI,CAAA;IAC/E,kBAAkB,CAAS,UAAA,QAAQ,iBAAiB,KAAK,IAAI,SAAS;IACtE;EAAA,CACH;AACL;AAiBO,SAAS,mBAAwB,SAAuB,UAA4C;AACjG,QAAA,OAAQ,CAAC,OAAO,WAAW;AAC7B,UAAM,iBAAiB,WAAW,IAAI,QAAQ,MAAM,MAAM,MAAM;AAC1D,UAAA,gBAAgB,kBAAkB,gBAAgB,QAAQ;AAChE,QAAI,kBAAkB,IAAI;AAChB,YAAA,IAAIA,YAAY,yDAAyD;QAC3E,cAAc;QACd,iBAAiB,SAAS,cAAc;QACxC,aAAa,SAAS,QAAQ;QAC9B;MAAA,CACH;IAAA;AAEL,UAAM,mBAAmB,eAAe,MAAM,GAAG,aAAa;AAIvD,WAAA,CAAC,QAAQ,OAAO,gBAAgB,GAAG,SAAS,iBAAiB,SAAS,SAAS,MAAM;EAAA;AAG5F,MAAA,YAAY,OAAO,GAAG;AACf,WAAA,cAAc,EAAE,GAAG,SAAS,WAAW,QAAQ,YAAY,SAAS,QAAQ,KAAA,CAAM;EAAA;AAG7F,SAAO,cAAc;IACjB,GAAG;IACH,GAAI,QAAQ,WAAW,OAAO,EAAE,SAAS,QAAQ,UAAU,SAAS,OAAO,IAAI,CAAA;IAC/E;EAAA,CACH;AACL;AAmDO,SAAS,iBACZ,OACA,UACiB;AACV,SAAA,aAAa,mBAAmB,OAAO,QAAQ,GAAG,mBAAmB,OAAO,QAAQ,CAAC;AAChG;AAEA,SAAS,kBAAkB,OAA2B,UAA8B;AAChF,SAAO,MAAM,UAAU,CAAC,MAAM,OAAO,QAAQ;AACzC,QAAI,SAAS,WAAW,EAAU,QAAA,SAAS,SAAS,CAAC;AAC9C,WAAA,cAAc,KAAK,UAAU,KAAK;EAAA,CAC5C;AACL;AAEA,SAAS,SAAS,OAAmC;AACjD,SAAO,MAAM,OAAO,CAAC,KAAK,SAAS,MAAM,KAAK,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,GAAG,EAAE;AACnF;AC9JO,SAAS,kCACZ,kBACA,OACA,SAAS,GACX;AACM,MAAA,MAAM,SAAS,UAAU,GAAG;AACtB,UAAA,IAAIA,YAAY,sDAAsD;MACxE;IAAA,CACH;EAAA;AAET;AAuBO,SAAS,sCACZ,kBACA,UACA,OACA,SAAS,GACX;AACQ,QAAA,cAAc,MAAM,SAAS;AACnC,MAAI,cAAc,UAAU;AAClB,UAAA,IAAIA,YAAY,2CAA2C;MAC7D;MACA;MACA;IAAA,CACH;EAAA;AAET;AAoBO,SAAS,qCAAqC,kBAA0B,QAAgB,aAAqB;AAC5G,MAAA,SAAS,KAAK,SAAS,aAAa;AAC9B,UAAA,IAAIA,YAAY,2CAA2C;MAC7D;MACA;MACA;IAAA,CACH;EAAA;AAET;ACzDO,SAAS,qBAA4B,SAAyB,QAAuC;AACxG,QAAM,QAAS,CAAC,OAAO,OAAO,WAAW;AAG/B,UAAA,eAAe,QAAQ,OAAO,KAAK;AACzC,aAAS,OAAO,MAAM,aAAa,QAAQ,OAAO,MAAM;AAClD,UAAA,IAAI,cAAc,MAAM;AAC9B,WAAO,SAAS,aAAa;EAAA;AAGjC,MAAI,YAAY,MAAM,KAAK,YAAY,OAAO,GAAG;AACtC,WAAA,cAAc,EAAE,GAAG,SAAS,WAAW,OAAO,YAAY,QAAQ,WAAW,MAAA,CAAO;EAAA;AAG/F,QAAM,gBAAgB,YAAY,MAAM,IAAI,OAAO,YAAa,OAAO,WAAW;AAClF,QAAM,iBAAiB,YAAY,OAAO,IAAI,QAAQ,YAAa,QAAQ,WAAW;AACtF,QAAM,UAAU,kBAAkB,QAAQ,mBAAmB,OAAO,gBAAgB,iBAAiB;AAErG,SAAO,cAAc;IACjB,GAAG;IACH,GAAI,YAAY,OAAO,EAAE,QAAA,IAAY,CAAA;IACrC,kBAAkB,CAAS,UAAA;AACjB,YAAA,cAAc,eAAe,OAAO,OAAO;AAC1C,aAAA,eAAe,aAAa,MAAM,IAAI;IAAA;IAEjD;EAAA,CACH;AACL;AAgBO,SAAS,qBAA0B,SAAuB,QAAqC;AAC5F,QAAA,OAAQ,CAAC,OAAO,WAAW;AAC7B,UAAM,CAAC,YAAY,aAAa,IAAI,OAAO,KAAK,OAAO,MAAM;AACvD,UAAA,OAAO,OAAO,UAAU;AACrB,aAAA;AAET,QAAI,SAAS,KAAK,MAAM,SAAS,MAAM;AACnC,cAAQ,MAAM,MAAM,QAAQ,SAAS,IAAI;IAAA;AAEP,0CAAA,wBAAwB,MAAM,KAAK;AAGzE,WAAO,CAAC,QAAQ,OAAO,KAAK,GAAG,SAAS,IAAI;EAAA;AAGhD,MAAI,YAAY,MAAM,KAAK,YAAY,OAAO,GAAG;AACtC,WAAA,cAAc,EAAE,GAAG,SAAS,WAAW,OAAO,YAAY,QAAQ,WAAW,KAAA,CAAM;EAAA;AAG9F,QAAM,gBAAgB,YAAY,MAAM,IAAI,OAAO,YAAa,OAAO,WAAW;AAClF,QAAM,iBAAiB,YAAY,OAAO,IAAI,QAAQ,YAAa,QAAQ,WAAW;AACtF,QAAM,UAAU,kBAAkB,QAAQ,mBAAmB,OAAO,gBAAgB,iBAAiB;AACrG,SAAO,cAAc,EAAE,GAAG,SAAS,GAAI,YAAY,OAAO,EAAE,QAAQ,IAAI,CAAA,GAAK,KAAA,CAAM;AACvF;AA4CO,SAAS,mBACZ,OACA,QACiB;AACV,SAAA,aAAa,qBAAqB,OAAO,MAAM,GAAG,qBAAqB,OAAO,MAAM,CAAC;AAChG;AClHO,SAAS,eACZ,SACA,YAC8B;AAC9B,SAAO,cAAc;IACjB,WAAW;IACX,OAAO,CAAC,OAAc,OAAmB,WAAmB;AAIlD,YAAA,oBAAoB,QAAQ,OAAO,KAAK;AACxC,YAAA,iBACF,kBAAkB,SAAS,aAAa,kBAAkB,MAAM,GAAG,UAAU,IAAI;AAC/E,YAAA,IAAI,gBAAgB,MAAM;AAChC,aAAO,SAAS;IAAA;EACpB,CACH;AACL;AA+BO,SAAS,eACZ,SACA,YAC4B;AAC5B,SAAO,cAAc;IACjB,WAAW;IACX,MAAM,CAAC,OAAO,WAAW;AACiB,4CAAA,gBAAgB,YAAY,OAAO,MAAM;AAE/E,UAAI,SAAS,KAAK,MAAM,SAAS,YAAY;AACzC,gBAAQ,MAAM,MAAM,QAAQ,SAAS,UAAU;MAAA;AAG/C,UAAA,YAAY,OAAO,GAAG;AACd,gBAAA,SAAS,OAAO,QAAQ,SAAS;MAAA;AAG7C,YAAM,CAAC,KAAK,IAAI,QAAQ,KAAK,OAAO,CAAC;AAC9B,aAAA,CAAC,OAAO,SAAS,UAAU;IAAA;EACtC,CACH;AACL;AAiDO,SAAS,aACZ,OACA,YACiC;AAC1B,SAAA,aAAa,eAAe,OAAO,UAAU,GAAG,eAAe,OAAO,UAAU,CAAC;AAC5F;AC+CO,SAAS,cAA2C,SAAmB,QAAgC;AAC1G,SAAO,cAAc;IACjB,GAAG;IACH,OAAO,CAAC,OAAO,OAAO,cAAc;AAChC,YAAM,YAAY,CAAC,WAAmB,OAAO,QAAQ,MAAM,MAAM;AAC3D,YAAA,eAAe,OAAO,YAAY,OAAO,UAAU,EAAE,OAAO,WAAW,UAAU,CAAC,IAAI;AACvD,2CAAA,iBAAiB,cAAc,MAAM,MAAM;AAChF,YAAM,aAAa,QAAQ,MAAM,OAAO,OAAO,YAAY;AAC3D,YAAM,gBAAgB,OAAO,aACvB,OAAO,WAAW,EAAE,OAAO,cAAc,YAAY,WAAW,UAAU,CAAC,IAC3E;AAC+B,2CAAA,iBAAiB,eAAe,MAAM,MAAM;AAC1E,aAAA;IAAA;EACX,CACH;AACL;AAwDO,SAAS,cAA2C,SAAmB,QAAgC;AAC1G,SAAO,cAAc;IACjB,GAAG;IACH,MAAM,CAAC,OAAO,cAAc;AACxB,YAAM,YAAY,CAAC,WAAmB,OAAO,QAAQ,MAAM,MAAM;AAC3D,YAAA,eAAe,OAAO,YAAY,OAAO,UAAU,EAAE,OAAO,WAAW,UAAU,CAAC,IAAI;AACvD,2CAAA,iBAAiB,cAAc,MAAM,MAAM;AAChF,YAAM,CAAC,OAAO,UAAU,IAAI,QAAQ,KAAK,OAAO,YAAY;AAC5D,YAAM,gBAAgB,OAAO,aACvB,OAAO,WAAW,EAAE,OAAO,cAAc,YAAY,WAAW,UAAU,CAAC,IAC3E;AAC+B,2CAAA,iBAAiB,eAAe,MAAM,MAAM;AAC1E,aAAA,CAAC,OAAO,aAAa;IAAA;EAChC,CACH;AACL;AAoEO,SAAS,YAAqC,OAAe,QAA8B;AACvF,SAAA,aAAa,cAAc,OAAO,MAAM,GAAG,cAAc,OAAO,MAAM,CAAC;AAClF;AAGA,SAAS,OAAO,UAAkB,SAAiB;AAC3C,MAAA,YAAY,EAAU,QAAA;AACjB,UAAA,WAAW,UAAW,WAAW;AAC9C;ACxTO,SAAS,cACZ,SACA,QACQ;AACJ,MAAA,YAAY,OAAO,GAAG;AAChB,UAAA,YAAY,OAAO,QAAQ,SAAS;AAC1C,QAAI,YAAY,GAAG;AACT,YAAA,IAAIA,YAAY,qDAAqD;QACvE,aAAa;QACb,kBAAkB;MAAA,CACrB;IAAA;AAEL,WAAO,cAAc,EAAE,GAAG,SAAS,UAAA,CAAW;EAAA;AAElD,SAAO,cAAc;IACjB,GAAG;IACH,kBAAkB,CAAS,UAAA;AACvB,YAAM,UAAU,OAAO,QAAQ,iBAAiB,KAAK,CAAC;AACtD,UAAI,UAAU,GAAG;AACP,cAAA,IAAIA,YAAY,qDAAqD;UACvE,aAAa;UACb,kBAAkB;QAAA,CACrB;MAAA;AAEE,aAAA;IAAA;EACX,CACH;AACL;AA8CO,SAAS,cACZ,SACA,QACQ;AACJ,MAAA,YAAY,OAAO,GAAG;AAChB,UAAA,YAAY,OAAO,QAAQ,SAAS;AAC1C,QAAI,YAAY,GAAG;AACT,YAAA,IAAIA,YAAY,qDAAqD;QACvE,aAAa;QACb,kBAAkB;MAAA,CACrB;IAAA;AAEL,WAAO,cAAc,EAAE,GAAG,SAAS,UAAA,CAAW;EAAA;AAE3C,SAAA;AACX;AAoDO,SAAS,YAAqC,OAAe,QAA0C;AACnG,SAAA,aAAa,cAAc,OAAO,MAAM,GAAG,cAAc,OAAO,MAAM,CAAC;AAClF;AC/KO,SAAS,eAA4C,SAAmB,QAA0B;AAC9F,SAAA;IACH,cAAc,SAAS,CAAQ,SAAA,OAAO,MAAM;IAC5C,EAAE,WAAW,CAAC,EAAE,UAAU,MAAM,YAAY,OAAO;EAAA;AAE3D;AAuBO,SAAS,gBAA6C,SAAmB,QAA0B;AAC/F,SAAA;IACH,cAAc,SAAS,CAAQ,SAAA,OAAO,MAAM;IAC5C,EAAE,YAAY,CAAC,EAAE,WAAW,MAAM,aAAa,OAAO;EAAA;AAE9D;AAuBO,SAAS,eAA4C,SAAmB,QAA0B;AAC9F,SAAA;IACH,cAAc,SAAS,CAAQ,SAAA,OAAO,MAAM;IAC5C,EAAE,WAAW,CAAC,EAAE,UAAU,MAAM,YAAY,OAAO;EAAA;AAE3D;AAuBO,SAAS,gBAA6C,SAAmB,QAA0B;AAC/F,SAAA;IACH,cAAc,SAAS,CAAQ,SAAA,OAAO,MAAM;IAC5C,EAAE,YAAY,CAAC,EAAE,WAAW,MAAM,aAAa,OAAO;EAAA;AAE9D;AAmCO,SAAS,aAAsC,OAAe,QAAwB;AAClF,SAAA,aAAa,eAAe,OAAO,MAAM,GAAG,eAAe,OAAO,MAAM,CAAC;AACpF;AAmCO,SAAS,cAAuC,OAAe,QAAwB;AACnF,SAAA,aAAa,gBAAgB,OAAO,MAAM,GAAG,gBAAgB,OAAO,MAAM,CAAC;AACtF;ACzLA,SAAS,4BACL,QACA,oBACA,cACA,cACA,eAAuB,GACzB;AACS,SAAA,eAAe,EAAE,cAAc;AAC5B,UAAA,YAAY,OAAO,YAAY;AACrC,uBAAmB,eAAe,YAAY,IAAI,OAAO,YAAY;AAClD,uBAAA,eAAe,YAAY,IAAI;AAClD;EAAA;AAEJ,MAAI,iBAAiB,cAAc;AAC/B,uBAAmB,eAAe,YAAY,IAAI,OAAO,YAAY;EAAA;AAE7E;AA4BO,SAAS,eACZ,SAC8B;AAC9B,oBAAkB,OAAO;AACzB,SAAO,cAAc;IACjB,GAAG;IACH,OAAO,CAAC,OAAc,OAAO,WAAW;AACpC,YAAM,YAAY,QAAQ,MAAM,OAAO,OAAO,MAAM;AACpD;QACI;QACA;QACA;QACA,SAAS,QAAQ;MAAA;AAEd,aAAA;IAAA;EACX,CACH;AACL;AA4BO,SAAS,eACZ,SAC4B;AAC5B,oBAAkB,OAAO;AACzB,SAAO,cAAc;IACjB,GAAG;IACH,MAAM,CAAC,OAAO,WAAW;AACf,YAAA,gBAAgB,MAAM,MAAM;AAClC;QACI;QACA;QACA;QACA,SAAS,QAAQ;MAAA;AAEd,aAAA,QAAQ,KAAK,eAAe,MAAM;IAAA;EAC7C,CACH;AACL;AAqCO,SAAS,aACZ,OACiC;AACjC,SAAO,aAAa,eAAe,KAAK,GAAG,eAAe,KAAK,CAAC;AACpE;ACtGO,SAAS,iBACZ,SACA,OACiB;AACjB,SAAO,cAAc;IACjB,GAAI,eAAe,OAAO,IACpB,EAAE,GAAG,SAAS,kBAAkB,CAAC,UAAoB,QAAQ,iBAAiB,MAAM,KAAK,CAAC,EAAA,IAC1F;IACN,OAAO,CAAC,OAAiB,OAAO,WAAW,QAAQ,MAAM,MAAM,KAAK,GAAG,OAAO,MAAM;EAAA,CACvF;AACL;AAyCO,SAAS,iBACZ,SACA,KACe;AACf,SAAO,cAAc;IACjB,GAAG;IACH,MAAM,CAAC,OAAwC,WAAW;AACtD,YAAM,CAAC,OAAO,SAAS,IAAI,QAAQ,KAAK,OAAO,MAAM;AACrD,aAAO,CAAC,IAAI,OAAO,OAAO,MAAM,GAAG,SAAS;IAAA;EAChD,CACH;AACL;AAgFO,SAAS,eACZ,OACA,OACA,KACuB;AACvB,SAAO,YAAY;IACf,GAAG,iBAAiB,OAAO,KAAK;IAChC,MAAM,MAAM,iBAAiB,OAAO,GAAG,EAAE,OAAQ,MAAM;EAAA,CAC1D;AACL;;;ACzLO,SAAS,sBAAsBC,WAAkB,WAAmB,aAAa,WAAW;AAC3F,MAAA,CAAC,UAAU,MAAM,IAAI,OAAO,KAAKA,SAAQ,KAAK,CAAC,GAAG;AAC5C,UAAA,IAAI,YAAY,+CAA+C;MACjE,UAAAA;MACA,MAAMA,UAAS;MACf,OAAO;IAAA,CACV;EAAA;AAET;ACEa,IAAA,kBAAkB,CAACA,cAAkD;AAC9E,SAAO,cAAc;IACjB,kBAAkB,CAAC,UAA0B;AACnC,YAAA,CAAC,eAAe,SAAS,IAAI,uBAAuB,OAAOA,UAAS,CAAC,CAAC;AACxE,UAAA,CAAC,UAAW,QAAO,MAAM;AAEvB,YAAA,eAAe,mBAAmB,WAAWA,SAAQ;AACpD,aAAA,cAAc,SAAS,KAAK,KAAK,aAAa,SAAS,EAAE,EAAE,SAAS,CAAC;IAAA;IAEhF,MAAM,OAAe,OAAO,QAAQ;AAEhC,4BAAsBA,WAAU,KAAK;AACjC,UAAA,UAAU,GAAW,QAAA;AAGnB,YAAA,CAAC,eAAe,SAAS,IAAI,uBAAuB,OAAOA,UAAS,CAAC,CAAC;AAC5E,UAAI,CAAC,WAAW;AACN,cAAA,IAAI,IAAI,WAAW,cAAc,MAAM,EAAE,KAAK,CAAC,GAAG,MAAM;AAC9D,eAAO,SAAS,cAAc;MAAA;AAI9B,UAAA,eAAe,mBAAmB,WAAWA,SAAQ;AAGzD,YAAM,YAAsB,CAAA;AAC5B,aAAO,eAAe,IAAI;AACtB,kBAAU,QAAQ,OAAO,eAAe,IAAI,CAAC;AAC7B,wBAAA;MAAA;AAGd,YAAA,aAAa,CAAC,GAAG,MAAM,cAAc,MAAM,EAAE,KAAK,CAAC,GAAG,GAAG,SAAS;AAClE,YAAA,IAAI,YAAY,MAAM;AAC5B,aAAO,SAAS,WAAW;IAAA;EAC/B,CACH;AACL;AAuBa,IAAA,kBAAkB,CAACA,cAAkD;AAC9E,SAAO,cAAc;IACjB,KAAK,UAAU,QAA0B;AACrC,YAAM,QAAQ,WAAW,IAAI,WAAW,SAAS,MAAM,MAAM;AAC7D,UAAI,MAAM,WAAW,EAAU,QAAA,CAAC,IAAI,CAAC;AAGrC,UAAI,aAAa,MAAM,UAAU,CAAA,MAAK,MAAM,CAAC;AAChC,mBAAA,eAAe,KAAK,MAAM,SAAS;AAChD,YAAM,gBAAgBA,UAAS,CAAC,EAAE,OAAO,UAAU;AACnD,UAAI,eAAe,MAAM,OAAA,QAAe,CAAC,eAAe,SAAS,MAAM;AAGvE,YAAM,eAAe,MAAM,MAAM,UAAU,EAAE,OAAO,CAAC,KAAK,SAAS,MAAM,OAAO,OAAO,IAAI,GAAG,EAAE;AAG1F,YAAA,YAAY,mBAAmB,cAAcA,SAAQ;AAE3D,aAAO,CAAC,gBAAgB,WAAW,SAAS,MAAM;IAAA;EACtD,CACH;AACL;AA+Ca,IAAA,gBAAgB,CAACA,cAC1B,aAAa,gBAAgBA,SAAQ,GAAG,gBAAgBA,SAAQ,CAAC;AAErE,SAAS,uBACL,OACA,eACqD;AAC/C,QAAA,CAAC,cAAc,SAAS,IAAI,MAAM,MAAM,IAAI,OAAO,OAAO,aAAa,MAAM,CAAC;AAC7E,SAAA,CAAC,cAAc,SAAS;AACnC;AAEA,SAAS,mBAAmB,OAAeA,WAA0B;AAC3D,QAAA,OAAO,OAAOA,UAAS,MAAM;AACnC,MAAI,MAAM;AACV,aAAW,QAAQ,OAAO;AACf,WAAA;AACP,WAAO,OAAOA,UAAS,QAAQ,IAAI,CAAC;EAAA;AAEjC,SAAA;AACX;AAEA,SAAS,mBAAmB,OAAeA,WAA0B;AAC3D,QAAA,OAAO,OAAOA,UAAS,MAAM;AACnC,QAAM,YAAY,CAAA;AAClB,SAAO,QAAQ,IAAI;AACf,cAAU,QAAQA,UAAS,OAAO,QAAQ,IAAI,CAAC,CAAC;AACvC,aAAA;EAAA;AAEN,SAAA,UAAU,KAAK,EAAE;AAC5B;AC1LA,IAAM,WAAW;AAqBJ,IAAA,mBAAmB,MAAM,gBAAgB,QAAQ;AAoBjD,IAAA,mBAAmB,MAAM,gBAAgB,QAAQ;AA2CjD,IAAA,iBAAiB,MAAM,cAAc,QAAQ;ACnE1D,IAAM,mCAAmC;EACrC,UAAU;EACV,MAAM;AACV;AAEA,SAAS,iBAAiB,MAAc;AACpC,MAAI,QAAQ,MAAa,QAAQ,GAAA,QAAkB,OAAO;AAC1D,MAAI,QAAQ,MAAa,QAAQ,GAAW,QAAO,QAAQ,KAAY;AACvE,MAAI,QAAQ,MAAa,QAAQ,IAAW,QAAO,QAAQ,KAAY;AAC3E;AAqBa,IAAA,mBAAmB,MAC5BC,cAAc;EACV,kBAAkB,CAAC,UAAkB,KAAK,KAAK,MAAM,SAAS,CAAC;EAC/D,MAAM,OAAe,OAAO,QAAQ;AAChC,UAAM,MAAM,MAAM;AAClB,UAAM,KAAK,MAAM;AACjB,QAAI,QAAQ,GAAG;AACL,YAAA,IAAI,MAAM,WAAW,CAAC;AACtB,YAAA,IAAI,iBAAiB,CAAC;AAC5B,UAAI,MAAM,QAAW;AACX,cAAA,IAAIC,YAAYC,+CAA+C;UACjE,GAAG;UACH;QAAA,CACH;MAAA;AAEL,YAAM,IAAI,CAAC,CAAC,GAAG,MAAM;AACrB,aAAO,IAAI;IAAA;AAET,UAAAC,YAAW,IAAI,WAAW,EAAE;AAClC,aAAS,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,KAAK;AAC1B,YAAA,KAAK,MAAM,WAAW,GAAG;AACzB,YAAA,KAAK,MAAM,WAAW,GAAG;AAEzB,YAAA,KAAK,iBAAiB,EAAE;AACxB,YAAA,KAAK,iBAAiB,EAAE;AAC1B,UAAA,OAAO,UAAc,OAAO,UAAa,CAAC,OAAO,MAAM,EAAE,GAAI;AACvD,cAAA,IAAIF,YAAYC,+CAA+C;UACjE,GAAG;UACH;QAAA,CACH;MAAA;AAEI,MAAAC,UAAA,CAAC,IAAI,CAAC,OAAO,MAAM,EAAE,IAAK,MAAM,KAAM,MAAM,KAAK;IAAA;AAGxD,UAAA,IAAIA,WAAU,MAAM;AAC1B,WAAOA,UAAS,SAAS;EAAA;AAEjC,CAAC;AAoBQ,IAAA,mBAAmB,MAC5BC,cAAc;EACV,KAAK,OAAO,QAAQ;AAChB,UAAM,QAAQ,MAAM,MAAM,MAAM,EAAE,OAAO,CAAC,KAAK,SAAS,MAAM,KAAK,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,GAAG,EAAE;AAC7F,WAAA,CAAC,OAAO,MAAM,MAAM;EAAA;AAEnC,CAAC;AA2CE,IAAM,iBAAiB,MAAiCC,aAAa,iBAAiB,GAAG,iBAAA,CAAkB;ACzJlH,IAAMN,YAAW;AAqBJ,IAAA,mBAAmB,MAAM,gBAAgBA,SAAQ;AAoBjD,IAAA,mBAAmB,MAAM,gBAAgBA,SAAQ;AA2CjD,IAAA,iBAAiB,MAAM,cAAcA,SAAQ;ACpDnD,IAAM,yBAAyB,CAACA,WAAkB,SACrDC,cAAc;EACV,kBAAkB,CAAC,UAAkB,KAAK,MAAO,MAAM,SAAS,OAAQ,CAAC;EACzE,MAAM,OAAe,OAAO,QAAQ;AAChC,0BAAsBD,WAAU,KAAK;AACjC,QAAA,UAAU,GAAW,QAAA;AACnB,UAAA,cAAc,CAAC,GAAG,KAAK,EAAE,IAAI,CAAKA,MAAAA,UAAS,QAAQ,CAAC,CAAC;AAC3D,UAAM,gBAAgB,QAAQ,aAAa,MAAM,GAAG,KAAK;AACnD,UAAA,IAAI,eAAe,MAAM;AAC/B,WAAO,cAAc,SAAS;EAAA;AAEtC,CAAC;AAyBE,IAAM,yBAAyB,CAACA,WAAkB,SACrDK,cAAc;EACV,KAAK,UAAU,SAAS,GAAqB;AACzC,UAAM,QAAQ,WAAW,IAAI,WAAW,SAAS,MAAM,MAAM;AAC7D,QAAI,MAAM,WAAW,EAAA,QAAU,CAAC,IAAI,SAAS,MAAM;AAC7C,UAAA,cAAc,QAAQ,CAAC,GAAG,KAAK,GAAG,GAAG,MAAM,IAAI;AACrD,WAAO,CAAC,YAAY,IAAI,CAAA,MAAKL,UAAS,CAAC,CAAC,EAAE,KAAK,EAAE,GAAG,SAAS,MAAM;EAAA;AAE3E,CAAC;AA+CE,IAAM,uBAAuB,CAACA,WAAkB,SACnDM,aAAa,uBAAuBN,WAAU,IAAI,GAAG,uBAAuBA,WAAU,IAAI,CAAC;AAG/F,SAAS,QAAQ,OAAiB,WAAmB,YAAoB,cAAiC;AACtG,QAAM,SAAS,CAAA;AACf,MAAI,cAAc;AAClB,MAAI,oBAAoB;AAClB,QAAA,QAAQ,KAAK,cAAc;AACjC,aAAW,SAAS,OAAO;AACvB,kBAAe,eAAe,YAAa;AACtB,yBAAA;AACrB,WAAO,qBAAqB,YAAY;AACf,2BAAA;AACd,aAAA,KAAM,eAAe,oBAAqB,IAAI;IAAA;EACzD;AAEA,MAAA,gBAAgB,oBAAoB,GAAG;AACvC,WAAO,KAAM,eAAgB,aAAa,oBAAsB,IAAI;EAAA;AAEjE,SAAA;AACX;ACnIA,IAAMA,YAAW;AAqBV,IAAM,mBAAmB,MAAmC;AAC9C;AACb,WAAOC,cAAc;MACjB,kBAAkB,CAAC,UAAkB;AAC7B,YAAA;AACQ,iBAAA,KAAwB,KAAK,EAAE;QAAA,QACnC;AACE,gBAAA,IAAIC,YAAYC,+CAA+C;YACjE,UAAAH;YACA,MAAM;YACN;UAAA,CACH;QAAA;MACL;MAEJ,MAAM,OAAe,OAAO,QAAQ;AAC5B,YAAA;AACA,gBAAM,aAAc,KAAwB,KAAK,EAC5C,MAAM,EAAE,EACR,IAAI,CAAK,MAAA,EAAE,WAAW,CAAC,CAAC;AACvB,gBAAA,IAAI,YAAY,MAAM;AAC5B,iBAAO,WAAW,SAAS;QAAA,QACvB;AACE,gBAAA,IAAIE,YAAYC,+CAA+C;YACjE,UAAAH;YACA,MAAM;YACN;UAAA,CACH;QAAA;MACL;IACJ,CACH;EAAA;AAgBT;AAoBO,IAAM,mBAAmB,MAAmC;AAC9C;AACb,WAAOK,cAAc;MACjB,KAAK,OAAO,SAAS,GAAG;AACd,cAAA,QAAQ,MAAM,MAAM,MAAM;AAChC,cAAM,QAAS,KAAwB,OAAO,aAAa,GAAG,KAAK,CAAC;AAC7D,eAAA,CAAC,OAAO,MAAM,MAAM;MAAA;IAC/B,CACH;EAAA;AAYT;AA2CO,IAAM,iBAAiB,MAAiCC,aAAa,iBAAiB,GAAG,iBAAA,CAAkB;ACrJ3G,IAAM,uBAAuB,CAAC;;EAEjC,MAAM,QAAQ,WAAW,EAAE;;AAkBxB,IAAM,oBAAoB,CAAC,OAAe,UAAkB,MAAM,OAAO,OAAO,IAAQ;ACnCxF,IAAMC,IAAc,WAAW;AAA/B,IACMC,IAAc,WAAW;AC8B/B,IAAM,iBAAiB,MAAmC;AACzD,MAAA;AACJ,SAAOP,cAAc;IACjB,kBAAkB,CAAA,WAAU,gBAAgB,IAAI,EAAA,GAAe,OAAO,KAAK,EAAE;IAC7E,OAAO,CAAC,OAAe,OAAO,WAAW;AACrC,YAAM,cAAc,gBAAgB,IAAI,EAAY,GAAG,OAAO,KAAK;AAC7D,YAAA,IAAI,YAAY,MAAM;AAC5B,aAAO,SAAS,WAAW;IAAA;EAC/B,CACH;AACL;AAqBO,IAAM,iBAAiB,MAAmC;AACzD,MAAA;AACJ,SAAOI,cAAc;IACjB,KAAK,OAAO,QAAQ;AACV,YAAA,SAAS,gBAAgB,IAAI,EAAA,GAAe,OAAO,MAAM,MAAM,MAAM,CAAC;AAC5E,aAAO,CAAC,qBAAqB,KAAK,GAAG,MAAM,MAAM;IAAA;EACrD,CACH;AACL;AA2CO,IAAM,eAAe,MAAiCC,aAAa,eAAe,GAAG,eAAA,CAAgB;;;ACrGrG,IAAM,oBAAoB;AC6B1B,SAAS,cACZ,gBACA,SACwD;AACpD,MAAA;AACA,QAAI,YAAY,kBAAkB,CAAC,eAAe,QAAQ;AAC/C,aAAA;IAAA;AAEJ,WAAA,OAAO,OAAO,EAAE,GAAG,gBAAgB,MAAM,QAAQ,OAAO,eAAe,IAAI,EAAA,CAAG;EAAA,QACjF;AACE,UAAA,IAAI,YAAY,kDAAkD;MACpE,SAAS,eAAe;IAAA,CAC3B;EAAA;AAET;AAEA,SAAS,cAAoC,SAA0E;AACnH,SAAO,EAAE,YAAY,YAAa,YAAY,WAAW,QAAQ;AACrE;AAyCO,SAAS,qBACZ,SAC2E;AAC3E,MAAI,cAAc,OAAO,KAAK,QAAQ,gBAAgB,YAAY;AACxD,UAAA,IAAI,YAAY,kDAAkD;MACpE,SAAS,QAAQ;IAAA,CACpB;EAAA;AAET;AA2BO,SAAS,sBACZ,UACgF;AAC1E,QAAA,UAAU,SAAS,OAAO,CAAA,MAAK,cAAc,CAAC,KAAK,EAAE,gBAAgB,UAAU;AACjF,MAAA,QAAQ,SAAS,GAAG;AACpB,UAAM,mBAAmB,QAAQ,IAAI,CAAA,MAAK,EAAE,OAAO;AAC7C,UAAA,IAAI,YAAY,6DAA6D;MAC/E,WAAW;IAAA,CACd;EAAA;AAET;AC7GO,SAAS,sBACZG,UACA,YACwD;AACpD,MAAA,CAAC,WAAmB,QAAA,OAAO,OAAO,EAAE,SAAAA,UAAS,QAAQ,MAAA,CAAO;AAChE,QAAM,OAAO,iBAAiB,EAAE,OAAO,WAAW,KAAK,CAAC,CAAC;AAClD,SAAA,OAAO,OAAO,EAAE,GAAG,iBAAiB,UAAU,GAAG,SAAAA,UAAS,MAAM,QAAQ,KAAA,CAAM;AACzF;AAyBO,SAAS,sBACZA,UACA,YACwD;AACpD,MAAA,CAAC,WAAmB,QAAA,OAAO,OAAO,EAAE,SAAAA,UAAS,QAAQ,MAAA,CAAO;AAChE,QAAM,OAAO,iBAAA,EAAmB,OAAO,OAAO,WAAW,SAAS,WAAW,WAAW,OAAO,WAAW,KAAK,CAAC,CAAC;AAC1G,SAAA,OAAO,OAAO,EAAE,GAAG,iBAAiB,UAAU,GAAG,SAAAA,UAAS,MAAM,QAAQ,KAAA,CAAM;AACzF;AA0BO,SAAS,oBACZA,UACA,YACwD;AACpD,MAAA,CAAC,WAAmB,QAAA,OAAO,OAAO,EAAE,SAAAA,UAAS,QAAQ,MAAA,CAAO;AAC1D,QAAA,OAAO,WAAW,KAAK,OAAO;AAC7B,SAAA,OAAO,OAAO,EAAE,GAAG,iBAAiB,UAAU,GAAG,SAAAA,UAAS,MAAM,QAAQ,KAAA,CAAM;AACzF;AAEA,SAAS,iBAAiB,YAA0C;AAChE,SAAO,OAAO,OAAO;IACjB,YAAY,WAAW;IACvB,UAAU,WAAW;IACrB,gBAAgB,WAAW;IAC3B,OAAO,WAAW;EAAA,CACrB;AACL;AChEA,eAAsB,oBAClB,KACAA,UACA,SAA6B,CAAA,GACS;AACtC,QAAM,EAAE,aAAa,GAAG,UAAA,IAAc;AACtC,QAAM,WAAW,MAAM,IAAI,eAAeA,UAAS,EAAE,GAAG,WAAW,UAAU,SAAA,CAAU,EAAE,KAAK,EAAE,YAAA,CAAa;AACtG,SAAA,sBAAsBA,UAAS,SAAS,KAAK;AACxD;AA2BA,eAAsB,uBAClB,KACAA,UACA,SAA6B,CAAA,GACyC;AACtE,QAAM,EAAE,aAAa,GAAG,UAAA,IAAc;AACtC,QAAM,EAAE,OAAO,QAAA,IAAY,MAAM,IAC5B,eAAeA,UAAS,EAAE,GAAG,WAAW,UAAU,aAAa,CAAC,EAChE,KAAK,EAAE,YAAA,CAAa;AACzB,SAAO,CAAC,CAAC,WAAW,OAAO,YAAY,YAAY,YAAY,QAAQ,OACjE,oBAAqCA,UAAS,OAAoD,IAClG,sBAAgCA,UAAS,OAAsD;AACzG;AAoDA,eAAsB,qBAKpB,KAAkC,WAA8B,SAA8B,CAAA,GAAI;AAChG,QAAM,EAAE,aAAa,GAAG,UAAA,IAAc;AACtC,QAAM,WAAW,MAAM,IAClB,oBAAoB,WAAW,EAAE,GAAG,WAAW,UAAU,SAAA,CAAU,EACnE,KAAK,EAAE,YAAA,CAAa;AAClB,SAAA,SAAS,MAAM,IAAI,CAAC,SAAS,UAAU,sBAAsB,UAAU,KAAK,GAAG,OAAO,CAAC;AAGlG;AAyBA,eAAsB,wBAMpB,KAAkC,WAA8B,SAA8B,CAAA,GAAI;AAChG,QAAM,EAAE,aAAa,GAAG,UAAA,IAAc;AACtC,QAAM,WAAW,MAAM,IAClB,oBAAoB,WAAW,EAAE,GAAG,WAAW,UAAU,aAAA,CAAc,EACvE,KAAK,EAAE,YAAA,CAAa;AACzB,SAAO,SAAS,MAAM,IAAI,CAAC,SAAS,UAAU;AAC1C,WAAO,CAAC,CAAC,WAAW,OAAO,YAAY,YAAY,YAAY,QAAQ,OACjE,oBAAoB,UAAU,KAAK,GAAG,OAAoD,IAC1F,sBAAsB,UAAU,KAAK,GAAG,OAAsD;EAAA,CACvG;AASL;AC7HO,SAAS,oBACZ,SAC8D;AAC1D,MAAA,CAAC,QAAQ,QAAQ;AACjB,UAAM,IAAIC,YAAY,2CAA2C,EAAE,SAAS,QAAQ,QAAA,CAAS;EAAA;AAErG;AAsBO,SAAS,oBACZ,UACmE;AACnE,QAAM,kBAAkB,SAAS,OAAO,CAAK,MAAA,CAAC,EAAE,MAAM;AAClD,MAAA,gBAAgB,SAAS,GAAG;AAC5B,UAAM,mBAAmB,gBAAgB,IAAI,CAAA,MAAK,EAAE,OAAO;AAC3D,UAAM,IAAIA,YAAY,wDAAwD,EAAE,WAAW,iBAAA,CAAkB;EAAA;AAErH;A;;;;;;ACvHO,SAAS,wBAAwB;AAChC,MAAA,OAAO,WAAW,WAAW,eAAe,OAAO,WAAW,OAAO,oBAAoB,YAAY;AAC/F,UAAA,IAAI,YAAY,0DAA0D;EAAA;AAExF;ACCA,SAAS,wBAAwB;AACV,MAAA,CAAC,WAAW,iBAAiB;AACtC,UAAA,IAAIC,YAAY,2DAA2D;EAAA;AAEzF;AAEA,IAAI;AACJ,eAAe,wBAAwB,QAAwC;AAC3E,MAAI,0BAA0B,QAAW;AACb,4BAAA,IAAI,QAAQ,CAAW,YAAA;AAEtC,aAAA;QAAY;;QAA6B;QAAO,CAAC,QAAQ,QAAQ;MAAA,EACjE,KAAK,MAAM;AACR,gBAAS,wBAAwB,IAAK;MAAA,CACzC,EACA,MAAM,MAAM;AACT,gBAAS,wBAAwB,KAAM;MAAA,CAC1C;IAAA,CACR;EAAA;AAED,MAAA,OAAO,0BAA0B,WAAW;AACrC,WAAA;EAAA,OACJ;AACH,WAAO,MAAM;EAAA;AAErB;AAMO,SAAS,oCAAoC;AAC1B,wBAAA;AAClB,MAAA,OAAO,WAAW,WAAW,eAAe,OAAO,WAAW,OAAO,QAAQ,WAAW,YAAY;AAC9F,UAAA,IAAIA,YAAY,iDAAiD;EAAA;AAE/E;AAMA,eAAsB,iCAAiC;AAC7B,wBAAA;AAClB,MAAA,OAAO,WAAW,WAAW,eAAe,OAAO,WAAW,OAAO,QAAQ,gBAAgB,YAAY;AACnG,UAAA,IAAIA,YAAY,4DAA4D;EAAA;AAEtF,MAAI,CAAE,MAAM,wBAAwB,WAAW,OAAO,MAAM,GAAI;AACtD,UAAA,IAAIA,YAAY,4DAA4D;EAAA;AAE1F;AAMO,SAAS,+BAA+B;AACrB,wBAAA;AAClB,MAAA,OAAO,WAAW,WAAW,eAAe,OAAO,WAAW,OAAO,QAAQ,cAAc,YAAY;AACjG,UAAA,IAAIA,YAAY,0DAA0D;EAAA;AAExF;AAMO,SAAS,qCAAqC;AAC3B,wBAAA;AAClB,MAAA,OAAO,WAAW,WAAW,eAAe,OAAO,WAAW,OAAO,QAAQ,SAAS,YAAY;AAC5F,UAAA,IAAIA,YAAY,wDAAwD;EAAA;AAEtF;AAKO,SAAS,0CAA0C;AAChC,wBAAA;AAClB,MAAA,OAAO,WAAW,WAAW,eAAe,OAAO,WAAW,OAAO,QAAQ,WAAW,YAAY;AAC9F,UAAA,IAAIA,YAAY,0DAA0D;EAAA;AAExF;;;ACjEA,IAAI;AACJ,IAAI;AAEJ,SAAS,2BAA4C;AAC7C,MAAA,CAAC,sBAAuB,yBAAwB,iBAAiB;AAC9D,SAAA;AACX;AAEA,SAAS,2BAA4C;AAC7C,MAAA,CAAC,sBAAuB,yBAAwB,iBAAiB;AAC9D,SAAA;AACX;AAoBO,SAAS,UAAU,iBAA6E;AAEnG;;IAEI,gBAAgB,SAAS;IAEzB,gBAAgB,SAAS;IAC3B;AACS,WAAA;EAAA;AAGX,QAAMC,iBAAgB,yBAAyB;AAC3C,MAAA;AACA,WAAOA,eAAc,OAAO,eAAe,EAAE,eAAe;EAAA,QACxD;AACG,WAAA;EAAA;AAEf;AA2BO,SAAS,gBAAgB,iBAAqF;AAEjH;;IAEI,gBAAgB,SAAS;IAEzB,gBAAgB,SAAS;IAC3B;AACQ,UAAA,IAAI,YAAY,qDAAqD;MACvE,cAAc,gBAAgB;IAAA,CACjC;EAAA;AAGL,QAAMA,iBAAgB,yBAAyB;AACzC,QAAA,QAAQA,eAAc,OAAO,eAAe;AAClD,QAAM,WAAW,MAAM;AACvB,MAAI,aAAa,IAAI;AACX,UAAA,IAAI,YAAY,8CAA8C;MAChE,cAAc;IAAA,CACjB;EAAA;AAET;AAyBO,SAAS,QAA0C,iBAA8C;AACpG,kBAAgB,eAAe;AACxB,SAAA;AACX;AAoBO,SAAS,oBAAmD;AACxD,SAAA;IAAiB,eAAe,yBAAyB,GAAG,EAAE;IAAG,CAAA,oBACpE,QAAQ,eAAe;EAAA;AAE/B;AAoBO,SAAS,oBAAmD;AACxD,SAAA,eAAe,yBAAyB,GAAG,EAAE;AACxD;AAQO,SAAS,kBAAwD;AACpE,SAAO,aAAa,kBAAA,GAAqB,kBAAA,CAAmB;AAChE;AAEO,SAAS,uBAAyD;AAC9D,SAAA,IAAI,KAAK,SAAS,MAAM;IAC3B,WAAW;IACX,mBAAmB;IACnB,eAAe;IACf,SAAS;IACT,aAAa;IACb,OAAO;EAAA,CACV,EAAE;AACP;AClMA,IAAM,IAAI;AACV,IAAM,IAAI;AACV,IAAM,MAAM;AAGZ,SAAS,IAAI,GAAmB;AAC5B,QAAM,IAAI,IAAI;AACP,SAAA,KAAK,KAAK,IAAI,IAAI;AAC7B;AACA,SAAS,KAAK,GAAW,OAAuB;AAE5C,MAAI,IAAI;AACR,SAAO,UAAU,IAAI;AACZ,SAAA;AACA,SAAA;EAAA;AAEF,SAAA;AACX;AACA,SAAS,YAAY,GAAmB;AAE9B,QAAA,KAAM,IAAI,IAAK;AACf,QAAA,KAAM,KAAK,IAAK;AACtB,QAAM,KAAM,KAAK,IAAI,EAAE,IAAI,KAAM;AACjC,QAAM,KAAM,KAAK,IAAI,EAAE,IAAI,IAAK;AAChC,QAAM,MAAO,KAAK,IAAI,EAAE,IAAI,KAAM;AAClC,QAAM,MAAO,KAAK,KAAK,GAAG,IAAI,MAAO;AACrC,QAAM,MAAO,KAAK,KAAK,GAAG,IAAI,MAAO;AACrC,QAAM,MAAO,KAAK,KAAK,GAAG,IAAI,MAAO;AACrC,QAAM,OAAQ,KAAK,KAAK,GAAG,IAAI,MAAO;AACtC,QAAM,OAAQ,KAAK,MAAM,GAAG,IAAI,MAAO;AACvC,QAAM,OAAQ,KAAK,MAAM,GAAG,IAAI,MAAO;AACvC,QAAM,YAAa,KAAK,MAAM,EAAE,IAAI,IAAK;AAClC,SAAA;AACX;AACA,SAAS,QAAQ,GAAW,GAA0B;AAElD,QAAM,KAAK,IAAI,IAAI,IAAI,CAAC;AACxB,QAAM,KAAK,IAAI,KAAK,KAAK,CAAC;AACpB,QAAA,MAAM,YAAY,IAAI,EAAE;AAC9B,MAAI,IAAI,IAAI,IAAI,KAAK,GAAG;AACxB,QAAM,MAAM,IAAI,IAAI,IAAI,CAAC;AACzB,QAAM,QAAQ;AACR,QAAA,QAAQ,IAAI,IAAI,GAAG;AACzB,QAAM,WAAW,QAAQ;AACzB,QAAM,WAAW,QAAQ,IAAI,CAAC,CAAC;AAC/B,QAAM,SAAS,QAAQ,IAAI,CAAC,IAAI,GAAG;AACnC,MAAI,SAAc,KAAA;AACd,MAAA,YAAY,OAAY,KAAA;AACvB,OAAA,IAAI,CAAC,IAAI,QAAQ,GAAQ,KAAA,IAAI,CAAC,CAAC;AAChC,MAAA,CAAC,YAAY,CAAC,UAAU;AACjB,WAAA;EAAA;AAEJ,SAAA;AACX;AAEO,SAAS,eAAe,GAAW,UAA2B;AAC3D,QAAA,KAAK,IAAI,IAAI,CAAC;AACd,QAAA,IAAI,IAAI,KAAK,EAAE;AACrB,QAAM,IAAI,IAAI,IAAI,KAAK,EAAE;AACnB,QAAA,IAAI,QAAQ,GAAG,CAAC;AACtB,MAAI,MAAM,MAAM;AACL,WAAA;EAAA;AAEL,QAAA,iBAAiB,WAAW,SAAU;AACxC,MAAA,MAAM,MAAM,eAAe;AACpB,WAAA;EAAA;AAEJ,SAAA;AACX;ACzFA,SAAS,UAAU,MAAsB;AAC/B,QAAA,YAAY,KAAK,SAAS,EAAE;AAC9B,MAAA,UAAU,WAAW,GAAG;AACxB,WAAO,IAAI,SAAS;EAAA,OACjB;AACI,WAAA;EAAA;AAEf;AAEA,SAAS,qBAAqB,OAAmC;AAC7D,QAAM,YAAY,MAAM,OAAO,CAAC,KAAK,MAAM,OAAO,GAAG,UAAU,OAAO,KAAK,OAAO,OAAQ,IAAI,CAAC,GAAG,GAAG,IAAI,EAAE;AACrG,QAAA,uBAAuB,KAAK,SAAS;AAC3C,SAAO,OAAO,oBAAoB;AACtC;AAEO,SAAS,+BAA+B,OAAoC;AAC3E,MAAA,MAAM,eAAe,IAAI;AAClB,WAAA;EAAA;AAEL,QAAA,IAAI,qBAAqB,KAAK;AACpC,SAAO,eAAe,GAAG,MAAM,EAAE,CAAC;AACtC;ACOO,SAAS,kBACZ,yBACoD;AACpD,QAAM,eAAe,gBAAA,EAAkB,OAAO,uBAAuB;AAC9D,SAAA,+BAA+B,YAAY,MAAM;AAC5D;AA8BO,SAAS,wBACZ,yBAC4D;AACxD,MAAA,CAAC,kBAAkB,uBAAuB,GAAG;AACvC,UAAA,IAAIC,YAAY,kDAAkD;EAAA;AAEhF;AAMO,SAAS,gBACZ,yBACyB;AACzB,0BAAwB,uBAAuB;AACxC,SAAA;AACX;ACzCO,SAAS,wBACZ,OACwC;AACxC,SACI,MAAM,QAAQ,KAAK,KACnB,MAAM,WAAW,KACjB,OAAO,MAAM,CAAC,MAAM,YACpB,OAAO,MAAM,CAAC,MAAM,YACpB,MAAM,CAAC,KAAK,KACZ,MAAM,CAAC,KAAK,OACZ,UAAU,MAAM,CAAC,CAAC;AAE1B;AAQO,SAAS,8BACZ,OACgD;AAChD,QAAM,cACF,MAAM,QAAQ,KAAK,KAAK,MAAM,WAAW,KAAK,OAAO,MAAM,CAAC,MAAM,YAAY,OAAO,MAAM,CAAC,MAAM;AACtG,MAAI,CAAC,aAAa;AACR,UAAA,IAAIA,YAAY,sCAAsC;EAAA;AAEhE,MAAI,MAAM,CAAC,IAAI,KAAK,MAAM,CAAC,IAAI,KAAK;AAC1B,UAAA,IAAIA,YAAY,qDAAqD;MACvE,MAAM,MAAM,CAAC;IAAA,CAChB;EAAA;AAEW,kBAAA,MAAM,CAAC,CAAC;AAC5B;AAeA,IAAM,kBAAkB;AACxB,IAAM,YAAY;AAClB,IAAM,mBAAmB;;EAErB;EAAI;EAAK;EAAK;EAAK;EAAK;EAAI;EAAK;EAAI;EAAK;EAAK;EAAK;EAAK;EAAK;EAAK;EAAI;EAAK;EAAK;EAAK;EAAK;EAAK;AACpG;AAEA,eAAe,4BAA4B,EAAE,gBAAgB,MAAA,GAAuD;AAC9E,oCAAA;AAC9B,MAAA,MAAM,SAAS,WAAW;AACpB,UAAA,IAAIA,YAAY,2DAA2D;MAC7E,QAAQ,MAAM;MACd,UAAU;IAAA,CACb;EAAA;AAED,MAAA;AACJ,QAAM,YAAY,MAAM,OAAO,CAAC,KAAK,MAAM,OAAO;AACxC,UAAA,QAAQ,OAAO,SAAS,YAAY,gBAAgB,IAAI,YAAY,GAAG,OAAO,IAAI,IAAI;AACxF,QAAA,MAAM,aAAa,iBAAiB;AAC9B,YAAA,IAAIA,YAAY,uDAAuD;QACzE,QAAQ,MAAM;QACd,OAAO;QACP,eAAe;MAAA,CAClB;IAAA;AAED,QAAA,KAAK,GAAG,KAAK;AACV,WAAA;EAAA,GACR,CAAA,CAAc;AACjB,QAAM,4BAA4B,gBAAgB;AAC5C,QAAA,sBAAsB,0BAA0B,OAAO,cAAc;AACrE,QAAA,qBAAqB,MAAM,OAAO,OAAO;IAC3C;IACA,IAAI,WAAW,CAAC,GAAG,WAAW,GAAG,qBAAqB,GAAG,gBAAgB,CAAC;EAAA;AAExE,QAAA,eAAe,IAAI,WAAW,kBAAkB;AAClD,MAAA,+BAA+B,YAAY,GAAG;AACxC,UAAA,IAAIA,YAAY,qDAAqD;EAAA;AAExE,SAAA,0BAA0B,OAAO,YAAY;AACxD;AAwBA,eAAsB,yBAAyB;EAC3C;EACA;AACJ,GAA+D;AAC3D,MAAI,WAAW;AACf,SAAO,WAAW,GAAG;AACb,QAAA;AACMC,YAAAA,WAAU,MAAM,4BAA4B;QAC9C;QACA,OAAO,CAAC,GAAG,OAAO,IAAI,WAAW,CAAC,QAAQ,CAAC,CAAC;MAAA,CAC/C;AACM,aAAA,CAACA,UAAS,QAAqC;IAAA,SACjDC,IAAG;AACJ,UAAA,cAAcA,IAAG,qDAAqD,GAAG;AACzE;MAAA,OACG;AACG,cAAAA;MAAA;IACV;EACJ;AAEE,QAAA,IAAIF,YAAY,4DAA4D;AACtF;AAmBA,eAAsB,sBAAsB,EAAE,aAAa,gBAAgB,KAAA,GAAqC;AAC5G,QAAM,EAAE,QAAQ,OAAO,IAAI,gBAAgB;AAErC,QAAA,YAAY,OAAO,SAAS,WAAW,IAAI,YAAY,EAAE,OAAO,IAAI,IAAI;AAC1E,MAAA,UAAU,aAAa,iBAAiB;AAClC,UAAA,IAAIA,YAAY,uDAAuD;MACzE,QAAQ,UAAU;MAClB,OAAO;MACP,eAAe;IAAA,CAClB;EAAA;AAGC,QAAA,sBAAsB,OAAO,cAAc;AACjD,MACI,oBAAoB,UAAU,iBAAiB,UAC/C,oBAAoB,MAAM,CAAC,iBAAiB,MAAM,EAAE,MAAM,CAAC,MAAM,UAAU,SAAS,iBAAiB,KAAK,CAAC,GAC7G;AACQ,UAAA,IAAIA,YAAY,iDAAiD;EAAA;AAGrE,QAAA,qBAAqB,MAAM,OAAO,OAAO;IAC3C;IACA,IAAI,WAAW,CAAC,GAAG,OAAO,WAAW,GAAG,GAAG,WAAW,GAAG,mBAAmB,CAAC;EAAA;AAE3E,QAAA,eAAe,IAAI,WAAW,kBAAkB;AAEtD,SAAO,OAAO,YAAY;AAC9B;AC/MA,eAAsB,wBAAwB,WAAwC;AACrD,+BAAA;AAC7B,MAAI,UAAU,SAAS,YAAY,UAAU,UAAU,SAAS,WAAW;AACjE,UAAA,IAAIA,YAAY,mDAAmD;EAAA;AAE7E,QAAM,iBAAiB,MAAM,OAAO,OAAO,UAAU,OAAO,SAAS;AACrE,SAAO,kBAAA,EAAoB,OAAO,IAAI,WAAW,cAAc,CAAC;AACpE;AAYA,eAAsB,wBAAwBC,UAAkB;AAC5D,QAAM,eAAe,kBAAA,EAAoB,OAAOA,QAAO;AACvD,SAAO,MAAM,OAAO,OAAO,UAAU,OAAO,cAAc,EAAE,MAAM,UAAU,GAAG,MAAwB,CAAC,QAAQ,CAAC;AACrH;;;ACrCA;A;;;;;;AC2BO,SAAS,8BACZ,kBACA,KACA,KACA,OACF;AACM,MAAA,QAAQ,OAAO,QAAQ,KAAK;AACtB,UAAA,IAAI,YAAY,2CAA2C;MAC7D;MACA;MACA;MACA;IAAA,CACH;EAAA;AAET;ACiDY,IAAA,UAAA,CAAAE,YAAL;AACHA,UAAA,QAAA,QAAA,IAAA,CAAA,IAAA;AACAA,UAAA,QAAA,KAAA,IAAA,CAAA,IAAA;AAFQA,SAAAA;AAAA,GAAA,UAAA,CAAA,CAAA;AC7DZ,SAAS,eAAe,QAAqC;AAClD,SAAA,QAAQ,WAAA,IAAwB,QAAQ;AACnD;AAEO,SAAS,qBACZ,OAC8B;AAC9B,SAAO,cAAc;IACjB,WAAW,MAAM;IACjB,MAAM,OAAc,OAAmB,QAAwB;AAC3D,UAAI,MAAM,OAAO;AACiB,sCAAA,MAAM,MAAM,MAAM,MAAM,CAAC,GAAG,MAAM,MAAM,CAAC,GAAG,KAAK;MAAA;AAEnF,YAAM,cAAc,IAAI,YAAY,MAAM,IAAI;AACxC,YAAA,IAAI,IAAI,SAAS,WAAW,GAAG,OAAO,eAAe,MAAM,MAAM,CAAC;AACxE,YAAM,IAAI,IAAI,WAAW,WAAW,GAAG,MAAM;AAC7C,aAAO,SAAS,MAAM;IAAA;EAC1B,CACH;AACL;AAEO,SAAS,qBACZ,OAC4B;AAC5B,SAAO,cAAc;IACjB,WAAW,MAAM;IACjB,KAAK,OAAO,SAAS,GAAkB;AACD,wCAAA,MAAM,MAAM,OAAO,MAAM;AAC3D,4CAAsC,MAAM,MAAM,MAAM,MAAM,OAAO,MAAM;AACrE,YAAA,OAAO,IAAI,SAAS,cAAc,OAAO,QAAQ,MAAM,IAAI,CAAC;AAC3D,aAAA,CAAC,MAAM,IAAI,MAAM,eAAe,MAAM,MAAM,CAAC,GAAG,SAAS,MAAM,IAAI;IAAA;EAC9E,CACH;AACL;AAMA,SAAS,cAAc,OAAwC,QAAiB,QAA8B;AACpG,QAAA,cAAc,MAAM,cAAc,UAAU;AAC5C,QAAA,cAAc,UAAU,MAAM;AACpC,SAAO,MAAM,OAAO,MAAM,aAAa,cAAc,WAAW;AACpE;AC/CO,IAAM,gBAAgB,CAAC,SAA4B,CAAA,MACtD,qBAAqB;EACjB;EACA,MAAM;EACN,KAAK,CAAC,MAAM,OAAO,OAAO,KAAK,WAAW,GAAG,OAAO,KAAK,GAAG,EAAE;EAC9D,MAAM;AACV,CAAC;AAsBE,IAAM,gBAAgB,CAAC,SAA4B,CAAA,MACtD,qBAAqB;EACjB;EACA,KAAK,CAAC,MAAM,OAAO,KAAK,WAAW,GAAG,EAAE;EACxC,MAAM;EACN,MAAM;AACV,CAAC;AA2CQ,IAAA,cAAc,CAAC,SAA4B,CAAA,MACpD,aAAa,cAAc,MAAM,GAAG,cAAc,MAAM,CAAC;AC9EtD,IAAM,gBAAgB,CAAC,SAA4B,CAAA,MACtD,qBAAqB;EACjB;EACA,MAAM;EACN,KAAK,CAAC,MAAM,OAAO,OAAO,KAAK,WAAW,GAAG,OAAO,KAAK,GAAG,EAAE;EAC9D,MAAM;AACV,CAAC;AAsBE,IAAM,gBAAgB,CAAC,SAA4B,CAAA,MACtD,qBAAqB;EACjB;EACA,KAAK,CAAC,MAAM,OAAO,KAAK,WAAW,GAAG,EAAE;EACxC,MAAM;EACN,MAAM;AACV,CAAC;AA2CQ,IAAA,cAAc,CAAC,SAA4B,CAAA,MACpDC,aAAa,cAAc,MAAM,GAAG,cAAc,MAAM,CAAC;AC9EtD,IAAM,iBAAiB,CAAC,SAA4B,CAAA,MACvD,qBAAqB;EACjB;EACA,MAAM;EACN,OAAO,CAAC,CAAC,OAAO,oCAAoC,IAAI,IAAI,OAAO,oCAAoC,CAAC;EACxG,KAAK,CAAC,MAAM,OAAO,OAAO;AAChB,UAAA,aAAa,KAAK,IAAI;AACtB,UAAA,cAAc,KAAK,IAAI;AAC7B,UAAM,YAAY;AAClB,SAAK,YAAY,YAAY,OAAO,KAAK,KAAK,KAAK,EAAE;AACrD,SAAK,aAAa,aAAa,OAAO,KAAK,IAAI,WAAW,EAAE;EAAA;EAEhE,MAAM;AACV,CAAC;AAyBE,IAAM,iBAAiB,CAAC,SAA4B,CAAA,MACvD,qBAAqB;EACjB;EACA,KAAK,CAAC,MAAM,OAAO;AACT,UAAA,aAAa,KAAK,IAAI;AACtB,UAAA,cAAc,KAAK,IAAI;AAC7B,UAAM,OAAO,KAAK,YAAY,YAAY,EAAE;AAC5C,UAAM,QAAQ,KAAK,aAAa,aAAa,EAAE;AAC/C,YAAQ,QAAQ,OAAO;EAAA;EAE3B,MAAM;EACN,MAAM;AACV,CAAC;AA4CQ,IAAA,eAAe,CAAC,SAA4B,CAAA,MACrDA,aAAa,eAAe,MAAM,GAAG,eAAe,MAAM,CAAC;AC/FxD,IAAM,gBAAgB,CAAC,SAA4B,CAAA,MACtD,qBAAqB;EACjB;EACA,MAAM;EACN,OAAO,CAAC,CAAC,OAAO,QAAQ,IAAI,GAAG,OAAO,QAAQ,CAAC;EAC/C,KAAK,CAAC,MAAM,OAAO,OAAO,KAAK,SAAS,GAAG,OAAO,KAAK,GAAG,EAAE;EAC5D,MAAM;AACV,CAAC;AAsBE,IAAM,gBAAgB,CAAC,SAA4B,CAAA,MACtD,qBAAqB;EACjB;EACA,KAAK,CAAC,MAAM,OAAO,KAAK,SAAS,GAAG,EAAE;EACtC,MAAM;EACN,MAAM;AACV,CAAC;AA2CQ,IAAA,cAAc,CAAC,SAA4B,CAAA,MACpDA,aAAa,cAAc,MAAM,GAAG,cAAc,MAAM,CAAC;AC/EtD,IAAM,gBAAgB,CAAC,SAA4B,CAAA,MACtD,qBAAqB;EACjB;EACA,MAAM;EACN,OAAO,CAAC,CAAC,OAAO,YAAY,IAAI,GAAG,OAAO,YAAY,CAAC;EACvD,KAAK,CAAC,MAAM,OAAO,OAAO,KAAK,SAAS,GAAG,OAAO,KAAK,GAAG,EAAE;EAC5D,MAAM;AACV,CAAC;AAsBE,IAAM,gBAAgB,CAAC,SAA4B,CAAA,MACtD,qBAAqB;EACjB;EACA,KAAK,CAAC,MAAM,OAAO,KAAK,SAAS,GAAG,EAAE;EACtC,MAAM;EACN,MAAM;AACV,CAAC;AA2CQ,IAAA,cAAc,CAAC,SAA4B,CAAA,MACpDA,aAAa,cAAc,MAAM,GAAG,cAAc,MAAM,CAAC;AC/EtD,IAAM,gBAAgB,CAAC,SAA4B,CAAA,MACtD,qBAAqB;EACjB;EACA,MAAM;EACN,OAAO,CAAC,CAAC,OAAO,oBAAoB,IAAI,IAAI,OAAO,oBAAoB,CAAC;EACxE,KAAK,CAAC,MAAM,OAAO,OAAO,KAAK,YAAY,GAAG,OAAO,KAAK,GAAG,EAAE;EAC/D,MAAM;AACV,CAAC;AAwBE,IAAM,gBAAgB,CAAC,SAA4B,CAAA,MACtD,qBAAqB;EACjB;EACA,KAAK,CAAC,MAAM,OAAO,KAAK,YAAY,GAAG,EAAE;EACzC,MAAM;EACN,MAAM;AACV,CAAC;AA4CQ,IAAA,cAAc,CAAC,SAA4B,CAAA,MACpDA,aAAa,cAAc,MAAM,GAAG,cAAc,MAAM,CAAC;ACpFhD,IAAA,eAAe,MACxB,qBAAqB;EACjB,MAAM;EACN,OAAO,CAAC,CAAC,OAAO,MAAM,IAAI,GAAG,OAAO,MAAM,CAAC;EAC3C,KAAK,CAAC,MAAM,UAAU,KAAK,QAAQ,GAAG,OAAO,KAAK,CAAC;EACnD,MAAM;AACV,CAAC;AAqBQ,IAAA,eAAe,MACxB,qBAAqB;EACjB,KAAK,CAAA,SAAQ,KAAK,QAAQ,CAAC;EAC3B,MAAM;EACN,MAAM;AACV,CAAC;AAkCE,IAAM,aAAa,MACtBA,aAAa,aAAa,GAAG,aAAA,CAAc;ACxDlC,IAAA,qBAAqB,MAC9BC,cAAc;EACV,kBAAkB,CAAC,UAAmC;AAC9C,QAAA,SAAS,IAAmB,QAAA;AAC5B,QAAA,SAAS,MAA2B,QAAA;AACjC,WAAA;EAAA;EAEX,SAAS;EACT,OAAO,CAAC,OAAwB,OAAmB,WAA2B;AAC5C,kCAAA,YAAY,GAAG,OAAO,KAAK;AACnD,UAAA,gBAAgB,CAAC,CAAC;AACf,aAAA,KAAK,KAAK,MAAM,GAAG;AAExB,YAAM,eAAe,OAAO,KAAK,KAAM,KAAK;AAC5C,UAAI,iBAAiB,GAAG;AAEpB;MAAA;AAGJ,YAAM,gBAAgB,MAAY;AAClC,oBAAc,EAAE,IAAI;AACpB,UAAI,KAAK,GAAG;AAEM,sBAAA,KAAK,CAAC,KAAK;MAAA;IAC7B;AAEE,UAAA,IAAI,eAAe,MAAM;AAC/B,WAAO,SAAS,cAAc;EAAA;AAEtC,CAAC;AAuBQ,IAAA,qBAAqB,MAC9BC,cAAc;EACV,SAAS;EACT,MAAM,CAAC,OAAwC,WAA6B;AACxE,QAAI,QAAQ;AACZ,QAAI,YAAY;AAChB,WAAO,EAAE,WAAW;AAChB,YAAM,YAAY,YAAY;AACxB,YAAA,cAAc,MAAM,SAAS,SAAS;AAC5C,YAAM,gBAAgB,MAAY;AAElC,eAAS,iBAAkB,YAAY;AAClC,WAAA,cAAc,SAAgB,GAAG;AAElC;MAAA;IACJ;AAEG,WAAA,CAAC,OAAO,SAAS,SAAS;EAAA;AAEzC,CAAC;AAmDE,IAAM,mBAAmB,MAC5BF,aAAa,mBAAmB,GAAG,mBAAA,CAAoB;ACpIpD,IAAM,iBAAiB,CAAC,SAA4B,CAAA,MACvD,qBAAqB;EACjB;EACA,MAAM;EACN,OAAO,CAAC,IAAI,OAAO,oCAAoC,CAAC;EACxD,KAAK,CAAC,MAAM,OAAO,OAAO;AAChB,UAAA,aAAa,KAAK,IAAI;AACtB,UAAA,cAAc,KAAK,IAAI;AAC7B,UAAM,YAAY;AAClB,SAAK,aAAa,YAAY,OAAO,KAAK,KAAK,KAAK,EAAE;AACtD,SAAK,aAAa,aAAa,OAAO,KAAK,IAAI,WAAW,EAAE;EAAA;EAEhE,MAAM;AACV,CAAC;AAsBE,IAAM,iBAAiB,CAAC,SAA4B,CAAA,MACvD,qBAAqB;EACjB;EACA,KAAK,CAAC,MAAM,OAAO;AACT,UAAA,aAAa,KAAK,IAAI;AACtB,UAAA,cAAc,KAAK,IAAI;AAC7B,UAAM,OAAO,KAAK,aAAa,YAAY,EAAE;AAC7C,UAAM,QAAQ,KAAK,aAAa,aAAa,EAAE;AAC/C,YAAQ,QAAQ,OAAO;EAAA;EAE3B,MAAM;EACN,MAAM;AACV,CAAC;AA2CQ,IAAA,eAAe,CAAC,SAA4B,CAAA,MACrDA,aAAa,eAAe,MAAM,GAAG,eAAe,MAAM,CAAC;AC3FxD,IAAM,gBAAgB,CAAC,SAA4B,CAAA,MACtD,qBAAqB;EACjB;EACA,MAAM;EACN,OAAO,CAAC,GAAG,OAAO,QAAQ,CAAC;EAC3B,KAAK,CAAC,MAAM,OAAO,OAAO,KAAK,UAAU,GAAG,OAAO,KAAK,GAAG,EAAE;EAC7D,MAAM;AACV,CAAC;AAsBE,IAAM,gBAAgB,CAAC,SAA4B,CAAA,MACtD,qBAAqB;EACjB;EACA,KAAK,CAAC,MAAM,OAAO,KAAK,UAAU,GAAG,EAAE;EACvC,MAAM;EACN,MAAM;AACV,CAAC;AAyCQ,IAAA,cAAc,CAAC,SAA4B,CAAA,MACpDA,aAAa,cAAc,MAAM,GAAG,cAAc,MAAM,CAAC;AC7EtD,IAAM,gBAAgB,CAAC,SAA4B,CAAA,MACtD,qBAAqB;EACjB;EACA,MAAM;EACN,OAAO,CAAC,GAAG,OAAO,YAAY,CAAC;EAC/B,KAAK,CAAC,MAAM,OAAO,OAAO,KAAK,UAAU,GAAG,OAAO,KAAK,GAAG,EAAE;EAC7D,MAAM;AACV,CAAC;AAsBE,IAAM,gBAAgB,CAAC,SAA4B,CAAA,MACtD,qBAAqB;EACjB;EACA,KAAK,CAAC,MAAM,OAAO,KAAK,UAAU,GAAG,EAAE;EACvC,MAAM;EACN,MAAM;AACV,CAAC;AAyCQ,IAAA,cAAc,CAAC,SAA4B,CAAA,MACpDA,aAAa,cAAc,MAAM,GAAG,cAAc,MAAM,CAAC;AC7EtD,IAAM,gBAAgB,CAAC,SAA4B,CAAA,MACtD,qBAAqB;EACjB;EACA,MAAM;EACN,OAAO,CAAC,IAAI,OAAO,oBAAoB,CAAC;EACxC,KAAK,CAAC,MAAM,OAAO,OAAO,KAAK,aAAa,GAAG,OAAO,KAAK,GAAG,EAAE;EAChE,MAAM;AACV,CAAC;AAsBE,IAAM,gBAAgB,CAAC,SAA4B,CAAA,MACtD,qBAAqB;EACjB;EACA,KAAK,CAAC,MAAM,OAAO,KAAK,aAAa,GAAG,EAAE;EAC1C,MAAM;EACN,MAAM;AACV,CAAC;AA4CQ,IAAA,cAAc,CAAC,SAA4B,CAAA,MACpDA,aAAa,cAAc,MAAM,GAAG,cAAc,MAAM,CAAC;ACnFhD,IAAA,eAAe,MACxB,qBAAqB;EACjB,MAAM;EACN,OAAO,CAAC,GAAG,OAAO,MAAM,CAAC;EACzB,KAAK,CAAC,MAAM,UAAU,KAAK,SAAS,GAAG,OAAO,KAAK,CAAC;EACpD,MAAM;AACV,CAAC;AAoBQ,IAAA,eAAe,MACxB,qBAAqB;EACjB,KAAK,CAAA,SAAQ,KAAK,SAAS,CAAC;EAC5B,MAAM;EACN,MAAM;AACV,CAAC;AAgCE,IAAM,aAAa,MACtBA,aAAa,aAAa,GAAG,aAAA,CAAc;;;ACnFxC,SAAS,iCACZ,kBACA,UACA,QACF;AACE,MAAI,aAAa,QAAQ;AACf,UAAA,IAAI,YAAY,+CAA+C;MACjE;MACA;MACA;IAAA,CACH;EAAA;AAET;ACDO,SAAS,cAAc,OAAyC;AACnE,SAAO,MAAM;IACT,CAAC,KAAK,SAAU,QAAQ,QAAQ,SAAS,OAAO,OAAO,KAAK,IAAI,KAAK,IAAI;IACzE;EAAA;AAER;AAEO,SAAS,cAAc,OAAyC;AACnE,SAAO,MAAM,OAAO,CAAC,KAAK,SAAU,QAAQ,QAAQ,SAAS,OAAO,OAAO,MAAM,MAAO,CAAkB;AAC9G;AAEO,SAAS,aAAa,OAAoE;AAC7F,SAAO,YAAY,KAAK,IAAI,MAAM,YAAY;AAClD;AAEO,SAAS,WAAW,OAAoE;AAC3F,SAAO,YAAY,KAAK,IAAI,MAAM,YAAa,MAAM,WAAW;AACpE;AC+DO,SAAS,gBACZ,MACA,SAA0C,CAAA,GAC1B;AACV,QAAA,OAAO,OAAO,QAAQ,cAAc;AAC1C,QAAM,YAAY,0BAA0B,MAAM,aAAa,IAAI,CAAC;AACpE,QAAM,UAAU,0BAA0B,MAAM,WAAW,IAAI,CAAC,KAAK;AAErE,SAAO,cAAc;IACjB,GAAI,cAAc,OACZ,EAAE,UAAA,IACF;MACI,kBAAkB,CAAC,UAAmB;AAC5B,cAAA,aAAa,OAAO,SAAS,WAAW,eAAe,MAAM,QAAQ,IAAI,IAAI;AACnF,eAAO,aAAa,CAAC,GAAG,KAAK,EAAE,OAAO,CAAC,KAAK,UAAU,MAAM,eAAe,OAAO,IAAI,GAAG,CAAC;MAAA;MAE9F;IAAA;IAEV,OAAO,CAAC,OAAgB,OAAO,WAAW;AAClC,UAAA,OAAO,SAAS,UAAU;AACO,yCAAA,SAAS,MAAM,MAAM,MAAM;MAAA;AAE5D,UAAA,OAAO,SAAS,UAAU;AAC1B,iBAAS,KAAK,MAAM,MAAM,QAAQ,OAAO,MAAM;MAAA;AAEnD,YAAM,QAAQ,CAAS,UAAA;AACnB,iBAAS,KAAK,MAAM,OAAO,OAAO,MAAM;MAAA,CAC3C;AACM,aAAA;IAAA;EACX,CACH;AACL;AA0CO,SAAS,gBAAqB,MAAoB,SAA0C,CAAA,GAAoB;AAC7G,QAAA,OAAO,OAAO,QAAQ,cAAc;AACpC,QAAA,WAAW,aAAa,IAAI;AAC5B,QAAA,YAAY,0BAA0B,MAAM,QAAQ;AAC1D,QAAM,UAAU,0BAA0B,MAAM,WAAW,IAAI,CAAC,KAAK;AAErE,SAAO,cAAc;IACjB,GAAI,cAAc,OAAO,EAAE,UAAU,IAAI,EAAE,QAAQ;IACnD,MAAM,CAAC,OAAwC,WAAW;AACtD,YAAM,QAAe,CAAA;AACjB,UAAA,OAAO,SAAS,YAAY,MAAM,MAAM,MAAM,EAAE,WAAW,GAAG;AACvD,eAAA,CAAC,OAAO,MAAM;MAAA;AAGzB,UAAI,SAAS,aAAa;AACf,eAAA,SAAS,MAAM,QAAQ;AAC1B,gBAAM,CAAC,OAAOG,UAAS,IAAI,KAAK,KAAK,OAAO,MAAM;AACzCA,mBAAAA;AACT,gBAAM,KAAK,KAAK;QAAA;AAEb,eAAA,CAAC,OAAO,MAAM;MAAA;AAGzB,YAAM,CAAC,cAAc,SAAS,IAAI,OAAO,SAAS,WAAW,CAAC,MAAM,MAAM,IAAI,KAAK,KAAK,OAAO,MAAM;AAC5F,eAAA;AACT,eAAS,IAAI,GAAG,IAAI,cAAc,KAAK,GAAG;AACtC,cAAM,CAAC,OAAOA,UAAS,IAAI,KAAK,KAAK,OAAO,MAAM;AACzCA,iBAAAA;AACT,cAAM,KAAK,KAAK;MAAA;AAEb,aAAA,CAAC,OAAO,MAAM;IAAA;EACzB,CACH;AACL;AAqFO,SAAS,cACZ,MACA,SAAwC,CAAA,GACnB;AACd,SAAA,aAAa,gBAAgB,MAAM,MAAgB,GAAG,gBAAgB,MAAM,MAAgB,CAAC;AACxG;AAEA,SAAS,0BAA0B,MAAqC,UAAwC;AACxG,MAAA,OAAO,SAAS,SAAiB,QAAA;AACjC,MAAA,SAAS,EAAU,QAAA;AAChB,SAAA,aAAa,OAAO,OAAO,WAAW;AACjD;AC5OO,SAAS,mBACZ,MACA,SAAwC,CAAA,GACN;AAClC,QAAM,eAAoC,OAAO,WAAW,YAAY,EAAE,UAAU,OAAA,IAAW;AACzF,QAAA,WAAW,aAAa,YAAY;AAC1C,SAAOC,cAAc;IACjB,WAAW;IACX,MAAM,OAAkB,OAAO,QAAQ;AACnC,YAAM,aAAuB,CAAA;AAE7B,eAAS,IAAI,GAAG,IAAI,MAAM,KAAK,GAAG;AAC9B,YAAI,OAAO;AACX,iBAAS,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG;AAC3B,gBAAM,UAAU,OAAO,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC;AACpC,kBAAA,YAAY,WAAW,IAAI,IAAI;QAAA;AAE3C,YAAI,UAAU;AACV,qBAAW,QAAQ,IAAI;QAAA,OACpB;AACH,qBAAW,KAAK,IAAI;QAAA;MACxB;AAGE,YAAA,IAAI,YAAY,MAAM;AACrB,aAAA;IAAA;EACX,CACH;AACL;AA8BO,SAAS,mBACZ,MACA,SAAwC,CAAA,GACN;AAClC,QAAM,eAAoC,OAAO,WAAW,YAAY,EAAE,UAAU,OAAA,IAAW;AACzF,QAAA,WAAW,aAAa,YAAY;AAC1C,SAAOC,cAAc;IACjB,WAAW;IACX,KAAK,OAAO,QAAQ;AACsB,4CAAA,YAAY,MAAM,OAAO,MAAM;AACrE,YAAM,WAAsB,CAAA;AAC5B,UAAI,QAAQ,MAAM,MAAM,QAAQ,SAAS,IAAI;AACrC,cAAA,WAAW,MAAM,QAAA,IAAY;AAErC,YAAM,QAAQ,CAAQ,SAAA;AAClB,iBAAS,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG;AAC3B,cAAI,UAAU;AACV,qBAAS,KAAK,QAAQ,OAAO,CAAC,CAAC;AACtB,qBAAA;UAAA,OACN;AACH,qBAAS,KAAK,QAAQ,OAAO,GAAW,CAAC;AAChC,qBAAA;UAAA;QACb;MACJ,CACH;AAEM,aAAA,CAAC,UAAU,SAAS,IAAI;IAAA;EACnC,CACH;AACL;AAkDO,SAAS,iBACZ,MACA,SAAwC,CAAA,GACG;AACpCC,SAAAA,aAAa,mBAAmB,MAAM,MAAM,GAAG,mBAAmB,MAAM,MAAM,CAAC;AAC1F;AC9HO,SAAS,kBAAkB,SAA4C,CAAA,GAAsB;AACzF,SAAA,iBAAiB,OAAO,QAAQ,aAAA,GAAgB,CAAC,UAAoB,QAAQ,IAAI,CAAE;AAC9F;AA6BO,SAAS,kBAAkB,SAA4C,CAAA,GAAsB;AACzF,SAAA,iBAAiB,OAAO,QAAQ,aAAa,GAAG,CAAC,UAAoC,OAAO,KAAK,MAAM,CAAC;AACnH;AAmDO,SAAS,gBAAgB,SAA0C,CAAA,GAAoB;AAC1F,SAAOA,aAAa,kBAAkB,MAAM,GAAG,kBAAkB,MAAM,CAAC;AAC5E;AC/HO,SAAS,kBAAwE;AACpF,SAAOF,cAAc;IACjB,kBAAkB,CAAA,UAAS,MAAM;IACjC,OAAO,CAAC,OAAO,OAAO,WAAW;AACvB,YAAA,IAAI,OAAO,MAAM;AACvB,aAAO,SAAS,MAAM;IAAA;EAC1B,CACH;AACL;AA2BO,SAAS,kBAA2D;AACvE,SAAOC,cAAc;IACjB,MAAM,CAAC,OAAO,WAAW;AACf,YAAA,QAAQ,MAAM,MAAM,MAAM;AAChC,aAAO,CAAC,OAAO,SAAS,MAAM,MAAM;IAAA;EACxC,CACH;AACL;AAmCO,SAAS,gBAAwF;AACpG,SAAOC,aAAa,gBAAA,GAAmB,gBAAA,CAAiB;AAC5D;ACRa,IAAAC,oBAAmB,MAC5BF,cAAc;EACV,KAAK,OAAO,QAAQ;AAChB,UAAM,QAAQ,MAAM,MAAM,MAAM,EAAE,OAAO,CAAC,KAAK,SAAS,MAAM,KAAK,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,GAAG,EAAE;AAC7F,WAAA,CAAC,OAAO,MAAM,MAAM;EAAA;AAEnC,CAAC;AC1EE,SAAS,mBACZ,UAC2C;AAC3C,SAAOD,cAAc;IACjB,WAAW,SAAS;IACpB,OAAO,CAAC,GAAG,OAAO,WAAW;AACnB,YAAA,IAAI,UAAU,MAAM;AAC1B,aAAO,SAAS,SAAS;IAAA;EAC7B,CACH;AACL;AA0BO,SAAS,mBACZ,UAC2C;AAC3C,SAAOC,cAAc;IACjB,WAAW,SAAS;IACpB,MAAM,CAAC,OAAO,WAAW;AACrB,YAAM,SAASE,kBAAiB;AAChC,UAAI,CAAC,cAAc,OAAO,UAAU,MAAM,GAAG;AACnC,cAAA,IAAIC,YAAY,wCAAwC;UAC1D;UACA,MAAM;UACN,aAAa,OAAO,OAAO,QAAQ;UACnC,SAAS,OAAO,OAAO,KAAK;UAC5B;QAAA,CACH;MAAA;AAEL,aAAO,CAAC,QAAW,SAAS,SAAS,MAAM;IAAA;EAC/C,CACH;AACL;AAqCO,SAAS,iBACZ,UAC+C;AAC/C,SAAOF,aAAa,mBAAmB,QAAQ,GAAG,mBAAmB,QAAQ,CAAC;AAClF;AC3DO,SAAS,gBACZ,OACwC;AAExC,QAAM,YAAY,cAAc,MAAM,IAAI,YAAY,CAAC;AACvD,QAAM,UAAU,cAAc,MAAM,IAAI,UAAU,CAAC,KAAK;AAExD,SAAOF,cAAc;IACjB,GAAI,cAAc,OACZ;MACI,kBAAkB,CAAC,UACf,MAAM,IAAI,CAAC,MAAM,UAAUK,eAAe,MAAM,KAAK,GAAG,IAAI,CAAC,EAAE,OAAO,CAAC,KAAK,QAAQ,MAAM,KAAK,CAAC;MACpG;IAAA,IAEJ,EAAE,UAAU;IAClB,OAAO,CAAC,OAAc,OAAO,WAAW;AACpC,uCAAiC,SAAS,MAAM,QAAQ,MAAM,MAAM;AAC9D,YAAA,QAAQ,CAAC,MAAM,UAAU;AAC3B,iBAAS,KAAK,MAAM,MAAM,KAAK,GAAG,OAAO,MAAM;MAAA,CAClD;AACM,aAAA;IAAA;EACX,CACH;AACL;AAkCO,SAAS,gBACZ,OACwC;AAExC,QAAM,YAAY,cAAc,MAAM,IAAI,YAAY,CAAC;AACvD,QAAM,UAAU,cAAc,MAAM,IAAI,UAAU,CAAC,KAAK;AAExD,SAAOJ,cAAc;IACjB,GAAI,cAAc,OAAO,EAAE,QAAQ,IAAI,EAAE,UAAU;IACnD,MAAM,CAAC,OAAwC,WAAW;AACtD,YAAM,SAAS,CAAA;AACf,YAAM,QAAQ,CAAQ,SAAA;AAClB,cAAM,CAAC,UAAU,SAAS,IAAI,KAAK,KAAK,OAAO,MAAM;AACrD,eAAO,KAAK,QAAQ;AACX,iBAAA;MAAA,CACZ;AACM,aAAA,CAAC,QAAQ,MAAM;IAAA;EAC1B,CACH;AACL;AAoDO,SAAS,cACZ,OACyG;AAClGC,SAAAA;IACH,gBAAgB,KAAK;IACrB,gBAAgB,KAAK;EAAA;AAE7B;ACvIO,SAAS,gBACZ,UACA,mBAC8C;AAExC,QAAA,YAAY,kBAAkB,QAAQ;AAC5C,QAAM,QAAiC,CAAC,SAAS,OAAO,WAAW;AACzD,UAAA,QAAQ,kBAAkB,OAAO;AACvC,4BAAwB,UAAU,KAAK;AACvC,WAAO,SAAS,KAAK,EAAE,MAAM,SAAS,OAAO,MAAM;EAAA;AAGvD,MAAI,cAAc,MAAM;AACpB,WAAOF,cAAc,EAAE,WAAW,MAAA,CAAO;EAAA;AAGvC,QAAA,UAAU,gBAAgB,QAAQ;AACxC,SAAOA,cAAc;IACjB,GAAI,YAAY,OAAO,EAAE,QAAA,IAAY,CAAA;IACrC,kBAAkB,CAAW,YAAA;AACnB,YAAA,QAAQ,kBAAkB,OAAO;AACvC,8BAAwB,UAAU,KAAK;AACvC,aAAOK,eAAe,SAAS,SAAS,KAAK,CAAC;IAAA;IAElD;EAAA,CACH;AACL;AAkCO,SAAS,gBACZ,UACA,mBAC8C;AAExC,QAAA,YAAY,kBAAkB,QAAQ;AACtC,QAAA,OAA6B,CAAC,OAAO,WAAW;AAC5C,UAAA,QAAQ,kBAAkB,OAAO,MAAM;AAC7C,4BAAwB,UAAU,KAAK;AACvC,WAAO,SAAS,KAAK,EAAE,KAAK,OAAO,MAAM;EAAA;AAG7C,MAAI,cAAc,MAAM;AACpB,WAAOJ,cAAc,EAAE,WAAW,KAAA,CAAM;EAAA;AAGtC,QAAA,UAAU,gBAAgB,QAAQ;AACjCA,SAAAA,cAAc,EAAE,GAAI,YAAY,OAAO,EAAE,QAAA,IAAY,CAAA,GAAK,KAAA,CAAM;AAC3E;AAiDO,SAAS,cACZ,UACA,mBACA,mBAIF;AACSC,SAAAA;IACH,gBAAgB,UAAU,iBAAiB;IAC3C,gBAAgB,UAAU,iBAAiB;EAAA;AAInD;AAEA,SAAS,wBAAwB,UAA8B,OAAe;AAC1E,MAAI,OAAO,SAAS,KAAK,MAAM,aAAa;AAClC,UAAA,IAAIE,YAAY,kDAAkD;MACpE,UAAU,SAAS,SAAS;MAC5B,UAAU;MACV,SAAS;IAAA,CACZ;EAAA;AAET;AAEA,SAAS,kBAAoF,UAAqB;AAC1G,MAAA,SAAS,WAAW,EAAU,QAAA;AAClC,MAAI,CAACE,YAAY,SAAS,CAAC,CAAC,EAAU,QAAA;AAChC,QAAA,cAAc,SAAS,CAAC,EAAE;AAC1B,QAAA,oBAAoB,SAAS,MAAM,CAAA,YAAWA,YAAY,OAAO,KAAK,QAAQ,cAAc,WAAW;AAC7G,SAAO,oBAAoB,cAAc;AAC7C;AAEA,SAAS,gBAAkF,UAAqB;AAC5G,SAAO,cAAc,SAAS,IAAI,CAAA,YAAW,WAAW,OAAO,CAAC,CAAC;AACrE;AClEO,SAAS,6BAIZ,UACA,SAA+E,CAAA,GACT;AAEhE,QAAA,wBAAyB,OAAO,iBAAiB;AACjD,QAAA,SAAS,OAAO,QAAQC,aAAa;AACpC,SAAA;IACH,SAAS;MAAI,CAAC,CAAA,EAAG,OAAO,GAAG,UACvBC,iBAAiB,gBAAgB,CAAC,QAAQ,OAAO,CAAC,GAAG,CAAC,UAAkC,CAAC,OAAO,KAAK,CAAC;IAAA;IAE1G,CAAS,UAAA,wBAAwB,UAAU,MAAM,qBAAqB,CAAC;EAAA;AAE/E;AAwCO,SAAS,6BAIZ,UACA,SAA+E,CAAA,GACT;AAChE,QAAA,wBAAwB,OAAO,iBAAiB;AAChD,QAAA,SAAS,OAAO,QAAQC,aAAa;AACpC,SAAA;IACH,SAAS;MAAI,CAAC,CAAC,eAAe,OAAO,MACjCC,iBAAiB,gBAAgB,CAAC,QAAQ,OAAO,CAAC,GAAG,CAAC,CAAA,EAAG,KAAK,OAAO;QACjE,CAAC,qBAAqB,GAAG;QACzB,GAAG;MAAA,EACL;IAAA;IAEN,CAAC,OAAO,WAAW,OAAO,OAAO,KAAK,OAAO,MAAM,EAAE,CAAC,CAAC;EAAA;AAE/D;AA0EO,SAAS,2BAIZ,UACA,SAA6E,CAAA,GAK/E;AACSR,SAAAA;IACH,6BAA6B,UAAU,MAAM;IAC7C,6BAA6B,UAAU,MAAM;EAAA;AAKrD;AAEA,SAAS,wBACL,UACA,oBACF;AACQ,QAAA,gBAAgB,SAAS,UAAU,CAAC,CAAC,GAAG,MAAM,uBAAuB,GAAG;AAC9E,MAAI,gBAAgB,GAAG;AACb,UAAA,IAAIE,YAAY,2DAA2D;MAC7E,OAAO;MACP,UAAU,SAAS,IAAI,CAAC,CAAC,GAAG,MAAM,GAAG;IAAA,CACxC;EAAA;AAEE,SAAA;AACX;AAGO,IAAM,qBAAqB;AAG3B,IAAM,qBAAqB;AAG3B,IAAM,mBAAmB;ACzUzB,SAAS,aAAa,aAA+B;AACxD,QAAM,kBAAkB,CAAC,GAAG,IAAI,IAAI,OAAO,OAAO,WAAW,EAAE,OAAO,CAAA,MAAK,OAAO,MAAM,QAAQ,CAAC,CAAC,EAAE,KAAK;AACnG,QAAA,aAAa,OAAO,YAAY,OAAO,QAAQ,WAAW,EAAE,MAAM,gBAAgB,MAAM,CAAC;AAIzF,QAAA,WAAW,OAAO,KAAK,UAAU;AACjC,QAAA,aAAa,OAAO,OAAO,UAAU;AAC3C,QAAM,eAAyB;IAC3B,GAAG,oBAAI,IAAI,CAAC,GAAG,UAAU,GAAG,WAAW,OAAO,CAAC,MAAmB,OAAO,MAAM,QAAQ,CAAC,CAAC;EAAA;AAG7F,SAAO,EAAE,UAAU,YAAY,YAAY,iBAAiB,aAAa;AAC7E;AAEO,SAAS,wBAAwB;EACpC;EACA;EACA;AACJ,GAIW;AACP,QAAM,aAAa,cAAc,YAAY,CAAA,UAAS,UAAU,OAAO;AACnE,MAAA,cAAc,EAAU,QAAA;AAC5B,SAAO,SAAS,UAAU,CAAO,QAAA,QAAQ,OAAO;AACpD;AAEO,SAAS,8BAA8B;EAC1C;EACA;EACA;EACA;AACJ,GAKW;AACP,MAAI,CAAC,2BAA2B;AAC5B,WAAO,iBAAiB,KAAK,gBAAgB,SAAS,SAAS,gBAAgB;EAAA;AAEnF,SAAO,cAAc,YAAY,CAAS,UAAA,UAAU,aAAa;AACrE;AAEA,SAAS,cAAiB,OAAiB,WAAmE;AAC1G,MAAI,IAAI,MAAM;AACd,SAAO,KAAK;AACR,QAAI,UAAU,MAAM,CAAC,GAAG,GAAG,KAAK,EAAU,QAAA;EAAA;AAEvC,SAAA;AACX;AAEO,SAAS,sBAAsB,QAA0B;AACxD,MAAA,OAAO,WAAW,EAAU,QAAA;AAChC,MAAI,QAA0B,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AACnD,QAAM,SAAmB,CAAA;AACzB,WAAS,QAAQ,GAAG,QAAQ,OAAO,QAAQ,SAAS;AAC1C,UAAA,QAAQ,OAAO,KAAK;AAC1B,QAAI,MAAM,CAAC,IAAI,MAAM,OAAO;AACxB,YAAM,CAAC,IAAI;IAAA,OACR;AACI,aAAA,KAAK,MAAM,CAAC,MAAM,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,CAAC,KAAK,GAAG,MAAM,CAAC,CAAC,IAAI,MAAM,CAAC,CAAC,EAAE;AACrE,cAAA,CAAC,OAAO,KAAK;IAAA;EACzB;AAEG,SAAA,KAAK,MAAM,CAAC,MAAM,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,CAAC,KAAK,GAAG,MAAM,CAAC,CAAC,IAAI,MAAM,CAAC,CAAC,EAAE;AACtE,SAAA,OAAO,KAAK,IAAI;AAC3B;ACOO,SAAS,eACZ,aACA,SAAyC,CAAA,GACd;AACrB,QAAA,SAAS,OAAO,QAAQG,aAAa;AACrC,QAAA,4BAA4B,OAAO,6BAA6B;AACtE,QAAM,EAAE,UAAU,YAAY,iBAAiB,aAAa,IAAI,aAAa,WAAW;AACxF,MAAI,6BAA6B,WAAW,KAAK,CAAA,UAAS,OAAO,UAAU,QAAQ,GAAG;AAC5E,UAAA,IAAIH,YAAY,wEAAwE;MAC1F,cAAc,WAAW,OAAO,CAAC,MAAmB,OAAO,MAAM,QAAQ;IAAA,CAC5E;EAAA;AAEEI,SAAAA,iBAAiB,QAAQ,CAAC,YAAwC;AACrE,UAAM,QAAQ,wBAAwB,EAAE,UAAU,YAAY,QAAA,CAAS;AACvE,QAAI,QAAQ,GAAG;AACL,YAAA,IAAIJ,YAAY,4CAA4C;QAC9D,0BAA0B,sBAAsB,eAAe;QAC/D;QACA;QACA;MAAA,CACH;IAAA;AAEE,WAAA,4BAA6B,WAAW,KAAK,IAAe;EAAA,CACtE;AACL;AA0CO,SAAS,eACZ,aACA,SAAyC,CAAA,GAChB;AACnB,QAAA,SAAS,OAAO,QAAQK,aAAa;AACrC,QAAA,4BAA4B,OAAO,6BAA6B;AACtE,QAAM,EAAE,UAAU,YAAY,gBAAgB,IAAI,aAAa,WAAW;AAC1E,MAAI,6BAA6B,WAAW,KAAK,CAAA,UAAS,OAAO,UAAU,QAAQ,GAAG;AAC5E,UAAA,IAAIL,YAAY,wEAAwE;MAC1F,cAAc,WAAW,OAAO,CAAC,MAAmB,OAAO,MAAM,QAAQ;IAAA,CAC5E;EAAA;AAEEM,SAAAA,iBAAiB,QAAQ,CAAC,UAA6C;AACpE,UAAA,gBAAgB,OAAO,KAAK;AAClC,UAAM,QAAQ,8BAA8B;MACxC;MACA;MACA;MACA;IAAA,CACH;AACD,QAAI,QAAQ,GAAG;AACL,YAAA,sBAAsB,4BACtB,kBACA,CAAC,GAAG,MAAM,SAAS,MAAM,EAAE,KAAA,CAAM;AACjC,YAAA,IAAIN,YAAY,uDAAuD;QACzE;QACA,8BAA8B,sBAAsB,mBAAmB;QACvE;MAAA,CACH;IAAA;AAEL,WAAO,WAAW,KAAK;EAAA,CAC1B;AACL;AAiGO,SAAS,aACZ,aACA,SAAuC,CAAA,GACI;AACpCF,SAAAA,aAAa,eAAe,aAAa,MAAM,GAAG,eAAe,aAAa,MAAM,CAAC;AAChG;AAGO,IAAM,uBAAuB;AAG7B,IAAM,uBAAuB;AAG7B,IAAM,qBAAqB;ACrQ3B,SAAS,uBACZ,SACA,kBACc;AACPM,SAAAA;IACH,gBAAgB,CAAC,GAAG,kBAAkB,OAAO,CAAC;IAC9C,CAAC,UAAiB,CAAC,GAAG,iBAAiB,IAAI,MAAM,MAAS,GAAG,KAAK;EAAA;AAE1E;AAsCO,SAAS,uBACZ,SACA,kBACY;AACLE,SAAAA;IACH,gBAAgB,CAAC,GAAG,kBAAkB,OAAO,CAAC;IAC9C,CAAS,UAAA,MAAM,MAAM,SAAS,CAAC;EAAA;AAEvC;AAgEO,SAAS,qBACZ,OACA,gBACiB;AACVR,SAAAA,aAAa,uBAAuB,OAAO,cAAc,GAAG,uBAAuB,OAAO,cAAc,CAAC;AACpH;AC3HO,SAAS,uBACZ,SACA,kBACc;AACPM,SAAAA;IACH,gBAAgB,CAAC,SAAS,GAAG,gBAAgB,CAAC;IAC9C,CAAC,UAAiB,CAAC,OAAO,GAAG,iBAAiB,IAAI,MAAM,MAAS,CAAC;EAAA;AAE1E;AAsCO,SAAS,uBACZ,SACA,kBACY;AACLE,SAAAA;IACH,gBAAgB,CAAC,SAAS,GAAG,gBAAgB,CAAC;IAC9C,CAAA,UAAS,MAAM,CAAC;EAAA;AAExB;AAgEO,SAAS,qBACZ,OACA,gBACiB;AACVR,SAAAA,aAAa,uBAAuB,OAAO,cAAc,GAAG,uBAAuB,OAAO,cAAc,CAAC;AACpH;AC3FO,SAAS,uBACZ,UACA,SAAiD,CAAA,GACV;AACjC,QAAA,gBAAgB,OAAO,QAAQK,aAAa;AAC3CC,SAAAA,iBAAiB,eAAe,CAAW,YAAA;AACxC,UAAA,QAAQ,SAAS,QAAQ,OAAO;AACtC,QAAI,QAAQ,GAAG;AACL,YAAA,IAAIJ,YAAY,qDAAqD;QACvE,OAAO;QACP;MAAA,CACH;IAAA;AAEE,WAAA;EAAA,CACV;AACL;AAwCO,SAAS,uBACZ,UACA,SAAiD,CAAA,GACV;AACjC,QAAA,gBAAgB,OAAO,QAAQK,aAAa;AAC3CC,SAAAA,iBAAiB,eAAe,CAAC,UAA2B;AAC/D,QAAI,QAAQ,KAAK,SAAS,SAAS,QAAQ;AACjC,YAAA,IAAIN,YAAY,gEAAgE;QAClF,eAAe;QACf,UAAU,SAAS,SAAS;QAC5B,UAAU;MAAA,CACb;IAAA;AAEE,WAAA,SAAS,OAAO,KAAK,CAAC;EAAA,CAChC;AACL;AAqFO,SAAS,qBACZ,UACA,SAA+C,CAAA,GACV;AAC9BF,SAAAA,aAAa,uBAAuB,UAAU,MAAM,GAAG,uBAAuB,UAAU,MAAM,CAAC;AAC1G;AClKO,SAAS,cACZ,KACA,OACA,SAAwC,CAAA,GACN;AAC3BM,SAAAA;IACH,gBAAgB,gBAAgB,CAAC,KAAK,KAAK,CAAC,GAAG,MAAgB;IAC/D,CAAC,QAA6D,CAAC,GAAG,IAAI,QAAA,CAAS;EAAA;AAEvF;AA8CO,SAAS,cACZ,KACA,OACA,SAAwC,CAAA,GACV;AACvBE,SAAAA;IACH,gBAAgB,gBAAgB,CAAC,KAAK,KAAK,CAAC,GAAG,MAAgB;IAC/D,CAAC,YAAyD,IAAI,IAAI,OAAO;EAAA;AAEjF;AA2HO,SAAS,YAMZ,KACA,OACA,SAAsC,CAAA,GACiB;AAChDR,SAAAA,aAAa,cAAc,KAAK,OAAO,MAAgB,GAAG,cAAc,KAAK,OAAO,MAAgB,CAAC;AAChH;AC/PO,SAAS,iBAA4C;AACxD,SAAOF,cAAc;IACjB,WAAW;IACX,OAAO,CAAC,QAAQ,QAAQ,WAAW;EAAA,CACtC;AACL;AAqBO,SAAS,iBAA4C;AACxD,SAAOC,cAAc;IACjB,WAAW;IACX,MAAM,CAAC,QAAyC,WAAW,CAAC,QAAW,MAAM;EAAA,CAChF;AACL;AAgDO,SAAS,eAA8C;AAC1D,SAAOC,aAAa,eAAA,GAAkB,eAAA,CAAgB;AAC1D;ACQO,SAAS,mBACZ,MACA,SAA6C,CAAA,GACxB;AACrB,QAAM,UAAU,MAAM;AACd,QAAA,OAAO,WAAW,MAAM;AACxB,aAAOM,iBAAiB,eAAA,GAAkB,CAAC,aAAsB,MAAS;IAAA;AAE9E,WAAO,kBAAkB,EAAE,MAAM,OAAO,UAAUD,aAAAA,EAAAA,CAAgB;EAAA,GACnE;AACH,QAAM,aAAa,MAAM;AACjB,QAAA,OAAO,cAAc,UAAU;AAC/B,wBAAkB,IAAI;AACtB,aAAO,eAAe,eAAA,GAAkB,KAAK,SAAS;IAAA;AAEtD,QAAA,CAAC,OAAO,WAAW;AACnB,aAAO,eAAe;IAAA;AAEnB,WAAA,mBAAmB,OAAO,SAAS;EAAA,GAC3C;AAEI,SAAA;IACH;MACIC,iBAAiB,gBAAgB,CAAC,QAAQ,SAAS,CAAC,GAAG,CAAC,WAAkC;QACtF;QACA;MAAA,CACH;MACDA,iBAAiB,gBAAgB,CAAC,QAAQ,IAAI,CAAC,GAAG,CAAC,UAAmC,CAAC,MAAM,KAAK,CAAC;IAAA;IAEvG,CAAA,YAAW,OAAO,YAAY,IAAI;EAAA;AAE1C;AA6CO,SAAS,mBACZ,MACA,SAA6C,CAAA,GAC1B;AACnB,QAAM,UAAU,MAAM;AACd,QAAA,OAAO,WAAW,MAAM;AACxB,aAAOE,iBAAiB,eAAA,GAAkB,MAAM,KAAK;IAAA;AAEzD,WAAO,kBAAkB,EAAE,MAAM,OAAO,UAAUD,aAAAA,EAAAA,CAAgB;EAAA,GACnE;AACH,QAAM,aAAa,MAAM;AACjB,QAAA,OAAO,cAAc,UAAU;AAC/B,wBAAkB,IAAI;AACtB,aAAO,eAAe,eAAA,GAAkB,KAAK,SAAS;IAAA;AAEtD,QAAA,CAAC,OAAO,WAAW;AACnB,aAAO,eAAe;IAAA;AAEnB,WAAA,mBAAmB,OAAO,SAAS;EAAA,GAC3C;AAEI,SAAA;IACH;MACIC,iBAAiB,gBAAgB,CAAC,QAAQ,SAAS,CAAC,GAAG,MAAM,IAAI;MACjEA,iBAAiB,gBAAgB,CAAC,QAAQ,IAAI,CAAC,GAAG,CAAC,CAAA,EAAG,KAAK,MAAW,KAAK;IAAA;IAE/E,CAAC,OAAO,WAAW;AACf,UAAI,OAAO,WAAW,QAAQ,CAAC,OAAO,WAAW;AACtC,eAAA,OAAO,SAAS,MAAM,MAAM;MAAA;AAEvC,UAAI,OAAO,WAAW,QAAQ,OAAO,aAAa,MAAM;AACpD,cAAM,YACF,OAAO,cAAc,WAAW,IAAI,WAAW,UAAU,SAAS,EAAE,KAAK,CAAC,IAAI,OAAO;AACzF,eAAOC,cAAc,OAAO,WAAW,MAAM,IAAI,IAAI;MAAA;AAEzD,aAAO,OAAO,OAAO,KAAK,OAAO,MAAM,EAAE,CAAC,CAAC;IAAA;EAC/C;AAER;AAkHO,SAAS,iBACZ,MACA,SAA2C,CAAA,GACZ;AAExBT,SAAAA;IACH,mBAA0B,MAAM,MAAoB;IACpD,mBAAwB,MAAM,MAAoB;EAAA;AAE1D;ACvRO,SAAS,cACZ,MACA,SAAwC,CAAA,GACrB;AACZM,SAAAA,iBAAiB,gBAAgB,MAAM,MAAgB,GAAG,CAAC,QAA6B,CAAC,GAAG,GAAG,CAAC;AAC3G;AAsCO,SAAS,cAAmB,MAAoB,SAAwC,CAAA,GAAuB;AAC3GE,SAAAA,iBAAiB,gBAAgB,MAAM,MAAgB,GAAG,CAAC,YAA6B,IAAI,IAAI,OAAO,CAAC;AACnH;AA+EO,SAAS,YACZ,MACA,SAAsC,CAAA,GACX;AACpBR,SAAAA,aAAa,cAAc,MAAM,MAAgB,GAAG,cAAc,MAAM,MAAgB,CAAC;AACpG;ACnHO,SAAS,iBACZ,QAC0C;AAEpC,QAAA,cAAc,OAAO,IAAI,CAAC,CAAA,EAAG,KAAK,MAAM,KAAK;AACnD,QAAM,YAAY,cAAc,YAAY,IAAI,YAAY,CAAC;AAC7D,QAAM,UAAU,cAAc,YAAY,IAAI,UAAU,CAAC,KAAK;AAE9D,SAAOF,cAAc;IACjB,GAAI,cAAc,OACZ;MACI,kBAAkB,CAAC,UACf,OACK,IAAI,CAAC,CAAC,KAAK,KAAK,MAAMK,eAAe,MAAM,GAAkB,GAAG,KAAK,CAAC,EACtE,OAAO,CAAC,KAAK,QAAQ,MAAM,KAAK,CAAC;MAC1C;IAAA,IAEJ,EAAE,UAAU;IAClB,OAAO,CAAC,QAAe,OAAO,WAAW;AACrC,aAAO,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AAC7B,iBAAS,MAAM,MAAM,OAAO,GAAkB,GAAG,OAAO,MAAM;MAAA,CACjE;AACM,aAAA;IAAA;EACX,CACH;AACL;AAqCO,SAAS,iBACZ,QAC0C;AAEpC,QAAA,cAAc,OAAO,IAAI,CAAC,CAAA,EAAG,KAAK,MAAM,KAAK;AACnD,QAAM,YAAY,cAAc,YAAY,IAAI,YAAY,CAAC;AAC7D,QAAM,UAAU,cAAc,YAAY,IAAI,UAAU,CAAC,KAAK;AAE9D,SAAOJ,cAAc;IACjB,GAAI,cAAc,OAAO,EAAE,QAAQ,IAAI,EAAE,UAAU;IACnD,MAAM,CAAC,OAAwC,WAAW;AACtD,YAAM,SAAS,CAAA;AACf,aAAO,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AAC7B,cAAM,CAAC,OAAO,SAAS,IAAI,MAAM,KAAK,OAAO,MAAM;AAC1C,iBAAA;AACT,eAAO,GAAgB,IAAI;MAAA,CAC9B;AACM,aAAA,CAAC,QAAQ,MAAM;IAAA;EAC1B,CACH;AACL;AA2DO,SAAS,eACZ,QAC+G;AACxGC,SAAAA;IACH,iBAAiB,MAAM;IACvB,iBAAiB,MAAM;EAAA;AAE/B;A;;;AClGO,IAAM,OAAO,CAAI,WAAyB,EAAE,UAAU,QAAQ,MAAM;AAuBpE,IAAM,OAAO,OAAqB,EAAE,UAAU,OAAO;AAwBrD,IAAM,WAAW,CAAc,UAClC,CAAC,EACG,SACA,OAAO,UAAU,YACjB,cAAc,UACZ,MAAM,aAAa,UAAU,WAAW,SAAU,MAAM,aAAa;AAuBxE,IAAM,SAAS,CAAI,WAAyC,OAAO,aAAa;AAsBhF,IAAM,SAAS,CAAI,WAAsC,OAAO,aAAa;ACzM7E,SAAS,aAA0B,QAAmB,UAA2B;AACpF,MAAI,OAAO,MAAM,EAAG,QAAO,OAAO;AAC3B,SAAA,WAAW,SAAA,IAAc;AACpC;AAwBa,IAAA,eAAe,CAAI,aAAmC,aAAa,OAAO,KAAK,QAAQ,IAAI,KAAQ;AC6EzG,SAAS,iBACZ,MACA,SAA2C,CAAA,GACX;AAChC,QAAM,UAAU,MAAM;AACd,QAAA,OAAO,WAAW,MAAM;AACxB,aAAO,iBAAiB,eAAA,GAAkB,CAAC,aAAsB,MAAS;IAAA;AAE9E,WAAO,kBAAkB,EAAE,MAAM,OAAO,UAAU,aAAA,EAAA,CAAgB;EAAA,GACnE;AACH,QAAM,aAAa,MAAM;AACjB,QAAA,OAAO,cAAc,UAAU;AAC/B,wBAAkB,IAAI;AACtB,aAAO,eAAe,eAAA,GAAkB,KAAK,SAAS;IAAA;AAEtD,QAAA,CAAC,OAAO,WAAW;AACnB,aAAO,eAAe;IAAA;AAEnB,WAAA,mBAAmB,OAAO,SAAS;EAAA,GAC3C;AAEI,SAAA;IACH;MACI,iBAAiB,gBAAgB,CAAC,QAAQ,SAAS,CAAC,GAAG,CAAC,WAAyC;QAC7F;QACA;MAAA,CACH;MACD,iBAAiB,gBAAgB,CAAC,QAAQ,IAAI,CAAC,GAAG,CAAC,UAAiD;QAChG;QACA,SAAS,KAAK,KAAK,OAAO,KAAK,IAAI,MAAM,QAAQ;MAAA,CACpD;IAAA;IAEL,CAAW,YAAA;AACP,YAAM,SAAS,SAAgB,OAAO,IAAI,UAAU,aAAa,OAAO;AACjE,aAAA,OAAO,OAAO,MAAM,CAAC;IAAA;EAChC;AAER;AAmDO,SAAS,iBACZ,MACA,SAA2C,CAAA,GACvB;AACpB,QAAM,UAAU,MAAM;AACd,QAAA,OAAO,WAAW,MAAM;AACxB,aAAO,iBAAiB,eAAA,GAAkB,MAAM,KAAK;IAAA;AAEzD,WAAO,kBAAkB,EAAE,MAAM,OAAO,UAAU,aAAA,EAAA,CAAgB;EAAA,GACnE;AACH,QAAM,aAAa,MAAM;AACjB,QAAA,OAAO,cAAc,UAAU;AAC/B,wBAAkB,IAAI;AACtB,aAAO,eAAe,eAAA,GAAkB,KAAK,SAAS;IAAA;AAEtD,QAAA,CAAC,OAAO,WAAW;AACnB,aAAO,eAAe;IAAA;AAEnB,WAAA,mBAAmB,OAAO,SAAS;EAAA,GAC3C;AAEI,SAAA;IACH;MACI,iBAAiB,gBAAgB,CAAC,QAAQ,SAAS,CAAC,GAAG,MAAM,KAAA,CAAW;MACxE,iBAAiB,gBAAgB,CAAC,QAAQ,IAAI,CAAC,GAAG,CAAC,CAAA,EAAG,KAAK,MAAM,KAAK,KAAK,CAAC;IAAA;IAEhF,CAAC,OAAO,WAAW;AACf,UAAI,OAAO,WAAW,QAAQ,CAAC,OAAO,WAAW;AACtC,eAAA,OAAO,SAAS,MAAM,MAAM;MAAA;AAEvC,UAAI,OAAO,WAAW,QAAQ,OAAO,aAAa,MAAM;AACpD,cAAM,YACF,OAAO,cAAc,WAAW,IAAI,WAAW,UAAU,SAAS,EAAE,KAAK,CAAC,IAAI,OAAO;AACzF,eAAO,cAAc,OAAO,WAAW,MAAM,IAAI,IAAI;MAAA;AAEzD,aAAO,OAAO,OAAO,KAAK,OAAO,MAAM,EAAE,CAAC,CAAC;IAAA;EAC/C;AAER;AA0HO,SAAS,eACZ,MACA,SAAyC,CAAA,GACE;AAEpC,SAAA;IACH,iBAAwB,MAAM,MAAoB;IAClD,iBAAsB,MAAM,MAAoB;EAAA;AAExD;AC/QO,SAAS,wBAAqC,OAAU,UAA2C;AAEtG,MAAI,CAAC,SAAS,YAAY,OAAO,KAAK,GAAG;AAC9B,WAAA;EAAA;AAGL,QAAA,OAAO,CAAI,MACZ,WAAW,wBAAwB,GAAG,QAAQ,IAAI,wBAAwB,CAAC;AAG5E,MAAA,SAAS,KAAK,GAAG;AACjB,QAAI,OAAO,KAAK,EAAU,QAAA,KAAK,MAAM,KAAK;AAClC,WAAA,WAAW,SAAA,IAAa;EAAA;AAIhC,MAAA,MAAM,QAAQ,KAAK,GAAG;AACf,WAAA,MAAM,IAAI,IAAI;EAAA;AAErB,MAAA,OAAO,UAAU,UAAU;AAC3B,WAAO,OAAO,YAAY,OAAO,QAAQ,KAAK,EAAE,IAAI,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;EAAA;AAE1E,SAAA;AACX;;;;ACoFO,SAAS,KAAe,SAAmB,KAAyB;AAChE,SAAA,IAAI,OAAO,CAAC,KAAK,OAAO,GAAG,GAAG,GAAG,IAAI;AAChD;A;;;AC7LO,SAAS,wBACZ,aACA,gBAC0E;AAC1E,SAAO,YAAY,mBAAmB;AAC1C;AAEO,SAAS,8BACZ,aACA,gBACkF;AAC9E,MAAA,YAAY,mBAAmB,gBAAgB;AACzC,UAAA,IAAI,YAAY,gDAAgD;MAClE,sBAAsB,YAAY;MAClC,wBAAwB;IAAA,CAC3B;EAAA;AAET;AAEO,SAAS,0BAGd,aAA6F;AAC3F,SAAO,YAAY,aAAa;AACpC;AAEO,SAAS,gCAGd,aAAqG;AAC/F,MAAA,YAAY,aAAa,QAAW;AAC9B,UAAA,IAAI,YAAY,sDAAsD;MACxE,MAAM,YAAY;MAClB,gBAAgB,YAAY;IAAA,CAC/B;EAAA;AAET;AA4BO,SAAS,sBAGd,aAAqF;AACnF,SAAO,YAAY,SAAS;AAChC;AAEO,SAAS,4BAGd,aAA6F;AACvF,MAAA,YAAY,SAAS,QAAW;AAC1B,UAAA,IAAI,YAAY,kDAAkD;MACpE,kBAAkB,YAAY,UAAU,IAAI,CAAA,MAAK,EAAE,OAAO;MAC1D,gBAAgB,YAAY;IAAA,CAC/B;EAAA;AAET;ACjHY,IAAA,eAAA,CAAAU,iBAAL;AAEHA,eAAA,aAAA,iBAAA;EAA0B,CAA1B,IAAA;AACAA,eAAA,aAAA,iBAAA;EAA0B,CAA1B,IAAA;AACAA,eAAA,aAAA,UAAA;EAA0B,CAA1B,IAAA;AACAA,eAAA,aAAA,UAAA;EAA0B,CAA1B,IAAA;AALQA,SAAAA;AAAA,GAAA,eAAA,CAAA,CAAA;AASZ,IAAM,oBAAoB;AAC1B,IAAM,sBAAsB;AAQrB,SAAS,yBAAyB,MAAgC;AACrE,SAAO,OAAO;AAClB;AAQO,SAAS,wBAAwB,MAAgC;AACpE,SAAO,OAAO;AAClB;AAMO,SAAS,aAAa,MAAsF;AAC/G,SAAO,QAAQ;AACnB;AAMO,SAAS,eAAe,MAA+E;AAC1G,UAAQ,OAAO,yBAAyB;AAC5C;AAsBO,SAAS,WAAW,OAAoB,OAAiC;AAC5E,SAAO,QAAQ;AACnB;AAQO,SAAS,oBAAoB,MAAgC;AAChE,SAAO,OAAO;AAClB;AAQO,SAAS,sBAAsB,MAAgC;AAClE,SAAO,OAAO;AAClB;A;;;ACxGO,IAAM;;;EAGT,OAAO,OAAO,EAAE,MAAM,UAAA,CAAW;;ACErC,SAAS,eAAe,OAA+C;AAEnE,SAAO,IAAI,WAAW;;;;IAIlB;;IACA;;IAEI;;IACA;;IACI;;IAEJ;;IACA;;IACI;;IACA;;;IAEQ;;IACA;;;IAEA;;;;;IAKhB;;IACA;;;IAGI;;IACA;;IAEJ,GAAG;EAAA,CACN;AACL;AAoBA,eAAsB,0BAClB,OACA,cAAuB,OACL;AAClB,QAAM,eAAe,MAAM;AAC3B,MAAI,iBAAiB,IAAI;AACf,UAAA,IAAI,YAAY,qDAAqD;MACvE;IAAA,CACH;EAAA;AAEC,QAAA,uBAAuB,eAAe,KAAK;AACjD,SAAO,MAAM,OAAO,OAAO,UAAU,SAAS,sBAAsB,8BAA8B,aAAa;IAC3G;EAAA,CACH;AACL;ACpDA,eAAsB,2BAClB,YACA,cAAuB,OACL;AACW,+BAAA;AAEzB,MAAA,WAAW,gBAAgB,OAAO;AAClC,UAAM,IAAIC,YAAY,gEAAgE,EAAE,KAAK,WAAA,CAAY;EAAA;AAI7G,QAAM,MAAM,MAAM,OAAO,OAAO,UAAU,OAAO,UAAU;AAGpD,SAAA,MAAM,OAAO,OAAO;IACvB;IACA;MACI,KAAiB;MACjB,KAAuB;MACvB,SAA8B,CAAC,QAAQ;MACvC,KAAoB;MACpB,GAAiC,IAAI;IAAA;IAEzC;IACA;IACA,CAAC,QAAQ;EAAA;AAEjB;ACxBA,IAAI;AA8BG,SAAS,kBAAkB,mBAAmE;AAC7F,MAAA,CAAC,cAAe,iBAAgB,iBAAiB;AAErD;;IAEI,kBAAkB,SAAS;IAE3B,kBAAkB,SAAS;IAC7B;AACQ,UAAA,IAAIA,YAAY,0DAA0D;MAC5E,cAAc,kBAAkB;IAAA,CACnC;EAAA;AAGC,QAAA,QAAQ,cAAc,OAAO,iBAAiB;AACpD,QAAM,WAAW,MAAM;AACvB,MAAI,aAAa,IAAI;AACX,UAAA,IAAIA,YAAY,mDAAmD;MACrE,cAAc;IAAA,CACjB;EAAA;AAET;AAsBO,SAAS,YAAY,mBAA2D;AAC/E,MAAA,CAAC,cAAe,iBAAgB,iBAAiB;AAGrD;;IAEI,kBAAkB,SAAS;IAE3B,kBAAkB,SAAS;IAC7B;AACS,WAAA;EAAA;AAGL,QAAA,QAAQ,cAAc,OAAO,iBAAiB;AACpD,QAAM,WAAW,MAAM;AACvB,MAAI,aAAa,IAAI;AACV,WAAA;EAAA;AAEJ,SAAA;AACX;AAeA,eAAsB,UAAU,KAAgB,MAAmD;AAC5D,qCAAA;AACnC,QAAM,aAAa,MAAM,OAAO,OAAO,KAAK,8BAA8B,KAAK,IAAI;AAC5E,SAAA,IAAI,WAAW,UAAU;AACpC;AAgBO,SAAS,UAAU,mBAAsC;AAC5D,oBAAkB,iBAAiB;AAC5B,SAAA;AACX;AAkBA,eAAsB,gBAClB,KACAC,YACA,MACgB;AACwB,0CAAA;AACxC,SAAO,MAAM,OAAO,OAAO,OAAO,8BAA8B,KAAKA,YAAW,IAAI;AACxF;AC5JA,eAAsB,kBAA0C;AAC5D,QAAM,+BAA+B;AAC/B,QAAA,UAAU,MAAM,OAAO,OAAO;;IAChB;;;IACE;;;IACC,CAAC,QAAQ,QAAQ;EAAA;AAEjC,SAAA;AACX;AA0BA,eAAsB,uBAClB,OACA,cAAuB,OACD;AACA,wBAAA;AAElB,MAAA,MAAM,eAAe,IAAI;AACzB,UAAM,IAAID,YAAY,kDAAkD,EAAE,YAAY,MAAM,WAAA,CAAY;EAAA;AAE5G,QAAM,CAAC,WAAW,UAAU,IAAI,MAAM,QAAQ,IAAI;IAC9C,OAAO,OAAO;MAAU;MAAO,MAAM,MAAM,EAAE;MAAG;;MAAgD;MAAM;QAClG;MAAA;IACJ;IACA,0BAA0B,MAAM,MAAM,GAAG,EAAE,GAAG,WAAW;EAAA,CAC5D;AAGK,QAAA,cAAc,IAAI,WAAW,EAAE;AACrC,SAAO,gBAAgB,WAAW;AAClC,QAAM,aAAa,MAAM,UAAU,YAAY,WAAW;AAC1D,QAAM,UAAU,MAAM,gBAAgB,WAAW,YAAY,WAAW;AACxE,MAAI,CAAC,SAAS;AACJ,UAAA,IAAIA,YAAY,qDAAqD;EAAA;AAGxE,SAAA,EAAE,YAAY,UAAU;AACnC;AAiCA,eAAsB,iCAClB,OACA,cAAuB,OACD;AAChB,QAAA,oBAAoB,0BAA0B,OAAO,WAAW;AAOtE,QAAM,CAAC,WAAW,UAAU,IAAI,MAAM,QAAQ,IAAI;;;;KAI7C,cAAc,oBAAoB;MAA0B;MAAO;;IAAA,GAAyB;MACzF,OAAME,gBAAc,MAAM;QAA2BA;QAAY;;MAAA;IAAsB;IAE3F;EAAA,CACH;AAEM,SAAA,EAAE,YAAY,UAAU;AACnC;A;;;AC7GO,SAAS,eACZ,OACA,oBACA,gBACA,MAE4D;AAC5D,MAAI,CAAC,cAAc,OAAO,uCAAuC,GAAG;AACzD,WAAA;EAAA;AAEX,QAAM,4BAA4B,mBAAmB,aAAa,MAAM,QAAQ,KAAK,GAAG;AACpF,MAAA,CAAC,6BAA6B,8BAA8B,gBAAgB;AACrE,WAAA;EAAA;AAEX,SAAO,OAAO,SAAS,eAAe,MAAM,QAAQ,SAAS;AACjE;A;;;;;;;;;;;;ACxCO,SAAS,qBAAqB,MAAuB;AACxD,SAAO,KAAK,MAAM,gCAAgC,IAAI,GAAG,CAAC,GAAG,UAAU;AACnE,WAAO,oBAAoB,KAAK,IAAI,wBAAwB,KAAK,IAAI;EAAA,CACxE;AACL;AAEA,SAAS,gCAAgC,MAAsB;AAC3D,QAAM,MAAM,CAAA;AACZ,MAAI,UAAU;AACd,WAAS,KAAK,GAAG,KAAK,KAAK,QAAQ,MAAM;AACrC,QAAI,YAAY;AACZ,QAAA,KAAK,EAAE,MAAM,MAAM;AACf,UAAA,KAAK,KAAK,IAAI,CAAC;AACnB,kBAAY,CAAC;IAAA;AAEb,QAAA,KAAK,EAAE,MAAM,KAAK;AACd,UAAA,KAAK,KAAK,EAAE,CAAC;AACjB,UAAI,CAAC,WAAW;AACZ,kBAAU,CAAC;MAAA;AAEf;IAAA;AAEJ,QAAI,CAAC,SAAS;AACJ,YAAA,iBAAiB,cAAc,MAAM,EAAE;AAC7C,UAAI,gBAAgB,QAAQ;AACxB,cAAM,eAAe,SAAS;AAE1B,YAAA,eAAe,MAAM,UAAU,GAAG;AAClC,cAAI,KAAK,cAAc;QAAA,OACpB;AACC,cAAA,KAAK,sBAAsB,cAAc,CAAC;QAAA;AAElD;MAAA;IACJ;AAEA,QAAA,KAAK,KAAK,EAAE,CAAC;EAAA;AAGd,SAAA,IAAI,KAAK,EAAE;AACtB;AAEA,SAAS,cAAc,MAAc,IAA2B;AAE5D,QAAM,oBAAoB;AAG1B,MAAI,CAAC,KAAK,EAAE,GAAG,MAAM,OAAO,GAAG;AACpB,WAAA;EAAA;AAIX,QAAM,cAAc,KAAK,MAAM,EAAE,EAAE,MAAM,iBAAiB;AACnD,SAAA,cAAc,YAAY,CAAC,IAAI;AAC1C;AAQA,SAAS,sBAAsB,OAAuB;AAClD,SAAO,UAAU,KAAK;AAC1B;AAEA,SAAS,wBAAwB,EAAE,GAAA,GAAiC;AAC5D,MAAA,GAAG,MAAM,MAAM,GAAG;AAClB,UAAM,CAAC,OAAO,QAAQ,IAAI,GAAG,MAAM,MAAM;AACzC,WAAO,OAAO,KAAK,IAAI,OAAO,EAAE,KAAK,OAAO,QAAQ;EAAA;AAExD,SAAO,OAAO,EAAE;AACpB;AAEA,SAAS,oBAAoB,OAA4C;AAC9D,SAAA,CAAC,CAAC,SAAS,OAAO,UAAU,YAAY,QAAQ,SAAS,OAAO,MAAM,OAAO;AACxF;AC9EA,IAAI,iBAAiB;AACrB,SAAS,mBAA2B;AAChC,QAAM,KAAK;AACX;AACA,SAAO,GAAG,SAAS;AACvB;AAOO,SAAS,iBAA0B,SAA8B;AAC7D,SAAA;IACH,IAAI,iBAAiB;IACrB,SAAS;IACT,QAAQ,QAAQ;IAChB,QAAQ,QAAQ;EAAA;AAExB;AClBO,SAAS,yBAAyB,OAAgB,OAAiC;AAC/EC,SAAAA;IACH,KAAK,UAAU,OAAO,CAAC,GAAG,MAAO,OAAO,MAAM,WAAWC,uBAAsB,CAAC,IAAI,GAAI,KAAK;EAAA;AAErG;AAQA,SAASA,uBAAsB,OAAkC;AAC7D,SAAO,EAAE,IAAI,GAAG,KAAK,GAAG;AAC5B;AAEA,SAASD,yBAAwB,OAAuB;AAC7C,SAAA,MAAM,QAAQ,oCAAoC,IAAI;AACjE;;;ACoCO,SAAS,UACZ,WACgB;AAChB,SAAO,UAAU,SAAS;AAC9B;AAEA,SAAS,UACL,WACgB;AACT,SAAA,IAAI,MAAM,UAAU,KAAK;IAC5B,iBAAiB;AACN,aAAA;IAAA;IAEX,iBAAiB;AACN,aAAA;IAAA;IAEX,IAAI,QAAQ,GAAG,UAAU;AACrB,UAAI,MAAM,QAAQ;AACP,eAAA;MAAA;AAEX,aAAO,YAAa,WAAsB;AAChC,cAAA,aAAa,EAAE,SAAS;AAC9B,cAAM,aAAa,QAAQ,IAAI,QAAQ,YAAY,QAAQ;AAC3D,YAAI,CAAC,YAAY;AACP,gBAAA,IAAI,YAAY,oDAAoD;YACtE,QAAQ;YACR,QAAQ;UAAA,CACX;QAAA;AAEC,cAAA,UAAU,WAAW,GAAG,SAAS;AAChC,eAAA,wBAAwB,WAAW,OAAO;MAAA;IACrD;EACJ,CACH;AACL;AAEA,SAAS,wBACL,EAAE,UAAU,GACZ,MAC4B;AACrB,SAAA;IACH,MAAM,KAAK,SAA8C;AAC9C,aAAA,MAAM,KAAK,QAAQ,EAAE,QAAQ,SAAS,aAAa,UAAA,CAAW;IAAA;EACzE;AAER;ACAO,SAAS,iBAAoD,QAA4C;AACrG,SAAA,IAAI,MAAM,CAAA,GAA2B;IACxC,iBAAiB;AACN,aAAA;IAAA;IAEX,iBAAiB;AACN,aAAA;IAAA;IAEX,OACO,MACL;AACQ,YAAA,CAAC,GAAG,CAAC,IAAI;AACT,YAAA,aAAa,EAAE,SAAS;AAC9B,aAAO,YACA,WAG0C;AAC7C,cAAM,aAAa,OAAO,OAAO,EAAE,YAAY,QAAQ,UAAA,CAAW;AAClE,cAAM,UAAU,QAAQ,qBAAqB,QAAQ,mBAAmB,UAAU,IAAI;AACtF,eAAO,OAAO,OAAsD;UAChE,SAAS,OAAO,EAAE,QAAQ,UAAA,MAAgB;AAChC,kBAAA,UAAU,iBAAiB,OAAO;AACxC,kBAAM,WAAW,MAAM,UAAU,EAAE,SAAS,OAAA,CAAQ;AAChD,gBAAA,CAAC,QAAQ,qBAAqB;AACvB,qBAAA;YAAA;AAEJ,mBAAA,OAAO,oBAAoB,UAAU,OAAO;UAAA;QACvD,CACH;MAAA;IACL;EACJ,CACH;AACL;AChGO,SAAS,iBAAiB,SAI9B;AACK,MAAA,WAAW,QAAQ,OAAO,YAAY,YAAY,MAAM,QAAQ,OAAO,GAAG;AACnE,WAAA;EAAA;AAGP,SAAA,aAAa,WACb,QAAQ,YAAY,SACpB,YAAY,WACZ,OAAO,QAAQ,WAAW,YAC1B,YAAY;AAEpB;A;;;ACpDO,SAAS,6BAA6B,OAAyB;AAClE,SAAO,OAAO,UAAU;;;;IAIlB,OAAO,KAAK;MACZ;AACV;ACJO,IAAM,mBAAmB,CAAA;AAOhC,SAAS,cAAc,UAAyB;AACrC,SAAA,SAAS,SAAwC,MAAe,OAAwB;AACvF,QAAA,MAAM,QAAQ,IAAI,GAAG;AACrB,aAAO,KAAK,IAAI,CAAC,SAAS,OAAO;AAC7B,cAAM,YAAY;UACd,GAAG;UACH,SAAS,CAAC,GAAG,MAAM,SAAS,EAAE;QAAA;AAE3B,eAAA,SAAS,SAAS,SAAS;MAAA,CACrC;IAAA,WACM,OAAO,SAAS,YAAY,SAAS,MAAM;AAClD,YAAM,MAAiD,CAAA;AACvD,iBAAW,YAAY,MAAM;AACzB,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,MAAM,QAAQ,GAAG;AACvD;QAAA;AAEJ,cAAM,YAAY;UACd,GAAG;UACH,SAAS,CAAC,GAAG,MAAM,SAAS,QAAQ;QAAA;AAExC,YAAI,QAAQ,IAAI,SAAS,KAAK,QAA6B,GAAG,SAAS;MAAA;AAEpE,aAAA;IAAA,OACJ;AACI,aAAA,SAAS,OAAO,CAAC,KAAK,cAAc,UAAU,KAAK,KAAK,GAAG,IAAI;IAAA;EAC1E;AAER;AAqBO,SAAS,gCACZ,UACA,cACqB;AACrB,SAAO,CAAU,YAA6C;AACpD,UAAA,WAAW,cAAc,QAAQ;AACvC,WAAO,OAAO,OAAO;MACjB,GAAG;MACH,QAAQ,SAAS,QAAQ,QAAQ,YAAY;IAAA,CAChD;EAAA;AAET;AAEO,SAAS,iCACZ,UACA,cACsB;AACtB,SAAO,CAAQ,SAAA,cAAc,QAAQ,EAAE,MAAM,YAAY;AAC7D;AChEO,SAAS,sCAAsC;AAC3C,SAAA,gCAAgC,CAAC,4BAA4B,GAAG,EAAE,SAAS,CAAA,EAAA,CAAI;AAC1F;ACdO,SAAS,uBAAuB;EACnC;EACA;EACA;EACA;AACJ,GAKI;AACM,QAAA,wBAAwB,OAAO,6BAA6B;AAClE;;IAEI,0BAA0B;IAEzB,yBAAyB,OAAO,0BAA0B,YAAY,CAAC,MAAM,QAAQ,qBAAqB;IAC7G;AACE;;MAEI,yBACA,0BAA0B;MAC5B;AACE,UACI,CAAC,sBAAsB,sBAA4D,KACnF,sBAAsB,sBAA4D,MAAM,aAC1F;AAEQ,cAAA,aAAa,CAAC,GAAG,MAAM;AACvB,cAAA;UACF,CAAC,sBAA4D,GAAG;;UAChE,GAAG;QAAA,IACH;AACJ,YAAI,OAAO,KAAK,IAAI,EAAE,SAAS,GAAG;AAC9B,qBAAW,6BAA6B,IAAI;QAAA,OACzC;AACC,cAAA,kCAAkC,WAAW,SAAS,GAAG;AAC9C,uBAAA;UAAA,OACR;AACH,uBAAW,6BAA6B,IAAI;UAAA;QAChD;AAEG,eAAA;MAAA;IACX,WACO,uBAAuB,aAAa;AAErC,YAAA,aAAa,CAAC,GAAG,MAAM;AAC7B,iBAAW,6BAA6B,IAAI;QACxC,GAAG;QACH,CAAC,sBAAsB,GAAG;MAAA;AAEvB,aAAA;IAAA;EACX;AAEG,SAAA;AACX;ACtCO,SAAS,uCAAuC;EACnD;EACA;AACJ,GAG2B;AACvB,SAAO,CAAU,YAA6C;AACpD,UAAA,EAAE,QAAQ,WAAA,IAAe;AAG/B,QAAI,CAAC,MAAM,QAAQ,MAAM,GAAG;AACjB,aAAA;IAAA;AAIL,UAAA,gCAAgC,8BAA8B,UAAU;AAC9E,QAAI,iCAAiC,MAAM;AAChC,aAAA;IAAA;AAGX,WAAO,OAAO,OAAO;MACjB;MACA,QAAQ,uBAAuB;QAC3B,wBAAwB,eAAe,oBAAoB,wBAAwB;QACnF;QACA,oBAAoB;QACpB;MAAA,CACH;IAAA,CACJ;EAAA;AAET;AChDO,SAAS,8BAA8B,mBAA8D;AACxG,SAAO,CAAI,OAAU,EAAE,QAAA,MAAiC;AAChD,QAAA,OAAO,UAAU,UAAU;AAC3B,UAAI,sBAAsB,QAAQ,OAAO,oBAAoB,QAAQ,CAAC,OAAO,mBAAmB;AAC5F,0BAAkB,SAAgC,KAAK;MAAA;IAC3D;AAEG,WAAA;EAAA;AAEf;ACSO,SAAS,qCAAqC,mBAA2C;AAC5F,SAAO,CAAU,YAA6C;AAC1D,UAAM,cAAc;MAChB,CAAC,8BAA8B,IAAI,SAAS,kBAAkB,SAAS,GAAG,IAAI,CAAC,CAAC;MAChF,EAAE,SAAS,CAAA,EAAG;IAAA;AAElB,WAAO,YAAY,OAAO;EAAA;AAElC;AC5BO,IAAM,oCAA4D;EACrE,sBAAsB;EACtB,oBAAoB;EACpB,gBAAgB;EAChB,YAAY;EACZ,UAAU;EACV,gBAAgB;EAChB,oBAAoB;EACpB,WAAW;EACX,oBAAoB;EACpB,cAAc;EACd,kBAAkB;EAClB,sBAAsB;EACtB,oBAAoB;EACpB,oBAAoB;EACpB,oBAAoB;EACpB,mBAAmB;EACnB,mCAAmC;EACnC,qBAAqB;EACrB,oBAAoB;EACpB,yBAAyB;EACzB,SAAS;EACT,eAAe;EACf,2BAA2B;EAC3B,WAAW;EACX,wBAAwB;EACxB,4BAA4B;EAC5B,yBAAyB;EACzB,yBAAyB;EACzB,gBAAgB;EAChB,gBAAgB;EAChB,qBAAqB;EACrB,iBAAiB;EACjB,kBAAkB;EAClB,mBAAmB;EACnB,sBAAsB;EACtB,gBAAgB;EAChB,iBAAiB;EACjB,wBAAwB;EACxB,qBAAqB;AACzB;ACKO,SAAS,yCAAyC,QAA0D;AAC/G,QAAM,wBAAwB,QAAQ;AACtC,SAAO,CAAC,YAAoC;AACjC,WAAA;MACH;MACA,wBAAwB,qCAAqC,qBAAqB,IAAI,CAAK,MAAA;MAC3F,oCAAoC;MACpC,uCAAuC;QACnC,mBAAmB,QAAQ;QAC3B,+BAA+B;MAAA,CAClC;IAAA;EACL;AAER;ACxDO,SAAS,uBAAuB,wBAA4C;AAC/E,SAAO,SAAS,2BAA2B,OAAgB,EAAE,QAAA,GAA2B;AAC9E,UAAA,YAAa,OAAO,UAAU,YAAY,OAAO,UAAU,KAAK,KAAM,OAAO,UAAU;AACzF,QAAA,CAAC,UAAkB,QAAA;AACnB,QAAA,4BAA4B,SAAS,sBAAsB,GAAG;AAC9D,aAAO,OAAO,KAAK;IAAA,OAChB;AACH,aAAO,OAAO,KAAK;IAAA;EACvB;AAER;AAEA,SAAS,4BAA4B,SAAkB,wBAA4C;AACxF,SAAA,uBAAuB,KAAK,CAAqB,sBAAA;AAChD,QAAA,kBAAkB,WAAW,QAAQ,QAAQ;AACtC,aAAA;IAAA;AAEX,aAAS,KAAK,QAAQ,SAAS,GAAG,MAAM,GAAG,MAAM;AACvC,YAAA,cAAc,QAAQ,EAAE;AACxB,YAAA,wBAAwB,kBAAkB,EAAE;AAClD,UACI,0BAA0B,gBACzB,0BAA0B,oBAAoB,OAAO,gBAAgB,WACxE;AACS,eAAA;MAAA;IACX;AAEG,WAAA;EAAA,CACV;AACL;ACTO,SAAS,mCAAmC,wBAA4C;AACpF,SAAA,iCAAiC,CAAC,uBAAuB,sBAAsB,CAAC,GAAG,EAAE,SAAS,CAAA,EAAC,CAAG;AAC7G;ACRO,SAAS,+BAAuD;AACnE,SAAO,CAAA,SAAS,KAAyB;AAC7C;ACFO,SAAS,yCAAiE;AAC7E,SAAO,CAAQ,SAAA;AACX,UAAM,kBAAkB;AACxB,QAAI,WAAW,iBAAiB;AACtB,YAAA,+BAA+B,gBAAgB,KAAK;IAAA;AAEvD,WAAA;EAAA;AAEf;ACUO,SAAS,0CACZ,QACsB;AACf,SAAA,CAAC,UAAuB,YAAqC;AAChE,UAAM,aAAa,QAAQ;AAC3B,UAAM,WACF,QAAQ,0BAA0B,aAAa,OAAO,uBAAuB,UAAU,IAAI;AACxFE,WAAAA;MACH;MACA,CAAK,MAAA,uCAAA,EAAyC,GAAG,OAAO;MACxD,CAAK,MAAA,6BAAA,EAA+B,GAAG,OAAO;MAC9C,CAAA,MAAK,mCAAmC,YAAY,CAAA,CAAE,EAAE,GAAG,OAAO;IAAA;EACtE;AAER;AAgBO,SAAS,uDACZ,QACsB;AACf,SAAA,CAAC,UAAuB,YAAqC;AAChE,UAAM,aAAa,QAAQ;AAC3B,UAAM,WACF,QAAQ,0BAA0B,aAAa,OAAO,uBAAuB,UAAU,IAAI;AACxFA,WAAAA,KAAK,UAAU,CAAA,MAAK,mCAAmC,YAAY,CAAA,CAAE,EAAE,GAAG,OAAO,CAAC;EAAA;AAEjG;ACpEO,IAAM,iCAAiC;;EAE1C,CAAC,QAAQ,UAAU,QAAQ,eAAe,UAAU;EACpD,CAAC,QAAQ,UAAU,QAAQ,eAAe,UAAU;EACpD,CAAC,QAAQ,UAAU,QAAQ,qBAAqB,UAAU;EAC1D,CAAC,QAAQ,UAAU,QAAQ,qBAAqB,UAAU;EAC1D,CAAC,QAAQ,UAAU,QAAQ,mBAAmB,UAAU;EACxD,CAAC,QAAQ,UAAU,QAAQ,mBAAmB,UAAU;EACxD,CAAC,QAAQ,UAAU,QAAQ,cAAc,kBAAkB,SAAS,oBAAoB,wBAAwB;EAChH,CAAC,QAAQ,UAAU,QAAQ,cAAc,kBAAkB,SAAS,oBAAoB,wBAAwB;EAChH,CAAC,QAAQ,UAAU,QAAQ,cAAc,kBAAkB,SAAS,sBAAsB;EAC1F,CAAC,QAAQ,UAAU,QAAQ,cAAc,kBAAkB,SAAS,aAAa;AACrF;AACO,IAAM,4BAA4B;EACrC,GAAG;;EAEH,CAAC,QAAQ,UAAU,QAAQ,4BAA4B;;EAEvD,CAAC,QAAQ,UAAU,QAAQ,cAAc;EACzC,CAAC,QAAQ,UAAU,QAAQ,oBAAoB;;EAE/C,CAAC,QAAQ,UAAU,QAAQ,UAAU;;EAErC,CAAC,QAAQ,UAAU,QAAQ,oBAAoB;EAC/C,CAAC,QAAQ,UAAU,QAAQ,iBAAiB;;EAE5C,CAAC,QAAQ,UAAU,QAAQ,SAAS,cAAc,oBAAoB;;EAEtE,CAAC,QAAQ,UAAU,QAAQ,oBAAoB;EAC/C,CAAC,QAAQ,UAAU,QAAQ,aAAa;;EAExC,CAAC,QAAQ,UAAU,QAAQ,YAAY;EACvC,CAAC,QAAQ,UAAU,QAAQ,SAAS,kBAAkB,mBAAmB;AAC7E;AACO,IAAM,2BAA2B;EACpC,CAAC,OAAO;EACR,CAAC,gBAAgB,kBAAkB,YAAY,gBAAgB;EAC/D,CAAC,gBAAgB,kBAAkB,gBAAgB;EACnD,CAAC,gBAAgB,kBAAkB,aAAa;AACpD;AACO,IAAM,gBAAgB;EACzB,CAAC,uBAAuB,kBAAkB,mBAAmB,gBAAgB;EAC7E,CAAC,uBAAuB,kBAAkB,mBAAmB,gBAAgB;EAC7E,CAAC,UAAU,2BAA2B;EACtC,CAAC,UAAU,6BAA6B;EACxC,CAAC,UAAU,uBAAuB;EAClC,CAAC,gBAAgB,kBAAkB,YAAY,gBAAgB;EAC/D,CAAC,gBAAgB,kBAAkB,gBAAgB;EACnD,CAAC,gBAAgB,kBAAkB,aAAa;AACpD;;;ACwLO,SAAS,mBAGd,QAAsC;AACpC,SAAO,iBAA8B;IACjC,oBAAoB,yCAAyC,MAAM;IACnE,qBAAqB,0CAA0C;MAC3D,wBAAwB,0BAA0B;IAAA,CACrD;EAAA,CACJ;AACL;AAEA,IAAI;AAMJ,SAAS,4BAA0E;AAC/E,MAAI,CAAC,kBAAkB;AACA,uBAAA;MACf,gBAAgB,0BAA0B,IAAI,CAAA,MAAK,CAAC,SAAS,GAAG,CAAC,CAAC;MAClE,UAAU;QACN,CAAC,gBAAgB,kBAAkB,QAAQ,oBAAoB,kBAAkB,cAAc;QAC/F;UACI;UACA;UACA;UACA;UACA;UACA;UACA;QAAA;QAEJ,CAAC,gBAAgB,kBAAkB,QAAQ,qBAAqB,kBAAkB,cAAc;QAChG;UACI;UACA;UACA;UACA;UACA;UACA;UACA;QAAA;QAEJ,CAAC,gBAAgB,kBAAkB,QAAQ,WAAW,kBAAkB,YAAY;QACpF,GAAG,yBAAyB,IAAI,CAAK,MAAA;UACjC;UACA;UACA;UACA;UACA;UACA,GAAG;QAAA,CACN;QACD,GAAG,cAAc,IAAI,CAAK,MAAA,CAAC,gBAAgB,kBAAkB,eAAe,WAAW,GAAG,CAAC,CAAU;QACrG,CAAC,WAAW,kBAAkB,YAAY;MAAA;MAE9C,iBAAiB;QACb,CAAC,kBAAkB,YAAY;QAC/B,CAAC,kBAAkB,cAAc;MAAA;MAErC,sBAAsB,CAAC,CAAC,SAAS,GAAG,CAAC,YAAY,GAAG,CAAC,gBAAgB,GAAG,CAAC,OAAO,GAAG,CAAC,UAAU,CAAC;MAC/F,kBAAkB,CAAC,CAAC,YAAY,GAAG,CAAC,OAAO,GAAG,CAAC,WAAW,CAAC;MAC3D,oBAAoB,CAAC,CAAC,kBAAkB,YAAY,CAAC;MACrD,qBAAqB,0BAA0B,IAAI,CAAA,MAAK,CAAC,SAAS,kBAAkB,GAAG,CAAC,CAAC;MACzF,oBAAoB,0BAA0B,QAAQ,CAAK,MAAA;QACvD,CAAC,SAAS,kBAAkB,WAAW,GAAG,CAAC;QAC3C,CAAC,kBAAkB,WAAW,GAAG,CAAC;MAAA,CACrC;MACD,6BAA6B,CAAC,CAAC,kBAAkB,kBAAkB,CAAC;MACpE,wBAAwB;QACpB,CAAC,SAAS,UAAU;QACpB,CAAC,SAAS,UAAU;MAAA;MAExB,4BAA4B,+BAA+B,IAAI,CAAK,MAAA;QAChE;QACA;QACA;QACA,GAAG;MAAA,CACN;MACD,yBAAyB,+BAA+B,IAAI,CAAK,MAAA;QAC7D;QACA;QACA;QACA,GAAG;MAAA,CACN;MACD,yBAAyB;QACrB,CAAC,SAAS,kBAAkB,UAAU;QACtC,CAAC,SAAS,kBAAkB,UAAU;MAAA;MAE1C,gBAAgB;QACZ,CAAC,SAAS,UAAU;QACpB,CAAC,SAAS,UAAU;MAAA;MAExB,gBAAgB;QACZ,CAAC,QAAQ,oBAAoB,kBAAkB,cAAc;QAC7D,CAAC,QAAQ,oBAAoB,kBAAkB,iBAAiB,UAAU;QAC1E,CAAC,QAAQ,qBAAqB,kBAAkB,cAAc;QAC9D,CAAC,QAAQ,qBAAqB,kBAAkB,iBAAiB,UAAU;QAC3E,CAAC,QAAQ,WAAW,kBAAkB,YAAY;QAClD,GAAG,yBAAyB,IAAI,CAAK,MAAA,CAAC,QAAQ,qBAAqB,kBAAkB,GAAG,CAAC,CAAC;QAC1F,GAAG,cAAc,IAAI,CAAA,MAAK,CAAC,eAAe,WAAW,GAAG,CAAC,CAAU;MAAA;MAEvE,YAAY,CAAC,CAAC,aAAa,CAAC;MAC5B,iBAAiB;QACb,CAAC,WAAW,kBAAkB,YAAY;QAC1C,CAAC,cAAc,kBAAkB,YAAY;MAAA;MAEjD,qBAAqB;QACjB,GAAG,0BAA0B,IAAI,CAAK,MAAA,CAAC,SAAS,YAAY,kBAAkB,GAAG,CAAC,CAAC;QACnF,GAAG,yBAAyB,IAAI,CAAK,MAAA,CAAC,SAAS,qBAAqB,kBAAkB,GAAG,CAAC,CAAC;MAAA;IAC/F;EACJ;AAEG,SAAA;AACX;A;;;AChTA,IAAM,qBAA8C;EAChD,QAAQ;EACR,kBAAkB;EAClB,gBAAgB;AACpB;AAEA,IAAM,oBAAoE,OAAA;EACtE;IACI,kBAAkB;IAClB,kCAAkC;IAClC,iCAAiC;IACjC,YAAY;IACZ,kBAAkB;IAClB,QAAQ;IACR,MAAM;IACN,KAAK;IACL,QAAQ;IACR,MAAM;IACN,cAAc;IACd,QAAQ;IACR,sBAAsB;;;;IAItB,SAAS;IACT,IAAI;IACJ,SAAS;IACT,qBAAqB;IACrB,SAAS;IACT,KAAK;EAAA;EAEgB,EAAE,mBAAmB,KAAK;AACvD;AAEO,SAAS,kCACZ,SAC4C;AAC5C,QAAM,aAAa,OAAO,KAAK,OAAO,EAAE,OAAO,CAAc,eAAA;AACnD,UAAA,sBAAsB,WAAW,YAAY;AACnD,WACI,mBAAmB,WAAW,YAAA,CAAa,MAAM,QACjD,kBAAkB,WAAW,YAAA,CAAa,MAAM,QAChD,oBAAoB,WAAW,QAAQ,KACvC,oBAAoB,WAAW,MAAM;EAAA,CAE5C;AACG,MAAA,WAAW,SAAS,GAAG;AACjB,UAAA,IAAI,YAAY,oDAAoD;MACtE,SAAS;IAAA,CACZ;EAAA;AAET;AAIO,SAAS,iBACZ,SACiD;AACjD,QAAM,MAA8B,CAAA;AACpC,aAAW,cAAc,SAAS;AAC9B,QAAI,WAAW,YAAA,CAAa,IAAI,QAAQ,UAAU;EAAA;AAE/C,SAAA;AACX;ACtGA,IAAI,mDAAmD;AACvD,SAAS,gDAAgD;AACrD,MAAI,kDAAkD;AAClD;EAAA;AAE+C,qDAAA;AAC3C,UAAA;IACJ;EAAA;AAKR;AAiBO,SAAS,oBAAoB,QAA8B;AAC9D,MAAI,eAAAC,QAAyB,IAAA,aAAA,gBAAgB,QAAe,0BAA0B,QAAQ;AAC5C,kDAAA;EAAA;AAElD,QAAM,EAAE,UAAU,SAAS,QAAQ,IAAA,IAAQ;AACvC,MAAA,eAAAA,QAAA,IAAA,aAAyB,gBAAgB,SAAS;AAClD,sCAAkC,OAAO;EAAA;AAEzC,MAAA;AAIE,QAAA,gBAAgB,WAAW,iBAAiB,OAAO;AACzD,SAAO,eAAe,gBAA2B;IAC7C;IACA;EAAA,GAC6D;AAC7D,UAAM,OAAO,SAAS,OAAO,OAAO,IAAI,KAAK,UAAU,OAAO;AAC9D,UAAM,cAAc;MAChB,GAAG;MACH;MACA,SAAS;QACL,GAAG;;QAEH,QAAQ;QACR,kBAAkB,KAAK,OAAO,SAAS;QACvC,gBAAgB;MAAA;MAEpB,QAAQ;MACR;IAAA;AAEJ,UAAM,WAAW,MAAM,MAAM,KAAK,WAAW;AACzC,QAAA,CAAC,SAAS,IAAI;AACR,YAAA,IAAIC,YAAY,yCAAyC;QAC3D,SAAS,SAAS;QAClB,SAAS,SAAS;QAClB,YAAY,SAAS;MAAA,CACxB;IAAA;AAEL,QAAI,UAAU;AACV,aAAO,SAAS,MAAM,SAAS,KAAA,GAAQ,OAAO;IAAA;AAE3C,WAAA,MAAM,SAAS,KAAK;EAAA;AAEnC;AC/EA,IAAM,qBAAqB;EACvB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ;AAKO,SAAS,gBAAgB,SAI7B;AACC,SAAO,iBAAiB,OAAO,KAAM,mBAAyC,SAAS,QAAQ,MAAM;AACzG;AC5CO,SAAS,gCAAgC,QAA8B;AAC1E,SAAO,oBAAoB;IACvB,GAAG;IACH,UAAU,CAAC,aAAqB,YAC5B,gBAAgB,OAAO,IAAI,qBAAqB,WAAW,IAAI,KAAK,MAAM,WAAW;IACzF,QAAQ,CAAC,YACL,gBAAgB,OAAO,IAAI,yBAAyB,OAAO,IAAI,KAAK,UAAU,OAAO;EAAA,CAC5F;AACL;;;;ACPA,IAAM,cAAc,OAAO,UAAU;AACrC,IAAM,UACF,OAAO,QACP,SAAU,KAAK;AACX,QAAM,OAAO,CAAA;AACb,aAAW,QAAQ,KAAK;AACpB,SAAK,KAAK,IAAI;EAAA;AAEX,SAAA;AACX;AAEJ,SAAS,UAAU,KAAc,aAAsB;AACnD,MAAI,GAAG,KAAK,KAAK,MAAM,KAAK,SAAS;AACrC,MAAI,QAAQ,MAAM;AACP,WAAA;EAAA;AAEX,MAAI,QAAQ,OAAO;AACR,WAAA;EAAA;AAEX,UAAQ,OAAO,KAAK;IAChB,KAAK;AACD,UAAI,QAAQ,MAAM;AACP,eAAA;MAAA,WACA,YAAY,OAAO,OAAO,IAAI,WAAW,YAAY;AAC5D,eAAO,UAAU,IAAI,OAAO,GAAG,WAAW;MAAA,OACvC;AACK,gBAAA,YAAY,KAAK,GAAG;AAC5B,YAAI,UAAU,kBAAkB;AACtB,gBAAA;AACN,gBAAO,IAAkB,SAAS;AAClC,eAAK,IAAI,GAAG,IAAI,KAAK,KAAK;AAEtB,mBAAO,UAAW,IAAkB,CAAC,GAAG,IAAI,IAAI;UAAA;AAEpD,cAAI,MAAM,IAAI;AAEV,mBAAO,UAAW,IAAkB,CAAC,GAAG,IAAI;UAAA;AAEhD,iBAAO,MAAM;QAAA,WACN,UAAU,mBAAmB;AAE7B,iBAAA,QAAQ,GAAG,EAAE,KAAK;AACzB,gBAAM,KAAK;AACL,gBAAA;AACF,cAAA;AACJ,iBAAO,IAAI,KAAK;AACZ,kBAAM,KAAK,CAAC;AACZ,sBAAU,UAAW,IAAoC,GAAG,GAAG,KAAK;AACpE,gBAAI,YAAY,QAAW;AACvB,kBAAI,KAAK;AACE,uBAAA;cAAA;AAGX,qBAAO,KAAK,UAAU,GAAG,IAAI,MAAM;YAAA;AAEvC;UAAA;AAEJ,iBAAO,MAAM,MAAM;QAAA,OAChB;AACI,iBAAA,KAAK,UAAU,GAAG;QAAA;MAC7B;IAER,KAAK;IACL,KAAK;AACD,aAAO,cAAc,OAAO;IAChC,KAAK;AACM,aAAA,GAAG,IAAI,SAAA,CAAU;IAC5B,KAAK;AACM,aAAA,KAAK,UAAU,GAAG;IAC7B;AACW,aAAA,SAAS,GAAa,IAAI,MAAM;EAAA;AAEnD;AAQe,SAAR,cAAkB,KAAkC;AACjD,QAAA,YAAY,UAAU,KAAK,KAAK;AACtC,MAAI,cAAc,QAAW;AAEzB,WAAO,KAAK;EAAA;AAEpB;;;AC3GO,SAAS,wCACZ,YACA,SACA,OACuD;AACvD,MAAI,gBAAgB;AACpB,MAAI,OAAO,QAAQ,CAAC,MAAM,UAAU;AAC1B,UAAA,cAAc,QAAQ,CAAC,IAAI;AACjC,UAAM,YAAY,cAAc;AAChC,UAAM,gBAAgB,cAAc;AAChC,QAAA,aAAa,KAAK,iBAAiB,IAAI;AACvC,sBAAgB,cAAc;IAAA,WACvB,aAAa,KAAK,iBAAiB,IAAI;AAC9C,sBAAgB,cAAc;IAAA,WACvB,aAAa,KAAK,iBAAiB,IAAI;AAC9C,sBAAgB,cAAc;IAAA,OAC3B;AACH,sBAAgB,cAAc;IAAA;EAClC,OACG;AACH,oBAAgB,KAAK,QAAQ,CAAC,EAAE,SAAA,CAAU;EAAA;AAExC,QAAA,OACF,QAAQ,SAAS,IACX,QACK,MAAM,CAAC,EACP,IAAI,CAAA,aAAa,OAAO,aAAa,WAAW,IAAI,QAAQ,MAAM,QAAS,EAC3E,KAAK,GAAG,IACb;AACJ,QAAA,QAAQ,IAAI,YAAY,qCAAqC;IAC/D;IACA;IACA;IACA,mBAAmB,OAAO,cAAc,IAAI,OAAO;IACnD;IACA,GAAI,SAAS,SAAY,EAAE,KAAA,IAAS;EAAA,CACvC;AACD,wBAAsB,OAAO,uCAAuC;AAC7D,SAAA;AACX;AC1BO,IAAM,qBAAqF;EAC9F,mBAAmB;EACnB,kBAAkB,SAAS,SAAS,OAAO;AACvC,UAAM,wCAAwC,QAAQ,YAAY,SAAS,KAAK;EAAA;AAExF;ACrBO,IAAMC,KAAkB,WAAW;ACgB1C,IAAI;AACJ,SAAS,2BAA2B;AAGhC,SAAO,eAAAC,QAAA,IAAA,aAAyB,eAC1B;IACI,sBACI;EAAA,IAGR,CAAA;AACV;AAEO,SAAS,qCACZ,WACA,qBACU;AACN,MAAA;AACG,SAAA,eAAe,yBAClB,SAC+B;AACzB,UAAA,EAAE,SAAS,OAAA,IAAW;AACtB,UAAA,mBAAmB,oBAAoB,OAAO;AACpD,QAAI,qBAAqB,QAAW;AACzB,aAAA,MAAM,UAAU,OAAO;IAAA;AAElC,QAAI,CAAC,qCAAqC;AACtC,qBAAe,MAAM;AACqB,8CAAA;MAAA,CACzC;AACD,4CAAsC,CAAA;IAAC;AAEvC,QAAA,oCAAoC,gBAAgB,KAAK,MAAM;AACzD,YAAA,kBAAkB,IAAIC,GAAgB;AAC5C,YAAM,mBAAmB,YAAY;AAC7B,YAAA;AACA,iBAAO,MAAM,UAAqB;YAC9B,GAAG;YACH,QAAQ,gBAAgB;UAAA,CAC3B;QAAA,SACIC,IAAG;AACJ,cAAAA,QAAO,yBAAyB,yBAAA,IAA6B;AAI7D;UAAA;AAEE,gBAAAA;QAAA;MACV,GACD;AACH,0CAAoC,gBAAgB,IAAI;QACpD;QACA,cAAc;QACd;MAAA;IACJ;AAEE,UAAA,mBAAmB,oCAAoC,gBAAgB;AAC5D,qBAAA;AACjB,QAAI,QAAQ;AACR,YAAM,kBAAkB,iBAAiB;AACzC,aAAO,MAAM,IAAI,QAAgC,CAAC,SAAS,WAAW;AAC5D,cAAA,cAAc,CAACA,OAAoC;AAC9C,iBAAA,oBAAoB,SAAS,WAAW;AAC/C,2BAAiB,gBAAgB;AACjC,yBAAe,MAAM;AACb,gBAAA,iBAAiB,iBAAiB,GAAG;AACrC,oBAAM,kBAAkB,iBAAiB;AACzB,8BAAA,MAAO,yBAAyB,yBAAA,CAA2B;YAAA;UAC/E,CACH;AAEO,iBAAAA,GAAE,OAAuB,MAAM;QAAA;AAEpC,eAAA,iBAAiB,SAAS,WAAW;AAC5C,wBACK,KAAK,OAAO,EACZ,MAAM,MAAM,EACZ,QAAQ,MAAM;AACJ,iBAAA,oBAAoB,SAAS,WAAW;QAAA,CAClD;MAAA,CACR;IAAA,OACE;AACH,aAAQ,MAAM,iBAAiB;IAAA;EACnC;AAER;AClGO,SAAS,oCAAoC,SAAsC;AAC/E,SAAA,iBAAiB,OAAO,IAAI,cAAoB,CAAC,QAAQ,QAAQ,QAAQ,MAAM,CAAC,IAAI;AAC/F;ACQA,SAASC,kBACL,SACiD;AACjD,QAAM,MAA8B,CAAA;AACpC,aAAW,cAAc,SAAS;AAE9B,QAAI,WAAW,YAAA,CAAa,IAAI,QAAQ,UAAU;EAAA;AAE/C,SAAA;AACX;AAcO,SAAS,0BACZ,QACuC;AAChC,SAAA;IACH,gCAAgC;MAC5B,GAAG;MACH,SAAS;QACL,GAAI;QAOJ,GAAI,OAAO,UAAUA,kBAAiB,OAAO,OAAO,IAAI;QACxD,GAAI;;UAEA,iBAA+B,MAAM,OAAW;QAAK;MACzD;IACJ,CACH;IACD,CAAA,cAAa,qCAAqC,WAAW,mCAAmC;EAAA;AAExG;AC1CO,SAAS,gBACZ,YACA,QACF;AACS,SAAA,6BAA6B,0BAA0B,EAAE,KAAK,YAAY,GAAG,OAAA,CAAQ,CAAC;AACjG;AAMO,SAAS,6BAA8D,WAAuB;AACjG,SAAO,UAAU;IACb,KAAK,mBAAmB,kBAAkB;IAC1C;EAAA,CACH;AACL;;;ACjCA;A;;;;;;;;;;;;ACAO,IAAMC,KAAkB,WAAW;AAAnC,IACMC,IAAc,WAAW;AC6DtC,IAAIC;AACJ,SAASC,4BAA2B;AAGzB,SAAA;IACH,eAAAC,QAAA,IAAA,aAAyB,eACnB,yGAEA;EAAA;AAEd;AAEA,IAAM,gBAAgB,OAAO;AA4CtB,SAAS,qCAA4C;EACxD;EACA;EACA;EACA;AACJ,GAAiC;AACvB,QAAA,gBAAA,oBAA4D,IAAI;AACtE,WAAS,2BAA2B,QAAiB;AACjD,eAAW,CAAC,aAAa,KAAK,KAAK,cAAc,QAAA,GAAW;AACxD,UAAI,MAAM,aAAa;AACnB,sBAAc,OAAO,WAAW;AAChC,cAAM,QAAQ,MAAM;MAAA,OACjB;AACH,cAAM,aAAa,KAAK;UACpB,QAAQ;UACR,KAAK;QAAA,CACR;MAAA;IACL;EACJ;AAEE,QAAA,kBAAkB,IAAIC,GAAgB;AAChC,cAAA,iBAAiB,SAAS,MAAM;AACxC,oBAAgB,MAAM;AACM,+BAAAH,0BAAyBC,0BAAA,CAA2B;EAAA,CACnF;AACD,QAAM,UAAU,EAAE,QAAQ,gBAAgB,OAAO;AACjD,MAAI,aAAsB;AACZ,gBAAA;IACV;IACA,CAAO,QAAA;AACH,UAAI,eAAe,eAAe;AACjB,qBAAA;AACb,wBAAgB,MAAM;AACtB,mCAA2B,GAAG;MAAA;IAClC;IAEJ;EAAA;AAEU,gBAAA;IACV;IACA,CAAQ,SAAA;AACU,oBAAA,QAAQ,CAAC,OAAO,gBAAgB;AAC1C,YAAI,MAAM,aAAa;AACb,gBAAA,EAAE,OAAA,IAAW;AACL,wBAAA,IAAI,aAAa,EAAE,aAAa,OAAO,cAAc,CAAA,EAAA,CAAI;AACvE,iBAAO,IAAa;QAAA,OACjB;AACH,gBAAM,aAAa,KAAK;YACpB,QAAQ;YACR;UAAA,CACH;QAAA;MACL,CACH;IAAA;IAEL;EAAA;AAEG,SAAA;IACH,QAAQ,OAAO,aAAa,IAAI;AAC5B,UAAI,YAAY,SAAS;AACrB;MAAA;AAEJ,UAAI,eAAe,eAAe;AACxB,cAAA;MAAA;AAEV,YAAM,cAAc,OAAO;AACb,oBAAA,IAAI,aAAa,EAAE,aAAa,OAAO,cAAc,CAAA,EAAA,CAAI;AACnE,UAAA;AACA,eAAO,MAAM;AACH,gBAAA,QAAQ,cAAc,IAAI,WAAW;AAC3C,cAAI,CAAC,OAAO;AAEF,kBAAA,IAAI,YAAY,sEAAsE;UAAA;AAEhG,cAAI,MAAM,aAAa;AAEnB,kBAAM,IAAI;cACN;YAAA;UACJ;AAEJ,gBAAM,eAAe,MAAM;AACvB,cAAA;AACA,gBAAI,aAAa,QAAQ;AACrB,oBAAM,eAAe,CAAA;AACrB,yBAAW,QAAQ,cAAc;AACzB,oBAAA,KAAK,WAAW,GAAkB;AAClC,wBAAM,KAAK;gBAAA,OACR;AACH,wBAAM,KAAK;gBAAA;cACf;YACJ,OACG;AACH,oBAAM,MAAM,IAAI,QAAe,CAAC,SAAS,WAAW;AAChD,8BAAc,IAAI,aAAa;kBAC3B,aAAa;kBACb,QAAQ;kBACR,SAAS;gBAAA,CACZ;cAAA,CACJ;YAAA;UACL,SACKG,IAAG;AACJ,gBAAAA,QAAOJ,0BAAyBC,0BAAA,IAA6B;AAC7D;YAAA,OACG;AACG,oBAAAG;YAAA;UACV;QACJ;MACJ,UACF;AACE,sBAAc,OAAO,WAAW;MAAA;IACpC;EACJ;AAER;ACnLO,SAAS,iCACZ,cAGD;AACQ,SAAA;IACH,GAAG,aAAa,YAAY,SAAS;AACjC,eAAS,cAAc,IAAW;AAC9B,YAAI,cAAc,aAAa;AAC3B,gBAAM,OAAQ,GAAkD;AAC/D,qBAAwE,IAAI;QAAA,OAC1E;AACF,qBAA0B;QAAA;MAC/B;AAES,mBAAA,iBAAiB,aAAa,eAAe,OAAO;AACjE,aAAO,MAAM;AACI,qBAAA,oBAAoB,aAAa,aAAa;MAAA;IAC/D;EACJ;AAER;ACrCO,SAAS,yBAIZ,WACA,mBACA,oBAKa;AACT,MAAA;AAME,QAAA,cAAc,IAAI,EAAY;AAC9B,QAAA,6BAA6B,iCAAiC,WAAW;AACxE,SAAA;IACH,GAAG;IACH,GAAG,aAAa,YAAY,SAAS;AACjC,UAAI,CAAC,qBAAqB;AACtB,cAAM,4BAA4B,UAAU,GAAG,mBAAmB,CAAiB,kBAAA;AACzE,gBAAA,kBAAkB,mBAAmB,aAAa;AACxD,cAAI,CAAC,iBAAiB;AAClB;UAAA;AAEE,gBAAA,CAAC,wBAAwB,OAAO,IAAI;AAC9B,sBAAA;YACR,IAAI,YAAY,wBAAwB;cACpC,QAAQ;YAAA,CACX;UAAA;QACL,CACH;AACqB,8BAAA;UAClB,SAAS;UACT,gBAAgB;QAAA;MACpB;AAEgB,0BAAA;AACpB,YAAM,cAAc,2BAA2B,GAAG,aAAa,YAAY,OAAO;AAClF,UAAI,WAAW;AACf,eAAS,oBAAoB;AACzB,YAAI,CAAC,UAAU;AACX;QAAA;AAEO,mBAAA;AACF,iBAAA,OAAO,oBAAoB,SAAS,iBAAiB;AACzC,4BAAA;AACjB,YAAA,oBAAqB,mBAAmB,GAAG;AAC3C,8BAAqB,QAAQ;AACP,gCAAA;QAAA;AAEd,oBAAA;MAAA;AAEP,eAAA,OAAO,iBAAiB,SAAS,iBAAiB;AACpD,aAAA;IAAA;EACX;AAER;;;;ACzDA,SAAS,SAAS,OAAiC;AAC/C,SAAO,UAAU,SAAS,OAAO,UAAU,YAAY,OAAO,UAAU;AAC5E;AAEA,SAAS,iBAAiB,WAAmB;AACnC,QAAA,YAAA,oBAAgB,IAAc;AACpC,QAAM,SAAS,EAAE,WAAW,SAAS,MAAM;AAGnC,UAAA,QAAQ,SAAS,EAAE;IACvB,CAAS,UAAA;AACM,iBAAA,EAAE,QAAQ,KAAK,WAAW;AACjC,gBAAQ,KAAK;MAAA;AAGjB,gBAAU,MAAM;AAChB,aAAO,UAAU;IAAA;IAErB,CAAO,QAAA;AACQ,iBAAA,EAAE,OAAO,KAAK,WAAW;AAChC,eAAO,GAAG;MAAA;AAGd,gBAAU,MAAM;AAChB,aAAO,UAAU;IAAA;EACrB;AAEG,SAAA;AACX;AAIA,IAAM,KAAA,oBAAS,QAAgE;AAQ/E,eAAsB,SAA4C,YAA4C;AACtG,MAAA;AACJ,QAAM,SAAS,IAAI,QAAQ,CAAC,SAAS,WAAW;AACjC,eAAA,EAAE,QAAQ,QAAQ;AAC7B,eAAW,aAAa,YAAY;AAC5B,UAAA,CAAC,SAAS,SAAS,GAAG;AAKtB,gBAAQ,QAAQ,SAAS,EAAE,KAAK,SAAS,MAAM;AAC/C;MAAA;AAGA,UAAA,SAAS,GAAG,IAAI,SAAS;AAC7B,UAAI,WAAW,QAAW;AACtB,iBAAS,iBAAiB,SAAS;AAC5B,eAAA,UAAU,IAAI,QAAQ;AAC1B,WAAA,IAAI,WAAW,MAAM;MAAA,WACjB,OAAO,SAAS;AAGvB,gBAAQ,QAAQ,SAAS,EAAE,KAAK,SAAS,MAAM;MAAA,OAC5C;AACI,eAAA,UAAU,IAAI,QAAQ;MAAA;IACjC;EACJ,CACH;AAIM,SAAA,MAAO,OAAO,QAAQ,MAAM;AAC/B,eAAW,aAAa,YAAY;AAC5B,UAAA,SAAS,SAAS,GAAG;AACf,cAAA,SAAS,GAAG,IAAI,SAAS;AACxB,eAAA,UAAU,OAAO,QAAQ;MAAA;IACpC;EACJ,CACH;AACL;;;AEvEO,SAAS,sBACZ,WAC6C;AACtC,SAAA,IAAI,MAAM,UAAU,KAAK;IAC5B,iBAAiB;AACN,aAAA;IAAA;IAEX,iBAAiB;AACN,aAAA;IAAA;IAEX,IAAI,QAAQ,GAAG,UAAU;AACrB,UAAI,MAAM,QAAQ;AACP,eAAA;MAAA;AAEX,aAAO,YAAa,WAAsB;AAChC,cAAA,mBAAmB,EAAE,SAAS;AACpC,cAAM,4BAA4B,QAAQ,IAAI,QAAQ,kBAAkB,QAAQ;AAChF,YAAI,CAAC,2BAA2B;AACtB,gBAAA,IAAI,YAAY,kEAAkE;YACpF;UAAA,CACH;QAAA;AAEC,cAAA,mBAAmB,0BAA0B,GAAG,SAAS;AACxD,eAAA,6BAA6B,UAAU,WAAW,gBAAgB;MAAA;IAC7E;EACJ,CACH;AACL;AAEA,SAAS,6BACL,WACA,mBAC6C;AACtC,SAAA;IACH,MAAM,UAAU,EAAE,YAAA,GAA2E;AACnF,YAAA,6BAA6B,MAAM,UAAU;QAC/C,QAAQ;QACR,GAAG;MAAA,CACN;AACD,aAAO,qCAAoD;QACvD;QACA,iBAAiB;QACjB,eAAe;QACf,kBAAkB;MAAA,CACrB;IAAA;EACL;AAER;ACwCO,SAAS,0BACZ,QACgD;AACzC,SAAA,IAAI,MAAM,CAAA,GAAwD;IACrE,iBAAiB;AACN,aAAA;IAAA;IAEX,iBAAiB;AACN,aAAA;IAAA;IAEX,OACO,MACL;AACQ,YAAA,CAAC,GAAG,CAAC,IAAI;AACT,YAAA,aAAa,EAAE,SAAS;AAC9B,aAAO,YACA,QAK6E;AAC1E,cAAA,aAAa,EAAE,YAAY,OAAO;AACxC,cAAM,UAAU,OAAO,qBAAqB,OAAO,mBAAmB,UAAU,IAAI;AAC7E,eAAA;UACH,QAAQ,YAAY;AAChB,mBAAO,OAAO,aAAa,EAAE,GAAG,YAAY,QAAA,CAAS;UAAA;UAEzD;QAAA;MACJ;IACJ;EACJ,CACH;AACL;AC5GO,SAAS,gCACZ,SACA,WAC6D;AAC7D,SAAO,OAAO,OAAsE;IAChF,GAAG;IACH,GAAG,MAAM,YAAY,SAAS;AAC1B,UAAI,SAAS,WAAW;AACpB,eAAO,QAAQ;UACX;UACA;UACA;QAAA;MACJ;AAEJ,aAAO,QAAQ;QACX;QACA,CAAY,YAAA,WAAkD,UAAU,OAAO,CAAC;QAChF;MAAA;IACJ;EACJ,CACH;AACL;AAWO,SAAS,iCACZ,SACA,WAC6D;AAC7D,SAAO,OAAO,OAAsE;IAChF,GAAG;IACH,MAAM,CAAW,YAAA,QAAQ,KAAK,UAAU,OAAO,CAAC;EAAA,CACnD;AACL;ACnGO,IAAMC,KAAkB,WAAW;ACqC1C,IAAM,2CAAA,oBAA+C,QAAyC;AAC9F,SAAS,0CAA0C,SAAkB,gBAA6C;AACvG,SAAA,wCAAwC,IAAI,SAAS,cAAc;AAC9E;AACA,SAAS,yBAAyB,SAAkB,gBAA+B;AACvC,0CAAA,GAAG,SAAS,cAAc;AACtE;AACA,SAAS,6CAA6C,SAA0C;AACxF,MAAA,kCAAkC,yCAAyC,IAAI,OAAO;AAC1F,MAAI,CAAC,iCAAiC;AAClC,6CAAyC,IAAI,SAAU,kCAAkC,CAAA,CAAG;EAAA;AAEzF,SAAA;AACX;AACA,SAAS,wCACL,QACA,SACA,gBACkB;AAClB,MAAI,mBAAmB,QAAW;AAC9B;EAAA;AAEE,QAAA,kCAAkC,6CAA6C,OAAO;AAC5F,MAAI,CAAC,gCAAgC,cAAc,KAAK,SAAS,GAAG;AAChE,oCAAgC,cAAc,IAAI;EAAA;AAEhD,QAAA,WAAW,SAAS,gCAAgC,cAAc;AACxE,MAAI,YAAY,GAAG;AACf,WAAO,gCAAgC,cAAc;EAAA,OAClD;AACH,oCAAgC,cAAc,IAAI;EAAA;AAE/C,SAAA;AACX;AAEA,IAAM,QAAA,oBAAY,QAAQ;AAC1B,SAAS,+EACL,SACA,kBACA,qBAGD;AACK,MAAA,iCAAiC,MAAM,IAAI,OAAO;AACtD,MAAI,CAAC,gCAAgC;AACjC,UAAM,IAAI,SAAU,iCAAiC,oBAAI,QAAA,CAAU;EAAA;AAEvE,QAAM,yBAAyB,uBAAuB;AAClD,MAAA,YAAY,+BAA+B,IAAI,sBAAsB;AACzE,MAAI,CAAC,WAAW;AACmB,mCAAA;MAC3B;MACC,YAAY,yBAAyB,SAAS,WAAW,CAAc,eAAA;AACpE,cAAM,UAAU;AACZ,YAAA,EAAE,YAAY,UAAU;AACxB;QAAA;AAEE,cAAA,0BAA0B,sBAC1B,oBAAoB,QAAQ,OAAO,QAAQ,gBAAgB,IAC3D,QAAQ,OAAO;AACrB,eAAO,CAAC,gBAAgB,QAAQ,OAAO,YAAY,IAAI,uBAAuB;MAAA,CACjF;IAAA;EACL;AAEG,SAAA;AACX;AAcA,eAAsB,iCAAgD;EAClE;EACA;EACA;EACA;EACA;AACJ,GAAoG;AAC5F,MAAA;AACI,UAAA;IACJ;IACA,MAAM;AAIe,uBAAA;AACjB,+CAAyC,OAAO,OAAO;IAAA;IAE3D,EAAE,OAAO;EAAA;AAOb,QAAM,eAAe,IAAI,QAAe,CAAC,GAAG,WAAW;AACnD,aAAS,cAA+B;AAOpC,UAAI,0CAA0C,SAAS,cAAc,MAAM,GAAG;AAC1E,cAAM,qBAAqB,iBAAiB;UACxC,YAAY;UACZ,QAAQ,CAAC,cAAc;QAAA,CAC1B;AACgB,yBAAA;AACjB,gBAAQ,KAAK,kBAAkB,EAAE,MAAM,MAAM;QAAA,CAAE;MAAA;AAGnD,aAAO,KAAK,MAAM;IAAA;AAEtB,QAAI,OAAO,SAAS;AAChB,kBAAY,KAAK,MAAM;IAAA,OACpB;AACI,aAAA,iBAAiB,SAAS,WAAW;IAAA;EAChD,CACH;AAKK,QAAA,mBAAmB,iBAAiB,gBAAgB;AACpD,QAAA,QAAQ,KAAK,gBAAgB;AAKnC,QAAM,wBAAwB,IAAI,QAA2B,CAAC,SAAS,WAAW;AACxE,UAAA,kBAAkB,IAAIC,GAAgB;AAC5C,WAAO,iBAAiB,SAAS,gBAAgB,MAAM,KAAK,eAAe,CAAC;AAC5E,UAAM,UAAU,EAAE,QAAQ,gBAAgB,OAAO;AACzC,YAAA;MACJ;MACA,CAAO,QAAA;AACH,wBAAgB,MAAM;AACtB,eAAO,GAAG;MAAA;MAEd;IAAA;AAEI,YAAA;MACJ;MACA,CAAW,YAAA;AACH,YAAA,WAAW,OAAO,YAAY,YAAY,QAAQ,WAAW,QAAQ,OAAO,iBAAiB,IAAI;AACjG,0BAAgB,MAAM;AACtB,cAAI,WAAW,SAAS;AACb,mBAAA,+BAA+B,QAAQ,KAAK,CAAC;UAAA,OACjD;AACH,oBAAQ,QAAQ,MAAM;UAAA;QAC1B;MACJ;MAEJ;IAAA;EACJ,CACH;AACD,mBAAiB,MAAM,SAAS,CAAC,cAAc,qBAAqB,CAAC;AACrE,MAAI,kBAAkB,MAAM;AAClB,UAAA,IAAIC,YAAY,gEAAgE;EAAA;AAE1F,2BAAyB,SAAS,cAAc;AAKhD,QAAM,wBAAwB;IAC1B;IACA;IACA;EAAA;AAEE,QAAA,kBAAkB,gBAAgB,cAAc;AAC/C,SAAA;IACH,GAAG,MAAM,UAAU,SAAS;AACxB,cAAQ,MAAM;QACV,KAAK;AACD,iBAAO,sBAAsB;YACzB;YACA;YACA;UAAA;QAER,KAAK;AACD,iBAAO,QAAQ;YACX;YACA;YACA;UAAA;QAER;AACU,gBAAA,IAAIA,YAAY,yEAAyE;YAC3F,aAAa;YACb,uBAAuB,CAAC,gBAAgB,OAAO;UAAA,CAClD;MAAA;IACT;EACJ;AAER;;;AC/LA,SAAS,yCACL,QACyB;AACnB,QAAA,qBAAqB,yCAAyC,MAAM;AAC1E,QAAM,sBAAsB,uDAAuD;IAC/E,wBAAwBC,2BAA0B;EAAA,CACrD;AACD,SAAO,0BAAgC;IACnC,aAAa,EAAE,SAAS,GAAG,KAAA,GAAQ;AAC/B,aAAO,iCAAiC;QACpC,GAAG;QACH;QACA,kBAAkB,EAAE,GAAG,SAAS,YAAY,QAAQ,WAAW,QAAQ,kBAAkB,WAAW,EAAE;QACtG,uBAAuB,QAAQ,WAAW,QAAQ,kBAAkB,aAAa;MAAA,CACpF;IAAA;IAEL;EAAA,CACH;AACL;AAEO,SAAS,gCACZ,QACyB;AACzB,SAAO,yCAA+C,MAAM;AAChE;AAEO,SAAS,yCAAyC,QAAiB;AAC/D,SAAA;IACH;EAAA;AAER;AAEA,IAAIC;AAQJ,SAASD,6BAEP;AACE,MAAI,CAACC,mBAAkB;AACA,IAAAA,oBAAA;MACf,sBAAsB,0BAA0B,IAAI,CAAA,MAAK,CAAC,SAAS,GAAG,CAAC,CAAC;MACxE,oBAAoB;QAChB;UACI;UACA;UACA;UACA;UACA;UACA;UACA;UACA;QAAA;QAEJ;UACI;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;QAAA;QAEJ;UACI;UACA;UACA;UACA;UACA;UACA;UACA;UACA;QAAA;QAEJ;UACI;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;QAAA;QAEJ,CAAC,SAAS,SAAS,gBAAgB,kBAAkB,QAAQ,WAAW,kBAAkB,YAAY;QACtG;UACI;UACA;UACA;UACA;UACA;UACA;UACA;UACA;QAAA;QAEJ;UACI;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;QAAA;QAEJ;UACI;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;QAAA;QAEJ;UACI;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;QAAA;QAEJ;UACI;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;QAAA;QAEJ;UACI;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;QAAA;QAEJ;UACI;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;QAAA;QAEJ;UACI;UACA;UACA;UACA;UACA;UACA;UACA;UACA;QAAA;QAEJ;UACI;UACA;UACA;UACA;UACA;UACA;UACA;UACA;QAAA;QAEJ;UACI;UACA;UACA;UACA;UACA;UACA;UACA;UACA;QAAA;QAEJ,CAAC,SAAS,SAAS,WAAW,kBAAkB,YAAY;MAAA;MAEhE,sBAAsB,0BAA0B,QAAQ,CAAK,MAAA;QACzD,CAAC,SAAS,kBAAkB,WAAW,GAAG,CAAC;QAC3C,CAAC,kBAAkB,WAAW,GAAG,CAAC;MAAA,CACrC;IAAA;EACL;AAEG,SAAAA;AACX;A;;;ACpQO,IACMC,KAAc,WAAW;ACDtC,IAAOC,KAAQ,WAAW;AC0C1B,IAAM,sBAAsB;AASrB,SAAS,uBAAuB;EACnC;EACA;EACA;AACJ,GAAuE;AACnE,MAAI,OAAO,SAAS;AAET,WAAA,QAAQ,OAAO,OAAO,MAAM;EAAA;AAEnC,MAAA;AACJ,MAAI,eAAe;AACb,QAAA,mBAAA,oBAAuB,IAAgB;AAC7C,WAAS,mBAAmB;AACxB,qBAAiB,QAAQ,CAAK,MAAA;AACxB,QAAA;IAAA,CACL;AACD,qBAAiB,MAAM;EAAA;AAE3B,WAAS,cAAc;AACF,qBAAA;AACjB,QAAI,CAAC,cAAc;AACf,iBAAW,OAAO,MAAM;IAAA;AAE5B,QAAI,UAAU,eAAeC,GAAU,UAAU,UAAU,eAAeA,GAAU,SAAS;AACzF,gBAAU,MAAM,mBAAmB;IAAA;EACvC;AAEJ,WAAS,YAAY,IAAgB;AAChB,qBAAA;AACjB,wBAAoB,SAAS;AACtB,WAAA,oBAAoB,SAAS,WAAW;AACrC,cAAA,oBAAoB,SAAS,WAAW;AACxC,cAAA,oBAAoB,SAAS,WAAW;AACxC,cAAA,oBAAoB,WAAW,aAAa;AAC5C,cAAA,oBAAoB,QAAQ,UAAU;AAC5C,QAAA,CAAC,OAAO,WAAW,EAAE,GAAG,YAAY,GAAG,SAAS,sBAAsB;AAC1D,kBAAA;QACR,IAAI,YAAY,SAAS;UACrB,QAAQ,IAAI,YAAY,4DAA4D;YAChF,OAAO;UAAA,CACV;QAAA,CACJ;MAAA;IACL;EACJ;AAEJ,WAAS,YAAY,IAAW;AAC5B,QAAI,OAAO,SAAS;AAChB;IAAA;AAEJ,QAAI,CAAC,cAAc;AACT,YAAA,uBAAuB,IAAI,YAAY,4DAA4D;QACrG,YAAY;MAAA,CACf;AACD,iBAAW,oBAAoB;AACnB,kBAAA;QACR,IAAI,YAAY,SAAS;UACrB,QAAQ;QAAA,CACX;MAAA;IACL;EACJ;AAEJ,WAAS,cAAc,IAAkB;AACrC,QAAI,OAAO,SAAS;AAChB;IAAA;AAEQ,gBAAA,cAAc,IAAI,YAAY,WAAW,EAAE,QAAQ,GAAG,KAAK,CAAC,CAAC;EAAA;AAEvE,QAAA,cAAc,IAAIC,GAAY;AAC9B,QAAA,gBAAgB,iCAAiC,WAAW;AAClE,WAAS,aAAa;AACH,mBAAA;AACH,gBAAA;MACR,GAAG;MACH,MAAM,KAAK,SAAS;AACZ,YAAA,UAAU,eAAeD,GAAU,MAAM;AACnC,gBAAA,IAAI,YAAY,0DAA0D;QAAA;AAEpF,YAAI,CAAC,sBAAsB,UAAU,iBAAiB,yBAAyB;AACvE,cAAA;AACJ,gBAAM,UAAU,IAAI,QAAc,CAAC,SAAS,WAAW;AAC7C,kBAAA,aAAa,YAAY,MAAM;AACjC,kBACI,UAAU,eAAeA,GAAU,QACnC,EAAE,UAAU,iBAAiB,0BAC/B;AACE,8BAAc,UAAU;AACH,qCAAA;AACb,wBAAA;cAAA;YACZ,GACD,EAAE;AACL,uBAAW,MAAM;AACQ,mCAAA;AACrB,4BAAc,UAAU;AACxB;gBACI,IAAI;kBACA;gBAAA;cACJ;YACJ;UACJ,CACH;AACoB,+BAAA;YACjB;YACA;UAAA;QACJ;AAEJ,YAAI,oBAAoB;AACpB,cAAI,YAAY,OAAO,OAAO,KAAK,EAAE,mBAAmB,WAAW;AAC/D,kBAAM,wBAAwB,QAAQ;AAI5B,sBAAA,IAAI,sBAAsB,OAAO;UAAA;AAE/C,gBAAM,mBAAmB;QAAA;AAE7B,kBAAU,KAAK,OAAO;MAAA;IAC1B,CACH;EAAA;AAEC,QAAA,YAAY,IAAIA,GAAU,GAAG;AAC5B,SAAA,iBAAiB,SAAS,WAAW;AAClC,YAAA,iBAAiB,SAAS,WAAW;AACrC,YAAA,iBAAiB,SAAS,WAAW;AACrC,YAAA,iBAAiB,WAAW,aAAa;AACzC,YAAA,iBAAiB,QAAQ,UAAU;AACzC,MAAA;AACA,MAAA;AACJ,SAAO,IAAI,QAA2D,CAAC,SAAS,WAAW;AAC1E,iBAAA;AACC,kBAAA;EAAA,CACjB;AACL;;;ACnLO,SAASE,yCACZ,YACA,SACA,OACuD;AACvD,MAAI,gBAAgB;AACpB,MAAI,OAAO,QAAQ,CAAC,MAAM,UAAU;AAC1B,UAAA,cAAc,QAAQ,CAAC,IAAI;AACjC,UAAM,YAAY,cAAc;AAChC,UAAM,gBAAgB,cAAc;AAChC,QAAA,aAAa,KAAK,iBAAiB,IAAI;AACvC,sBAAgB,cAAc;IAAA,WACvB,aAAa,KAAK,iBAAiB,IAAI;AAC9C,sBAAgB,cAAc;IAAA,WACvB,aAAa,KAAK,iBAAiB,IAAI;AAC9C,sBAAgB,cAAc;IAAA,OAC3B;AACH,sBAAgB,cAAc;IAAA;EAClC,OACG;AACH,oBAAgB,KAAK,QAAQ,CAAC,EAAE,SAAA,CAAU;EAAA;AAExC,QAAA,OACF,QAAQ,SAAS,IACX,QACK,MAAM,CAAC,EACP,IAAI,CAAA,aAAa,OAAO,aAAa,WAAW,IAAI,QAAQ,MAAM,QAAS,EAC3E,KAAK,GAAG,IACb;AACJ,QAAA,QAAQ,IAAI,YAAY,qCAAqC;IAC/D;IACA;IACA;IACA,mBAAmB,OAAO,cAAc,IAAI,OAAO;IACnD;IACA,GAAI,SAAS,SAAY,EAAE,KAAA,IAAS;EAAA,CACvC;AACD,wBAAsB,OAAOA,wCAAuC;AAC7D,SAAA;AACX;ACtCO,IAAM,mCAET;EACA,mBAAmB;EACnB,kBAAkB,SAAS,SAAS,OAAO;AACvC,UAAMA,yCAAwC,QAAQ,YAAY,SAAS,KAAK;EAAA;AAExF;ACXO,IAAMC,KAAkB,WAAW;ACU1C,IAAM,eAAe;EACjB,SAAS;EACT,QAAQ;AACZ;AAQO,SAAS,uCAAkG;EAC9G,aAAa;EACb;EACA;AACJ,GAA+B;AACvB,MAAA;AACJ,WAAS,WAAW;AAChB,YAAQ,KAAK,YAAY,EAAE,MAAM,CAACC,OAAe;AACzC,UAAA,cAAcA,IAAG,0DAA0D,GAAG;AAC9E,8BAAsB,MAAM;MAAA;IAChC,CACH;EAAA;AAEL,WAAS,mBAAmB;AACxB,kBAAc,UAAU;AACX,iBAAA,YAAY,UAAU,UAAU;EAAA;AAE3C,QAAA,wBAAwB,IAAIC,GAAgB;AAC5B,wBAAA,OAAO,iBAAiB,SAAS,MAAM;AACzD,kBAAc,UAAU;EAAA,CAC3B;AACiB,oBAAA,iBAAiB,SAAS,MAAM;AAC9C,0BAAsB,MAAM;EAAA,CAC/B;AACO,UAAA;IACJ;IACA,MAAM;AACF,4BAAsB,MAAM;IAAA;IAEhC,EAAE,QAAQ,sBAAsB,OAAO;EAAA;AAE3C,UAAQ,GAAG,WAAW,kBAAkB,EAAE,QAAQ,sBAAsB,OAAA,CAAQ;AAC5D,MAAA,WAAW,UAAU,QAAQ;AAC5B,qBAAA;EAAA;AAEJ;AACF,eAAA;MACP;MACA,SAAS,gBAAgB;AACrB,sBAAc,UAAU;MAAA;MAE5B,EAAE,QAAQ,sBAAsB,OAAO;IAAA;AAEhC,eAAA;MACP;MACA,SAAS,eAAe;AACX,iBAAA;AACQ,yBAAA;MAAA;MAErB,EAAE,QAAQ,sBAAsB,OAAO;IAAA;EAC3C;AAEG,SAAA;IACH,GAAG;IACH,QAAQ,MAAM;AACN,UAAA,CAAC,sBAAsB,OAAO,SAAS;AACtB,yBAAA;MAAA;AAEd,aAAA,QAAQ,KAAK,GAAG,IAAI;IAAA;EAC/B;AAER;ACxEO,SAAS,oBAAiC;AACtC,SAAA;IACH,SAAS,CAAA;IACT,kBAAkB;EAAA;AAE1B;ACUO,SAAS,gCAEd,eAAgC,EAAE,4BAA4B,YAAA,GAAwC;AACpG,QAAM,OAAO,kBAAkB;AAK/B,WAAS,4BAA4B;AAC7B,QAAA,KAAK,QAAQ,SAAS,aAAa;AAGnC,WAAK,mBAAmB;AACxB;IAAA;AAEA,QAAA;AACJ,aAAS,KAAK,GAAG,KAAK,KAAK,QAAQ,QAAQ,MAAM;AAC7C,YAAM,iBAAiB,KAAK,mBAAmB,KAAK,KAAK,KAAK,QAAQ;AAChE,YAAA;;;;;QAKF,KAAK,QAAQ,aAAa;;AAE1B,UAAA,cAAc,oBAAoB,+BACjC,CAAC,mBAAmB,gBAAgB,qBAAqB,cAAc,oBAC1E;AACoB,0BAAA;UACd,WAAW;UACX,mBAAmB,cAAc;QAAA;MACrC;IACJ;AAEC,SAAA,mBAAmB,iBAAiB,aAAa;EAAA;AAE1D,SAAO,SAAS,kDAAkD,EAAE,YAAA,GAAe;AAC3E,QAAA;AACJ,aAAS,mBAAmB;AACxB,YAAM,QAAQ,KAAK,QAAQ,UAAU,CAAA,UAAS,UAAU,SAAS;AAC5D,WAAA,QAAQ,OAAO,OAAO,CAAC;AAC5B,gBAAU,QAAQ;AACQ,gCAAA;IAAA;AAE1B,QAAA,KAAK,qBAAqB,IAAI;AACxB,YAAA,kBAAkB,IAAIA,GAAgB;AAC5C,YAAM,oBAAoB,cAAc,EAAE,aAAa,gBAAgB,OAAA,CAAQ;AAC/E,wBACK,KAAK,CAAc,eAAA;AAChB,mBAAW,GAAG,SAAS,kBAAkB,EAAE,QAAQ,gBAAgB,OAAA,CAAQ;MAAA,CAC9E,EACA,MAAM,gBAAgB;AACf,kBAAA;QACR,SAAS;QACT,UAAU;AACN,0BAAgB,MAAM;QAAA;QAE1B,mBAAmB;MAAA;AAElB,WAAA,QAAQ,KAAK,SAAS;IAAA,OACxB;AACS,kBAAA,KAAK,QAAQ,KAAK,gBAAgB;IAAA;AAYxC,cAAA;AACE,gBAAA,iBAAiB,SAAS,SAAS,kBAAkB;AACnD,gBAAA;AACN,UAAA,UAAU,sBAAsB,GAAG;AAClB,yBAAA;MAAA,WACV,KAAK,qBAAqB,IAAI;AAEhC,aAAA;AACqB,kCAAA;MAAA;IAC9B,CACH;AACyB,8BAAA;AAC1B,WAAO,UAAU;EAAA;AAEzB;ACpGO,SAAS,gDACZ,SACyC;AAClC,SAAA;IACH;IACA,CAAK,MAAA,gCAAgC,GAAG,KAAK,KAAK;IAClD,CAAK,MAAA,iCAAiC,GAAG,KAAK,SAAS;EAAA;AAE/D;ACLO,SAAS,sDACZ,SACyC;AAClCC,SAAAA;IACH;IACA,CAAA,MAAKC,gCAAgC,GAAG,oBAAoB;IAC5D,CAAA,MAAKC,iCAAiC,GAAG,wBAAwB;EAAA;AAEzE;ACsBO,SAAS,kDACZ,QAC2E;AAC3E,SAAO,gDAAgD;IACnD,GAAG;IACH,gBAAgB;EAAA,CACnB;AACL;AAKO,SAAS,4CACZ,QAC2E;AAC3E,SAAO,gDAAgD;IACnD,GAAG;IACH,gBAAgB;EAAA,CACnB;AACL;AAEA,SAAS,gDACL,QAG2E;AAC3E,MAAI,UAAU,KAAK,OAAO,GAAG,MAAM,OAAO;AACtC,UAAM,gBAAgB,OAAO,IAAI,MAAM,WAAW;AAClD,UAAM,IAAI;MACN,gBACM,oFACW,cAAc,CAAC,CAAC,uBAC3B,6CAA6C,OAAO,GAAG;IAAA;EACjE;AAEJ,QAAM,EAAE,YAAY,GAAG,KAAA,IAAS;AAChC,QAAM,uCAAwC,CAAC,EAAE,YAAA,MAAkB;AAC/D,WAAO,uBAAuB;MAC1B,GAAG;MACH,yBACI,OAAO;MAEP;MACJ,QAAQ;IAAA,CACX,EACI,KAAK,OAAO,cAAc,EAC1B;MAAK,CAAA,YACF,uCAAuC;QACnC;QACA;QACA,YAAY,cAAc;MAAA,CAC7B;IAAA;EACL;AAER,SAAO,gCAAgC,sCAAsC;IACzE,4BACI,OAAO;;;;;;;;IASP;IACJ,aAAa,OAAO,eAAe;EAAA,CACtC;AACL;AC/FO,SAAS,uDACZ,WACU;AACJ,QAAAC,SAAA,oBAAY,IAAwB;AACnC,SAAA,SAAS,oDAAoD,QAAQ;AAClE,UAAA,EAAE,SAAS,OAAA,IAAW;AAC5B,UAAM,gCAAgC,cAAoB,CAAC,QAAQ,YAAY,QAAQ,MAAM,CAAC;AAE1F,QAAA,6BAA6BA,OAAM,IAAI,6BAA6B;AACxE,QAAI,CAAC,4BAA4B;AACvB,YAAA,kBAAkB,IAAIJ,GAAgB;AAC5C,YAAM,uBAAuB,UAAU;QACnC,GAAG;QACH,QAAQ,gBAAgB;MAAA,CAC3B;AACD,2BACK,KAAK,CAAiB,kBAAA;AACL,sBAAA;UACV;UACA,MAAM;AACF,YAAAI,OAAM,OAAO,6BAA6B;AAC1C,4BAAgB,MAAM;UAAA;UAE1B,EAAE,QAAQ,gBAAgB,OAAO;QAAA;MACrC,CACH,EACA,MAAM,MAAM;MAAA,CAAE;AACb,MAAAA,OAAA;QACF;QACC,6BAA6B;UAC1B;UACA;UACA,gBAAgB;QAAA;MACpB;IACJ;AAEuB,+BAAA;AACpB,WAAA;MACH;MACA,MAAM;AACyB,mCAAA;AACvB,YAAA,2BAA2B,mBAAmB,GAAG;AACjD,yBAAe,MAAM;AACb,gBAAA,2BAA2B,mBAAmB,GAAG;AACjD,cAAAA,OAAM,OAAO,6BAA6B;AAC1C,yCAA2B,gBAAgB,MAAM;YAAA;UACrD,CACH;QAAA;MACL;MAEJ,EAAE,QAAQ,2BAA2B,gBAAgB,OAAO;IAAA;AAEhE,WAAO,2BAA2B;EAAA;AAE1C;AC3CO,SAAS,uCAAuE;EACnF;AACJ,GAAwD;AAC7CH,SAAAA;IACH;MACI;IAAA;IAEJ,CAAA,cAAa,uDAAuD,SAAS;EAAA;AAErF;AAEO,SAAS,kDAId,eAAgC;AAC9B,SAAQ,OAAO,EAAE,SAAS,OAAA,MAAa;AACnC,UAAM,UAAU,MAAM,cAAc,EAAE,aAAa,OAAA,CAAQ;AAC3D,WAAO,MAAM,QAAQ,EAAE,SAAS,OAAA,CAAQ;EAAA;AAQhD;ACpCA,SAAS,iCACL,YACA,QACF;AACE,QAAM,YAAY,uCAAuC;IACrD,eAAe,kDAAkD,EAAE,GAAG,QAAQ,KAAK,WAAA,CAAY;EAAA,CAClG;AACD,SAAO,0CAAkE,SAAS;AACtF;AAOO,SAAS,6BACZ,YACA,QACF;AACS,SAAA,iCAAyE,YAAY,MAAM;AACtG;AAOO,SAAS,sCACZ,YACA,QACF;AACS,SAAA;IACH;IACA;EAAA;AAER;AAMO,SAAS,0CAGd,WAAuB;AACrB,SAAO,sBAAsB;IACzB,KAAK,gCAAsC,gCAAgC;IAC3E;EAAA,CACH;AACL;A;;;ACpCO,SAAS,YAAY,mBAA2D;AACnF,SAAO,UAAU,iBAAiB;AACtC;AA2BO,SAAS,kBAAkB,mBAAmE;AAC7F,MAAA;AACA,oBAAgB,iBAAiB;EAAA,SAC5B,OAAO;AACR,QAAA,cAAc,OAAO,mDAAmD,GAAG;AAC3E,YAAM,IAAI,YAAY,oDAAoD,MAAM,OAAO;IAAA;AAEvF,QAAA,cAAc,OAAO,4CAA4C,GAAG;AACpE,YAAM,IAAI,YAAY,6CAA6C,MAAM,OAAO;IAAA;AAE9E,UAAA;EAAA;AAEd;AAwBO,SAAS,UAAU,mBAAsC;AAC5D,oBAAkB,iBAAiB;AAC5B,SAAA;AACX;AAoBO,SAAS,sBAAuD;AACnE,QAAM,iBAAiB,kBAAkB;AACzC,SAAO,cAAc;IACjB,WAAW;IACX,OAAO,CAAC,OAAe,OAAO,WAAW;AACrC,wBAAkB,KAAK;AACvB,aAAO,eAAe,MAAM,OAA4B,OAAO,MAAM;IAAA;EACzE,CACH;AACL;AAoBO,SAAS,sBAAuD;AACnE,SAAO,kBAAkB;AAC7B;AAQO,SAAS,oBAA8D;AAC1E,SAAO,aAAa,oBAAA,GAAuB,oBAAA,CAAqB;AACpE;AAEO,SAAS,yBAA2D;AAChE,SAAA,IAAI,KAAK,SAAS,MAAM;IAC3B,WAAW;IACX,mBAAmB;IACnB,eAAe;IACf,SAAS;IACT,aAAa;IACb,OAAO;EAAA,CACV,EAAE;AACP;ACtKO,SAAS,QAAQ,gBAAoC;AACjD,SAAA;AACX;AAEO,SAAS,OAAO,gBAAmC;AAC/C,SAAA;AACX;AAEO,SAAS,QAAQ,gBAAoC;AACjD,SAAA;AACX;ACNA,SAAS,mBAAmB,YAAgC;AACxD,UAAQ,YAAY;IAChB,KAAK;AACM,aAAA;IACX,KAAK;AACM,aAAA;IACX,KAAK;AACM,aAAA;IACX;AACU,YAAA,IAAII,YAAY,8DAA8D;QAChF,iBAAiB;MAAA,CACpB;EAAA;AAEb;AAEO,SAAS,qBAAqB,GAAe,GAA2B;AAC3E,MAAI,MAAM,GAAG;AACF,WAAA;EAAA;AAEX,SAAO,mBAAmB,CAAC,IAAI,mBAAmB,CAAC,IAAI,KAAK;AAChE;ACRA,IAAM,cAAc;AAEpB,IAAI;AACJ,IAAI;AAEJ,SAAS,wBAA8D;AAC/D,MAAA,CAAC,mBAAoB,sBAAqB,cAAc;AACrD,SAAA;AACX;AAEA,SAAS,wBAAqD;AACtD,MAAA,CAAC,mBAAoB,sBAAqB,cAAc;AACrD,SAAA;AACX;AAmBO,SAAS,WAAW,kBAAwD;AACxE,SAAA,oBAAoB,KAAK,oBAAoB;AACxD;AA8BO,SAAS,iBAAiB,kBAAgE;AACzF,MAAA,mBAAmB,KAAK,mBAAmB,aAAa;AAClD,UAAA,IAAIA,YAAY,mCAAmC;EAAA;AAEjE;AAaO,SAAS,SAAS,kBAAoC;AACzD,mBAAiB,gBAAgB;AAC1B,SAAA;AACX;AAQO,SAAS,4BAA2D;AAChE,SAAA,mBAAmB,sBAAA,CAAuB;AACrD;AAkBO,SAAS,mBACZ,cACmE;AAC5D,SAAA;AACX;AAMO,SAAS,4BAA2D;AAChE,SAAA,mBAAmB,sBAAA,CAAuB;AACrD;AAmBO,SAAS,mBACZ,cACmE;AAC5D,SAAA;IAA4C;IAAc,CAAA,UAC7D,SAAS,OAAO,UAAU,WAAW,QAAQ,OAAO,KAAK,CAAC;EAAA;AAElE;AAQO,SAAS,0BAAiE;AAC7E,SAAOC,aAAa,0BAAA,GAA6B,0BAAA,CAA2B;AAChF;AAQO,SAAS,iBACZ,YACuE;AACvE,SAAOA,aAAa,mBAAmB,UAAU,GAAG,mBAAmB,UAAU,CAAC;AAEtF;ACzKO,SAAS,oBAAoB,gBAA6D;AACzF,MAAA;AACA,WAAO,cAAc;AACd,WAAA;EAAA,QACH;AACG,WAAA;EAAA;AAEf;AAwBO,SAAS,0BAA0B,gBAAqE;AACvG,MAAA;AACA,WAAO,cAAc;EAAA,QACjB;AACE,UAAA,IAAID,YAAY,uCAAuC;MACzD,OAAO;IAAA,CACV;EAAA;AAET;AAaO,SAAS,kBAAkB,gBAA2C;AACzE,4BAA0B,cAAc;AACjC,SAAA;AACX;ACtDO,SAAS,oBAAoB,gBAA6D;AAC7F,SAAO,CAAC,OAAO,MAAM,OAAO,cAAc,CAAC;AAC/C;AAwBO,SAAS,0BAA0B,gBAAqE;AAC3G,MAAI,OAAO,MAAM,OAAO,cAAc,CAAC,GAAG;AAChC,UAAA,IAAIA,YAAY,uCAAuC;MACzD,OAAO;IAAA,CACV;EAAA;AAET;AAaO,SAAS,kBAAkB,gBAA2C;AACzE,4BAA0B,cAAc;AACjC,SAAA;AACX;AC/DA,IAAM,cAAc;AACpB,IAAM,cAAc,CAAC;AAoBd,SAAS,gBAAgB,mBAA+D;AACpF,SAAA,qBAAqB,eAAe,qBAAqB;AACpE;AA2BO,SAAS,sBAAsB,mBAAuE;AACrG,MAAA,oBAAoB,eAAe,oBAAoB,aAAa;AAC9D,UAAA,IAAIA,YAAY,sCAAsC;MACxD,OAAO;IAAA,CACV;EAAA;AAET;AAaO,SAAS,cAAc,mBAA0C;AACpE,wBAAsB,iBAAiB;AAChC,SAAA;AACX;A;;;;;;;;;ACrBO,SAAS,0CACZ,oBACsF;AACtF,SACI,wBAAwB,sBACxB,OAAO,mBAAmB,mBAAmB,cAAc,YAC3D,OAAO,mBAAmB,mBAAmB,yBAAyB,YACtE,YAAY,mBAAmB,mBAAmB,SAAS;AAEnE;AAwBO,SAAS,gDACZ,oBAC8F;AAC1F,MAAA,CAAC,0CAA0C,kBAAkB,GAAG;AAC1D,UAAA,IAAI,YAAY,sDAAsD;EAAA;AAEpF;AAeO,SAAS,4CAGZ,6BACA,oBACgG;AAGhG,MACI,wBAAwB,sBACxB,mBAAmB,sBACnB,eAAe,mBAAmB,sBAClC,mBAAmB,mBAAmB,cAAc,4BAA4B,aAChF,mBAAmB,mBAAmB,yBAAyB,4BAA4B,sBAC7F;AACS,WAAA;EAAA;AAGX,SAAO,OAAO,OAAO;IACjB,GAAG;IACH,oBAAoB,OAAO,OAAO,2BAA2B;EAAA,CAChE;AACL;ACpHO,SAASE,uBAAsBC,WAAkB,WAAmB,aAAa,WAAW;AAC3F,MAAA,CAAC,UAAU,MAAM,IAAI,OAAO,KAAKA,SAAQ,KAAK,CAAC,GAAG;AAC5C,UAAA,IAAIC,YAAY,+CAA+C;MACjE,UAAAD;MACA,MAAMA,UAAS;MACf,OAAO;KACV;EAAA;AAET;ACEa,IAAAE,mBAAkB,CAACF,cAAkD;AAC9E,SAAO,cAAc;IACjB,kBAAkB,CAAC,UAA0B;AACnC,YAAA,CAAC,eAAe,SAAS,IAAIG,wBAAuB,OAAOH,UAAS,CAAC,CAAC;AACxE,UAAA,CAAC,UAAW,QAAO,MAAM;AAEvB,YAAA,eAAeI,oBAAmB,WAAWJ,SAAQ;AACpD,aAAA,cAAc,SAAS,KAAK,KAAK,aAAa,SAAS,EAAE,EAAE,SAAS,CAAC;IAAA;IAEhF,MAAM,OAAe,OAAO,QAAQ;AAEhC,MAAAD,uBAAsBC,WAAU,KAAK;AACjC,UAAA,UAAU,GAAW,QAAA;AAGnB,YAAA,CAAC,eAAe,SAAS,IAAIG,wBAAuB,OAAOH,UAAS,CAAC,CAAC;AAC5E,UAAI,CAAC,WAAW;AACN,cAAA,IAAI,IAAI,WAAW,cAAc,MAAM,EAAE,KAAK,CAAC,GAAG,MAAM;AAC9D,eAAO,SAAS,cAAc;MAAA;AAI9B,UAAA,eAAeI,oBAAmB,WAAWJ,SAAQ;AAGzD,YAAM,YAAsB,CAAA;AAC5B,aAAO,eAAe,IAAI;AACtB,kBAAU,QAAQ,OAAO,eAAe,IAAI,CAAC;AAC7B,wBAAA;MAAA;AAGd,YAAA,aAAa,CAAC,GAAG,MAAM,cAAc,MAAM,EAAE,KAAK,CAAC,GAAG,GAAG,SAAS;AAClE,YAAA,IAAI,YAAY,MAAM;AAC5B,aAAO,SAAS,WAAW;IAAA;GAElC;AACL;AAuBa,IAAAK,mBAAkB,CAACL,cAAkD;AAC9E,SAAO,cAAc;IACjB,KAAK,UAAU,QAA0B;AACrC,YAAM,QAAQ,WAAW,IAAI,WAAW,SAAS,MAAM,MAAM;AAC7D,UAAI,MAAM,WAAW,EAAU,QAAA,CAAC,IAAI,CAAC;AAGrC,UAAI,aAAa,MAAM,UAAU,CAAA,MAAK,MAAM,CAAC;AAChC,mBAAA,eAAe,KAAK,MAAM,SAAS;AAChD,YAAM,gBAAgBA,UAAS,CAAC,EAAE,OAAO,UAAU;AACnD,UAAI,eAAe,MAAM,OAAA,QAAe,CAAC,eAAe,SAAS,MAAM;AAGvE,YAAM,eAAe,MAAM,MAAM,UAAU,EAAE,OAAO,CAAC,KAAK,SAAS,MAAM,OAAO,OAAO,IAAI,GAAG,EAAE;AAG1F,YAAA,YAAYM,oBAAmB,cAAcN,SAAQ;AAE3D,aAAO,CAAC,gBAAgB,WAAW,SAAS,MAAM;IAAA;GAEzD;AACL;AAkDA,SAASG,wBACL,OACA,eACqD;AAC/C,QAAA,CAAC,cAAc,SAAS,IAAI,MAAM,MAAM,IAAI,OAAO,OAAO,aAAa,MAAM,CAAC;AAC7E,SAAA,CAAC,cAAc,SAAS;AACnC;AAEA,SAASC,oBAAmB,OAAeJ,WAA0B;AAC3D,QAAA,OAAO,OAAOA,UAAS,MAAM;AACnC,MAAI,MAAM;AACV,aAAW,QAAQ,OAAO;AACf,WAAA;AACP,WAAO,OAAOA,UAAS,QAAQ,IAAI,CAAC;EAAA;AAEjC,SAAA;AACX;AAEA,SAASM,oBAAmB,OAAeN,WAA0B;AAC3D,QAAA,OAAO,OAAOA,UAAS,MAAM;AACnC,QAAM,YAAY,CAAA;AAClB,SAAO,QAAQ,IAAI;AACf,cAAU,QAAQA,UAAS,OAAO,QAAQ,IAAI,CAAC,CAAC;AACvC,aAAA;EAAA;AAEN,SAAA,UAAU,KAAK,EAAE;AAC5B;AC1LA,IAAMA,aAAW;AAqBJ,IAAAO,oBAAmB,MAAML,iBAAgBF,UAAQ;AAoBjD,IAAAQ,oBAAmB,MAAMH,iBAAgBL,UAAQ;AC3B9D,IAAI;AACG,SAAS,+BAAwE;AACpF,MAAI,CAAC,mCAAmC;AAC9B,UAAA,eAAe,gBAAgB,aAAa,GAAG,EAAE,MAAM,mBAAA,EAAA,CAAsB;AAGnF,wCAAoC,iBAAiB;MACjD,CAAC,sBAAsB,kBAAA,CAAmB;MAC1C,CAAC,mBAAmB,YAAY;MAChC,CAAC,mBAAmB,YAAY;IAAA,CACnC;EAAA;AAGE,SAAA;AACX;AAEA,IAAI;AACG,SAAS,+BAAwE;AACpF,MAAI,CAAC,mCAAmC;AAC9B,UAAA,eAAe,gBAAgB,aAAa,GAAG,EAAE,MAAM,mBAAA,EAAA,CAAsB;AAE/C,wCAAA;MAChC,iBAAiB;QACb,CAAC,sBAAsB,kBAAA,CAAmB;QAC1C,CAAC,mBAAmB,YAAY;QAChC,CAAC,mBAAmB,YAAY;MAAA,CACnC;MACD,CAAA,gBACI,qBAAqB,cACd;QACG,GAAG;QACH,iBAAiB,YAAY;;QAE7B,iBAAiB,YAAY;MAAA,IAEjC;IAAA;EACd;AAIG,SAAA;AACX;ACjDA,IAAI;AACJ,SAAS,uBAAoD;AACrD,MAAA,CAAC,kBAAmB,qBAAoBS,aAAa;AAClD,SAAA;AACX;AAEA,IAAI;AACJ,SAAS,uBAAoD;AACrD,MAAA,CAAC,kBAAmB,qBAAoBC,aAAa;AAClD,SAAA;AACX;AAQO,SAAS,0BAA8D;AAC1E,SAAOC,iBAAiB;IACpB,CAAC,qBAAqB,qBAAA,CAAsB;IAC5C,CAAC,6BAA6B,qBAAA,CAAsB;IACpD,CAAC,gCAAgC,qBAAA,CAAsB;EAAA,CAC1D;AACL;AAEO,SAAS,0BAA8D;AAC1E,SAAOC,iBAAiB;IACpB,CAAC,qBAAqB,qBAAA,CAAsB;IAC5C,CAAC,6BAA6B,qBAAA,CAAsB;IACpD,CAAC,gCAAgC,qBAAA,CAAsB;EAAA,CAC1D;AACL;AChBA,IAAI;AACG,SAAS,wBAA0D;AACtE,MAAI,CAAC,+BAA+B;AACA,oCAAA;MAC5BD,iBAAiB;QACb,CAAC,uBAAuBF,aAAAA,CAAc;QACtC,CAAC,kBAAkBI,gBAAgBJ,aAAa,GAAG,EAAE,MAAMK,mBAAAA,EAAqB,CAAC,CAAC;QAClF,CAAC,QAAQ,qBAAqB,gBAAA,GAAmBA,mBAAAA,CAAoB,CAAC;MAAA,CACzE;;MAED,CAAC,gBAAoD;AACjD,YAAI,YAAY,mBAAmB,UAAa,YAAY,SAAS,QAAW;AACrE,iBAAA;QAAA;AAEJ,eAAA;UACH,GAAG;UACH,gBAAgB,YAAY,kBAAkB,CAAA;UAC9C,MAAM,YAAY,QAAQ,IAAI,WAAW,CAAC;QAAA;MAC9C;IACJ;EACJ;AAGG,SAAA;AACX;AAEA,IAAI;AACG,SAAS,wBAA0D;AACtE,MAAI,CAAC,+BAA+B;AACAC,oCAAAA;MAC5BH,iBAAiB;QACb,CAAC,uBAAuBF,aAAAA,CAAc;QACtC,CAAC,kBAAkBM,gBAAgBN,aAAa,GAAG,EAAE,MAAMO,mBAAAA,EAAqB,CAAC,CAAC;QAClF;UACI;UACA,qBAAqB,gBAAA,GAAmBA,mBAAAA,CAAoB;QAAA;MAChE,CACH;;MAED,CAAC,gBAAoD;AACjD,YAAI,YAAY,eAAe,UAAU,YAAY,KAAK,YAAY;AAC3D,iBAAA;QAAA;AAEX,cAAM,EAAE,gBAAgB,MAAM,GAAG,KAAA,IAAS;AACnC,eAAA;UACH,GAAG;UACH,GAAI,eAAe,SAAS,EAAE,eAAA,IAAmB;UACjD,GAAI,KAAK,aAAa,EAAE,KAAA,IAAS;QAAA;MACrC;IACJ;EACJ;AAEG,SAAA;AACX;ACjEA,IAAM,oBAAoB;AAQnB,SAAS,+BAAwE;AACpF,SAAOC,cAAc;IACjB,kBAAkB,CAAA,UAAU,UAAU,WAAW,IAAI;IACrD,SAAS;IACT,OAAO,CAAC,OAAO,OAAO,WAAW;AAC7B,UAAI,UAAU,UAAU;AACb,eAAA;MAAA;AAEP,UAAA,QAAQ,KAAK,QAAQ,KAAK;AACpB,cAAA,IAAIjB,YAAY,wDAAwD;UAC1E,eAAe;QAAA,CAClB;MAAA;AAEL,YAAM,IAAI,CAAC,QAAQ,iBAAiB,GAAG,MAAM;AAC7C,aAAO,SAAS;IAAA;EACpB,CACH;AACL;AASO,SAAS,+BAAwE;AACpF,SAAOkB,cAAc;IACjB,SAAS;IACT,MAAM,CAAC,OAAO,WAAW;AACf,YAAA,YAAY,MAAM,MAAM;AACzB,WAAA,YAAY,uBAAuB,GAAG;AAEhC,eAAA,CAAC,UAAU,MAAM;MAAA,OACrB;AACH,cAAM,UAAW,YAAY;AACtB,eAAA,CAAC,SAAS,SAAS,CAAC;MAAA;IAC/B;EACJ,CACH;AACL;AAQO,SAAS,6BAAoE;AAChF,SAAOC,aAAa,6BAAA,GAAgC,6BAAA,CAA8B;AACtF;AC9CA,SAAS,kCAAmF;AACjFT,SAAAA,iBAAiB,6BAAA,CAA8B;AAC1D;AAEA,SAAS,qCAAsF;AACpFU,SAAAA;IACHV,iBAAiB;MACb,GAAG,6BAA6B;MAChC,CAAC,uBAAuB,kCAAA,CAAmC;IAAA,CAC9D;IACD,CAAC,UAAsC;AAC/B,UAAA,MAAM,YAAY,UAAU;AACrB,eAAA;MAAA;AAEJ,aAAA;QACH,GAAG;QACH,qBAAqB,MAAM,uBAAuB,CAAA;MAAC;IACvD;EACJ;AAER;AAEA,SAAS,+BAA+B;AAC7B,SAAA;IACH,CAAC,WAAW,6BAAA,CAA8B;IAC1C,CAAC,UAAU,wBAAA,CAAyB;IACpC,CAAC,kBAAkBE,gBAAgBS,kBAAkB,GAAG,EAAE,MAAMR,mBAAAA,EAAqB,CAAC,CAAC;IACvF,CAAC,iBAAiB,eAAeP,kBAAiB,GAAG,EAAE,CAAC;IACxD,CAAC,gBAAgBM,gBAAgB,sBAAsB,GAAG,EAAE,MAAMC,mBAAAA,EAAqB,CAAC,CAAC;EAAA;AAEjG;AAEA,SAAS,+BAA+B;AAC7B,SAAA;IACH,CAAC,WAAW,6BAAA,CAAiD;IAC7D,CAAC,UAAU,wBAAA,CAAyB;IACpC,CAAC,kBAAkBE,gBAAgBO,kBAAkB,GAAG,EAAE,MAAMN,mBAAAA,EAAqB,CAAC,CAAC;IACvF,CAAC,iBAAiB,eAAeT,kBAAiB,GAAG,EAAE,CAAC;IACxD,CAAC,gBAAgBQ,gBAAgB,sBAAsB,GAAG,EAAE,MAAMC,mBAAAA,EAAqB,CAAC,CAAC;IACzF,CAAC,uBAAuB,kCAAA,CAAmC;EAAA;AAEnE;AAEA,SAAS,oCAAoC;AACzC,SAAOJ,gBAAgB,6BAA6B,GAAG,EAAE,MAAMC,mBAAAA,EAAAA,CAAsB;AACzF;AAEA,SAAS,oCAAoC;AACzC,SAAOE,gBAAgB,6BAA6B,GAAG,EAAE,MAAMC,mBAAAA,EAAAA,CAAsB;AACzF;AASO,SAAS,uCAAwF;AACpG,SAAOC,cAAc;IACjB,kBAAkB,CAAC,oBAAgD;AAC3D,UAAA,gBAAgB,YAAY,UAAU;AAC/B,eAAA,gCAAA,EAAkC,iBAAiB,eAAe;MAAA,OACtE;AACI,eAAA,mCAAA,EAAqC,iBAAiB,eAAe;MAAA;IAChF;IAEJ,OAAO,CAAC,iBAAiB,OAAO,WAAW;AACnC,UAAA,gBAAgB,YAAY,UAAU;AACtC,eAAO,gCAAgC,EAAE,MAAM,iBAAiB,OAAO,MAAM;MAAA,OAC1E;AACH,eAAO,mCAAmC,EAAE,MAAM,iBAAiB,OAAO,MAAM;MAAA;IACpF;EACJ,CACH;AACL;AASO,SAAS,uCAAwF;AAC7FH,SAAAA;IACHH,iBAAiB,6BAAA,CAA8B;IAG/C,CAAC,EAAE,qBAAqB,GAAG,cAAA,MAAoB;AAC3C,UAAI,cAAc,YAAY,YAAY,CAAC,qBAAqB,QAAQ;AAC7D,eAAA;MAAA;AAEJ,aAAA,EAAE,GAAG,eAAe,oBAAoB;IAAA;EAInD;AAER;AAQO,SAAS,qCAAoF;AAChG,SAAOQ,aAAa,qCAAA,GAAwC,qCAAA,CAAsC;AACtG;ACzFA,SAAS,OACL,YACAI,UACA,QAGF;AACa,aAAAA,QAAO,IAAI,OAAO,WAAWA,QAAO,KAAK,EAAE,MAAM,YAAY,SAAA,CAAU;AACtF;AAEA,IAAMC,QAAO,OAAO,wBAAwB;AAGrC,SAAS,8BAA8B,UAAmB,cAAkD;AAC/G,QAAM,aAAyB;IAC3B,CAAC,QAAQ,GAAG,EAAE,CAACA,KAAI,GAAG,GAA+B,MAAM,YAAY,gBAAgB;EAAA;AAErF,QAAA,6BAAA,oBAAiC,IAAa;AACpD,aAAW,eAAe,cAAc;AAC7B,WAAA,YAAY,YAAY,gBAAgB,CAAS,UAAA;AACzB,iCAAA,IAAI,YAAY,cAAc;AACzD,UAAIA,SAAQ,OAAO;AACX,YAAA,eAAe,MAAM,IAAI,GAAG;AACpB,kBAAA,MAAMA,KAAI,GAAG;YACjB,KAAK;AACK,oBAAA,IAAIxB,YAAY,6DAA6D;gBAC/E,gBAAgB,YAAY;cAAA,CAC/B;YACL;AACU,oBAAA,IAAIA,YAAY,kEAAkE;gBACpF,gBAAgB,YAAY;cAAA,CAC/B;UAAA;QACT;AAEA,YAAA,MAAMwB,KAAI,MAAM,GAA4B;AACrC,iBAAA;QAAA;MACX;AAEJ,aAAO,EAAE,CAACA,KAAI,GAAG,GAA4B,MAAM,YAAY,SAAS;IAAA,CAC3E;AACG,QAAA;AACA,QAAA,CAAC,YAAY,UAAU;AACvB;IAAA;AAEO,eAAA,WAAW,YAAY,UAAU;AACjC,aAAA,YAAY,QAAQ,SAAS,CAAS,UAAA;AACnC,cAAA;;UAEF,SAAS;UACT,GAAG;QAAA,IACH;AACJ,YAAIA,SAAQ,OAAO;AACP,kBAAA,MAAMA,KAAI,GAAG;YACjB,KAAK;AAGM,qBAAA;YACX,KAAK,GAAkC;AACnC,oBAAM,WAAW,WAAW,MAAM,MAAM,YAAY,IAAI;AACxD,kBAAI,wBAAwB,aAAa;AAC/B,sBAAA;;kBAEF,MAAM,uBAAuB,YAAY;mBAExC,sBAAsB,qBAAqB;oBACxC,YAAY;oBACZ,MAAM;kBAAA,IACN;;AACR,oBAAI,oBAAoB;AACb,yBAAA;oBACH,CAACA,KAAI,GAAG;oBACR,GAAG;oBACH,MAAM;kBAAA;gBACV;cACJ,WACO,aAAa,YAAY,IAAI,GAAG;AAEhC,uBAAA;kBACH,CAACA,KAAI,GAAG;kBACR,MAAM;gBAAA;cACV;AAEA,kBAAA,MAAM,SAAS,UAAU;AAClB,uBAAA;kBACH,GAAG;kBACH,MAAM;gBAAA;cACV,OACG;AACI,uBAAA;cAAA;YACX;YAEJ,KAAK,GAA4B;AAC7B,oBAAM,WAAW,WAAW,MAAM,MAAM,YAAY,IAAI;AACxD;;;gBAGI,2BAA2B,IAAI,QAAQ,OAAO;gBAChD;AACM,oBAAA,eAAe,YAAY,IAAI,GAAG;AAClC,wBAAM,IAAIxB;oBACN;oBACA;sBACI,gBAAgB,QAAQ;oBAAA;kBAC5B;gBACJ;AAEA,oBAAA,MAAM,SAAS,UAAU;AAClB,yBAAA;oBACH,GAAG;oBACH,MAAM;kBAAA;gBACV,OACG;AACI,yBAAA;gBAAA;cACX,WAEA,wBAAwB;;cAGxB,CAAC,aAAa,MAAM,IAAI,GAC1B;AACS,uBAAA;kBACH,GAAG;kBACH,CAACwB,KAAI,GAAG;kBACR,MAAM;gBAAA;cACV,OACG;AACC,oBAAA,MAAM,SAAS,UAAU;AAElB,yBAAA;oBACH,GAAG;oBACH,MAAM;kBAAA;gBACV,OACG;AACI,yBAAA;gBAAA;cACX;YACJ;UACJ;QACJ;AAEJ,YAAI,wBAAwB,aAAa;AAC9B,iBAAA;YACH,GAAG;YACH,CAACA,KAAI,GAAG;;UAAA;QACZ,OACG;AACI,iBAAA;YACH,GAAG;YACH,CAACA,KAAI,GAAG;;UAAA;QACZ;MACJ,CACH;IAAA;EACL;AAEG,SAAA;AACX;AAEO,SAAS,iCAAiC,YAAyC;AAClF,MAAA;AACJ,QAAM,kBAAuD,OAAO,QAAQ,UAAU,EACjF,KAAK,CAAC,CAAC,aAAa,SAAS,GAAG,CAAC,cAAc,UAAU,MAAM;AAE5D,QAAI,UAAUA,KAAI,MAAM,WAAWA,KAAI,GAAG;AAClC,UAAA,UAAUA,KAAI,MAAM,GAA+B;AAC5C,eAAA;MAAA,WACA,WAAWA,KAAI,MAAM,GAA+B;AACpD,eAAA;MAAA,WACA,UAAUA,KAAI,MAAM,GAA4B;AAChD,eAAA;MAAA,WACA,WAAWA,KAAI,MAAM,GAA4B;AACjD,eAAA;MAAA;IACX;AAGE,UAAA,eAAe,aAAa,UAAU,IAAI;AAChD,QAAI,iBAAiB,aAAa,WAAW,IAAI,GAAG;AAChD,aAAO,eAAe,KAAK;IAAA;AAEzB,UAAA,iBAAiB,eAAe,UAAU,IAAI;AACpD,QAAI,mBAAmB,eAAe,WAAW,IAAI,GAAG;AACpD,aAAO,iBAAiB,KAAK;IAAA;AAGjC,0BAAsB,qBAAqB;AAEvC,QAAA,UAAUA,KAAI,MAAM,KACpB,WAAWA,KAAI,MAAM,KACrB,UAAU,uBAAuB,WAAW,oBAC9C;AACE,aAAO,kBAAkB,UAAU,oBAAoB,WAAW,kBAAkB;IAAA,OACjF;AACI,aAAA,kBAAkB,aAAa,YAAY;IAAA;EACtD,CACH,EACA,IAAI,CAAC,CAACD,UAAS,WAAW,OAAO;IAC9B,SAAAA;IACA,GAAG;EAAA,EACL;AACC,SAAA;AACX;AChOO,SAAS,+BAA+B,iBAAwD;AACnG,QAAM,QAKF,CAAA;AACJ,aAAW,WAAW,iBAAiB;AAC/B,QAAA,EAAE,wBAAwB,UAAU;AACpC;IAAA;AAEJ,UAAM,QAAS,MAAM,QAAQ,kBAAkB,MAAM;;MAEjD,iBAAiB,CAAA;MACjB,iBAAiB,CAAA;MACjB,iBAAiB,CAAA;;MAEjB,iBAAiB,CAAA;IAAC;AAElB,QAAA,QAAQ,SAASE,YAAY,UAAU;AACjC,YAAA,gBAAgB,KAAK,QAAQ,YAAY;AAEzC,YAAA,gBAAgB,KAAK,QAAQ,YAAY;IAAA,OAC5C;AAEG,YAAA,gBAAgB,KAAK,QAAQ,YAAY;AACzC,YAAA,gBAAgB,KAAK,QAAQ,YAAY;IAAA;EACnD;AAEG,SAAA,OAAO,KAAK,KAAK,EACnB,KAAKC,qBAAqB,CAAC,EAC3B,IAAI,CAAuB,wBAAA;IACxB;IACA,GAAG,MAAM,kBAAwC;EAAA,EACnD;AACV;ACnBO,SAAS,yBAAyB,iBAAiD;AACtF,MAAI,+BAA+B;AACnC,MAAI,4BAA4B;AAChC,MAAI,oBAAoB;AACxB,aAAW,WAAW,iBAAiB;AACnC,QAAI,wBAAwB,SAAS;AACjC;IAAA;AAEE,UAAA,oBAAoBC,eAAe,QAAQ,IAAI;AACjDC,QAAAA,aAAa,QAAQ,IAAI,GAAG;AAC5B;AACA,UAAI,CAAC,mBAAmB;AACpB;MAAA;IACJ,WACO,CAAC,mBAAmB;AAC3B;IAAA;EACJ;AAEG,SAAA;IACH;IACA;IACA;EAAA;AAER;ACpCA,SAAS,gBAAgB,iBAAkC;AACvD,QAAM,MAA+B,CAAA;AACrC,aAAW,CAAC,OAAO,OAAO,KAAK,gBAAgB,QAAA,GAAW;AAClD,QAAA,QAAQ,OAAO,IAAI;EAAA;AAEpB,SAAA;AACX;AAEO,SAAS,wBACZ,cACA,iBACqB;AACf,QAAA,eAAe,gBAAgB,eAAe;AACpD,SAAO,aAAa,IAAI,CAAC,EAAE,UAAU,MAAM,eAAA,MAAqB;AACrD,WAAA;MACH,qBAAqB,aAAa,cAAc;MAChD,GAAI,WAAW,EAAE,gBAAgB,SAAS,IAAI,CAAC,EAAE,SAAAL,SAAA,MAAc,aAAaA,QAAO,CAAC,EAAA,IAAM;MAC1F,GAAI,OAAO,EAAE,KAAA,IAAS;IAAA;EAC1B,CACH;AACL;ACvCO,SAAS,yBACZ,oBAIM;AACN,MAAI,WAAW,oBAAoB;AAC/B,WAAO,mBAAmB;EAAA;AAE9B,SAAO,mBAAmB;AAC9B;ACRO,SAAS,0BAA0B,iBAA6C;AACnF,QAAM,+BAA+B,gBAAgB,UAAU,CAAA,YAAW,wBAAwB,OAAO;AACzG,QAAM,wBACF,iCAAiC,KAAK,kBAAkB,gBAAgB,MAAM,GAAG,4BAA4B;AACjH,SAAO,sBAAsB,IAAI,CAAC,EAAE,SAAAA,SAAA,MAAcA,QAAO;AAC7D;ACwDO,SAAS,0BACZ,oBAC0B;AAC1B,QAAM,aAAa;IACf,mBAAmB,SAAS;IAC5B,mBAAmB;EAAA;AAEjB,QAAA,kBAAkB,iCAAiC,UAAU;AAC5D,SAAA;IACH,GAAI,mBAAmB,YAAY,WAC7B,EAAE,qBAAqB,+BAA+B,eAAe,EAAA,IACrE;IACN,QAAQ,yBAAyB,eAAe;IAChD,cAAc,wBAAwB,mBAAmB,cAAc,eAAe;IACtF,eAAe,yBAAyB,mBAAmB,kBAAkB;IAC7E,gBAAgB,0BAA0B,eAAe;IACzD,SAAS,mBAAmB;EAAA;AAEpC;ACxEA,SAAS,0BACLA,UACA,MACA,+BAC6B;AAC7B,aAAW,CAAC,oBAAoB,SAAS,KAAK,OAAO,QAAQ,6BAA6B,GAAG;AACzF,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACnC,UAAAA,aAAY,UAAU,CAAC,GAAG;AACnB,eAAA;UACH,SAAAA;UACA,cAAc;UACd;UACA;QAAA;MACJ;IACJ;EACJ;AAER;AAwDO,SAAS,mDAGZ,oBACA,+BAC8E;AACxE,QAAA,uBAAuB,IAAI,IAAI,OAAO,OAAO,6BAA6B,EAAE,QAAQ,CAAK,MAAA,CAAC,CAAC;AAEjG,QAAM,kBAAiC,CAAA;AACvC,MAAI,yBAAyB;AAClB,aAAA,eAAe,mBAAmB,cAAc;AACnD,QAAA,CAAC,YAAY,UAAU;AACvB,sBAAgB,KAAK,WAAW;AAChC;IAAA;AAGJ,UAAM,cAA6D,CAAA;AACnE,QAAI,qBAAqB;AACd,eAAA,WAAW,YAAY,UAAU;AAGpC,UAAA,wBAAwB,WACxB,CAAC,qBAAqB,IAAI,QAAQ,OAAO,KACzCK,aAAa,QAAQ,IAAI,GAC3B;AACE,oBAAY,KAAK,OAAO;AACxB;MAAA;AAIJ,YAAM,oBAAoB;QACtB,QAAQ;QACR,QAAQ;QACR;MAAA;AAEJ,kBAAY,KAAK,OAAO,OAAO,iBAAiB,CAAC;AAC5B,2BAAA;AACI,+BAAA;IAAA;AAGb,oBAAA;MACZ,OAAO,OAAO,qBAAqB,EAAE,GAAG,aAAa,UAAU,YAAY,IAAI,WAAW;IAAA;EAC9F;AAGJ,SAAO,OAAO;IACV,yBAAyB,EAAE,GAAG,oBAAoB,cAAc,gBAAA,IAAoB;EAAA;AAE5F;AC5GO,SAAS,yBACZ,QACiC;AACjC,SAAO,OAAO,OAAO;IACjB,cAAc,OAAO,OAAO,CAAA,CAAE;IAC9B,SAAS,OAAO;EAAA,CACnB;AACL;ACDA,IAAM,oCACF;AACJ,IAAM,yBAAyB;AAexB,SAAS,qCAIZ,qBACA,uBAC4E;AACrE,SAAA;IACH,UAAU;MACN,EAAE,SAAS,qBAAqB,MAAMH,YAAY,SAAS;MAC3D;QACI,SAAS;QACT,MAAMA,YAAY;MAAA;MAEtB,EAAE,SAAS,uBAAuB,MAAMA,YAAY,gBAAgB;IAAA;IAExE,MAAM,IAAI,WAAW,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC;IACjC,gBAAgB;EAAA;AAExB;AAmBO,SAAS,iCACZ,aAC6C;AAC7C,SACI,YAAY,mBAAmB;EAE/B,YAAY,QAAQ,QACpB,qCAAqC,YAAY,IAAI;EAErD,YAAY,UAAU,WAAW;EAEjC,YAAY,SAAS,CAAC,EAAE,WAAW,QACnC,YAAY,SAAS,CAAC,EAAE,SAASA,YAAY;EAE7C,YAAY,SAAS,CAAC,EAAE,YAAY,qCACpC,YAAY,SAAS,CAAC,EAAE,SAASA,YAAY;EAE7C,YAAY,SAAS,CAAC,EAAE,WAAW,QACnCG,aAAa,YAAY,SAAS,CAAC,EAAE,IAAI;AAEjD;AAEA,SAAS,qCAAqC,MAAsE;AAEhH,SAAO,KAAK,eAAe,KAAK,KAAK,CAAC,MAAM,KAAK,KAAK,CAAC,MAAM,KAAK,KAAK,CAAC,MAAM,KAAK,KAAK,CAAC,MAAM;AACnG;ACfO,SAAS,6CACZ,oBACyF;AACzF,SACI,wBAAwB,sBACxB,OAAO,mBAAmB,mBAAmB,UAAU,YACvD,mBAAmB,aAAa,CAAC,KAAK,QACtC,iCAAiC,mBAAmB,aAAa,CAAC,CAAC;AAE3E;AAwBO,SAAS,mDACZ,oBACiG;AAC7F,MAAA,CAAC,6CAA6C,kBAAkB,GAAG;AAC7D,UAAA,IAAI5B,YAAY,kDAAkD;EAAA;AAEhF;AAEA,SAAS,yCAIL,aACA,qBACA,uBAC2F;AAEvF,SAAA,YAAY,SAAS,CAAC,EAAE,YAAY,uBACpC,YAAY,SAAS,CAAC,EAAE,YAAY;AAE5C;AAyCO,SAAS,+CAMZ;EACI;EACA;EACA;AACJ,GACA,oBAMF;AAQM,MAAA;AAKE,QAAA,mBAAmB,mBAAmB,aAAa,CAAC;AACtD,MAAA,oBAAoB,iCAAiC,gBAAgB,GAAG;AACxE,QAAI,yCAAyC,kBAAkB,qBAAqB,qBAAqB,GAAG;AACxG,UACI,6CAA6C,kBAAkB,KAC/D,mBAAmB,mBAAmB,UAAU,OAClD;AACS,eAAA;MAAA,OACJ;AAEH,0BAAkB,CAAC,kBAAkB,GAAG,mBAAmB,aAAa,MAAM,CAAC,CAAC;MAAA;IACpF,OACG;AAEe,wBAAA;QACd,OAAO,OAAO,qCAAqC,qBAAqB,qBAAqB,CAAC;QAC9F,GAAG,mBAAmB,aAAa,MAAM,CAAC;MAAA;IAC9C;EACJ,OACG;AAEe,sBAAA;MACd,OAAO,OAAO,qCAAqC,qBAAqB,qBAAqB,CAAC;MAC9F,GAAG,mBAAmB;IAAA;EAC1B;AAGJ,SAAO,OAAO,OAAO;IACjB,GAAG;IACH,cAAc,OAAO,OAAO,eAAe;IAC3C,oBAAoB,OAAO,OAAO,EAAE,MAAA,CAAO;EAAA,CAC9C;AACL;ACzNO,SAAS,8BAIZ,UACA,oBACyG;AAErG,MAAA,cAAc,sBACd,aAAa,mBAAmB,UAAU,WAC1C,sBAAsB,mBAAmB,QAAQ,GACnD;AACS,WAAA;EAAA;AAGX,QAAM,MAAM;IACR,GAAG;IACH,UAAU,OAAO,OAAO,EAAE,SAAS,SAAA,CAAU;EAAA;AAEjD,SAAO,OAAO,GAAG;AACV,SAAA;AACX;AAEA,SAAS,sBACL,UACgC;AAChC,SACI,CAAC,CAAC,YACF,aAAa,YACb,OAAO,SAAS,YAAY,YAC5B,OAAO,KAAK,QAAQ,EAAE,WAAW;AAEzC;ACdO,SAAS,oCAIZ,aACA,oBACyE;AACzE,SAAO,qCAAqC,CAAC,WAAW,GAAG,kBAAkB;AACjF;AA6BO,SAAS,qCAIZ,cACA,oBACwE;AACxE,SAAO,OAAO,OAAO;IACjB,GAAG;IACH,cAAc,OAAO,OAAO;MACxB,GAAI,mBAAmB;MACvB,GAAG;IAAA,CACiE;EAAA,CAC3E;AACL;AAuBO,SAAS,qCAIZ,aACA,oBAC0E;AAC1E,SAAO,sCAAsC,CAAC,WAAW,GAAG,kBAAkB;AAClF;AA6BO,SAAS,sCAIZ,cACA,oBACyE;AACzE,SAAO,OAAO,OAAO;IACjB,GAAI;IACJ,cAAc,OAAO,OAAO;MACxB,GAAG;MACH,GAAI,mBAAmB;IAAA,CAC6C;EAAA,CAC3E;AACL;ACzJA,SAAS,gBAAgB,SAAoD;AACnE,QAAA,EAAE,OAAA,IAAW;AACb,QAAA,4BAA4B,OAAO,oBAAoB,OAAO;AACpE,QAAM,+BACF,QAAQ,eAAe,SAAS,OAAO,oBAAoB,OAAO;AAEtE,QAAM,eAA8B,CAAA;AAEpC,MAAI,eAAe;AACnB,WAAS,IAAI,GAAG,IAAI,2BAA2B,KAAK;AAChD,iBAAa,KAAK;MACd,SAAS,QAAQ,eAAe,YAAY;MAC5C,MAAMyB,YAAY;IAAA,CACrB;AACD;EAAA;AAGJ,WAAS,IAAI,GAAG,IAAI,OAAO,2BAA2B,KAAK;AACvD,iBAAa,KAAK;MACd,SAAS,QAAQ,eAAe,YAAY;MAC5C,MAAMA,YAAY;IAAA,CACrB;AACD;EAAA;AAGJ,WAAS,IAAI,GAAG,IAAI,8BAA8B,KAAK;AACnD,iBAAa,KAAK;MACd,SAAS,QAAQ,eAAe,YAAY;MAC5C,MAAMA,YAAY;IAAA,CACrB;AACD;EAAA;AAGJ,WAAS,IAAI,GAAG,IAAI,OAAO,8BAA8B,KAAK;AAC1D,iBAAa,KAAK;MACd,SAAS,QAAQ,eAAe,YAAY;MAC5C,MAAMA,YAAY;IAAA,CACrB;AACD;EAAA;AAGG,SAAA;AACX;AAEA,SAAS,sBACL,6BACA,+BACmB;AAEnB,QAAM,sCAAsC,4BAA4B,IAAI,CAAA,MAAK,EAAE,kBAAkB;AACrG,QAAM,UAAU,oCAAoC,OAAO,CAAA,MAAK,8BAA8B,CAAC,MAAM,MAAS;AAC1G,MAAA,QAAQ,SAAS,GAAG;AACd,UAAA,IAAIzB,YAAY,sFAAsF;MACxG,sBAAsB;IAAA,CACzB;EAAA;AAGL,QAAM,gBAAqC,CAAA;AAC3C,QAAM,gBAAqC,CAAA;AAG3C,aAAW,UAAU,6BAA6B;AACxC,UAAA,YAAY,8BAA8B,OAAO,kBAAkB;AACzE,UAAM,kBACF,OAAO;IAEP,OAAO;AACX,UAAM,kBACF,OAAO;IAEP,OAAO;AAEX,UAAM,eAAe,KAAK,IAAI,GAAG,iBAAiB,GAAG,eAAe;AAChE,QAAA,gBAAgB,UAAU,QAAQ;AAClC,YAAM,IAAIA;QACN;QACA;UACI,mBAAmB,UAAU,SAAS;UACtC,uBAAuB;UACvB,oBAAoB,OAAO;QAAA;MAC/B;IACJ;AAGE,UAAA,oBAAyC,gBAAgB,IAAI,CAAM,OAAA;MACrE,SAAS,UAAU,CAAC;MACpB,cAAc;MACd,oBAAoB,OAAO;MAC3B,MAAMyB,YAAY;IAAA,EACpB;AACY,kBAAA,KAAK,GAAG,iBAAiB;AAEjC,UAAA,oBAAyC,gBAAgB,IAAI,CAAM,OAAA;MACrE,SAAS,UAAU,CAAC;MACpB,cAAc;MACd,oBAAoB,OAAO;MAC3B,MAAMA,YAAY;IAAA,EACpB;AACY,kBAAA,KAAK,GAAG,iBAAiB;EAAA;AAG3C,SAAO,CAAC,GAAG,eAAe,GAAG,aAAa;AAC9C;AAEA,SAAS,mBACL,aACA,cACW;AACX,QAAM,iBAAiB,aAAa,YAAY,mBAAmB,GAAG;AACtE,MAAI,CAAC,gBAAgB;AACX,UAAA,IAAIzB,YAAY,sFAAsF;MACxG,OAAO,YAAY;IAAA,CACtB;EAAA;AAGL,QAAM,WAAW,YAAY,gBAAgB,IAAI,CAAgB,iBAAA,aAAa,YAAY,CAAC;AACrF,QAAA,EAAE,KAAA,IAAS;AAEjB,SAAO,OAAO,OAAO;IACjB;IACA,GAAI,YAAY,SAAS,SAAS,EAAE,UAAU,OAAO,OAAO,QAAQ,EAAE,IAAI,CAAA;IAC1E,GAAI,QAAQ,KAAK,SAAS,EAAE,KAAA,IAAS,CAAA;EAAC,CACzC;AACL;AAaA,SAAS,sBACL,sBACA,kBACA,sBACkB;AAClB,MAAI,CAAC,oBAAoB,CAAC,iCAAiC,gBAAgB,GAAG;AAEnE,WAAA;MACH,WAAW;MACX,sBAAsB,wBAAwB,MAAM,MAAM;;IAAA;EAC9D,OACG;AAEH,UAAM,sBAAsB,iBAAiB,SAAS,CAAC,EAAE;AACzD,oBAAgB,mBAAmB;AAEnC,UAAM,wBAAwB,iBAAiB,SAAS,CAAC,EAAE;AAC3D,oBAAgB,qBAAqB;AAE9B,WAAA;MACH,OAAO;MACP;MACA;IAAA;EACJ;AAER;AA8BO,SAAS,4BACZ,4BACA,QAC4B;AACtB,QAAA,WAAW,2BAA2B,eAAe,CAAC;AAC5D,MAAI,CAAC,UAAU;AACL,UAAA,IAAIA,YAAY,gEAAgE;EAAA;AAGpF,QAAA,eAAe,gBAAgB,0BAA0B;AACzD,QAAA,qBACF,yBAAyB,8BACzB,2BAA2B,wBAAwB,UACnD,2BAA2B,oBAAoB,SAAS,IAClD;IACI,2BAA2B;IAC3B,QAAQ,iCAAiC,CAAA;EAAC,IAE9C,CAAA;AACV,QAAM,mBAAmB,CAAC,GAAG,cAAc,GAAG,kBAAkB;AAE1D,QAAA,eAA8B,2BAA2B,aAAa;IAAI,CAAA,wBAC5E,mBAAmB,qBAAqB,gBAAgB;EAAA;AAGtD,QAAA,mBAAmB,aAAa,CAAC;AACvC,QAAM,qBAAqB;IACvB,2BAA2B;IAC3B;IACA,QAAQ;EAAA;AAGL,SAAA;IACH,yBAAyB,EAAE,SAAS,2BAA2B,QAAA,CAA+B;IAC9F,CAAA,MAAK,8BAA8B,UAAU,CAAC;IAC9C,CAAA,MACI,aAAa;MACT,CAAC,KAAK,gBAAgB,oCAAoC,aAAa,GAAG;MAC1E;IAAA;IAER,CAAA,MACI,eAAe,qBACT,4CAA4C,oBAAoB,CAAC,IACjE,+CAA+C,oBAAoB,CAAC;EAAA;AAEtF;AC3NO,IAAM,yCAAyC;AA2B/C,IAAM,4BAA4B;;;AC5DzC,SAAS,sBAAsB,eAAgD;AACrE,QAAA,aAAa,OAAO,OAAO,aAAa;AAC1C,MAAA,WAAW,WAAW,GAAG;AACnB,UAAA,IAAI,YAAY,8DAA8D;EAAA;AAGjF,SAAA,WAAW,IAAI,CAAa6B,eAAA;AAC/B,QAAI,CAACA,YAAW;AACZ,aAAO,IAAI,WAAW,EAAE,EAAE,KAAK,CAAC;IAAA;AAE7B,WAAAA;EAAA,CACV;AACL;AAEO,SAAS,uBAA2D;AAChE,SAAA;IACH,gBAAgB,eAAe,gBAAA,GAAmB,EAAE,GAAG,EAAE,MAAM,mBAAmB,EAAA,CAAG;IACrF;EAAA;AAER;ACIO,SAAS,wBAA0D;AACtE,SAAO,iBAAiB;IACpB,CAAC,cAAc,qBAAA,CAAsB;IACrC,CAAC,gBAAgBC,gBAAAA,CAAiB;EAAA,CACrC;AACL;AAkBO,SAAS,wBAA0D;AAC/D,SAAA;IACH,iBAAiB;MACb,CAAC,cAAc,gBAAgB,eAAe,gBAAgB,GAAG,EAAE,GAAG,EAAE,MAAM,mBAAmB,EAAA,CAAG,CAAC;MACrG,CAAC,gBAAgB,gBAAA,CAAiB;IAAA,CACrC;IACD;EAAA;AAER;AAQO,SAAS,sBAAsD;AAClE,SAAO,aAAa,sBAAA,GAAyB,sBAAA,CAAuB;AACxE;AAOA,SAAS,kCAAkC,aAAuD;AACxF,QAAA,EAAE,cAAc,WAAA,IAAe;AAWrC,QAAM,yBAAyB,gBAAgB;;IAE3C,6BAA6B;;;IAG7B,gBAAgB,aAAa,GAAG,CAAC;;IAEjC,gBAAgB,kBAAkB,GAAG,EAAE,MAAM,mBAAA,EAAA,CAAsB;EAAA,CACtE;AACD,QAAM,CAAC,YAAY,uBAAuB,eAAe,IAAI,uBAAuB,OAAO,YAAY;AAEvG,QAAM,kBAAkB,gBAAgB,MAAM,GAAG,qBAAqB;AAIlE,MAAA,gBAAgB,WAAW,WAAW,QAAQ;AACxC,UAAA,IAAIC,YAAY,wDAAwD;MAC1E;MACA,kBAAkB,WAAW;MAC7B;IAAA,CACH;EAAA;AAIL,QAAM,gBAA+B,CAAA;AACrB,kBAAA,QAAQ,CAACC,UAAS,UAAU;AAClC,UAAA,sBAAsB,WAAW,KAAK;AAC5C,QAAI,oBAAoB,MAAM,CAAK,MAAA,MAAM,CAAC,GAAG;AACzC,oBAAcA,QAAO,IAAI;IAAA,OACtB;AACH,oBAAcA,QAAO,IAAI;IAAA;EAC7B,CACH;AAEM,SAAA;IACH;IACA,YAAY,OAAO,OAAO,aAAa;EAAA;AAE/C;ACnGO,SAAS,mBACZ,oBAC0E;AAGpE,QAAA,kBAAkB,0BAA0B,kBAAkB;AACpE,QAAM,eAAe,qCAAA,EAAuC,OAAO,eAAe;AAElF,QAAM,qBAAqB,gBAAgB,eAAe,MAAM,GAAG,gBAAgB,OAAO,iBAAiB;AAC3G,QAAM,aAA4B,CAAA;AAClC,aAAW,iBAAiB,oBAAoB;AAC5C,eAAW,aAAa,IAAI;EAAA;AAG5B,MAAA;AACA,MAAA,0CAA0C,kBAAkB,GAAG;AAC1C,yBAAA;MACjB,WAAW,mBAAmB,mBAAmB;MACjD,sBAAsB,mBAAmB,mBAAmB;IAAA;EAChE,OACG;AACkB,yBAAA;MACjB,OAAO,mBAAmB,mBAAmB;MAC7C,qBAAqB,mBAAmB,aAAa,CAAC,EAAE,SAAS,CAAC,EAAE;IAAA;EACxE;AAGJ,SAAO,OAAO,OAAO;IACjB;IACA;IACA,YAAY,OAAO,OAAO,UAAU;EAAA,CACvC;AACL;AC1CA,IAAI;AAeG,SAAS,4BAA4B,aAAqC;AACzE,MAAA,CAAC,cAAe,iBAAgB,iBAAiB;AAIrD,QAAM,iBAAiB,OAAO,OAAO,YAAY,UAAU,EAAE,CAAC;AAC9D,MAAI,CAAC,gBAAgB;AACX,UAAA,IAAID,YAAY,sDAAsD;EAAA;AAE1E,QAAA,uBAAuB,cAAc,OAAO,cAAc;AACzD,SAAA;AACX;AAEA,SAAS,iBAAiB,MAAkB,MAAkB;AAC1D,SAAO,KAAK,WAAW,KAAK,UAAU,KAAK,MAAM,CAAC,OAAO,UAAU,UAAU,KAAK,KAAK,CAAC;AAC5F;AAsBA,eAAsB,yBAClB,UACA,aACU;AACN,MAAA;AACA,MAAA;AAEJ,QAAM,QAAQ;IACV,SAAS,IAAI,OAAM,YAAW;AAC1B,YAAMC,WAAU,MAAM,wBAAwB,QAAQ,SAAS;AACzD,YAAA,oBAAoB,YAAY,WAAWA,QAAO;AAGxD,UAAI,sBAAsB,QAAW;AAEjC,8BAAA,oBAA0B,IAAI;AAC9B,0BAAkB,IAAIA,QAAO;AAC7B;MAAA;AAIJ,UAAI,mBAAmB;AACnB;MAAA;AAGJ,YAAM,eAAe,MAAM,UAAU,QAAQ,YAAY,YAAY,YAAY;AAEjF,UAAI,sBAAsB,QAAQ,iBAAiB,cAAc,iBAAiB,GAAG;AAEjF;MAAA;AAGJ,wBAAkB,CAAA;AAClB,oBAAcA,QAAO,IAAI;IAAA,CAC5B;EAAA;AAGD,MAAA,qBAAqB,kBAAkB,OAAO,GAAG;AACjD,UAAM,kBAAkB,OAAO,KAAK,YAAY,UAAU;AACpD,UAAA,IAAID,YAAY,8DAA8D;MAChF,mBAAmB;MACnB,qBAAqB,CAAC,GAAG,iBAAiB;IAAA,CAC7C;EAAA;AAGL,MAAI,CAAC,eAAe;AACT,WAAA;EAAA;AAGX,SAAO,OAAO,OAAO;IACjB,GAAG;IACH,YAAY,OAAO,OAAO;MACtB,GAAG,YAAY;MACf,GAAG;IAAA,CACN;EAAA,CACJ;AACL;AAoBA,eAAsB,gBAClB,UACA,aACmC;AACnC,QAAM,MAAM,MAAM,yBAAyB,UAAU,WAAW;AAChE,iCAA+B,GAAG;AAClC,SAAO,OAAO,GAAG;AACV,SAAA;AACX;AAeO,SAAS,yBACZ,aACoD;AACpD,SAAO,OAAO,QAAQ,YAAY,UAAU,EAAE,MAAM,CAAC,CAAC,GAAG,cAAc,MAAM,CAAC,CAAC,cAAc;AACjG;AA0BO,SAAS,+BACZ,aAC4D;AAC5D,QAAM,cAAyB,CAAA;AACxB,SAAA,QAAQ,YAAY,UAAU,EAAE,QAAQ,CAAC,CAACC,UAAS,cAAc,MAAM;AAC1E,QAAI,CAAC,gBAAgB;AACjB,kBAAY,KAAKA,QAAkB;IAAA;EACvC,CACH;AAEG,MAAA,YAAY,SAAS,GAAG;AAClB,UAAA,IAAID,YAAY,+CAA+C;MACjE,WAAW;IAAA,CACd;EAAA;AAET;ACnMO,SAAS,gCAAgC,aAAwD;AACpG,QAAM,uBAAuB,sBAAA,EAAwB,OAAO,WAAW;AAChE,SAAA,iBAAA,EAAmB,OAAO,oBAAoB;AACzD;ACdO,IAAM,0BAA0B;AAMhC,IAAM,4BACT,KAAoD;AAQjD,IAAM,yBAAyB,0BAA0B;AAUzD,SAAS,mBAAmB,aAAkC;AAC1D,SAAA,sBAAA,EAAwB,iBAAiB,WAAW;AAC/D;AA+BO,SAAS,6BACZ,aACwD;AACjD,SAAA,mBAAmB,WAAW,KAAK;AAC9C;AAgBO,SAAS,mCACZ,aACgE;AAC1D,QAAA,kBAAkB,mBAAmB,WAAW;AACtD,MAAI,kBAAkB,wBAAwB;AACpC,UAAA,IAAIA,YAAY,+CAA+C;MACjE;MACA,sBAAsB;IAAA,CACzB;EAAA;AAET;ACpFO,SAAS,0BAA0B,oBAA0D;AACzF,SAAA,mBAAmB,mBAAmB,kBAAkB,CAAC;AACpE;AAeO,SAAS,oCACZ,oBAC6E;AACtE,SAAA,0BAA0B,kBAAkB,KAAK;AAC5D;AAiBO,SAAS,0CACZ,oBACqF;AAC/E,QAAA,kBAAkB,0BAA0B,kBAAkB;AACpE,MAAI,kBAAkB,wBAAwB;AACpC,UAAA,IAAIA,YAAYE,+CAA+C;MACjE;MACA,sBAAsB;IAAA,CACzB;EAAA;AAET;AClCO,IAAM,iCAAiC;;;ACfvC,SAAS,mBACZ,SACkB;AAClB,QAAM,eAAyC,CAAA;AAC/C,UAAQ,QAAQ,CAAU,WAAA;AACtB,QAAI,CAAC,aAAa,OAAO,OAAO,GAAG;AAClB,mBAAA,OAAO,OAAO,IAAI;IAAA,WACxB,aAAa,OAAO,OAAO,MAAM,QAAQ;AAC1C,YAAA,IAAI,YAAY,4DAA4D;QAC9E,SAAS,OAAO;MAAA,CACnB;IAAA;EACL,CACH;AACM,SAAA,OAAO,OAAO,YAAY;AACrC;ACoDO,SAAS,6BAAsD,OAGpB;AAC9C,SAAO,+BAA+B,SAAS,OAAO,MAAM,8BAA8B;AAC9F;AAmBO,SAAS,mCAA4D,OAGlB;AAClD,MAAA,CAAC,6BAA6B,KAAK,GAAG;AAChC,UAAA,IAAIC,YAAY,6DAA6D;MAC/E,SAAS,MAAM;IAAA,CAClB;EAAA;AAET;ACvCO,SAAS,2BAAoD,OAGpB;AAC5C,SAAO,sBAAsB,SAAS,OAAO,MAAM,qBAAqB;AAC5E;AAmBO,SAAS,iCAA0D,OAGlB;AAChD,MAAA,CAAC,2BAA2B,KAAK,GAAG;AAC9B,UAAA,IAAIA,YAAY,2DAA2D;MAC7E,SAAS,MAAM;IAAA,CAClB;EAAA;AAET;ACrBO,SAAS,2BAAoD,OAGpB;AAC5C,SAAO,6BAA6B,SAAS,OAAO,MAAM,4BAA4B;AAC1F;AAmBO,SAAS,iCAA0D,OAGlB;AAChD,MAAA,CAAC,2BAA2B,KAAK,GAAG;AAC9B,UAAA,IAAIA,YAAY,2DAA2D;MAC7E,SAAS,MAAM;IAAA,CAClB;EAAA;AAET;AC9EO,SAAS,oBAA6C,OAGpB;AACrC,SACI,2BAA2B,KAAK,KAAK,6BAA6B,KAAK,KAAK,2BAA2B,KAAK;AAEpH;AAqBO,SAAS,0BAAmD,OAGlB;AACzC,MAAA,CAAC,oBAAoB,KAAK,GAAG;AACvB,UAAA,IAAIA,YAAY,mDAAmD;MACrE,SAAS,MAAM;IAAA,CAClB;EAAA;AAET;AC2EO,SAAS,0BACZ,aACkB;AACX,SAAA;KACF,YAAY,YAAY,CAAA,GAAI,QAAQ,CAAY,YAAA,YAAY,UAAU,QAAQ,SAAS,CAAA,CAAG;EAAA;AAEnG;AAuCO,SAAS,iCAOd,aAAsD;AACpD,SAAO,mBAAmB;IACtB,GAAI,YAAY,YAAY,oBAAoB,YAAY,QAAQ,IAAI,CAAC,YAAY,QAAmB,IAAI,CAAA;IAC5G,GAAG,YAAY,aAAa,QAAQ,yBAAyB;EAAA,CAChE;AACL;ACtKO,SAAS,wBACZ,SACA,aACqC;AACrC,MAAI,CAAC,YAAY,YAAY,YAAY,SAAS,WAAW,GAAG;AACrD,WAAA;EAAA;AAGX,QAAM,kBAAkB,IAAI,IAAI,mBAAmB,OAAO,EAAE,IAAI,CAAA,WAAU,CAAC,OAAO,SAAS,MAAM,CAAC,CAAC;AACnG,SAAO,OAAO,OAAO;IACjB,GAAG;IACH,UAAU,YAAY,SAAS,IAAI,CAAW,YAAA;AAC1C,YAAM,SAAS,gBAAgB,IAAI,QAAQ,OAAO;AAC9C,UAAA,CAAC,aAAa,QAAQ,IAAI,KAAK,YAAY,WAAW,CAAC,QAAQ;AACxD,eAAA;MAAA;AAEX,aAAO,OAAO,OAAO,EAAE,GAAG,SAAS,OAAA,CAA6B;IAAA,CACnE;EAAA,CACJ;AACL;AA4CO,SAAS,+BACZ,SACA,oBACmD;AACnD,QAAM,iBAAiB,uBAAuB,kBAAkB,IAC1D,QAAQ,KAAK,CAAU,WAAA,OAAO,YAAY,mBAAmB,SAAS,OAAO,IAC7E;AAEN,MAAI,CAAC,kBAAkB,mBAAmB,aAAa,WAAW,GAAG;AAC1D,WAAA;EAAA;AAGX,SAAO,OAAO,OAAO;IACjB,GAAG;IACH,GAAI,iBAAiB,EAAE,UAAU,eAAA,IAAmB;IACpD,cAAc,mBAAmB,aAAa,IAAI,CAAA,gBAAe,wBAAwB,SAAS,WAAW,CAAC;EAAA,CACjH;AACL;AAEA,SAAS,uBACL,SACsE;AACtE,SACI,CAAC,CAAC,WACF,cAAc,WACd,CAAC,CAAC,QAAQ,YACV,OAAO,QAAQ,SAAS,YAAY,YACpC,CAAC,oBAAoB,QAAQ,QAAQ;AAE7C;ACtFO,SAAS,oCAKZ,UACA,oBAC8F;AAC9F,SAAO,OAAO,QAAQ;AACtB,QAAM,MAAM,EAAE,GAAG,oBAAoB,SAAS;AAC9C,SAAO,OAAO,GAAG;AACV,SAAA;AACX;ACaO,SAAS,uBAAgD,OAGpB;AACxC,SAAO,kBAAkB,SAAS,OAAO,MAAM,iBAAiB;AACpE;AAmBO,SAAS,6BAAsD,OAGlB;AAC5C,MAAA,CAAC,uBAAuB,KAAK,GAAG;AAC1B,UAAA,IAAIA,YAAY,uDAAuD;MACzE,SAAS,MAAM;IAAA,CAClB;EAAA;AAET;ACtDO,SAAS,gBAAyC,OAGpB;AAE7B,SAAA,aAAa,SACb,OAAO,MAAM,YAAY,YACzB,uBAAuB,KAAK,KAC5B,2BAA2B,KAAK;AAExC;AAgBO,SAAS,sBAA+C,OAGlB;AACrC,MAAA,CAAC,gBAAgB,KAAK,GAAG;AACnB,UAAA,IAAIA,YAAY,gDAAgD;MAClE,SAAS,MAAM;IAAA,CAClB;EAAA;AAET;AAuBA,eAAsB,wBAAwB,SAAgD;AAC1F,QAAMC,WAAU,MAAM,wBAAwB,QAAQ,SAAS;AAC/D,QAAM,MAAqB;IACvB,SAAAA;IACA;IACA,cAAc,CAAA,aACV,QAAQ;MACJ,SAAS;QAAI,OAAM,YACf,OAAO,OAAO,EAAE,CAACA,QAAO,GAAG,MAAM,UAAU,QAAQ,YAAY,QAAQ,OAAO,EAAA,CAAG;MAAA;IACrF;IAER,kBAAkB,CAAA,iBACd,QAAQ;MACJ,aAAa,IAAI,OAAM,gBAAe;AAClC,cAAM,oBAAoB,MAAM,yBAAyB,CAAC,OAAO,GAAG,WAAW;AAExE,eAAA,OAAO,OAAO,EAAE,CAACA,QAAO,GAAG,kBAAkB,WAAWA,QAAO,EAAA,CAAI;MAAA,CAC7E;IAAA;EACL;AAGD,SAAA,OAAO,OAAO,GAAG;AAC5B;AAeA,eAAsB,wBAAgD;AAClE,SAAO,MAAM,wBAAwB,MAAM,gBAAA,CAAiB;AAChE;AAoBA,eAAsB,6BAClB,OACA,aACsB;AACtB,SAAO,MAAM,wBAAwB,MAAM,uBAAuB,OAAO,WAAW,CAAC;AACzF;AAkBA,eAAsB,uCAClB,OACA,aACsB;AACtB,SAAO,MAAM,wBAAwB,MAAM,iCAAiC,OAAO,WAAW,CAAC;AACnG;ACvHO,SAAS,yBAAkD,OAGpB;AAEtC,SAAA,UAAU,MAAM,OAAO,KACvB,2BAA2B,SAC3B,OAAO,MAAM,0BAA0B;AAE/C;AAmBO,SAAS,+BAAwD,OAGlB;AAC9C,MAAA,CAAC,yBAAyB,KAAK,GAAG;AAC5B,UAAA,IAAID,YAAY,yDAAyD;MAC3E,SAAS,MAAM;IAAA,CAClB;EAAA;AAET;AChFO,SAAS,gBAAyC,OAGpB;AACjC,SAAO,uBAAuB,KAAK,KAAK,yBAAyB,KAAK;AAC1E;AAoBO,SAAS,sBAA+C,OAGlB;AACrC,MAAA,CAAC,gBAAgB,KAAK,GAAG;AACnB,UAAA,IAAIA,YAAY,+CAA+C;MACjE,SAAS,MAAM;IAAA,CAClB;EAAA;AAET;AClBO,SAAS,iBAAmDC,UAAkD;AACjH,QAAM,MAA4B;IAC9B,SAAAA;IACA,cAAc,CAAA,aAAY,QAAQ,QAAQ,SAAS,IAAI,MAAM,OAAO,OAAO,CAAA,CAAE,CAAC,CAAC;IAC/E,kBAAkB,CAAA,iBAAgB,QAAQ,QAAQ,aAAa,IAAI,MAAM,OAAO,OAAO,CAAA,CAAE,CAAC,CAAC;EAAA;AAGxF,SAAA,OAAO,OAAO,GAAG;AAC5B;ACKO,SAAS,4CACZ,aAC8E;AAC1E,MAAA;AACA,sDAAkD,WAAW;AACtD,WAAA;EAAA,QACH;AACG,WAAA;EAAA;AAEf;AAwBO,SAAS,kDAGZ,aACsF;AAChF,QAAA,UAAU,iCAAiC,WAAW;AACtD,QAAA,iBAAiB,QAAQ,OAAO,0BAA0B;AAE5D,MAAA,eAAe,WAAW,GAAG;AACvB,UAAA,IAAID,YAAY,wDAAwD;EAAA;AAMlF,QAAM,qBAAqB,eAAe;IACtC,CAAA,WAAU,CAAC,2BAA2B,MAAM,KAAK,CAAC,6BAA6B,MAAM;EAAA;AAGrF,MAAA,mBAAmB,SAAS,GAAG;AACzB,UAAA,IAAIA,YAAY,sEAAsE;EAAA;AAEpG;ACpDA,eAAsB,2CAGlB,oBACA,QACyE;AACnE,QAAA,EAAE,gBAAgB,iBAAA,IAAqB;IACzC,mBAAmB,iCAAiC,kBAAkB,EAAE,OAAO,mBAAmB,CAAC;IACnG,EAAE,uBAAuB,MAAM;EAAA;AAGnC,SAAO,MAAM;IACT;IACA;IACA;IACA;EAAA;AAER;AA4BA,eAAsB,kCAGlB,oBACA,QACkG;AAClG,QAAM,oBAAoB,MAAM,2CAA2C,oBAAoB,MAAM;AACrG,iCAA+B,iBAAiB;AACzC,SAAA;AACX;AAoDA,eAAsB,yCAEpB,aAAkC,QAAkE;AAClG,oDAAkD,WAAW;AAE7D,QAAM,cAAc,QAAQ;AAC5B,QAAM,EAAE,gBAAgB,kBAAkB,cAAA,IAAkB;IACxD,mBAAmB,iCAAiC,WAAW,EAAE,OAAO,mBAAmB,CAAC;EAAA;AAGhG,eAAa,eAAe;AAC5B,QAAM,oBAAoB,MAAM;IAC5B;IACA;IACA;IACA;EAAA;AAGJ,MAAI,CAAC,eAAe;AACV,UAAA,IAAIA,YAAYE,wDAAwD;EAAA;AAGlF,eAAa,eAAe;AACtB,QAAA,CAACC,UAAS,IAAI,MAAM,cAAc,wBAAwB,CAAC,iBAAiB,GAAG,MAAM;AAC3F,eAAa,eAAe;AAErB,SAAAA;AACX;AAUA,SAAS,6BACL,SACA,SAA8C,CAAA,GAK/C;AAEO,QAAA,wBAAwB,OAAO,yBAAyB;AAC9D,QAAM,gBAAgB,wBAAwB,iCAAiC,OAAO,IAAI;AAK1F,QAAM,eAAe,QAAQ;IACzB,CAAC,WACG,WAAW,kBAAkB,6BAA6B,MAAM,KAAK,2BAA2B,MAAM;EAAA;AAIxG,QAAA,mBAAmB,oCAAoC,YAAY;AAGnE,QAAA,iBAAiB,aAClB,OAAO,0BAA0B,EACjC,OAAO,CAAA,WAAU,CAAE,iBAAyC,SAAS,MAAM,CAAC;AAEjF,SAAO,OAAO,OAAO,EAAE,kBAAkB,gBAAgB,cAAA,CAAe;AAC5E;AAGA,SAAS,iCAAiC,SAAwE;AAExG,QAAA,iBAAiB,QAAQ,OAAO,0BAA0B;AAC5D,MAAA,eAAe,WAAW,EAAU,QAAA;AAGxC,QAAM,qBAAqB,eAAe;IACtC,CAAA,WAAU,CAAC,6BAA6B,MAAM,KAAK,CAAC,2BAA2B,MAAM;EAAA;AAErF,MAAA,mBAAmB,SAAS,GAAG;AAC/B,WAAO,mBAAmB,CAAC;EAAA;AAI/B,SAAO,eAAe,CAAC;AAC3B;AAGA,SAAS,oCACL,SACqC;AAE/B,QAAA,mBAAmB,QAAQ,OAAO,4BAA4B;AACpE,MAAI,iBAAiB,WAAW,EAAG,QAAO,CAAA;AAG1C,QAAM,oBAAoB,iBAAiB,OAAO,CAAA,WAAU,CAAC,2BAA2B,MAAM,CAAC;AAC3F,MAAA,kBAAkB,SAAS,EAAU,QAAA;AAGlC,SAAA,CAAC,iBAAiB,CAAC,CAAC;AAC/B;AAMA,eAAe,0CAGX,oBACA,mBAA0D,CAAA,GAC1D,iBAAsD,CAAA,GACtD,QACyE;AAInE,QAAA,cAAc,mBAAmB,kBAAkB;AAGnD,QAAA,sBAAsB,MAAM,iBAAiB;IAC/C,OAAOC,cAAa,oBAAoB;AACpC,cAAQ,aAAa,eAAe;AAC9B,YAAA,CAAC,EAAE,IAAI,MAAM,gBAAgB,0BAA0B,CAAC,MAAMA,YAAW,GAAG,MAAM;AACjF,aAAA,OAAO,OAAO,EAAE;IAAA;IAE3B,QAAQ,QAAQ,WAAW;EAAA;AAI/B,UAAQ,aAAa,eAAe;AAC9B,QAAA,wBAAwB,MAAM,QAAQ;IACxC,eAAe,IAAI,OAAM,kBAAiB;AAChC,YAAA,CAAC,UAAU,IAAI,MAAM,cAAc,iBAAiB,CAAC,mBAAmB,GAAG,MAAM;AAChF,aAAA;IAAA,CACV;EAAA;AAGL,SAAO,OAAO,OAAO;IACjB,GAAG;IACH,YAAY,OAAO;MACf,sBAAsB,OAAO,CAAC,YAAY,wBAAwB;AAC9D,eAAO,EAAE,GAAG,YAAY,GAAG,oBAAoB;MAAA,GAChD,oBAAoB,cAAc,CAAA,CAAE;IAAA;EAC3C,CACH;AACL;AChUO,IACMC,KAAc,WAAW;AC2C/B,SAAS,sBACZ,SACA,aAAkC,CAAA,GACnB;AACf,SAAO,OAAO,OAAO;IACjB,SAAS,OAAO,YAAY,WAAW,IAAIC,GAAY,EAAE,OAAO,OAAO,IAAI;IAC3E,YAAY,OAAO,OAAO,EAAE,GAAG,WAAA,CAAY;EAAA,CAC9C;AACL;A;;;ACpDO,IAAMC,KAAkB,WAAW;ACwEnC,SAAS,0CAEd;EACE;EACA;AACJ,GAAiG;AAC7F,SAAO,eAAe,gCAAgC;IAClD,aAAa;IACb;IACA;EAAA,GACe;AACf,sBAAkB,eAAe;AAC3B,UAAA,kBAAkB,IAAIC,GAAgB;AAC5C,UAAM,cAAc,MAAM;AACtB,sBAAgB,MAAM;IAAA;AAE1B,sBAAkB,iBAAiB,SAAS,aAAa,EAAE,QAAQ,gBAAgB,OAAA,CAAQ;AAC3F,mBAAe,6DAA6D;AACxE,YAAM,EAAE,cAAc,YAAA,IAAgB,MAAM,IACvC,aAAa,EAAE,WAAW,CAAC,EAC3B,KAAK,EAAE,aAAa,gBAAgB,OAAA,CAAQ;AAC1C,aAAA;QACH;QACA,2CAA2C,eAAe;MAAA;IAC9D;AAEA,QAAA;AACM,YAAA,CAAC,mBAAmB,EAAE,aAAa,oBAAoB,0CAAA,CAA2C,IACpG,MAAM,QAAQ,IAAI;QACd,iBAAiB,kBAAA,EAAoB,UAAU,EAAE,aAAa,gBAAgB,OAAA,CAAQ;QACtF,2DAA2D;MAAA,CAC9D;AACL,wBAAkB,eAAe;AACjC,UAAI,qBAAqB;AACzB,UAAI,sBAAsB,sBAAsB;AAC5C,YAAI,qDAAqD;AACzD,yBAAiB,oBAAoB,mBAAmB;AAC9C,gBAAA,EAAE,KAAA,IAAS;AACb,cAAA,OAAO,qDAAqD,sBAAsB;AAE5E,kBAAA;cACF,aAAa;cACb,2CAA2C;YAAA,IAC3C,MAAM,2DAA2D;AAChD,iCAAA;AACrB,gBAAI,qBAAqB,sBAAsB;AAE3C;YAAA,OACG;AAMC,mEAAA;YAAA;UACR;QACJ;MACJ;AAEJ,wBAAkB,eAAe;AAC3B,YAAA,IAAI,YAAY,qCAAqC;QACvD;QACA;MAAA,CACH;IAAA,UACH;AACE,sBAAgB,MAAM;IAAA;EAC1B;AAER;AC7GA,IAAM,qBACF;AACA;AACA;AAiDG,SAAS,sCAAuG;EACnH;EACA;AACJ,GAAyF;AACrF,SAAO,eAAe,4BAA4B;IAC9C,aAAa;IACb;IACA,mBAAmB;IACnB;EAAA,GACD;AACO,UAAA,kBAAkB,IAAIA,GAAgB;AAC5C,aAAS,cAAc;AACnB,sBAAgB,MAAM;IAAA;AAE1B,sBAAkB,iBAAiB,SAAS,aAAa,EAAE,QAAQ,gBAAgB,OAAA,CAAQ;AAI3F,UAAM,uBAAuB,MAAM,iBAC9B,qBAAqB,qBAAqB,EAAE,YAAY,UAAU,SAAS,CAAC,EAC5E,UAAU,EAAE,aAAa,gBAAgB,OAAA,CAAQ;AACtD,UAAMC,iBAAgB,iBAAiB;AACvC,UAAM,gBAAgB,iBAAiB;AAC9B,aAAA,wBAAwB,CAAC,kBAAkB,GAAqC;AAC/E,YAAA,OAAO,cAAc,OAAO,kBAAkB;AACpD,YAAM,kBAAkB,KAAK,MAAM,oBAAoB,qBAAqB,EAAE;AACvE,aAAAA,eAAc,OAAO,eAAe;IAAA;AAE/C,UAAM,iCAAiC,YAAY;AAC/C,uBAAiB,uBAAuB,sBAAsB;AAC1D,cAAM,aAAa,wBAAwB,oBAAoB,MAAM,IAAI;AACzE,YAAI,eAAe,oBAAoB;AAC7B,gBAAA,IAAIC,YAAY,6BAA6B;YAC/C,kBAAkB;YAClB;UAAA,CACH;QAAA;MACL;IACJ,GACD;AAKH,UAAM,gCAAgC,YAAY;AAC9C,YAAM,EAAE,OAAO,aAAA,IAAiB,MAAM,IACjC,eAAe,qBAAqB;QACjC;QACA,WAAW,EAAE,QAAQ,IAAI,QAAQ,mBAAmB;QACpD,UAAU;MAAA,CACb,EACA,KAAK,EAAE,aAAa,gBAAgB,OAAA,CAAQ;AACjD,UAAI,CAAC,cAAc;AACT,cAAA,IAAIA,YAAY,uCAAuC;UACzD;QAAA,CACH;MAAA;AAEC,YAAA;;;QAGF,aAAa,KAAK,CAAC;;AACvB,UAAI,eAAe,oBAAoB;AAC7B,cAAA,IAAIA,YAAY,6BAA6B;UAC/C,kBAAkB;UAClB;QAAA,CACH;MAAA,OACE;AACG,cAAA,IAAI,QAAQ,MAAM;QAAA,CAEvB;MAAA;IACL,GACD;AACC,QAAA;AACA,aAAO,MAAM,SAAS,CAAC,+BAA+B,4BAA4B,CAAC;IAAA,UACrF;AACE,sBAAgB,MAAM;IAAA;EAC1B;AAER;ACzFO,SAAS,gDAEd;EACE;EACA;AACJ,GAA6G;AACzG,SAAO,eAAe,sCAAsC;IACxD,aAAa;IACb;IACA,WAAAC;EAAA,GACD;AACO,UAAA,kBAAkB,IAAIH,GAAgB;AAC5C,aAAS,cAAc;AACnB,sBAAgB,MAAM;IAAA;AAE1B,sBAAkB,iBAAiB,SAAS,aAAa,EAAE,QAAQ,gBAAgB,OAAA,CAAQ;AAI3F,UAAM,+BAA+B,MAAM,iBACtC,uBAAuBG,YAAW,EAAE,WAAA,CAAY,EAChD,UAAU,EAAE,aAAa,gBAAgB,OAAA,CAAQ;AACtD,UAAM,6BAA6B,YAAY;AAC3C,uBAAiB,+BAA+B,8BAA8B;AACtE,YAAA,4BAA4B,MAAM,KAAK;AACjC,gBAAA,mCAAmC,4BAA4B,MAAM,GAAG;QAAA,OAC3E;AACH;QAAA;MACJ;IACJ,GACD;AAKH,UAAM,gCAAgC,YAAY;AAC9C,YAAM,EAAE,OAAO,uBAAA,IAA2B,MAAM,IAC3C,qBAAqB,CAACA,UAAS,CAAC,EAChC,KAAK,EAAE,aAAa,gBAAgB,OAAA,CAAQ;AAC3C,YAAA,kBAAkB,uBAAuB,CAAC;AAE5C,UAAA,mBACA,gBAAgB,sBAChB,qBAAqB,gBAAgB,oBAAoB,UAAU,KAAK,GAC1E;AACE;MAAA,OACG;AACG,cAAA,IAAI,QAAQ,MAAM;QAAA,CAEvB;MAAA;IACL,GACD;AACC,QAAA;AACA,aAAO,MAAMC,SAAS,CAAC,2BAA2B,4BAA4B,CAAC;IAAA,UACjF;AACE,sBAAgB,MAAM;IAAA;EAC1B;AAER;AChGA,eAAsB,kBAAkB,EAAE,aAAa,mBAAmB,WAAA,GAAsB;AAC5F,SAAO,MAAM,IAAI,QAAQ,CAAC,GAAG,WAAW;AAC9B,UAAA,cAAc,CAACC,OAAoC;AACrD,mBAAa,SAAS;AACtB,YAAM,aAAa,IAAI,aAAcA,GAAE,OAAuB,QAAQ,YAAY;AAClF,aAAO,UAAU;IAAA;AAEH,sBAAA,iBAAiB,SAAS,WAAW;AACjD,UAAA,YAAY,eAAe,cAAc,MAAS;AAClD,UAAA,UAAU,YAAY,IAAI;AAC1B,UAAA;;;;MAIF,WAAW,MAAM;AACP,cAAA,YAAY,YAAY,IAAA,IAAQ;AACtC,eAAO,IAAI,aAAa,yBAAyB,SAAS,OAAO,cAAc,CAAC;MAAA,GACjF,SAAS;;EAAA,CACnB;AACL;ACrCA,eAAsB,eAClBF,YACA,QACA,8BACF;AACE,QAAM,EAAE,aAAa,mBAAmB,YAAY,sCAAA,IAA0C;AAC9F,qBAAmB,eAAe;AAC5B,QAAA,kBAAkB,IAAIH,GAAgB;AAC5C,MAAI,mBAAmB;AACnB,UAAM,cAAc,MAAM;AACtB,sBAAgB,MAAM;IAAA;AAE1B,sBAAkB,iBAAiB,SAAS,aAAa,EAAE,QAAQ,gBAAgB,OAAA,CAAQ;EAAA;AAE3F,MAAA;AACA,UAAM,qBAAqB,6BAA6B;MACpD,GAAG;MACH,aAAa,gBAAgB;IAAA,CAChC;AACD,WAAO,MAAMI,SAAS;MAClB,sCAAsC;QAClC,aAAa,gBAAgB;QAC7B;QACA,WAAAD;MAAA,CACH;MACD,GAAG;IAAA,CACN;EAAA,UACH;AACE,oBAAgB,MAAM;EAAA;AAE9B;ACeA,eAAsB,2CAClB,QACa;AACP,QAAA;IACF,4BAA4B,OAAO,WAAW;IAC9C;IACA,SAAS,6BAA6B,EAAE,aAAa,YAAY,6BAA6B,YAAA,GAAe;AAClG,aAAA;QACH,4BAA4B;UACxB;UACA;UACA,mBAAmB,YAAY,mBAAmB;UAClD,qBAAqB,YAAY,mBAAmB;QAAA,CACvD;MAAA;IACL;EACJ;AAER;AAwBA,eAAsB,qCAClB,QACa;AACP,QAAA;IACF,4BAA4B,OAAO,WAAW;IAC9C;IACA,SAAS,6BAA6B;MAClC;MACA;MACA;MACA;IAAA,GACD;AACQ,aAAA;QACH,gCAAgC;UAC5B;UACA;UACA,sBAAsB,YAAY,mBAAmB;QAAA,CACxD;MAAA;IACL;EACJ;AAER;AAGA,eAAsB,iDAClB,QACa;AACP,QAAA;IACF,OAAO;IACP;IACA,SAAS,6BAA6B,EAAE,aAAa,YAAY,mBAAAG,mBAAAA,GAAqB;AAC3E,aAAA;QACHA,mBAAkB;UACd;UACA;QAAA,CACH;MAAA;IACL;EACJ;AAER;;;ACxHA,eAAsB,qDAAqD;EACvE;EACA;EACA;EACA,UAAAC;EACA;EACA;AACJ,GAAuD;AACnD,QAAM,8BAA8B,MAAM,IACrC,eAAe,kBAAkBA,WAAU,EAAE,WAAA,CAAY,EACzD,KAAK,EAAE,YAAA,CAAa;AACzB,QAAM,gCAAgC;IAClC;IACA;IACA,WAAW;EAAA,CACd;AACM,SAAA;AACX;ACeO,SAAS,eAAgF;EAC5F;EACA;AACJ,GAAoD;AAChD,QAAM,wCAAwC,gDAAgD;IAC1F;IACA;EAAA,CACsE;AAC1E,iBAAe,gCACX,QAIF;AACE,UAAM,iDAAiD;MACnD,GAAG;MACH;MACA;IAAA,CACH;EAAA;AAEE,SAAA,eAAe,QAAQ,QAAQ;AAClC,WAAO,MAAM,qDAAqD;MAC9D,GAAG;MACH;MACA;IAAA,CACH;EAAA;AAET;ACrCA,IAAM,iCACF;AAGJ,IAAM,mDAAmD;EACrD,WAAW;EACX,sBAAsB;;AAC1B;AACA,IAAM,2CAA2C;AAEjD,SAAS,kCAAkC,OAAmE;AACpG,QAAA,OAAO,IAAI,WAAW,CAAC;AAC7B,OAAK,CAAC,IAAI;AACV,gBAAA,EAAgB;IAAM;IAAO;IAAM;;EAAA;AACnC,SAAO,OAAO,OAAO;IACjB;IACA,gBAAgB;EAAA,CACnB;AACL;AAEA,SAAS,6BACL,aACmG;AAE/F,SAAA,wBAAwB,aAAa,8BAA8B,KACnE,sBAAsB,WAAW,KACjC,YAAY,KAAK,CAAC,MAAM;AAEhC;AA2DA,eAAsB,wEAAwE;EAC1F;EACA;EACA;EACA,GAAG;AACP,GAAoE;AAK1D,QAAA,mCAAmC,6CAA6C,kBAAkB;AACpG,MAAA;AACA,MAAA,oCAAoC,0CAA0C,kBAAkB,GAAG;AACpE,mCAAA;EAAA,OAC5B;AAC4B,mCAAA;MAC3B;MACA;IAAA;EACJ;AAMJ,QAAM,8CACF,mBAAmB,aAAa,UAAU,4BAA4B;AAC1E,QAAM,iCAAiC;IAAkC;;EAAA;AACzE,MAAI,gDAAgD,IAAI;AACrB,mCAAA;MAC3B;MACA;IAAA;EACJ,OACG;AACH,UAAM,mBAAmB,CAAC,GAAG,6BAA6B,YAAY;AACrD,qBAAA,OAAO,6CAA6C,GAAG,8BAA8B;AACtG,mCAA+B,OAAO,OAAO;MACzC,GAAG;MACH,cAAc;IAAA,CACsB;EAAA;AAKtC,QAAA,sBAAsB,mBAAmB,4BAA4B;AACrE,QAAA,uBAAuB,gCAAgC,mBAAmB;AAC5E,MAAA;AACM,UAAA;MACF,OAAO,EAAE,KAAK,kBAAkB,cAAc;IAAA,IAC9C,MAAM,IACL,oBAAoB,sBAAsB;MACvC,GAAG;MACH,UAAU;MACV,wBAAwB,CAAC;MACzB,WAAW;IAAA,CACd,EACA,KAAK,EAAE,YAAA,CAAa;AACzB,QAAI,iBAAiB,MAAM;AAEjB,YAAA,IAAI,YAAY,2DAA2D;IAAA;AAKrF,UAAM,wBAAwB,gBAAgB,cAAiB,aAAgB,OAAO,aAAa;AACnG,QAAI,kBAAkB;AACZ,YAAA,IAAI,YAAY,6EAA6E;QAC/F,OAAO;QACP,eAAe;MAAA,CAClB;IAAA;AAEE,WAAA;EAAA,SACFC,IAAG;AACR,QAAI,cAAcA,IAAG,2EAA2E,EAAS,OAAAA;AACnG,UAAA,IAAI,YAAY,6DAA6D;MAC/E,OAAOA;IAAA,CACV;EAAA;AAET;ACzHO,SAAS,mDAAmD;EAC/D;AACJ,GAA4G;AACjG,SAAA,eAAe,4CAA4C,oBAAoB,QAAQ;AAC1F,WAAO,MAAM,wEAAwE;MACjF,GAAG;MACH;MACA;IAAA,CACH;EAAA;AAET;AC1EA,eAAsB,8BAClB,sBACA,KACA,QACsC;AAClC,MAAA,qBAAqB,WAAW,GAAG;AACnC,WAAO,CAAA;EAAC;AAGZ,QAAM,sBAAsB,MAAM;IAC9B;IACA;IACA;EAAA;AAGJ,wBAAsB,mBAAmB;AACzC,sBAAoB,mBAAmB;AAEvC,SAAO,oBAAoB,OAAsC,CAAC,KAAK,WAAW;AACvE,WAAA;MACH,GAAG;MACH,CAAC,OAAO,OAAO,GAAG,OAAO,KAAK;IAAA;EAClC,GACD,CAAA,CAAE;AACT;ACtBA,eAAsB,gDAClB,4BACA,KACA,QACqC;AACrC,QAAM,eACF,yBAAyB,8BACzB,2BAA2B,wBAAwB,UACnD,2BAA2B,oBAAoB,SAAS,IAClD,2BAA2B,sBAC3B,CAAA;AACV,QAAM,uBAAuB,aAAa,IAAI,CAAA,MAAK,EAAE,kBAAkB;AAEvE,QAAM,EAAE,sBAAsB,GAAG,oBAAoB,IAAI,UAAU,CAAA;AAC7D,QAAA,gCACF,qBAAqB,SAAS,IACxB,MAAM,8BAA8B,sBAAsB,KAAK,mBAAmB,IAClF,CAAA;AAEV,SAAO,4BAA4B,4BAA4B;IAC3D;IACA;EAAA,CACH;AACL;ACIA,SAAS,wDACL,YACA,QAC2C;AAC3C;;IAEI,CAAC,QAAQ;IAET;MAAqB;MAAY;;IAAA,IAA4D;IAC/F;AACS,WAAA;MACH,GAAG;;;;;MAKH,qBAAqB;IAAA;EACzB;AAIG,SAAA;AACX;AAEA,eAAsB,4CAA4C;EAC9D;EACA;EACA;EACA;EACA,GAAG;AACP,GAAkD;AACxC,QAAA,+BAA+BC,gCAAgC,WAAW;AACzE,SAAA,MAAM,IACR,gBAAgB,8BAA8B;IAC3C,GAAG,wDAAwD,YAAY,qBAAqB;IAC5F,UAAU;EAAA,CACb,EACA,KAAK,EAAE,YAAA,CAAa;AAC7B;AAEA,eAAsB,kEAAkE;EACpF;EACA;EACA;EACA;EACA;EACA,GAAG;AACP,GAAoE;AAC1D,QAAA,uBAAuB,MAAM,4CAA4C;IAC3E,GAAG;IACH;IACA;IACA;IACA;EAAA,CACH;AACD,QAAM,+BAA+B;IACjC;IACA;IACA;EAAA,CACH;AACM,SAAA;AACX;AAEA,eAAsB,2EAA2E;EAC7F;EACA;EACA;EACA;EACA;EACA,GAAG;AACP,GAA6E;AACnE,QAAA,uBAAuB,MAAM,4CAA4C;IAC3E,GAAG;IACH;IACA;IACA;IACA;EAAA,CACH;AACD,QAAM,yBAAyB;IAC3B;IACA;IACA;EAAA,CACH;AACM,SAAA;AACX;AC/DO,SAAS,6CAEd;EACE;EACA;AACJ,GAAgH;AAC5G,QAAM,8BAA8B,sCAAsC,EAAE,KAAK,iBAAA,CAE7E;AACJ,QAAM,wCAAwCC,gDAAgD;IAC1F;IACA;EAAA,CACsE;AAC1E,iBAAe,+BACX,QAIF;AACE,UAAM,2CAA2C;MAC7C,GAAG;MACH;MACA;IAAA,CACH;EAAA;AAEE,SAAA,eAAe,sCAAsC,aAAa,QAAQ;AAC7E,UAAM,kEAAkE;MACpE,GAAG;MACH;MACA;MACA;IAAA,CACH;EAAA;AAET;AC1CO,SAAS,iCAAkG;EAC9G;EACA;AACJ,GAAkI;AAC9H,QAAM,kCAAkC,0CAA0C;IAC9E;IACA;EAAA,CACgE;AACpE,QAAM,wCAAwCA,gDAAgD;IAC1F;IACA;EAAA,CACsE;AAC1E,iBAAe,yBACX,QAIF;AACE,UAAM,qCAAqC;MACvC,GAAG;MACH;MACA;IAAA,CACH;EAAA;AAEE,SAAA,eAAe,0BAA0B,aAAa,QAAQ;AACjE,UAAM,2EAA2E;MAC7E,GAAG;MACH;MACA;MACA;IAAA,CACH;EAAA;AAET;ACrDO,SAAS,wCAAwC;EACpD;AACJ,GAA4F;AACjF,SAAA,eAAe,iCAAiC,aAAa,QAAQ;AACxE,UAAM,4CAA4C;MAC9C,GAAG;MACH;MACA;IAAA,CACH;EAAA;AAET;A;;;AC7BO,IAAMC,kCACX;AAEU,IAAA,4BAAA,CAAAC,8BAAL;AACLA,4BAAA,0BAAA,cAAA,IAAA,CAAA,IAAA;AACAA,4BAAA,0BAAA,kBAAA,IAAA,CAAA,IAAA;AACAA,4BAAA,0BAAA,qBAAA,IAAA,CAAA,IAAA;AACAA,4BAAA,0BAAA,qBAAA,IAAA,CAAA,IAAA;AACAA,4BAAA,0BAAA,gCAAA,IAAA,CAAA,IAAA;AALUA,SAAAA;AAAA,GAAA,4BAAA,CAAA,CAAA;AGGL,IAAM,uCAAuC;AAwB7C,SAAS,+CAAgG;AACvGC,SAAAA;IACLC,iBAAiB;MACf,CAAC,iBAAiBC,aAAAA,CAAc;MAChC,CAAC,SAASC,cAAAA,CAAe;IAAA,CAC1B;IACD,CAAC,WAAW;MACV,GAAG;MACH,eAAe;IAAA;EACjB;AAEJ;AAuBO,SAAS,kCAGd,OACA,QACiD;AAE3C,QAAA,iBACJ,QAAQ,kBAAkBC;AAGtB,QAAA,OAAO,EAAE,GAAG,MAAM;AAExB,QAAM,cAAc;IAClB;IACA,MAAM,6CAAA,EAA+C;MACnD;IAAA;EACF;AAGK,SAAA;AACT;AC/EO,IAAM,uCAAuC;AAwB7C,SAAS,+CAAgG;AACvGC,SAAAA;IACLC,iBAAiB;MACf,CAAC,iBAAiBC,aAAAA,CAAc;MAChC,CAAC,iBAAiB,cAAA,CAAe;IAAA,CAClC;IACD,CAAC,WAAW;MACV,GAAG;MACH,eAAe;IAAA;EACjB;AAEJ;AAuBO,SAAS,kCAGd,OACA,QACiD;AAE3C,QAAA,iBACJ,QAAQ,kBAAkBC;AAGtB,QAAA,OAAO,EAAE,GAAG,MAAM;AAExB,QAAM,cAAc;IAClB;IACA,MAAM,6CAAA,EAA+C;MACnD;IAAA;EACF;AAGK,SAAA;AACT;;;AUrGA,IAAM,kBAA4C;EAChD,OAAO;EACP,MAAM;EACN,MAAM;EACN,OAAO;AACT;AAgBA,IAAM,iBAAiB,MACpB,eAAAC,QAAQ,IAAI,oBACb,OAAO,wBACN,OAAO,WAAW,eAAgB,OAAe,wBAClD;AAKK,IAAM,iBAAiB,MAC5B;EACE,eAAAA,QAAQ,IAAI,oBACV,OAAO,wBACP,eAAAA,QAAQ,IAAI,eAAe,UAC3B,eAAAA,QAAQ,IAAI,eAAe,OAC3B,OAAO,mBAAmB,QACzB,OAAO,WAAW,eAAgB,OAAe,mBAAmB;AACzE;AAmBK,SAAS,MAAM,SAAkB,QAAkB,QAAQ,SAAiB,UAAU;AACvF,MAAA,CAAC,eAAA,EAAkB;AAEvB,MAAI,gBAAgB,KAAK,IAAI,gBAAgB,eAAA,CAAgB,EAAG;AAE1D,QAAA,mBAAmB,OAAO,YAAY,WAAW,UAAU,KAAK,UAAU,SAAS,MAAM,CAAC;AAEhG,UAAQ,OAAO;IACb,KAAK;AACK,cAAA,IAAI,QAAQ,gBAAgB;AACpC;IACF,KAAK;AACK,cAAA,KAAK,QAAQ,gBAAgB;AACrC;IACF,KAAK;AACK,cAAA,KAAK,QAAQ,gBAAgB;AACrC;IACF,KAAK;AACK,cAAA,MAAM,QAAQ,gBAAgB;AACtC;EAAA;AAEN;ACnFO,IAAM,mBAAmB;AAKzB,IAAM,eAAe;EAC1B,SAAS;EACT,QAAQ;EACR,SAAS;AACX;ACKO,SAAS,0BAA0B,MAAgD;AACxF,UAAQ,MAAM;IACZ,KAAK,aAAa;AACT,aAAA;IACT,KAAK,aAAa;AACT,aAAA;IACT,KAAK,aAAa;AACT,aAAA;IACT;AACS,aAAA;EAAA;AAEb;AAEO,SAAS,eACd,OACmB;AACnB,SAAO,OAAO,SAAS,WAAW,QAAQ,MAAM;AAClD;AAEO,SAAS,yBACd,OAC6B;AACzB,MAAA,OAAO,UAAU,YAAY,aAAa,SAAS,MAAO,SAAQ,iBAAiB,KAAK;AAC5F,MAAI,CAAC,oBAAoB,KAAK,EAAS,OAAA,IAAI,MAAM,iCAAiC;AAClF,4BAA0B,KAAK;AACxB,SAAA;AACT;AAKO,SAAS,cAAcC,WAAmC;AAE/D,SAAO,IAAI,KAAK,aAAa,SAAS,EAAE,uBAAuB,EAAE,CAAC,EAAE,OAAO,GAAGA,SAAQ,KAAK;AAC7F;AC9CO,SAAS,SAAS,gBAAqC;AACrD,SAAA;AACT;AAOO,SAAS,sBACd,SACoB;AACpB,UAAQ,SAAS;IACf,KAAK;AACI,aAAA;IACT,KAAK;AACI,aAAA;IACT,KAAK;IACL,KAAK;AACI,aAAA;IACT,KAAK;IACL,KAAK;AACI,aAAA;IACT;AACQ,YAAA,IAAI,MAAM,yBAAyB;EAAA;AAE/C;ACxBO,SAAS,gBAAgB,QAA6B,CAAA,GAAY;AACnE,MAAA,MAAM,IAAI,IAAI,6BAA6B;AAG/C,MAAI,CAAC,MAAM,WAAW,MAAM,WAAW,UAAA,OAAiB,UAAU;AAElE,MAAI,aAAa,OAAO;AAClB,QAAA,WAAW,YAAY,MAAM,OAAO;EAAA,WAC/B,iBAAiB,OAAO;AAC7B,QAAA,WAAW,OAAO,MAAM,WAAW;EAAA,WAC9B,WAAW,OAAO;AACvB,QAAA,WAAW,UAAU,MAAM,KAAK;EAAA;AAGlC,MAAA,MAAM,YAAY,gBAAgB;AACpC,QAAI,MAAM,YAAY,cAAc,MAAM,YAAY,aAAa;AAE7D,UAAA,aAAa,IAAI,WAAW,QAAQ;AACpC,UAAA,aAAa,IAAI,aAAa,uBAAuB;IAAA,OACpD;AACL,UAAI,aAAa,IAAI,WAAW,MAAM,OAAO;IAAA;EAC/C;AAGF,SAAO,IAAI,SAAS;AACtB;ACwBO,SAAS,kBAAsG;EACpH;EACA;EACA;EACA;EACA;EACA;AACF,GAGE;AACO,SAAA;IACL,yBAAyB,EAAE,SAAS,WAAY,SAAA,CAAuB;IACvE,CAAC,OAAO;AACN,YAAM,eAAe,kBAAkB,4CAA4C,iBAAiB,EAAE,IAAI;AAC1G,UAAI,OAAO,aAAa,YAAY,aAAa,YAAYC,oBAAoB,QAAQ,GAAG;AACnF,eAAA,oCAAoC,UAAU,YAAY;MAAA,MAC5D,QAAO,8BAA8B,UAAU,YAAY;IAAA;IAEpE,CAAC,OAAO;AACA,YAAA,mBACJ,OAAO,qBAAqB,cACxB;QACE,kCAAkC,EAAE,OAAO,OAAO,gBAAgB,EAAA,CAAG;QACrE;MAAA,IAEF;AAEA,YAAA,mBACJ,OAAO,qBAAqB,cACxB;QACE,kCAAkC,EAAE,eAAe,OAAO,gBAAgB,EAAA,CAAG;QAC7E;MAAA,IAEF;AAEC,aAAA,qCAAqC,cAAc,gBAAgB;IAAA;EAC5E;AAEJ;ACVO,SAAS,4CAEd;EACA;EACA;AACF,GAA8G;AAE5G,QAAM,4BAA4B,iCAAiC,EAAE,KAAK,iBAAA,CAAkB;AAC5F,SAAO,eAAe,qCAAqC,aAAa,SAAS,EAAE,YAAY,YAAA,GAAe;AACxG,QAAA,kBAAkB,eAAe,OAAO;AACtC,UAAA,wBAAwB,gBAAgB,OAAO;AACjD,cAAM,EAAE,OAAO,gBAAgB,IAAI,MAAM,IAAI,mBAAmB,EAAE,KAAK,EAAE,aAAa,OAAO,YAAA,CAAa;AAC5FC,sBAAAA,4CAA4C,iBAAiB,WAAW;AACtF,wDAAgD,WAAW;MAAA;AAE9C,oBAAA,MAAM,kCAAkC,WAAW;IAAA;AAI9D,UAAA,wBAAwB,gBAAgB,EAAE,aAAa,4BAA4B,WAAW,EAAA,CAAG,CAAC,EAAE;AAC1G,UAAM,0BAA0B,gCAAgC,WAAW,CAAC,IAAI,OAAO;AACjF,UAAA,0BAA0B,aAAa,MAAM;AACnD,WAAO,4BAA4B,WAAW;EAAA;AAElD;ACpGO,SAASC,8BACd,aACuG;AAErG,SAAA,wBAAwB,aAAaC,+BAA8B,KACnE,sBAAsB,WAAW,KACjC,YAAY,KAAK,CAAC,MAAM,yBAAyB;AAErD;ACCO,SAAS,oBAAoB,IAA8E;AAChH,MAAI,kBAAkB,GAAWC,QAAAA,KAAK,IAAIC,+BAA+B;MAC7DD,QAAAA,KAAK,IAAI,oBAAoBC,+BAA+B;AAC1E;AAOA,eAAsB,+BACpB,IACuC;AACvC,MAAI,kBAAkB,GAAW,QAAA,oBAAoB,EAAE;MAC3C,QAAA,oBAAoB,MAAM,2CAA2C,EAAE,CAAC;AACtF;AC4BA,eAAsB,mBACpB,QAC6D;AAE7D,MAAI,CAAC,OAAO,2BAA4B,QAAO,6BAA6B;AAC5E,MAAI,OAAO,mBAAmB,MAAO,QAAO,iBAAiB;AAE7D,QAAM,qBAAqB;IACzB,OAAO;IACP,OAAO;EAAA;AAGT,SAAO,YAAY,aAAa,IAAI,CAAC,IAAI,UAAU;AAC7C,QAAA,GAAG,kBAAkBF,gCAAgC;AAErD,QAAAD,8BAA6B,EAAE,GAAG;AACpC,yBAAmB,QAAQ;IAAA;EAC7B,CAID;AAGD,MAAI,mBAAmB,QAAQ,KAAK,OAAO,uBAAuB;AAC1D,UAAA,QAAQ,MAAM,mDAAmD,EAAE,KAAK,OAAO,IAAI,CAAC,EAAE,OAAO,WAAW;AACxG,UAAA,2CAA2C,KAAK,IAAI,OAAO;AACjE,UAAM,KAAKI,kCAAkC;MAC3C,OAAO,QAAQ,OAAO;IAAA,CACvB;AAEG,QAAA,mBAAmB,QAAQ,GAAG;AAChC,aAAO,cAAcC,oCAAoC,IAAI,OAAO,WAAW;IAAA,WACtE,OAAO,uBAAuB;AACvC,YAAM,mBAAmB,CAAC,GAAG,OAAO,YAAY,YAAY;AAC5D,uBAAiB,OAAO,mBAAmB,OAAO,GAAG,EAAE;AAChD,aAAA,cAAc,OAAO,OAAO;QACjC,GAAG,OAAO;QACV,cAAc;MAAA,CACH;IAAA;EACf;AAIF,MAAI,OAAO,kBAAkB,wBAAwB,OAAO,eAAe,OAAO;AAC1E,UAAA,EAAE,OAAO,gBAAgB,IAAI,MAAM,OAAO,IAAI,mBAAmB,EAAE,KAAK;AAC1E,QAAA,wBAAwB,OAAO,eAAe,OAAO;AACvD,YAAM,uDAAuD,OAAO;AACpE,aAAO,cAAcN,4CAA4C,iBAAiB,OAAO,WAAW;IAAA,WAC3F,OAAO,gBAAgB;AAChC,YAAM,wCAAwC,OAAO;AAC9C,aAAA,cAAc,OAAO,OAAO;QACjC,GAAG,OAAO;QACV,oBAAoB;MAAA,CACkD;IAAA;EAC1E;AAGFO,kDAAgD,OAAO,WAAW;AAGlE,MAAI,eAAA,GAAkB;AACpB,UAAM,0BAA0B,MAAM,+BAA+B,OAAO,WAAW,CAAC,IAAI,OAAO;EAAA;AAGrG,SAAO,OAAO;AAChB;AClGO,SAAS,2BAEd,EAAE,IAAA,GAAgF;AAC3E,SAAA,eAAe,oBAAoB,aAAa,QAAQ;AACzD,QAAA,kBAAkB,eAAe,OAAO;AAC5B,oBAAA,MAAMC,2CAA2C,WAAW;IAAA;AAG5E,WAAO,IACJ,oBAAoBJ,gCAAgC,WAAW,GAAG;MACjE,wBAAwB;;MAExB,GAAG;MACH,WAAW;MACX,UAAU;IAAA,CACX,EACA,KAAK;EAAA;AAEZ;ACXO,SAAS,mBAAwD;EACtE;EACA;EACA;AACF,GAAqC;AACnC,MAAI,CAAC,aAAoB,OAAA,IAAI,MAAM,oCAAoC;AACnE,MAAA,wBAAwB,OAAO,OAAO;AACpC,QAAA;AACF,qBAAe,IAAI,IAAI,aAAa,SAAA,CAAU;IAAA,SACvC,KAAK;AACR,UAAA;AACF,uBAAe,IAAI,IAAI,sBAAsB,aAAa,SAAA,CAAiB,CAAC;MAAA,SACrEK,MAAK;AACN,cAAA,IAAI,MAAM,gCAAgC;MAAA;IAClD;EACF;AAGF,MAAI,CAAC,aAAa,SAAS,MAAM,UAAU,GAAG;AACtC,UAAA,IAAI,MAAM,yDAAyD;EAAA;AAG3E,MAAI,WAAW,MAAM;AACN,iBAAA,OAAO,UAAU,KAAK,SAAS;EAAA;AAG9C,QAAM,MAAM,gBAA0B,aAAa,SAAA,GAAwB,SAAS;AAEpF,eAAa,WAAW,aAAa,SAAS,QAAQ,QAAQ,IAAI;AAElE,MAAI,wBAAwB,MAAM;AACnB,iBAAA,OAAO,uBAAuB,KAAK,SAAS;EAAA,WAChD,aAAa,YAAY,eAAe,aAAa,SAAS,WAAW,KAAK,GAAG;AAC1F,iBAAa,OAAO;EAAA;AAGtB,QAAM,mBAAmB;IACvB,aAAa,SAAS;IACtB;EAAA;AAGK,SAAA;IACL;IACA;IACA,2BAA2B,4CAA4C;;MAErE;;MAEA;IAAA,CACD;;IAED,qBAAqB,2BAA2B,EAAE,IAAA,CAAK;EAAA;AAE3D;ACpFO,SAAS,kCAAkC,QAAyB,GAAG;AAO5E,QAAM,OAAO;;;;IAIX,0BAA0B;;;;;IAK1B,6BAA6B,OAAO,KAAK,MAAM,IAAM,GAAI,CAAC,IAAI;;;;;;;;IAQ9D,gCAAgC;MAC9B,KAAK,MAAQ,MAAgB,MAAO,OAAQ,OAAO,KAAK;IAAA;EAC1D;AAIE,UAAA,KAAK,2BAA2B,OAAO,KAAK,KAC5C,KAAK,iCACL,KAAK,8BACP;AAEJ;AClCO,SAAS,2BAA2B,SAAqE;AACjF,+BAAA;AAEzB,MAAA,CAAC,QAAQ,YAAY;AACjB,UAAA,IAAI,MAAM,gCAAgC;EAAA;AAG9C,MAAA,CAAC,QAAQ,WAAW;AAChB,UAAA,IAAI,MAAM,+BAA+B;EAAA;AAG7C,MAAA,CAAC,QAAQ,WAAW,aAAa;AAC7B,UAAA,IAAI,MAAM,gCAAgC;EAAA;AAEpD;AAUA,eAAsB,6BAAgE;AACpF,QAAM,+BAA+B;AACrC,SAAO,OAAO,OAAO;;IACH;;;IACE;;IACC,CAAC,QAAQ,QAAQ;EAAA;AAExC;AAKA,eAAsB,mCAAsE;AACnF,SAAA,wBAAwB,MAAM,2BAAA,CAA4B;AACnE;AAYA,eAAsB,wBAAwB,SAAwE;AACpH,6BAA2B,OAAO;AAElC,QAAM,CAAC,gBAAgB,aAAa,IAAI,MAAM,QAAQ,IAAI;IACxD,OAAO,OAAO,UAAU,OAAO,QAAQ,SAAS;IAChD,OAAO,OAAO,UAAU,OAAO,QAAQ,UAAU;EAAA,CAClD;AAED,MAAI,CAAC,cAAc,EAAS,OAAA,IAAI,MAAM,iCAAiC;AAEvE,SAAO,IAAI,WAAW,CAAC,GAAG,qBAAO,KAAK,cAAc,GAAG,QAAQ,GAAG,GAAG,IAAI,WAAW,cAAc,CAAC,CAAC;AACtG;AAYA,eAAsB,8BACpB,eACqB;AACd,SAAA,wBAAwB,cAAc,OAAO;AACtD;AC5EA,eAAsB,wBAAwB,mBAAmD;AAC/F,SAAO,uBAAuB,iBAAA,EAAmB,OAAO,iBAAiB,CAAC;AAC5E;AAKA,eAAsB,8BAA8B,mBAAmD;AACrG,SAAOC,wBAAwB,MAAM,wBAAwB,iBAAiB,CAAC;AACjF;ACNO,SAAS,sBAAsB,0BAA+C;AACnF,SAAO,sBAAA,EAAwB,OAAO,iBAAA,EAAmB,OAAO,wBAAwB,CAAC;AAC3F;ACMA,eAAsB,6BACpB,KACAC,UACA,QAC+E;AAC/E,QAAM,aAAa,MAAM,IAAI,wBAAwBA,UAAS,MAAM,EAAE,KAAK,EAAE,aAAa,QAAQ,YAAA,CAAa;AAE3G,MAAA,CAAC,WAAW,QAAQ;AAChB,UAAA,IAAI,YAAY,0CAA0C;MAC9D,WAAW;IAAA,CACZ;EAAA;AAGH,QAAM,SAAS,WAAW,WAAW,SAAS,CAAC;AAC/C,MAAI,WAAW,UAAU,QAAQ,SAAS,KAAc,QAAA;AAEpD,MAAA;AAEK,WAAA,MAAM,6BAA6B,KAAKA,UAAS,EAAE,GAAG,QAAQ,QAAQ,OAAO,UAAA,CAAW;EAAA,SACxF,KAAK;AAEZ,QAAI,cAAc,KAAK,wCAAwC,EAAU,QAAA;AACnE,UAAA;EAAA;AAEV;AC7BO,SAAS,uCACd,WACA,aACc;AACd,SAAO,wCAAwC,CAAC,SAAS,GAAG,WAAW;AACzE;AASO,SAAS,wCACd,YACA,aACc;AACR,QAAA,eAAe,YAAY,aAAa;IAC5C,CAAC,OAAO,GAAG,mBAAmB;EAAA;AAGhC,MAAI,YAAY,aAAa,UAAU,KAAK,gBAAgB,IAAI;AACxD,UAAA,IAAIC,YAAY,gDAAgD;MACpE,OAAO,YAAY,aAAa,UAAU;MAC1C,OAAO;IAAA,CACR;EAAA;AAGH,QAAM,aAAa;IACjB,GAAG,YAAY,aAAa,YAAY;IACxC,UAAU;MACR,GAAI,YAAY,aAAa,YAAY,EAAE,YAAY,CAAA;;MAEvD,GAAG,WAAW,IAAI,CAAC,SAAS;QAC1B,SAAS;QACT,MAAM,YAAY;MAAA,EAClB;IAAA;EACJ;AAGF,QAAM,eAAe,CAAC,GAAG,YAAY,YAAY;AACpC,eAAA,OAAO,cAAc,GAAG,UAAU;AAE/C,SAAO,OAAO,OAAO;IACnB,GAAG;IACH,cAAc,OAAO,OAAO,YAAY;EAAA,CACzC;AACH;ACxDO,IAAM,2BAAmD;EAC9D,gBAAgB;EAChB,iBAAiB;EACjB,kBAAkB;EAClB,4BAA4B;EAC5B,qBAAqB;EACrB,qBAAqB;EACrB,cAAc;EACd,oBAAoB;EACpB,eAAe;EACf,gBAAgB;EAChB,gBAAgB;EAChB,eAAe;AACjB;AAiBO,SAAS,mBAAmB;EACjC;EACA;EACA;EACA,gBAAgB;AAClB,GAKG;AACM,SAAA;IACL;IACA,SAAS;MACP,IAAI;QACF,MAAM,CAAC,UAAU,EAAE,cAAA,CAAe;QAClC,MAAM;MAAA;MAER,MAAM,aACF;QACE,MAAM;QACN,MAAM;UACJ;UACA;YACE,aAAa;YACb,YAAY;UAAA;QACd;MACF,IAEF;IAAA;EACN;AAEJ;",
  "names": ["process", "e", "isSolanaError", "ORDERED_ERROR_NAMES", "SolanaError", "alphabet", "createEncoder", "SolanaError", "SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE", "hexBytes", "createDecoder", "combineCodec", "TextDecoder", "TextEncoder", "address", "SolanaError", "SolanaError", "base58Encoder", "SolanaError", "address", "e", "Endian", "combineCodec", "createEncoder", "createDecoder", "newOffset", "createEncoder", "createDecoder", "combineCodec", "getBase16Decoder", "SolanaError", "getEncodedSize", "isFixedSize", "getU8Encoder", "transformEncoder", "getU8Decoder", "transformDecoder", "containsBytes", "AccountRole", "SolanaError", "signature", "privateKey", "unwrapBigIntValueObject", "wrapBigIntValueObject", "pipe", "process", "SolanaError", "AbortController", "process", "o", "e", "normalizeHeaders", "AbortController", "EventTarget", "EXPLICIT_ABORT_TOKEN", "createExplicitAbortToken", "process", "o", "e", "AbortController", "o", "SolanaError", "getAllowedNumericKeypaths", "memoizedKeypaths", "EventTarget", "index_browser_default", "e", "t", "createSolanaJsonRpcIntegerOverflowError", "AbortController", "e", "o", "pipe", "transformChannelInboundMessages", "transformChannelOutboundMessages", "cache", "SolanaError", "combineCodec", "assertValidBaseString", "alphabet", "SolanaError", "getBaseXEncoder", "partitionLeadingZeroes", "getBigIntFromBaseX", "getBaseXDecoder", "getBaseXFromBigInt", "getBase58Encoder", "getBase58Decoder", "getU8Encoder", "getU8Decoder", "getStructEncoder", "getStructDecoder", "getArrayEncoder", "getShortU16Encoder", "transformDecoder", "getArrayDecoder", "getShortU16Decoder", "createEncoder", "createDecoder", "combineCodec", "transformEncoder", "getAddressEncoder", "getAddressDecoder", "address", "TYPE", "AccountRole", "getAddressComparator", "isWritableRole", "isSignerRole", "signature", "getBytesEncoder", "SolanaError", "address", "SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT", "SolanaError", "address", "SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING", "signature", "transaction", "TextEncoder", "o", "AbortController", "o", "base58Decoder", "SolanaError", "signature", "safeRace", "e", "getTimeoutPromise", "lamports", "e", "getBase64EncodedWireTransaction", "createRecentSignatureConfirmationPromiseFactory", "COMPUTE_BUDGET_PROGRAM_ADDRESS", "ComputeBudgetInstruction", "transformEncoder", "getStructEncoder", "getU8Encoder", "getU32Encoder", "COMPUTE_BUDGET_PROGRAM_ADDRESS", "transformEncoder", "getStructEncoder", "getU8Encoder", "COMPUTE_BUDGET_PROGRAM_ADDRESS", "process", "lamports", "isTransactionSigner", "setTransactionMessageLifetimeUsingBlockhash", "isSetComputeLimitInstruction", "COMPUTE_BUDGET_PROGRAM_ADDRESS", "pipe", "getBase64EncodedWireTransaction", "getSetComputeUnitLimitInstruction", "appendTransactionMessageInstruction", "assertIsTransactionMessageWithBlockhashLifetime", "partiallySignTransactionMessageWithSigners", "err", "createSignerFromKeyPair", "address", "SolanaError"]
}
