import{P as e,h as r}from"./paths-B891YjWw.mjs";import{mainnet as n,sepolia as t,optimism as a,optimismSepolia as o,polygon as i,polygonAmoy as l,base as s,baseSepolia as d,avalanche as c,avalancheFuji as u,arbitrum as f,arbitrumSepolia as p}from"@privy-io/js-sdk-core";import{useCallback as E,useContext as h}from"react";import{a as m,i as g,e as y,u as C,P as w}from"./privy-context-V2csHgUI.mjs";import{d1 as D,d2 as v,aS as T,ar as b,az as W,am as A,c2 as S,a9 as U}from"./SignRequestScreen-NOqdMm22.mjs";import{u as x}from"./internal-context-LlMdpfkb.mjs";function M(e){return["ethereum","solana"].includes(e.chainType)}function _(e){let r=e.replace("eip155:","");if(r)return parseInt(r);throw Error("Chain ID not compatible with CAIP-2 format.")}const P=e=>e.filter((e=>"wallets"===e.method||("exchange"===e.method?"coinbase"===e.provider:"card"===e.method||"payment-request"===e.method?"coinbase"===e.provider||"moonpay"===e.provider:(e.method,!1)))),R={[n.id]:"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",[t.id]:"0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",[a.id]:"0x0b2c639c533813f4aa9d7837caf62653d097ff85",[o.id]:"0x5fd84259d66Cd46123540766Be93DFE6D43130D7",[i.id]:"0x3c499c542cef5e3811e1192ce70d8cc03d5c3359",[l.id]:"0x41e94eb019c0762f9bfcf9fb1e58725bfb0e7582",[s.id]:"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",[d.id]:"0x036CbD53842c5426634e7929541eC2318f3dCF7e",[c.id]:"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",[u.id]:"0x5425890298aed601595a70ab815c96711a31bc65",[f.id]:"0xaf88d065e77c8cC2239327C5EDb3A432268e5831",[p.id]:"0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d"},F=({address:r,appConfig:n,fundWalletConfig:t,methodScreen:a,chainIdOverride:o,comingFromSendTransactionScreen:i=!1})=>{let l,s;if(!n.fundingConfig)throw Error("Wallet funding is not enabled");let d=P(n.fundingConfig.options);if(d.length<1)throw Error("Wallet funding is not enabled");l=o||(t?.chain?t.chain.id:_(n.fundingConfig.defaultRecommendedCurrency.chain));let c=n.chains.find((e=>e.id===l));if(!c)throw new e(`Funding chain ${l} is not in PrivyProvider chains list`);let u=t?.amount??n.fundingConfig.defaultRecommendedAmount,f=!1;function p(){if(!l)return;let e=R[l];d.find((e=>"wallets"===e.method))&&!e&&console.warn("Attempting to fund with USDC on chain where USDC address is not known. Funding via external wallet will be disabled."),s=e,f=!0}var E;t&&"asset"in t?"USDC"===t.asset?p():"string"!=typeof t.asset&&"erc20"in t.asset&&(E=s=t.asset.erc20,f=E===R[c.id]):"USDC"===n.fundingConfig.defaultRecommendedCurrency.asset&&p();let h=t?.defaultFundingMethod;return{chainType:"ethereum",address:r,amount:u,chain:c,erc20Address:s,erc20ContractInfo:f?{symbol:"USDC",decimals:6}:void 0,isUSDC:f,methodScreen:a,supportedOptions:d,comingFromSendTransactionScreen:i,defaultFundingMethod:h,usingDefaultFundingMethod:!!h,preferredCardProvider:t?.card?.preferredProvider,crossChainBridgingEnabled:n.fundingConfig.crossChainBridgingEnabled??!1,solanaChain:"solana:mainnet",uiConfig:t&&"uiConfig"in t?t.uiConfig:void 0,externalSolanaFundingScreen:null}};function I({address:e,fundWalletConfig:r,appConfig:n,comingFromSendTransactionScreen:t,externalSolanaFundingScreen:a,methodScreen:o}){if(!n.fundingConfig)throw Error("Wallet funding is not enabled");let i=P(n.fundingConfig.options);if(i.length<1)throw Error("Wallet funding is not enabled");if("USDC"===r?.asset&&"solana:testnet"===r?.chain)throw Error("USDC funding is not supported on the Solana testnet");let l=r?.amount??n.fundingConfig.defaultRecommendedAmount,s=r?.defaultFundingMethod;return{chainType:"solana",address:e,supportedOptions:i,amount:l,isUSDC:"USDC"===r?.asset,methodScreen:o,comingFromSendTransactionScreen:t,chain:r?.chain||"solana:mainnet",crossChainBridgingEnabled:n.fundingConfig.crossChainBridgingEnabled??!1,defaultFundingMethod:s,preferredCardProvider:r?.card?.preferredProvider,usingDefaultFundingMethod:!!s,uiConfig:r?.uiConfig,externalSolanaFundingScreen:a}}const B=e=>e.reduce(((e,r)=>!e||e.walletIndex<r.walletIndex?r:e),null),O=async({appConfig:e,getAccessToken:n,initializeWalletProxy:t,user:a,privy:o,emitPrivyEvent:i,recoverEmbeddedWallet:l,setModalData:s,openModal:d,setUser:c,options:u,timeoutDuration:f,refreshSessionAndUser:p,chainType:E})=>{let[h,m]=await Promise.all([t(f),n()]);if(!m||!a)throw i("createWallet","onError",r.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");if(!h&&e.customAuth?.enabled)throw i("createWallet","onError",r.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");if(u&&"walletIndex"in u&&"number"==typeof u.walletIndex){if("user-controlled-server-wallets-only"===e.embeddedWallets.mode)throw i("createWallet","onError",r.INVALID_DATA),Error("Invalid input, use `createAdditional` instead of `walletIndex` to create additional wallets.");return k({accessToken:m,appConfig:e,privy:o,emitPrivyEvent:i,openModal:d,proxy:h,refreshSessionAndUser:p,recoverEmbeddedWallet:l,setModalData:s,user:a,walletIndex:u.walletIndex,chainType:E,setUser:c})}let g=u&&"createAdditional"in u&&u.createAdditional,y=D(a,{chainType:E});if(y[0]&&!g)throw i("createWallet","onError",r.EMBEDDED_WALLET_ALREADY_EXISTS),Error("User already has an embedded wallet.");return k({accessToken:m,appConfig:e,privy:o,emitPrivyEvent:i,openModal:d,proxy:h,recoverEmbeddedWallet:l,setModalData:s,user:a,walletIndex:(B(y)?.walletIndex??-1)+1,chainType:E,refreshSessionAndUser:p,setUser:c})};let k=async({accessToken:e,appConfig:n,privy:t,emitPrivyEvent:a,proxy:o,refreshSessionAndUser:i,recoverEmbeddedWallet:l,user:s,walletIndex:d,setModalData:c,openModal:u,chainType:f,setUser:p})=>{if(d<0)throw a("createWallet","onError",r.EMBEDDED_WALLET_CREATE_ERROR),Error(`A negative walletIndex (${d}) is invalid.`);let E=m(s);if(d>0&&!E)throw a("createWallet","onError",r.EMBEDDED_WALLET_NOT_FOUND),Error("Must have an existing embedded wallet to create an additional wallet.");if(n.embeddedWallets.requireUserOwnedRecoveryOnCreate&&"user-controlled-server-wallets-only"===n.embeddedWallets.mode)throw a("createWallet","onError",r.EMBEDDED_WALLET_CREATE_ERROR),Error("User owned recovery not yet supported for this app.");if(!E&&n.embeddedWallets.requireUserOwnedRecoveryOnCreate)return await N({emitPrivyEvent:a,setModalData:c,openModal:u,chainType:f});let h=D(s,{chainType:f,walletIndex:d})[0];if(h)return{user:s,account:h};if(0===d&&!o)return N({emitPrivyEvent:a,setModalData:c,openModal:u,chainType:f});if(!o)throw a("createWallet","onError",r.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");return v({appConfig:n,walletIndex:d,chainType:f,user:s,accessToken:e,proxy:o,refreshSessionAndUser:i,privy:t,recoverEmbeddedWallet:l,setUser:p})},N=async({emitPrivyEvent:e,setModalData:n,openModal:t,chainType:a})=>new Promise(((o,i)=>{n({createWallet:{onSuccess:({user:r,account:n})=>{e("createWallet","onSuccess",{wallet:n}),o({user:r,account:n})},onFailure:n=>{e("createWallet","onError",r.UNKNOWN_EMBEDDED_WALLET_ERROR),i(n)},callAuthOnSuccessOnClose:!1,shouldCreateEth:"ethereum"===a,shouldCreateSol:"solana"===a}}),t(T)}));const L=()=>{let e=b(),n=W(),{setModalData:t}=A(),{initializeWalletProxy:a,recoverEmbeddedWallet:o,setUser:i,openModal:l,refreshSessionAndUser:s,privy:d,client:c}=x();return{create:async({chainType:u,options:f,latestUser:p})=>{let E=p;if(E||(E=await s()),!E)throw n("createWallet","onError",r.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");return await O({appConfig:e,privy:d,getAccessToken:()=>c.getAccessToken(),refreshSessionAndUser:s,initializeWalletProxy:a,user:E,emitPrivyEvent:n,recoverEmbeddedWallet:o,setModalData:t,openModal:l,setUser:i,options:f,timeoutDuration:S,chainType:u})}}};function K(e){let{create:r}=L();return U("createWallet",e),{createWallet:async e=>{e&&"target"in e&&e&&(e=void 0);let{account:n}=await r({chainType:"ethereum",options:e});return n}}}const z=async({emitPrivyEvent:n,getAccessToken:t,initializeWalletProxy:a,refreshSessionAndUser:o,user:i,appConfig:l},{privateKey:s,chainType:d})=>{if(!i)throw n("linkAccount","onError",r.MUST_BE_AUTHENTICATED,{linkMethod:"siwe"}),new e("User must be authenticated before linking an account.");let[c,u]=await Promise.all([t(),a(15e3)]);if(!u||!c)throw n("linkAccount","onError",r.MUST_BE_AUTHENTICATED,{linkMethod:"siwe"}),new e("User must be authenticated before linking an account.");await u.importWallet({privateKey:s,accessToken:c,chainType:d,mode:"user-controlled-server-wallets-only"===l.embeddedWallets.mode?"tee":"on-device"});let f=await o(),p="solana"===d?g(f):y(f);if(!p)throw n("createWallet","onError",r.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to import wallet");return n("createWallet","onSuccess",{wallet:p}),p},j=()=>{let{user:e}=C(),{client:r,refreshSessionAndUser:n,initializeWalletProxy:t}=x(),a=W(),o=b();return{importWallet:E((({privateKey:i})=>z({getAccessToken:()=>r.getAccessToken(),user:e,initializeWalletProxy:t,refreshSessionAndUser:n,emitPrivyEvent:a,appConfig:o},{privateKey:i,chainType:"ethereum"})),[e,r,n,t,a])}},q=()=>{let{importWallet:e}=j(),{createWallet:r}=K();return{...h(w),importWallet:e,createWallet:r}};export{L as a,K as b,j as c,z as d,_ as e,P as f,I as g,M as i,F as p,q as u};
