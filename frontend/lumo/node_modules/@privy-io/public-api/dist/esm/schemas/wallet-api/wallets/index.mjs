import{z as t}from"zod";import{InvalidInputError as e,PrivyErrorCode as i}from"@privy-io/api-base";import{Pagination as a}from"../../api.mjs";import{SolanaWalletAddress as r,WalletAddress as n}from"../../core.mjs";import{BaseTransactionResponse as o}from"../../transaction.mjs";import{PrivateKeyExportInput as s}from"../export.mjs";import{WalletApiSparkRpcInput as l,WalletApiTransferRpcResponse as d,WalletApiGetBalanceRpcResponse as c,WalletApiTransferTokensRpcResponse as p,WalletApiGetStaticDepositAddressRpcResponse as g,WalletApiClaimStaticDepositRpcResponse as u,WalletApiGetClaimStaticDepositQuoteRpcResponse as h,WalletApiPayLightningInvoiceRpcResponse as m,WalletApiCreateLightningInvoiceRpcResponse as _,WalletApiSignMessageWithIdentityKeyRpcResponse as b}from"./spark/index.mjs";export{WalletApiClaimStaticDepositRpcInput,WalletApiCreateLightningInvoiceRpcInput,WalletApiGetBalanceRpcInput,WalletApiGetClaimStaticDepositQuoteRpcInput,WalletApiGetStaticDepositAddressRpcInput,WalletApiPayLightningInvoiceRpcInput,WalletApiSignMessageWithIdentityKeyRpcInput,WalletApiTransferRpcInput,WalletApiTransferTokensRpcInput}from"./spark/index.mjs";export{OutputWithPreviousTransactionData,SparkBalance,SparkLightningReceiveRequest,SparkLightningSendRequest,SparkNetwork,SparkTransfer}from"./spark/utils.mjs";import"bs58";import"libphonenumber-js/max";import"viem";const y=t.enum(["secp256k1","ed25519","starknet"]),j=t.string().regex(/^[mM]'?(\/\d+'?)*$/),v=t.literal("ECDSA"),f=t.literal("EdDSA"),z=t.union([v,f]),x=t.string().regex(/^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$/,"Chain ID must be a valid CAIP-2 chain ID, e.g. 'eip155:1'");let k=t.object({address:r.optional(),chain_type:t.literal("solana").optional(),wallet_id:t.string().optional()}),I=t.object({address:n.optional(),chain_type:t.literal("ethereum").optional(),wallet_id:t.string().optional()});const w=t.enum(["root","manager","delegated-actions"]).nullable(),A=t.object({method:t.literal("signTransaction"),params:t.object({transaction:t.string(),encoding:t.literal("base64")}).strict()}).merge(k).strict(),T=t.object({method:t.literal("signAndSendTransaction"),caip2:x,params:t.object({transaction:t.string(),encoding:t.literal("base64")}).strict(),sponsor:t.boolean().optional()}).merge(k).strict(),D=t.object({method:t.literal("signMessage"),params:t.object({message:t.string(),encoding:t.literal("base64")}).strict()}).merge(k).strict(),S=t.string().startsWith("0x").refine((t=>!t.includes(".")),"Invalid hex string: must start with '0x' and not contain decimal points"),R=S.transform((t=>t));let W=t.number().int().nonnegative().safe({message:'Please use hex string prefixed with "0x" to represent large numbers (e.g. "0xDE0B6B3A7640000").'});const O=t.union([S,W],{invalid_type_error:"Invalid quantity: must be either a hex string starting with '0x' or a non-negative integer."}),E=t.object({from:n.optional(),to:n.optional(),chain_id:O.optional(),nonce:O.optional(),data:S.optional(),value:O.optional(),type:t.union([t.literal(0),t.literal(1),t.literal(2)]).optional(),gas_limit:O.optional(),gas_price:O.optional(),max_fee_per_gas:O.optional(),max_priority_fee_per_gas:O.optional()}).strict(),P=t.object({method:t.literal("eth_signTransaction"),params:t.object({transaction:E}).strict()}).merge(I).strict(),C=t.object({method:t.literal("eth_sendTransaction"),caip2:x,params:t.object({transaction:E}).strict(),sponsor:t.boolean().optional()}).merge(I).strict(),N=t.object({message:t.string(),encoding:t.union([t.literal("utf-8"),t.literal("hex")])}).strict(),L=t.object({method:t.literal("personal_sign"),params:N}).merge(I).strict(),M=t.object({method:t.literal("secp256k1_sign"),params:t.object({hash:R}).strict()}).merge(I).strict(),q=t.object({method:t.literal("eth_sign7702Authorization"),params:t.object({contract:n,chain_id:O,nonce:O.optional()}).strict()}).merge(I).strict(),B=t.object({params:t.object({hash:R}).strict()}).strict(),U=t.record(t.string(),t.any()),G=t.record(t.array(t.object({name:t.string(),type:t.string()}))),K=t.object({method:t.literal("eth_signTypedData_v4"),params:t.object({typed_data:t.object({domain:U,types:G,message:t.record(t.string(),t.any()),primary_type:t.string()}).strict()}).strict()}).merge(I).strict(),V=t.object({address:t.string(),method:t.literal("exportPrivateKey"),params:s}).strict(),Y=t.discriminatedUnion("method",[P,C,L,K,M,q]),$=t.discriminatedUnion("method",[A,T,D]),Q=t.union([Y,$,V,l]),Z=t.object({method:t.literal("signTransaction"),data:t.object({signed_transaction:t.string(),encoding:t.literal("base64")})}),F=t.object({method:t.literal("signAndSendTransaction"),data:t.object({transaction_id:t.string().optional(),hash:t.string(),caip2:x}).optional(),error:t.object({code:t.string(),message:t.string()}).optional()}),H=t.object({method:t.literal("signMessage"),data:t.object({signature:t.string(),encoding:t.literal("base64")})}),J=t.object({method:t.literal("eth_signTransaction"),data:t.object({signed_transaction:t.string(),encoding:t.literal("rlp")})}),X=t.object({method:t.literal("eth_sendTransaction"),data:t.object({transaction_id:t.string().optional(),hash:t.string(),caip2:x,transaction_request:E.optional()}).optional(),error:t.object({code:t.string(),message:t.string()}).optional()}),tt=t.object({method:t.literal("personal_sign"),data:t.object({signature:t.string(),encoding:t.literal("hex")})}),et=t.object({method:t.literal("secp256k1_sign"),data:t.object({signature:S,encoding:t.literal("hex")})});let it=t.object({contract:n,chain_id:O,nonce:O,r:S,s:S,y_parity:t.number()});const at=t.object({method:t.literal("eth_sign7702Authorization"),data:t.object({authorization:it})}),rt=t.object({method:t.literal("eth_signTypedData_v4"),data:t.object({signature:t.string(),encoding:t.literal("hex")})}),nt=t.object({method:t.literal("exportPrivateKey"),data:s}),ot=t.object({data:t.object({signature:S,encoding:t.literal("hex")})}).strict(),st=t.discriminatedUnion("method",[Z,F,H,J,X,tt,et,at,rt,nt,d,c,p,g,u,h,m,_,b]),lt=t.object({display_name:t.string().optional(),public_key:t.string(),role:w.optional()}),dt=t.literal("ethereum"),ct=t.literal("solana"),pt=t.literal("cosmos"),gt=t.literal("stellar"),ut=t.literal("sui"),ht=t.literal("tron"),mt=t.literal("bitcoin-segwit"),_t=t.literal("near"),bt=t.literal("ton"),yt=t.literal("spark"),jt=t.literal("starknet"),vt=t.union([pt,gt,ut,ht,mt,_t,bt,jt]),ft="curve_signing",zt=t.literal("curve_signing"),xt=t.union([vt,yt]),kt=t.union([t.literal("solana"),t.literal("ethereum")]),It=t.union([xt,kt]),wt=t.enum(["hd","private-key"]),At=t.enum(["ENTROPY_TO_SEED","ENTROPY_TO_MNEMONIC_TO_SEED"]),Tt=t.object({id:t.string(),address:t.string(),public_key:t.string().optional(),created_at:t.number(),exported_at:t.number().nullable(),imported_at:t.number().nullable(),chain_type:It,policy_ids:t.array(t.string()),authorization_threshold:t.number().optional(),additional_signers:t.array(t.object({signer_id:t.string().cuid2(),override_policy_ids:t.array(t.string()).optional()})),owner_id:t.string().cuid2().nullable()}),Dt=t.string().cuid2(),St=t.string(),Rt=t.union([t.object({user_id:t.string().startsWith("did:privy:",{message:"user_id must start with did:privy:"})}).strict(),t.object({public_key:St}).strict(),t.null()]),Wt={owner:Rt.optional(),owner_id:Dt.nullable().optional()},Ot=t.array(t.string().cuid2()).max(1,"Only one policy ID can be set").optional(),Et=t.array(t.object({signer_id:Dt,override_policy_ids:Ot}).strict()),Pt=t.object({chain_type:It,policy_ids:Ot,authorization_key_ids:t.array(t.string()).optional(),authorization_threshold:t.number().optional(),additional_signers:Et.optional(),...Wt}).strict(),Ct=Pt.refine((t=>{let e=void 0!==t.authorization_key_ids||void 0!==t.authorization_threshold,i=void 0!==t.additional_signers;return!e||!i}),"Please provide either additional_signers or authorization_key_ids, not both").refine((t=>void 0===t.authorization_threshold||t.authorization_threshold>=1&&t.authorization_key_ids&&t.authorization_threshold<=t.authorization_key_ids.length),{message:"If specified, authorization_threshold must be an integer between 1 and the length of authorization_key_ids."}).refine((t=>!t.owner||!t.owner_id),{message:"Only one of owner or owner_id can be provided."}).catch((t=>{throw new e(t.error.message,i.INVALID_DATA)})),Nt=t.object({id:t.string(),chain_type:It,address:t.string(),authorization_threshold:t.number().optional()}),Lt=t.object({wallet_id:t.string({required_error:"Wallet ID must be provided",invalid_type_error:"Wallet ID is not a valid string"}).min(1)}).catch((({error:t})=>{throw new e(t.message,i.INVALID_DATA)})),Mt=t.enum(["usdc","eth","pol"]),qt=t.enum(["sol"]),Bt=t.enum([...Mt.options,...qt.options]),Ut=t.enum(["ethereum","arbitrum","base","linea","optimism","polygon","solana","zksync_era"]),Gt=t.enum(["usd"]),Kt=t.object({asset:t.union([Bt,t.array(Bt).max(10)]),chain:t.union([Ut,t.array(Ut).max(10)]),include_currency:Gt.optional()}),Vt=t.object({chain:Ut,asset:Bt,raw_value:t.string(),raw_value_decimals:t.number(),display_values:t.record(t.union([Bt,Gt]),t.string())}),Yt=t.object({balances:t.array(Vt.refine((t=>t.asset in t.display_values),{message:"display_values must include the asset as a key",path:["display_values"]}))}),$t=t.object({id:t.string()}),Qt=t.object({id:t.string(),display_name:t.string().nullable(),public_key:t.string(),role:w,created_at:t.number()}),Zt=t.object({id:t.string(),display_name:t.string().nullable(),public_key:t.string(),created_at:t.number()}),Ft=a.extend({chain_type:It.optional(),user_id:t.string().optional()}).strict(),Ht=t.object({policy_ids:Ot,authorization_key_ids:t.array(t.string()).optional(),authorization_threshold:t.number().optional(),additional_signers:Et.optional(),...Wt}).strict().superRefine(((t,e)=>{Object.values(t).every((t=>void 0===t||""===t))&&e.addIssue({code:"custom",message:"At least one field must be provided"}),void 0!==t.owner&&void 0!==t.owner_id&&e.addIssue({code:"custom",message:"Only one of owner or owner_id can be provided."}),void 0!==t.authorization_threshold&&0!==t.authorization_threshold&&(t.authorization_threshold<0&&e.addIssue({code:"custom",path:["authorization_threshold"],message:"`authorization_threshold` must be non-negative if specified."}),void 0===t.authorization_key_ids&&e.addIssue({code:"custom",path:["authorization_key_ids"],message:"An array of `authorization_key_ids` must be provided for a non-zero `authorization_threshold`."}),t.authorization_key_ids&&t.authorization_threshold>t.authorization_key_ids.length&&e.addIssue({code:"custom",path:["authorization_threshold"],message:"`authorization_threshold` must be non-negative if specified."}))})),Jt=a.extend({chain:t.literal("base"),asset:t.union([Bt,t.array(Bt).max(2)])}).strict(),Xt=t.object({type:t.literal("transfer_sent"),sender:t.string(),sender_privy_user_id:t.string().nullable(),recipient:t.string(),recipient_privy_user_id:t.string().nullable()}).strict().merge(Vt),te=t.object({type:t.literal("transfer_received"),sender:t.string(),sender_privy_user_id:t.string().nullable(),recipient:t.string(),recipient_privy_user_id:t.string().nullable()}).strict().merge(Vt),ee=t.discriminatedUnion("type",[Xt,te]),ie=o.extend({details:ee.nullable()}),ae=ie.extend({privy_transaction_id:t.string(),wallet_id:t.string()}),re=t.object({transactions:t.array(ae),next_cursor:t.string().nullable()});export{Et as AdditionalSignerInput,Bt as Asset,Vt as AssetAmountDetails,Qt as AuthorizationKeyDashboardResponse,Zt as AuthorizationKeyResponse,w as AuthorizationKeyRole,Gt as BalanceFiatCurrency,Pt as BaseWalletApiCreateInput,mt as BitcoinSegwit,x as CAIP2,ft as CURVE_SIGNING,Ut as ChainNameInput,It as ChainType,pt as Cosmos,vt as CurveSigningChainTypes,zt as CurveSigningLiteral,y as CurveType,v as ECDSA,f as EdDSA,dt as Ethereum,Mt as EthereumAsset,xt as ExtendedChainTypes,kt as FirstClassChainTypes,j as HDPath,R as Hash,S as Hex,Dt as KeyQuorumId,_t as Near,Rt as OwnerInput,Wt as OwnerInputFields,St as P256PublicKey,Ot as PolicyInput,ae as PrivyTransactionResponseWithDetails,O as Quantity,z as SigningAlgorithm,ct as Solana,qt as SolanaAsset,At as SolanaWalletDerivationStrategy,yt as Spark,jt as Starknet,gt as Stellar,ut as Sui,bt as Ton,ee as TransactionDetail,ie as TransactionResponseWithDetails,te as TransferReceivedTransactionDetail,Xt as TransferSentTransactionDetail,ht as Tron,U as TypedDataDomainInputParams,G as TypedDataTypesInputParams,E as UnsignedEthereumTransaction,u as WalletApiClaimStaticDepositRpcResponse,Ct as WalletApiCreateInput,_ as WalletApiCreateLightningInvoiceRpcResponse,Nt as WalletApiCreateResponse,L as WalletApiEthereumPersonalSignRpcInput,N as WalletApiEthereumPersonalSignRpcInputParams,tt as WalletApiEthereumPersonalSignRpcResponse,Y as WalletApiEthereumRpcInput,M as WalletApiEthereumSecp256k1SignRpcInput,et as WalletApiEthereumSecp256k1SignRpcResponse,C as WalletApiEthereumSendTransactionRpcInput,X as WalletApiEthereumSendTransactionRpcResponse,q as WalletApiEthereumSign7702AuthorizationRpcInput,at as WalletApiEthereumSign7702AuthorizationRpcResponse,P as WalletApiEthereumSignTransactionRpcInput,J as WalletApiEthereumSignTransactionRpcResponse,K as WalletApiEthereumSignTypedDataRpcInput,rt as WalletApiEthereumSignTypedDataRpcResponse,V as WalletApiExportPrivateKeyRpcInput,nt as WalletApiExportPrivateKeyRpcResponse,c as WalletApiGetBalanceRpcResponse,h as WalletApiGetClaimStaticDepositQuoteRpcResponse,g as WalletApiGetStaticDepositAddressRpcResponse,m as WalletApiPayLightningInvoiceRpcResponse,B as WalletApiRawSignInput,ot as WalletApiRawSignResponse,lt as WalletApiRegisterAuthorizationKeyInput,$t as WalletApiRevokeAuthorizationKeyInput,Q as WalletApiRpcInput,st as WalletApiRpcResponse,b as WalletApiSignMessageWithIdentityKeyRpcResponse,$ as WalletApiSolanaRpcInput,T as WalletApiSolanaSignAndSendTransactionRpcInput,F as WalletApiSolanaSignAndSendTransactionRpcResponse,D as WalletApiSolanaSignMessageRpcInput,H as WalletApiSolanaSignMessageRpcResponse,A as WalletApiSolanaSignTransactionRpcInput,Z as WalletApiSolanaSignTransactionRpcResponse,l as WalletApiSparkRpcInput,d as WalletApiTransferRpcResponse,p as WalletApiTransferTokensRpcResponse,wt as WalletEntropyType,Kt as WalletGetBalanceInput,Yt as WalletGetBalanceResponse,Jt as WalletGetTransactionsInput,re as WalletGetTransactionsResponse,Lt as WalletIdFromPath,Tt as WalletResponse,Ht as WalletUpdateInput,Ft as WalletsSearchInput};
