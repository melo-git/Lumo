import{z as e}from"zod";import{WalletAddress as t,SolanaWalletAddress as i}from"../core.mjs";import{HPKEEncryption as r}from"./export.mjs";import{BaseWalletApiCreateInput as n}from"./wallets/index.mjs";import"bs58";import"libphonenumber-js/max";import"viem";import"@privy-io/api-base";import"../api.mjs";import"../transaction.mjs";import"./wallets/spark/index.mjs";import"./wallets/spark/utils.mjs";const s=e.enum(["ethereum","solana"]),o=e.enum(["private-key","hd"]);let a=e.union([t,i]),p=e=>"solana"===e.chain_type?i.safeParse(e.address).success:"ethereum"===e.chain_type&&t.safeParse(e.address).success,m=e.object({address:a,chain_type:s,encryption_type:r}),c=m.extend({entropy_type:e.literal("private-key")}).strict(),d=m.extend({entropy_type:e.literal("hd"),index:e.number().int().nonnegative()}).strict();const l=e.discriminatedUnion("entropy_type",[c,d]).refine(p,"Invalid address for specified chain type."),y=e.object({encryption_type:r,encryption_public_key:e.string()});let h=e.object({ciphertext:e.string(),encapsulated_key:e.string()}),_=c.merge(h),u=d.merge(h),f=e.discriminatedUnion("entropy_type",[_,u]);const j=n.omit({chain_type:!0,authorization_key_ids:!0,authorization_threshold:!0}).extend({wallet:f}).strict().refine((e=>p(e.wallet)),"Invalid address for specified chain type.");export{l as WalletImportInitInput,y as WalletImportInitResponse,j as WalletImportSubmitInput,s as WalletImportSupportedChains,o as WalletImportSupportedEntropyTypes};
