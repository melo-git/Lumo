"use strict";var e=require("zod"),t=require("../core.js"),r=require("./export.js"),i=require("./wallets/index.js");require("bs58"),require("libphonenumber-js/max"),require("viem"),require("@privy-io/api-base"),require("../api.js"),require("../transaction.js"),require("./wallets/spark/index.js"),require("./wallets/spark/utils.js");const s=e.z.enum(["ethereum","solana"]),n=e.z.enum(["private-key","hd"]);let a=e.z.union([t.WalletAddress,t.SolanaWalletAddress]),p=e=>"solana"===e.chain_type?t.SolanaWalletAddress.safeParse(e.address).success:"ethereum"===e.chain_type&&t.WalletAddress.safeParse(e.address).success,o=e.z.object({address:a,chain_type:s,encryption_type:r.HPKEEncryption}),l=o.extend({entropy_type:e.z.literal("private-key")}).strict(),d=o.extend({entropy_type:e.z.literal("hd"),index:e.z.number().int().nonnegative()}).strict();const c=e.z.discriminatedUnion("entropy_type",[l,d]).refine(p,"Invalid address for specified chain type."),u=e.z.object({encryption_type:r.HPKEEncryption,encryption_public_key:e.z.string()});let y=e.z.object({ciphertext:e.z.string(),encapsulated_key:e.z.string()}),m=l.merge(y),h=d.merge(y),z=e.z.discriminatedUnion("entropy_type",[m,h]);const _=i.BaseWalletApiCreateInput.omit({chain_type:!0,authorization_key_ids:!0,authorization_threshold:!0}).extend({wallet:z}).strict().refine((e=>p(e.wallet)),"Invalid address for specified chain type.");exports.WalletImportInitInput=c,exports.WalletImportInitResponse=u,exports.WalletImportSubmitInput=_,exports.WalletImportSupportedChains=s,exports.WalletImportSupportedEntropyTypes=n;
