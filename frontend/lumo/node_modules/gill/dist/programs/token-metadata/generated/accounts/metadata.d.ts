/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */
import { fetchEncodedAccount, fetchEncodedAccounts, type Account, type Address, type Codec, type Decoder, type EncodedAccount, type Encoder, type FetchAccountConfig, type FetchAccountsConfig, type MaybeAccount, type MaybeEncodedAccount, type Option, type OptionOrNullable } from "@solana/kit";
import { type Collection, type CollectionArgs, type CollectionDetails, type CollectionDetailsArgs, type Data, type DataArgs, type Key, type KeyArgs, type ProgrammableConfig, type ProgrammableConfigArgs, type TokenStandard, type TokenStandardArgs, type Uses, type UsesArgs } from "../types";
export type Metadata = {
    key: Key;
    updateAuthority: Address;
    mint: Address;
    data: Data;
    primarySaleHappened: boolean;
    isMutable: boolean;
    editionNonce: Option<number>;
    tokenStandard: Option<TokenStandard>;
    collection: Option<Collection>;
    uses: Option<Uses>;
    collectionDetails: Option<CollectionDetails>;
    programmableConfig: Option<ProgrammableConfig>;
};
export type MetadataArgs = {
    key: KeyArgs;
    updateAuthority: Address;
    mint: Address;
    data: DataArgs;
    primarySaleHappened: boolean;
    isMutable: boolean;
    editionNonce: OptionOrNullable<number>;
    tokenStandard: OptionOrNullable<TokenStandardArgs>;
    collection: OptionOrNullable<CollectionArgs>;
    uses: OptionOrNullable<UsesArgs>;
    collectionDetails: OptionOrNullable<CollectionDetailsArgs>;
    programmableConfig: OptionOrNullable<ProgrammableConfigArgs>;
};
export declare function getMetadataEncoder(): Encoder<MetadataArgs>;
export declare function getMetadataDecoder(): Decoder<Metadata>;
export declare function getMetadataCodec(): Codec<MetadataArgs, Metadata>;
export declare function decodeMetadata<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress>): Account<Metadata, TAddress>;
export declare function decodeMetadata<TAddress extends string = string>(encodedAccount: MaybeEncodedAccount<TAddress>): MaybeAccount<Metadata, TAddress>;
export declare function fetchMetadata<TAddress extends string = string>(rpc: Parameters<typeof fetchEncodedAccount>[0], address: Address<TAddress>, config?: FetchAccountConfig): Promise<Account<Metadata, TAddress>>;
export declare function fetchMaybeMetadata<TAddress extends string = string>(rpc: Parameters<typeof fetchEncodedAccount>[0], address: Address<TAddress>, config?: FetchAccountConfig): Promise<MaybeAccount<Metadata, TAddress>>;
export declare function fetchAllMetadata(rpc: Parameters<typeof fetchEncodedAccounts>[0], addresses: Array<Address>, config?: FetchAccountsConfig): Promise<Account<Metadata>[]>;
export declare function fetchAllMaybeMetadata(rpc: Parameters<typeof fetchEncodedAccounts>[0], addresses: Array<Address>, config?: FetchAccountsConfig): Promise<MaybeAccount<Metadata>[]>;
//# sourceMappingURL=metadata.d.ts.map